{"config":{"lang":["en"],"separator":"[\\s\\u200b\\u3000\\-\u3001\u3002\uff0c\uff0e\uff1f\uff01\uff1b]+","pipeline":["stemmer"]},"docs":[{"location":"","title":"Pydantic Validation","text":"<p>Pydantic \u662f Python \u4e2d\u6700\u5e7f\u6cdb\u4f7f\u7528\u7684\u6570\u636e\u9a8c\u8bc1\u5e93\u3002</p> <p>\u5feb\u901f\u4e14\u53ef\u6269\u5c55\uff0cPydantic \u4e0e\u60a8\u7684 linter/IDE/\u5927\u8111\u5b8c\u7f8e\u914d\u5408\u3002\u4f7f\u7528\u7eaf\u6b63\u7684\u3001\u89c4\u8303\u7684 Python 3.9+ \u5b9a\u4e49\u6570\u636e\u5e94\u8be5\u662f\u4ec0\u4e48\u6837\u5b50\uff1b\u7528 Pydantic Validation\u3002</p> \u4f7f\u7528 Pydantic Logfire \u76d1\u63a7 Pydantic  <p>Pydantic Logfire \u662f\u4e00\u4e2a\u5e94\u7528\u7a0b\u5e8f\u76d1\u63a7\u5de5\u5177\uff0c\u4f7f\u7528\u8d77\u6765\u548c Pydantic \u672c\u8eab\u4e00\u6837\u7b80\u5355\u800c\u5f3a\u5927\u3002</p> <p>Logfire \u96c6\u6210\u4e86\u8bb8\u591a\u6d41\u884c\u7684 Python \u5e93\uff0c\u5305\u62ec FastAPI\u3001OpenAI \u548c Pydantic \u672c\u8eab\uff0c\u56e0\u6b64\u60a8\u53ef\u4ee5\u4f7f\u7528 Logfire \u76d1\u63a7 Pydantic \u9a8c\u8bc1\uff0c\u5e76\u4e86\u89e3\u4e3a\u4ec0\u4e48\u67d0\u4e9b\u8f93\u5165\u9a8c\u8bc1\u5931\u8d25\uff1a</p> \u4f7f\u7528 Logfire \u76d1\u63a7 Pydantic<pre><code>from datetime import datetime\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)!\n\n\nclass Delivery(BaseModel):\n    timestamp: datetime\n    dimensions: tuple[int, int]\n\n\n# \u8fd9\u5c06\u8bb0\u5f55\u6210\u529f\u9a8c\u8bc1\u7684\u8be6\u7ec6\u4fe1\u606f\u5230 logfire\nm = Delivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10', '20'])\nprint(repr(m.timestamp))\n#&gt; datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC))\nprint(m.dimensions)\n#&gt; (10, 20)\n\nDelivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10'])  # (2)!\n</code></pre> <ol> <li>\u8bbe\u7f6e logfire \u8bb0\u5f55\u6240\u6709\u6210\u529f\u548c\u5931\u8d25\u7684\u9a8c\u8bc1\uff0c\u4f7f\u7528 <code>record='failure'</code> \u4ec5\u8bb0\u5f55\u5931\u8d25\u7684\u9a8c\u8bc1\uff0c\u4e86\u89e3\u66f4\u591a\u3002</li> <li>\u8fd9\u5c06\u5f15\u53d1 <code>ValidationError</code>\uff0c\u56e0\u4e3a <code>dimensions</code> \u592a\u5c11\uff0c\u8f93\u5165\u6570\u636e\u548c\u9a8c\u8bc1\u9519\u8bef\u7684\u8be6\u7ec6\u4fe1\u606f\u5c06\u88ab\u8bb0\u5f55\u5728 Logfire \u4e2d\u3002</li> </ol> <p>\u5728 Logfire \u5e73\u53f0\u4e2d\u4f1a\u663e\u793a\u5982\u4e0b\u89c6\u56fe\uff1a</p> <p></p> <p>\u8fd9\u53ea\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\uff0c\u4f46\u5e0c\u671b\u80fd\u6e05\u695a\u5730\u5c55\u793a\u5728\u66f4\u590d\u6742\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\u8fdb\u884c\u68c0\u6d4b\u7684\u6f5c\u5728\u4ef7\u503c\u3002</p> <p>\u4e86\u89e3\u66f4\u591a\u5173\u4e8e Pydantic Logfire</p>"},{"location":"#pydantic","title":"\u4e3a\u4ec0\u4e48\u4f7f\u7528 Pydantic\uff1f","text":"<ul> <li>\u7c7b\u578b\u63d0\u793a \u2014 \u4f7f\u7528 Pydantic\uff0c\u6a21\u5f0f\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u7531\u7c7b\u578b\u6ce8\u89e3\u63a7\u5236\uff1b\u5b66\u4e60\u6210\u672c\u66f4\u4f4e\uff0c\u4ee3\u7801\u66f4\u5c11\uff0c\u5e76\u4e0e\u60a8\u7684 IDE \u548c\u9759\u6001\u5206\u6790\u5de5\u5177\u96c6\u6210\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>\u901f\u5ea6\u5feb \u2014 Pydantic \u7684\u6838\u5fc3\u9a8c\u8bc1\u903b\u8f91\u662f\u7528 Rust \u7f16\u5199\u7684\u3002\u56e0\u6b64\uff0cPydantic \u662f Python \u4e2d\u6700\u5feb\u7684\u6570\u636e\u9a8c\u8bc1\u5e93\u4e4b\u4e00\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>JSON Schema \u2014 Pydantic \u6a21\u578b\u53ef\u4ee5\u751f\u6210 JSON Schema\uff0c\u4fbf\u4e8e\u4e0e\u5176\u4ed6\u5de5\u5177\u96c6\u6210\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>\u4e25\u683c \u548c \u5bbd\u677e \u6a21\u5f0f \u2014 Pydantic \u53ef\u4ee5\u5728\u4e25\u683c\u6a21\u5f0f\uff08\u6570\u636e\u4e0d\u8f6c\u6362\uff09\u6216\u5bbd\u677e\u6a21\u5f0f\u4e0b\u8fd0\u884c\uff0c\u5728\u9002\u5f53\u7684\u60c5\u51b5\u4e0b Pydantic \u4f1a\u5c1d\u8bd5\u5c06\u6570\u636e\u5f3a\u5236\u8f6c\u6362\u4e3a\u6b63\u786e\u7684\u7c7b\u578b\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>Dataclasses\u3001TypedDicts \u7b49 \u2014 Pydantic \u652f\u6301\u9a8c\u8bc1\u8bb8\u591a\u6807\u51c6\u5e93\u7c7b\u578b\uff0c\u5305\u62ec <code>dataclass</code> \u548c <code>TypedDict</code>\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>\u81ea\u5b9a\u4e49 \u2014 Pydantic \u5141\u8bb8\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u548c\u5e8f\u5217\u5316\u5668\uff0c\u4ee5\u591a\u79cd\u5f3a\u5927\u7684\u65b9\u5f0f\u6539\u53d8\u6570\u636e\u5904\u7406\u65b9\u5f0f\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>\u751f\u6001\u7cfb\u7edf \u2014 PyPI \u4e0a\u7ea6\u6709 8,000 \u4e2a\u5305\u4f7f\u7528 Pydantic\uff0c\u5305\u62ec\u975e\u5e38\u6d41\u884c\u7684\u5e93\u5982 FastAPI\u3001huggingface\u3001Django Ninja\u3001SQLModel \u548c LangChain\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> <li>\u7ecf\u8fc7\u5b9e\u6218\u68c0\u9a8c \u2014 Pydantic \u6bcf\u6708\u4e0b\u8f7d\u91cf\u8d85\u8fc7 3.6 \u4ebf\u6b21\uff0c\u88ab\u6240\u6709 FAANG \u516c\u53f8\u548c\u7eb3\u65af\u8fbe\u514b 25 \u5bb6\u6700\u5927\u516c\u53f8\u4e2d\u7684 20 \u5bb6\u4f7f\u7528\u3002\u5982\u679c\u60a8\u60f3\u7528 Pydantic \u505a\u67d0\u4e8b\uff0c\u53ef\u80fd\u5df2\u7ecf\u6709\u4eba\u505a\u8fc7\u4e86\u3002\u4e86\u89e3\u66f4\u591a\u2026</li> </ul> <p>\u5b89\u88c5 Pydantic \u975e\u5e38\u7b80\u5355</p> uvpip <pre><code>uv add pydantic\n</code></pre> <pre><code>pip install pydantic\n</code></pre>"},{"location":"#pydantic_1","title":"Pydantic \u793a\u4f8b","text":"<p>\u8981\u4e86\u89e3 Pydantic \u7684\u5de5\u4f5c\u539f\u7406\uff0c\u8ba9\u6211\u4eec\u4ece\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\u5f00\u59cb\uff0c\u521b\u5efa\u4e00\u4e2a\u7ee7\u627f\u81ea <code>BaseModel</code> \u7684\u81ea\u5b9a\u4e49\u7c7b\uff1a</p> \u9a8c\u8bc1\u6210\u529f<pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, PositiveInt\n\n\nclass User(BaseModel):\n    id: int  # (1)!\n    name: str = 'John Doe'  # (2)!\n    signup_ts: datetime | None  # (3)!\n    tastes: dict[str, PositiveInt]  # (4)!\n\n\nexternal_data = {\n    'id': 123,\n    'signup_ts': '2019-06-01 12:22',  # (5)!\n    'tastes': {\n        'wine': 9,\n        b'cheese': 7,  # (6)!\n        'cabbage': '1',  # (7)!\n    },\n}\n\nuser = User(**external_data)  # (8)!\n\nprint(user.id)  # (9)!\n#&gt; 123\nprint(user.model_dump())  # (10)!\n\"\"\"\n{\n    'id': 123,\n    'name': 'John Doe',\n    'signup_ts': datetime.datetime(2019, 6, 1, 12, 22),\n    'tastes': {'wine': 9, 'cheese': 7, 'cabbage': 1},\n}\n\"\"\"\n</code></pre> <ol> <li><code>id</code> \u662f <code>int</code> \u7c7b\u578b\uff1b\u4ec5\u901a\u8fc7\u6ce8\u89e3\u58f0\u660e\u544a\u8bc9 Pydantic \u6b64\u5b57\u6bb5\u662f\u5fc5\u9700\u7684\u3002\u5982\u679c\u53ef\u80fd\uff0c\u5b57\u7b26\u4e32\u3001\u5b57\u8282\u6216\u6d6e\u70b9\u6570\u5c06\u88ab\u5f3a\u5236\u8f6c\u6362\u4e3a\u6574\u6570\uff1b\u5426\u5219\u5c06\u5f15\u53d1\u5f02\u5e38\u3002</li> <li><code>name</code> \u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff1b\u56e0\u4e3a\u5b83\u6709\u9ed8\u8ba4\u503c\uff0c\u6240\u4ee5\u4e0d\u662f\u5fc5\u9700\u7684\u3002</li> <li><code>signup_ts</code> \u662f\u4e00\u4e2a <code>datetime</code> \u5b57\u6bb5\uff0c\u662f\u5fc5\u9700\u7684\uff0c\u4f46\u53ef\u4ee5\u63d0\u4f9b\u503c <code>None</code>\uff1bPydantic \u5c06\u5904\u7406 Unix \u65f6\u95f4\u6233\u6574\u6570\uff08\u4f8b\u5982 <code>1496498400</code>\uff09\u6216\u8868\u793a\u65e5\u671f\u548c\u65f6\u95f4\u7684\u5b57\u7b26\u4e32\u3002</li> <li><code>tastes</code> \u662f\u4e00\u4e2a\u5177\u6709\u5b57\u7b26\u4e32\u952e\u548c\u6b63\u6574\u6570\u503c\u7684\u5b57\u5178\u3002<code>PositiveInt</code> \u7c7b\u578b\u662f <code>Annotated[int, annotated_types.Gt(0)]</code> \u7684\u7b80\u5199\u3002</li> <li>\u8fd9\u91cc\u7684\u8f93\u5165\u662f ISO 8601 \u683c\u5f0f\u7684\u65e5\u671f\u65f6\u95f4\uff0c\u4f46 Pydantic \u4f1a\u5c06\u5176\u8f6c\u6362\u4e3a <code>datetime</code> \u5bf9\u8c61\u3002</li> <li>\u8fd9\u91cc\u7684\u952e\u662f <code>bytes</code>\uff0c\u4f46 Pydantic \u4f1a\u8d1f\u8d23\u5c06\u5176\u5f3a\u5236\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002</li> <li>\u7c7b\u4f3c\u5730\uff0cPydantic \u4f1a\u5c06\u5b57\u7b26\u4e32 <code>'1'</code> \u5f3a\u5236\u8f6c\u6362\u4e3a\u6574\u6570 <code>1</code>\u3002</li> <li>\u6211\u4eec\u901a\u8fc7\u5c06\u5916\u90e8\u6570\u636e\u4f5c\u4e3a\u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u7ed9 <code>User</code> \u6765\u521b\u5efa <code>User</code> \u7684\u5b9e\u4f8b\u3002</li> <li>\u6211\u4eec\u53ef\u4ee5\u5c06\u5b57\u6bb5\u4f5c\u4e3a\u6a21\u578b\u7684\u5c5e\u6027\u8bbf\u95ee\u3002</li> <li>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528 <code>model_dump()</code> \u5c06\u6a21\u578b\u8f6c\u6362\u4e3a\u5b57\u5178\u3002</li> </ol> <p>\u5982\u679c\u9a8c\u8bc1\u5931\u8d25\uff0cPydantic \u5c06\u5f15\u53d1\u9519\u8bef\u5e76\u8be6\u7ec6\u8bf4\u660e\u95ee\u9898\u6240\u5728\uff1a</p> \u9a8c\u8bc1\u9519\u8bef<pre><code># \u7ee7\u7eed\u4e0a\u9762\u7684\u793a\u4f8b...\n\nfrom datetime import datetime\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {'id': 'not an int', 'tastes': {}}  # (1)!\n\ntry:\n    User(**external_data)  # (2)!\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'type': 'int_parsing',\n            'loc': ('id',),\n            'msg': 'Input should be a valid integer, unable to parse string as an integer',\n            'input': 'not an int',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'missing',\n            'loc': ('signup_ts',),\n            'msg': 'Field required',\n            'input': {'id': 'not an int', 'tastes': {}},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        },\n    ]\n    \"\"\"\n</code></pre> <ol> <li>\u8fd9\u91cc\u7684\u8f93\u5165\u6570\u636e\u662f\u9519\u8bef\u7684 \u2014 <code>id</code> \u4e0d\u662f\u6709\u6548\u7684\u6574\u6570\uff0c\u5e76\u4e14 <code>signup_ts</code> \u7f3a\u5931\u3002</li> <li>\u5c1d\u8bd5\u5b9e\u4f8b\u5316 <code>User</code> \u5c06\u5f15\u53d1 <code>ValidationError</code> \u5e76\u9644\u5e26\u9519\u8bef\u5217\u8868\u3002</li> </ol>"},{"location":"#pydantic_2","title":"\u8c01\u5728\u4f7f\u7528 Pydantic\uff1f","text":"<p>\u6570\u767e\u4e2a\u7ec4\u7ec7\u548c\u5305\u6b63\u5728\u4f7f\u7528 Pydantic\u3002\u4e16\u754c\u5404\u5730\u4e00\u4e9b\u4f7f\u7528 Pydantic \u7684\u77e5\u540d\u516c\u53f8\u548c\u7ec4\u7ec7\u5305\u62ec\uff1a</p> <p>\u6709\u5173\u4f7f\u7528 Pydantic \u7684\u5f00\u6e90\u9879\u76ee\u7684\u66f4\u5168\u9762\u5217\u8868\uff0c\u8bf7\u53c2\u9605 github \u4e0a\u7684\u4f9d\u8d56\u9879\u5217\u8868\uff0c\u6216\u8005\u60a8\u53ef\u4ee5\u5728 awesome-pydantic \u4e2d\u627e\u5230\u4e00\u4e9b\u4f7f\u7528 Pydantic \u7684\u4f18\u79c0\u9879\u76ee\u3002</p>"},{"location":"contributing/","title":"\u8d21\u732e","text":"<p>\u6211\u4eec\u975e\u5e38\u6b22\u8fce\u60a8\u4e3a Pydantic \u505a\u51fa\u8d21\u732e\uff01</p>"},{"location":"contributing/#_2","title":"\u95ee\u9898\u62a5\u544a","text":"<p>\u95ee\u9898\u3001\u529f\u80fd\u8bf7\u6c42\u548c\u9519\u8bef\u62a5\u544a\u90fd\u53ef\u4ee5\u901a\u8fc7\u8ba8\u8bba\u6216\u95ee\u9898\u7684\u65b9\u5f0f\u63d0\u51fa\u3002 \u4f46\u662f\uff0c\u8981\u62a5\u544a\u5b89\u5168\u6f0f\u6d1e\uff0c\u8bf7\u53c2\u9605\u6211\u4eec\u7684\u5b89\u5168\u7b56\u7565\u3002</p> <p>\u4e3a\u4e86\u8ba9\u6211\u4eec\u5c3d\u53ef\u80fd\u7b80\u5355\u5730\u5e2e\u52a9\u60a8\uff0c\u8bf7\u5728\u60a8\u7684\u95ee\u9898\u4e2d\u5305\u542b\u4ee5\u4e0b\u8c03\u7528\u7684\u8f93\u51fa\uff1a</p> <pre><code>python -c \"import pydantic.version; print(pydantic.version.version_info())\"\n</code></pre> <p>\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f v2.0 \u4e4b\u524d\u7684 Pydantic\uff0c\u8bf7\u4f7f\u7528\uff1a</p> <pre><code>python -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n</code></pre> <p>\u9664\u975e\u60a8\u65e0\u6cd5\u5b89\u88c5 Pydantic \u6216\u77e5\u9053\u5b83\u4e0e\u60a8\u7684\u95ee\u9898\u6216\u529f\u80fd\u8bf7\u6c42\u65e0\u5173\uff0c\u5426\u5219\u8bf7\u59cb\u7ec8\u5305\u542b\u4e0a\u8ff0\u4fe1\u606f\u3002</p>"},{"location":"contributing/#_3","title":"\u62c9\u53d6\u8bf7\u6c42","text":"<p>\u5f00\u59cb\u521b\u5efa\u62c9\u53d6\u8bf7\u6c42\u5e94\u8be5\u975e\u5e38\u7b80\u5355\u3002 Pydantic \u4f1a\u5b9a\u671f\u53d1\u5e03\uff0c\u56e0\u6b64\u60a8\u5e94\u8be5\u80fd\u5728\u51e0\u5929\u6216\u51e0\u5468\u5185\u770b\u5230\u60a8\u7684\u6539\u8fdb\u53d1\u5e03 \ud83d\ude80\u3002</p> <p>\u9664\u975e\u60a8\u7684\u66f4\u6539\u662f\u5fae\u4e0d\u8db3\u9053\u7684\uff08\u62fc\u5199\u9519\u8bef\u3001\u6587\u6863\u8c03\u6574\u7b49\uff09\uff0c\u5426\u5219\u8bf7\u5728\u521b\u5efa\u62c9\u53d6\u8bf7\u6c42\u4e4b\u524d\u521b\u5efa\u4e00\u4e2a\u95ee\u9898\u6765\u8ba8\u8bba\u66f4\u6539\u3002</p> <p>Pydantic V1 \u5904\u4e8e\u7ef4\u62a4\u6a21\u5f0f</p> <p>Pydantic v1 \u5904\u4e8e\u7ef4\u62a4\u6a21\u5f0f\uff0c\u610f\u5473\u7740\u53ea\u63a5\u53d7\u9519\u8bef\u4fee\u590d\u548c\u5b89\u5168\u4fee\u590d\u3002 \u65b0\u529f\u80fd\u5e94\u8be5\u9488\u5bf9 Pydantic v2\u3002</p> <p>\u8981\u5411 Pydantic v1 \u63d0\u4ea4\u4fee\u590d\uff0c\u8bf7\u4f7f\u7528 <code>1.10.X-fixes</code> \u4f5c\u4e3a\u76ee\u6807\u5206\u652f\u3002</p> <p>\u5982\u679c\u60a8\u6b63\u5728\u5bfb\u627e\u4e00\u4e9b\u6709\u6311\u6218\u6027\u7684\u5de5\u4f5c\uff0c\u8bf7\u67e5\u770b GitHub \u4e0a\u7684 \"help wanted\" \u6807\u7b7e\u3002</p> <p>\u4e3a\u4e86\u4f7f\u8d21\u732e\u5c3d\u53ef\u80fd\u7b80\u5355\u5feb\u6377\uff0c\u60a8\u9700\u8981\u5728\u672c\u5730\u8fd0\u884c\u6d4b\u8bd5\u548c\u4ee3\u7801\u68c0\u67e5\u3002\u5e78\u8fd0\u7684\u662f\uff0c Pydantic \u4f9d\u8d56\u9879\u5f88\u5c11\uff0c\u4e0d\u9700\u8981\u7f16\u8bd1\uff0c\u6d4b\u8bd5\u4e5f\u4e0d\u9700\u8981\u8bbf\u95ee\u6570\u636e\u5e93\u7b49\u3002 \u56e0\u6b64\uff0c\u8bbe\u7f6e\u548c\u8fd0\u884c\u6d4b\u8bd5\u5e94\u8be5\u975e\u5e38\u7b80\u5355\u3002</p> <p>Tip</p> <p>tl;dr\uff1a\u4f7f\u7528 <code>make format</code> \u4fee\u590d\u683c\u5f0f\uff0c\u4f7f\u7528 <code>make</code> \u8fd0\u884c\u6d4b\u8bd5\u548c\u4ee3\u7801\u68c0\u67e5\uff0c\u4f7f\u7528 <code>make docs</code> \u6784\u5efa\u6587\u6863\u3002</p>"},{"location":"contributing/#_4","title":"\u5148\u51b3\u6761\u4ef6","text":"<p>\u60a8\u9700\u8981\u4ee5\u4e0b\u5148\u51b3\u6761\u4ef6\uff1a</p> <ul> <li>Python 3.9 \u5230 3.12 \u4e4b\u95f4\u7684\u4efb\u4f55 Python \u7248\u672c</li> <li>uv \u6216\u5176\u4ed6\u865a\u62df\u73af\u5883\u5de5\u5177</li> <li>git</li> <li>make</li> </ul>"},{"location":"contributing/#_5","title":"\u5b89\u88c5\u548c\u8bbe\u7f6e","text":"<p>\u5728 GitHub \u4e0a fork \u4ed3\u5e93\u5e76\u5728\u672c\u5730\u514b\u9686\u60a8\u7684 fork\u3002</p> <pre><code># \u514b\u9686\u60a8\u7684 fork \u5e76\u8fdb\u5165\u4ed3\u5e93\u76ee\u5f55\ngit clone git@github.com:&lt;your username&gt;/pydantic.git\ncd pydantic\n\n# \u5b89\u88c5 UV \u548c pre-commit\n# \u6211\u4eec\u5728\u8fd9\u91cc\u4f7f\u7528 pipx\uff0c\u6709\u5173\u5176\u4ed6\u9009\u9879\u8bf7\u53c2\u9605\uff1a\n# https://docs.astral.sh/uv/getting-started/installation/\n# https://pre-commit.com/#install\n# \u8981\u83b7\u53d6 pipx \u672c\u8eab\uff1a\n# https://pypa.github.io/pipx/\npipx install uv\npipx install pre-commit\n\n# \u5b89\u88c5 pydantic\u3001\u4f9d\u8d56\u9879\u3001\u6d4b\u8bd5\u4f9d\u8d56\u9879\u548c\u6587\u6863\u4f9d\u8d56\u9879\nmake install\n</code></pre>"},{"location":"contributing/#_6","title":"\u68c0\u51fa\u65b0\u5206\u652f\u5e76\u8fdb\u884c\u66f4\u6539","text":"<p>\u4e3a\u60a8\u7684\u66f4\u6539\u521b\u5efa\u4e00\u4e2a\u65b0\u5206\u652f\u3002</p> <pre><code># \u68c0\u51fa\u65b0\u5206\u652f\u5e76\u8fdb\u884c\u66f4\u6539\ngit checkout -b my-new-feature-branch\n# \u8fdb\u884c\u60a8\u7684\u66f4\u6539...\n</code></pre>"},{"location":"contributing/#_7","title":"\u8fd0\u884c\u6d4b\u8bd5\u548c\u4ee3\u7801\u68c0\u67e5","text":"<p>\u5728\u672c\u5730\u8fd0\u884c\u6d4b\u8bd5\u548c\u4ee3\u7801\u68c0\u67e5\uff0c\u786e\u4fdd\u4e00\u5207\u6309\u9884\u671f\u5de5\u4f5c\u3002</p> <pre><code># \u8fd0\u884c\u81ea\u52a8\u5316\u4ee3\u7801\u683c\u5f0f\u5316\u548c\u4ee3\u7801\u68c0\u67e5\nmake format\n# Pydantic \u4f7f\u7528 ruff\uff0c\u4e00\u4e2a\u7528 rust \u7f16\u5199\u7684\u4f18\u79c0 Python \u4ee3\u7801\u68c0\u67e5\u5668\n# https://github.com/astral-sh/ruff\n\n# \u8fd0\u884c\u6d4b\u8bd5\u548c\u4ee3\u7801\u68c0\u67e5\nmake\n# Makefile \u4e2d\u6709\u4e00\u4e9b\u5b50\u547d\u4ee4\uff0c\u5982 `test`\u3001`testcov` \u548c `lint`\n# \u60a8\u53ef\u80fd\u60f3\u8981\u4f7f\u7528\u8fd9\u4e9b\u547d\u4ee4\uff0c\u4f46\u901a\u5e38\u53ea\u9700 `make` \u5c31\u8db3\u591f\u4e86\u3002\n# \u60a8\u53ef\u4ee5\u8fd0\u884c `make help` \u67e5\u770b\u66f4\u591a\u9009\u9879\u3002\n</code></pre>"},{"location":"contributing/#_8","title":"\u6784\u5efa\u6587\u6863","text":"<p>\u5982\u679c\u60a8\u5bf9\u6587\u6863\u8fdb\u884c\u4e86\u4efb\u4f55\u66f4\u6539\uff08\u5305\u62ec\u5bf9\u51fd\u6570\u7b7e\u540d\u3001\u7c7b\u5b9a\u4e49\u6216\u5c06\u5728 API \u6587\u6863\u4e2d\u51fa\u73b0\u7684\u6587\u6863\u5b57\u7b26\u4e32\u7684\u66f4\u6539\uff09\uff0c\u8bf7\u786e\u4fdd\u6587\u6863\u6784\u5efa\u6210\u529f\u3002</p> <p>\u6211\u4eec\u4f7f\u7528 <code>mkdocs-material[imaging]</code> \u6765\u652f\u6301\u793e\u4ea4\u9884\u89c8\uff08\u8bf7\u53c2\u9605\u63d2\u4ef6\u6587\u6863\uff09\u3002</p> <pre><code># \u6784\u5efa\u6587\u6863\nmake docs\n# \u5982\u679c\u60a8\u66f4\u6539\u4e86\u6587\u6863\uff0c\u8bf7\u786e\u4fdd\u5b83\u6784\u5efa\u6210\u529f\u3002\n# \u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 `uv run mkdocs serve` \u5728 localhost:8000 \u4e0a\u63d0\u4f9b\u6587\u6863\u670d\u52a1\n</code></pre> <p>\u5982\u679c\u7531\u4e8e\u56fe\u50cf\u63d2\u4ef6\u7684\u95ee\u9898\u5bfc\u81f4\u65e0\u6cd5\u6b63\u5e38\u5de5\u4f5c\uff0c\u8bf7\u5c1d\u8bd5\u6ce8\u91ca\u6389 <code>mkdocs.yml</code> \u4e2d\u7684 <code>social</code> \u63d2\u4ef6\u884c\uff0c\u7136\u540e\u518d\u6b21\u8fd0\u884c <code>make docs</code>\u3002</p>"},{"location":"contributing/#_9","title":"\u66f4\u65b0\u6587\u6863","text":"<p>\u6211\u4eec\u4f1a\u5728\u6bcf\u4e2a\u6b21\u8981\u7248\u672c\u53d1\u5e03\u65f6\u63a8\u9001\u65b0\u7248\u672c\u7684\u6587\u6863\uff0c\u5e76\u5728\u6bcf\u6b21\u63d0\u4ea4\u5230 <code>main</code> \u65f6\u63a8\u9001\u5230 <code>dev</code> \u8def\u5f84\u3002</p> <p>\u5982\u679c\u60a8\u5728\u6b21\u8981\u7248\u672c\u53d1\u5e03\u5468\u671f\u4e4b\u5916\u66f4\u65b0\u6587\u6863\uff0c\u5e76\u5e0c\u671b\u60a8\u7684\u66f4\u6539\u53cd\u6620\u5728 <code>latest</code> \u4e0a\uff0c \u8bf7\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a</p> <ol> <li>\u9488\u5bf9 <code>main</code> \u5206\u652f\u6253\u5f00\u4e00\u4e2a\u5305\u542b\u6587\u6863\u66f4\u6539\u7684 PR</li> <li>PR \u5408\u5e76\u540e\uff0c\u68c0\u51fa <code>docs-update</code> \u5206\u652f\u3002\u6b64\u5206\u652f\u5e94\u4e0e\u6700\u65b0\u7684\u8865\u4e01\u7248\u672c\u4fdd\u6301\u540c\u6b65\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u6700\u65b0\u7248\u672c\u662f <code>v2.9.2</code>\uff0c\u60a8\u5e94\u786e\u4fdd <code>docs-update</code> \u4e0e <code>v2.9.2</code> \u6807\u7b7e\u4fdd\u6301\u540c\u6b65\u3002</li> <li>\u4ece <code>docs-update</code> \u68c0\u51fa\u4e00\u4e2a\u65b0\u5206\u652f\uff0c\u5e76\u5c06\u60a8\u7684\u66f4\u6539 cherry-pick \u5230\u6b64\u5206\u652f\u3002</li> <li>\u63a8\u9001\u60a8\u7684\u66f4\u6539\u5e76\u9488\u5bf9 <code>docs-update</code> \u6253\u5f00\u4e00\u4e2a PR\u3002</li> <li>PR \u5408\u5e76\u540e\uff0c\u65b0\u6587\u6863\u5c06\u88ab\u6784\u5efa\u548c\u90e8\u7f72\u3002</li> </ol> <p>Note</p> <p>\u7ef4\u62a4\u8005\u5feb\u6377\u65b9\u5f0f - \u4f5c\u4e3a\u7ef4\u62a4\u8005\uff0c\u60a8\u53ef\u4ee5\u8df3\u8fc7\u7b2c\u4e8c\u4e2a PR\uff0c\u76f4\u63a5 cherry-pick \u5230 <code>docs-update</code> \u5206\u652f\u3002</p>"},{"location":"contributing/#_10","title":"\u63d0\u4ea4\u5e76\u63a8\u9001\u60a8\u7684\u66f4\u6539","text":"<p>\u63d0\u4ea4\u60a8\u7684\u66f4\u6539\uff0c\u5c06\u5206\u652f\u63a8\u9001\u5230 GitHub\uff0c\u5e76\u521b\u5efa\u4e00\u4e2a\u62c9\u53d6\u8bf7\u6c42\u3002</p> <p>\u8bf7\u9075\u5faa\u62c9\u53d6\u8bf7\u6c42\u6a21\u677f\u5e76\u5c3d\u53ef\u80fd\u586b\u5199\u5b8c\u6574\u4fe1\u606f\u3002\u94fe\u63a5\u5230\u4efb\u4f55\u76f8\u5173\u95ee\u9898\u5e76\u5305\u542b\u5bf9\u60a8\u66f4\u6539\u7684\u63cf\u8ff0\u3002</p> <p>\u5f53\u60a8\u7684\u62c9\u53d6\u8bf7\u6c42\u51c6\u5907\u597d\u8fdb\u884c\u5ba1\u67e5\u65f6\uff0c\u6dfb\u52a0\u4e00\u6761\u5305\u542b \"please review\" \u6d88\u606f\u7684\u8bc4\u8bba\uff0c\u6211\u4eec\u4f1a\u5c3d\u5feb\u67e5\u770b\u3002</p>"},{"location":"contributing/#_11","title":"\u6587\u6863\u98ce\u683c","text":"<p>\u6587\u6863\u4f7f\u7528 Markdown \u7f16\u5199\uff0c\u5e76\u4f7f\u7528 Material for MkDocs \u6784\u5efa\u3002API \u6587\u6863\u4f7f\u7528 mkdocstrings \u4ece\u6587\u6863\u5b57\u7b26\u4e32\u6784\u5efa\u3002</p>"},{"location":"contributing/#_12","title":"\u4ee3\u7801\u6587\u6863","text":"<p>\u5728\u4e3a Pydantic \u505a\u8d21\u732e\u65f6\uff0c\u8bf7\u786e\u4fdd\u6240\u6709\u4ee3\u7801\u90fd\u6709\u826f\u597d\u7684\u6587\u6863\u8bb0\u5f55\u3002\u4ee5\u4e0b\u5185\u5bb9\u5e94\u4f7f\u7528\u6b63\u786e\u683c\u5f0f\u7684\u6587\u6863\u5b57\u7b26\u4e32\u8fdb\u884c\u8bb0\u5f55\uff1a</p> <ul> <li>\u6a21\u5757</li> <li>\u7c7b\u5b9a\u4e49</li> <li>\u51fd\u6570\u5b9a\u4e49</li> <li>\u6a21\u5757\u7ea7\u53d8\u91cf</li> </ul> <p>Pydantic \u4f7f\u7528 Google \u98ce\u683c\u7684\u6587\u6863\u5b57\u7b26\u4e32\uff0c\u6309\u7167 PEP 257 \u6307\u5357\u683c\u5f0f\u5316\u3002\uff08\u6709\u5173\u66f4\u591a\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605Google \u98ce\u683c Python \u6587\u6863\u5b57\u7b26\u4e32\u793a\u4f8b\u3002\uff09</p> <p>pydocstyle \u7528\u4e8e\u68c0\u67e5\u6587\u6863\u5b57\u7b26\u4e32\u3002\u60a8\u53ef\u4ee5\u8fd0\u884c <code>make format</code> \u6765\u68c0\u67e5\u60a8\u7684\u6587\u6863\u5b57\u7b26\u4e32\u3002</p> <p>\u5f53 Google \u98ce\u683c\u7684\u6587\u6863\u5b57\u7b26\u4e32\u4e0e pydocstyle \u68c0\u67e5\u5b58\u5728\u51b2\u7a81\u65f6\uff0c\u8bf7\u9075\u5faa pydocstyle \u7684\u68c0\u67e5\u63d0\u793a\u3002</p> <p>\u7c7b\u5c5e\u6027\u548c\u51fd\u6570\u53c2\u6570\u5e94\u4ee5 \"\u540d\u79f0: \u63cf\u8ff0\u3002\" \u7684\u683c\u5f0f\u8fdb\u884c\u8bb0\u5f55\u3002\u9002\u7528\u65f6\uff0c\u8fd4\u56de\u7c7b\u578b\u5e94\u4ec5\u5305\u542b\u63cf\u8ff0\u3002\u7c7b\u578b\u4ece\u7b7e\u540d\u4e2d\u63a8\u65ad\u3002</p> <pre><code>class Foo:\n    \"\"\"\u4e00\u4e2a\u7c7b\u6587\u6863\u5b57\u7b26\u4e32\u3002\n\n    Attributes:\n        bar: bar \u7684\u63cf\u8ff0\u3002\u9ed8\u8ba4\u4e3a \"bar\"\u3002\n    \"\"\"\n\n    bar: str = 'bar'\n</code></pre> <pre><code>def bar(self, baz: int) -&gt; str:\n    \"\"\"\u4e00\u4e2a\u51fd\u6570\u6587\u6863\u5b57\u7b26\u4e32\u3002\n\n    Args:\n        baz: `baz` \u7684\u63cf\u8ff0\u3002\n\n    Returns:\n        \u8fd4\u56de\u503c\u7684\u63cf\u8ff0\u3002\n    \"\"\"\n\n    return 'bar'\n</code></pre> <p>\u60a8\u53ef\u4ee5\u5728\u6587\u6863\u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u793a\u4f8b\u4ee3\u7801\u3002\u6b64\u4ee3\u7801\u5e94\u8be5\u662f\u5b8c\u6574\u3001\u81ea\u5305\u542b\u4e14\u53ef\u8fd0\u884c\u7684\u3002\u6587\u6863\u5b57\u7b26\u4e32\u793a\u4f8b\u4f1a\u88ab\u6d4b\u8bd5\uff0c\u56e0\u6b64\u8bf7\u786e\u4fdd\u5b83\u4eec\u6b63\u786e\u4e14\u5b8c\u6574\u3002\u6709\u5173\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605 <code>FieldInfo.from_annotated_attribute</code>\u3002</p> <p>\u7c7b\u548c\u5b9e\u4f8b\u5c5e\u6027</p> <p>\u7c7b\u5c5e\u6027\u5e94\u5728\u7c7b\u6587\u6863\u5b57\u7b26\u4e32\u4e2d\u8bb0\u5f55\u3002</p> <p>\u5b9e\u4f8b\u5c5e\u6027\u5e94\u5728 <code>__init__</code> \u6587\u6863\u5b57\u7b26\u4e32\u4e2d\u4f5c\u4e3a \"Args\" \u8bb0\u5f55\u3002</p>"},{"location":"contributing/#_13","title":"\u6587\u6863\u98ce\u683c","text":"<p>\u4e00\u822c\u6765\u8bf4\uff0c\u6587\u6863\u5e94\u8be5\u4ee5\u53cb\u597d\u3001\u5e73\u6613\u8fd1\u4eba\u7684\u98ce\u683c\u7f16\u5199\u3002\u5b83\u5e94\u8be5\u6613\u4e8e\u9605\u8bfb\u548c\u7406\u89e3\uff0c\u5e76\u4e14\u5728\u4fdd\u6301\u5b8c\u6574\u7684\u540c\u65f6\u5c3d\u53ef\u80fd\u7b80\u6d01\u3002</p> <p>\u9f13\u52b1\u4f7f\u7528\u4ee3\u7801\u793a\u4f8b\uff0c\u4f46\u5e94\u4fdd\u6301\u7b80\u77ed\u548c\u7b80\u5355\u3002\u7136\u800c\uff0c\u6bcf\u4e2a\u4ee3\u7801\u793a\u4f8b\u90fd\u5e94\u8be5\u662f\u5b8c\u6574\u3001\u81ea\u5305\u542b\u4e14\u53ef\u8fd0\u884c\u7684\u3002\uff08\u5982\u679c\u60a8\u4e0d\u786e\u5b9a\u5982\u4f55\u505a\u5230\u8fd9\u4e00\u70b9\uff0c\u8bf7\u5bfb\u6c42\u5e2e\u52a9\uff01\uff09\u6211\u4eec\u66f4\u559c\u6b22\u6253\u5370\u8f93\u51fa\u800c\u4e0d\u662f\u88f8\u65ad\u8a00\uff0c\u4f46\u5982\u679c\u60a8\u6d4b\u8bd5\u7684\u5185\u5bb9\u6ca1\u6709\u6709\u7528\u7684\u6253\u5370\u8f93\u51fa\uff0c\u65ad\u8a00\u4e5f\u53ef\u4ee5\u3002</p> <p>Pydantic \u7684\u5355\u5143\u6d4b\u8bd5\u5c06\u6d4b\u8bd5\u6587\u6863\u4e2d\u7684\u6240\u6709\u4ee3\u7801\u793a\u4f8b\uff0c\u56e0\u6b64\u786e\u4fdd\u5b83\u4eec\u6b63\u786e\u4e14\u5b8c\u6574\u975e\u5e38\u91cd\u8981\u3002\u6dfb\u52a0\u65b0\u7684\u4ee3\u7801\u793a\u4f8b\u65f6\uff0c\u8bf7\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u6765\u6d4b\u8bd5\u793a\u4f8b\u5e76\u66f4\u65b0\u5176\u683c\u5f0f\u548c\u8f93\u51fa\uff1a</p> <pre><code># \u8fd0\u884c\u6d4b\u8bd5\u5e76\u66f4\u65b0\u4ee3\u7801\u793a\u4f8b\npytest tests/test_docs.py --update-examples\n</code></pre>"},{"location":"contributing/#python-rust","title":"\u8c03\u8bd5 Python \u548c Rust","text":"<p>\u5982\u679c\u60a8\u6b63\u5728\u4f7f\u7528 <code>pydantic</code> \u548c <code>pydantic-core</code>\uff0c\u60a8\u53ef\u80fd\u4f1a\u53d1\u73b0\u540c\u65f6\u8c03\u8bd5 Python \u548c Rust \u4ee3\u7801\u5f88\u6709\u5e2e\u52a9\u3002 \u8fd9\u91cc\u662f\u4e00\u4e2a\u5feb\u901f\u6307\u5357\uff0c\u4ecb\u7ecd\u5982\u4f55\u505a\u5230\u8fd9\u4e00\u70b9\u3002\u672c\u6559\u7a0b\u662f\u5728 VSCode \u4e2d\u5b8c\u6210\u7684\uff0c\u4f46\u60a8\u53ef\u4ee5\u5728\u5176\u4ed6 IDE \u4e2d\u4f7f\u7528\u7c7b\u4f3c\u7684\u6b65\u9aa4\u3002</p>"},{"location":"contributing/#_14","title":"\u5fbd\u7ae0","text":"<p>Pydantic \u6709\u4e00\u4e2a\u5fbd\u7ae0\uff0c\u60a8\u53ef\u4ee5\u7528\u5b83\u6765\u663e\u793a\u60a8\u7684\u9879\u76ee\u4f7f\u7528\u4e86 Pydantic\u3002\u60a8\u53ef\u4ee5\u5728 <code>README.md</code> \u4e2d\u4f7f\u7528\u6b64\u5fbd\u7ae0\uff1a</p>"},{"location":"contributing/#markdown","title":"\u4f7f\u7528 Markdown","text":"<pre><code>[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n</code></pre>"},{"location":"contributing/#restructuredtext","title":"\u4f7f\u7528 reStructuredText","text":"<pre><code>.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n</code></pre>"},{"location":"contributing/#html","title":"\u4f7f\u7528 HTML","text":"<pre><code>&lt;a href=\"https://pydantic.dev\"&gt;&lt;img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\" alt=\"Pydantic Version 1\" style=\"max-width:100%;\"&gt;&lt;/a&gt;\n\n&lt;a href=\"https://pydantic.dev\"&gt;&lt;img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\" alt=\"Pydantic Version 2\" style=\"max-width:100%;\"&gt;&lt;/a&gt;\n</code></pre>"},{"location":"contributing/#pydantic","title":"\u5c06\u60a8\u7684\u5e93\u6dfb\u52a0\u4e3a Pydantic \u7b2c\u4e09\u65b9\u6d4b\u8bd5\u5957\u4ef6\u7684\u4e00\u90e8\u5206","text":"<p>\u4e3a\u4e86\u80fd\u591f\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u53ca\u65e9\u8bc6\u522b\u56de\u5f52\u95ee\u9898\uff0cPydantic \u4f1a\u5728\u5404\u79cd\u4f7f\u7528 Pydantic \u7684\u7b2c\u4e09\u65b9\u9879\u76ee\u4e0a\u8fd0\u884c\u6d4b\u8bd5\u3002 \u5982\u679c\u60a8\u7684\u9879\u76ee\u7b26\u5408\u4ee5\u4e0b\u4e00\u4e9b\u6807\u51c6\uff0c\u6211\u4eec\u4f1a\u8003\u8651\u6dfb\u52a0\u5bf9\u6d4b\u8bd5\u65b0\u7684\u5f00\u6e90\u9879\u76ee\uff08\u4e25\u91cd\u4f9d\u8d56 Pydantic\uff09\u7684\u652f\u6301\uff1a</p> <ul> <li>\u9879\u76ee\u6b63\u5728\u79ef\u6781\u7ef4\u62a4\u3002</li> <li>\u9879\u76ee\u4f7f\u7528\u4e86 Pydantic \u7684\u5185\u90e8\u7ed3\u6784\uff08\u4f8b\u5982\uff0c\u4f9d\u8d56\u4e8e <code>BaseModel</code> \u5143\u7c7b\u3001\u7c7b\u578b\u5de5\u5177\uff09\u3002</li> <li>\u9879\u76ee\u8db3\u591f\u53d7\u6b22\u8fce\uff08\u5c3d\u7ba1\u6839\u636e Pydantic \u7684\u4f7f\u7528\u65b9\u5f0f\uff0c\u5c0f\u578b\u9879\u76ee\u4ecd\u53ef\u80fd\u88ab\u5305\u542b\uff09\u3002</li> <li>\u9879\u76ee\u7684 CI \u8db3\u591f\u7b80\u5355\uff0c\u53ef\u4ee5\u79fb\u690d\u5230 Pydantic \u7684\u6d4b\u8bd5\u5de5\u4f5c\u6d41\u4e2d\u3002</li> </ul> <p>\u5982\u679c\u60a8\u7684\u9879\u76ee\u7b26\u5408\u5176\u4e2d\u4e00\u4e9b\u6807\u51c6\uff0c\u60a8\u53ef\u4ee5\u6253\u5f00\u529f\u80fd\u8bf7\u6c42 \u6765\u8ba8\u8bba\u5c06\u60a8\u7684\u9879\u76ee\u5305\u542b\u5728\u5185\u3002</p>"},{"location":"help_with_pydantic/","title":"\u83b7\u53d6\u5e2e\u52a9","text":"<p>\u5982\u679c\u60a8\u9700\u8981 Pydantic \u5165\u95e8\u5e2e\u52a9\u6216\u9ad8\u7ea7\u7528\u6cd5\u6307\u5bfc\uff0c\u4ee5\u4e0b\u8d44\u6e90\u53ef\u80fd\u4f1a\u5f88\u6709\u7528\u3002</p>"},{"location":"help_with_pydantic/#_2","title":"\u4f7f\u7528\u6587\u6863","text":"<p>\u4f7f\u7528\u6587\u6863\u662f\u5173\u4e8e\u5982\u4f55\u4f7f\u7528 Pydantic \u7684\u6700\u5b8c\u6574\u6307\u5357\u3002</p>"},{"location":"help_with_pydantic/#api","title":"API \u6587\u6863","text":"<p>API \u6587\u6863\u63d0\u4f9b\u4e86\u6240\u6709\u516c\u5171 Pydantic API \u7684\u53c2\u8003\u6587\u6863\u3002</p>"},{"location":"help_with_pydantic/#github","title":"GitHub \u8ba8\u8bba","text":"<p>GitHub \u8ba8\u8bba\u5bf9\u4e8e\u63d0\u95ee\u5f88\u6709\u7528\uff0c\u60a8\u7684\u95ee\u9898\u548c\u7b54\u6848\u5c06\u5e2e\u52a9\u5230\u6bcf\u4e2a\u4eba\u3002</p>"},{"location":"help_with_pydantic/#stack-overflow","title":"Stack Overflow","text":"<p>\u5728 Stack Overflow \u4e0a\u4f7f\u7528 <code>pydantic</code> \u6807\u7b7e\u63d0\u95ee\uff0c\u8bf7\u6ce8\u610f\u8fd9\u5e76\u4e0d\u603b\u662f\u7531 Pydantic \u6838\u5fc3\u56e2\u961f\u76d1\u63a7\u3002</p>"},{"location":"help_with_pydantic/#youtube","title":"YouTube","text":"<p>YouTube \u4e0a\u6709\u8bb8\u591a\u6709\u7528\u7684 Pydantic \u76f8\u5173\u89c6\u9891\u3002</p> <p>\u7279\u522b\u662f Marcelo Trylesinski \u7684\u89c6\u9891 \"Pydantic V1 \u5230 V2 - \u8fc1\u79fb\u6307\u5357\"\u5728\u4ece Pydantic V1 \u8fc1\u79fb\u5230 V2 \u65f6\u5bf9\u5f88\u591a\u4eba\u90fd\u6709\u5f88\u5927\u5e2e\u52a9\u3002</p>"},{"location":"install/","title":"\u5b89\u88c5","text":"<p>\u975e\u5e38\u7b80\u5355\uff1a</p> pipuv <pre><code>pip install pydantic\n</code></pre> <pre><code>uv add pydantic\n</code></pre> <p>Pydantic \u6709\u51e0\u4e2a\u4f9d\u8d56\u9879\uff1a</p> <ul> <li><code>pydantic-core</code>\uff1a\u7528 Rust \u7f16\u5199\u7684 Pydantic \u6838\u5fc3\u9a8c\u8bc1\u903b\u8f91\u3002</li> <li><code>typing-extensions</code>\uff1a\u6807\u51c6\u5e93 typing \u6a21\u5757\u7684\u540e\u5411\u79fb\u690d\u3002</li> <li><code>annotated-types</code>\uff1a\u4e0e <code>typing.Annotated</code> \u4e00\u8d77\u4f7f\u7528\u7684\u53ef\u91cd\u7528\u7ea6\u675f\u7c7b\u578b\u3002</li> </ul> <p>\u5982\u679c\u60a8\u5df2\u7ecf\u5b89\u88c5\u4e86 Python 3.9+ \u548c <code>pip</code>\uff0c\u90a3\u4e48\u60a8\u5c31\u53ef\u4ee5\u5f00\u59cb\u4f7f\u7528\u4e86\u3002</p> <p>Pydantic \u4e5f\u53ef\u4ee5\u5728 conda \u7684 conda-forge \u9891\u9053\u4e0a\u83b7\u53d6\uff1a</p> <pre><code>conda install pydantic -c conda-forge\n</code></pre>"},{"location":"install/#_2","title":"\u53ef\u9009\u4f9d\u8d56\u9879","text":"<p>Pydantic \u6709\u4ee5\u4e0b\u53ef\u9009\u4f9d\u8d56\u9879\uff1a</p> <ul> <li><code>email</code>\uff1a\u7531 email-validator \u5305\u63d0\u4f9b\u7684\u7535\u5b50\u90ae\u4ef6\u9a8c\u8bc1\u3002</li> <li><code>timezone</code>\uff1a\u7531 tzdata \u5305\u63d0\u4f9b\u7684\u5907\u7528 IANA \u65f6\u533a\u6570\u636e\u5e93\u3002</li> </ul> <p>\u8981\u5b89\u88c5 Pydantic \u53ca\u5176\u53ef\u9009\u4f9d\u8d56\u9879\uff1a</p> pipuv <pre><code># \u5305\u542b `email` \u989d\u5916\u4f9d\u8d56\uff1a\npip install 'pydantic[email]'\n# \u6216\u5305\u542b `email` \u548c `timezone` \u989d\u5916\u4f9d\u8d56\uff1a\npip install 'pydantic[email,timezone]'\n</code></pre> <pre><code># \u5305\u542b `email` \u989d\u5916\u4f9d\u8d56\uff1a\nuv add 'pydantic[email]'\n# \u6216\u5305\u542b `email` \u548c `timezone` \u989d\u5916\u4f9d\u8d56\uff1a\nuv add 'pydantic[email,timezone]'\n</code></pre> <p>\u5f53\u7136\uff0c\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>pip install email-validator tzdata</code> \u624b\u52a8\u5b89\u88c5\u9700\u6c42\u3002</p>"},{"location":"install/#_3","title":"\u4ece\u4ed3\u5e93\u5b89\u88c5","text":"<p>\u5982\u679c\u60a8\u5e0c\u671b\u76f4\u63a5\u4ece\u4ed3\u5e93\u5b89\u88c5 Pydantic\uff1a</p> pipuv <pre><code>pip install 'git+https://github.com/pydantic/pydantic@main'\n# \u6216\u5305\u542b `email` \u548c `timezone` \u989d\u5916\u4f9d\u8d56\uff1a\npip install 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n</code></pre> <pre><code>uv add 'git+https://github.com/pydantic/pydantic@main'\n# \u6216\u5305\u542b `email` \u548c `timezone` \u989d\u5916\u4f9d\u8d56\uff1a\nuv add 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n</code></pre>"},{"location":"migration/","title":"\u8fc1\u79fb\u6307\u5357","text":"<p>Pydantic V2 \u5f15\u5165\u4e86\u8bb8\u591a API \u53d8\u66f4\uff0c\u5305\u62ec\u4e00\u4e9b\u7834\u574f\u6027\u53d8\u66f4\u3002</p> <p>\u672c\u9875\u9762\u63d0\u4f9b\u4e86\u4e00\u4e2a\u6307\u5357\uff0c\u91cd\u70b9\u4ecb\u7ecd\u4e86\u6700\u91cd\u8981\u7684\u53d8\u66f4\uff0c\u4ee5\u5e2e\u52a9\u60a8\u5c06\u4ee3\u7801\u4ece Pydantic V1 \u8fc1\u79fb\u5230 Pydantic V2\u3002</p>"},{"location":"migration/#pydantic-v2","title":"\u5b89\u88c5 Pydantic V2","text":"<p>Pydantic V2 \u73b0\u5728\u662f Pydantic \u7684\u5f53\u524d\u751f\u4ea7\u7248\u672c\u3002 \u60a8\u53ef\u4ee5\u4ece PyPI \u5b89\u88c5 Pydantic V2\uff1a</p> <pre><code>pip install -U pydantic\n</code></pre> <p>\u5982\u679c\u9047\u5230\u4efb\u4f55\u95ee\u9898\uff0c\u8bf7\u4f7f\u7528 <code>bug V2</code> \u6807\u7b7e\u5728 GitHub \u4e0a\u521b\u5efa\u95ee\u9898\u3002\u8fd9\u5c06\u5e2e\u52a9\u6211\u4eec\u79ef\u6781\u76d1\u63a7\u548c\u8ddf\u8e2a\u9519\u8bef\uff0c\u5e76\u7ee7\u7eed\u6539\u8fdb\u5e93\u7684\u6027\u80fd\u3002</p> <p>\u5982\u679c\u51fa\u4e8e\u4efb\u4f55\u539f\u56e0\u9700\u8981\u4f7f\u7528\u6700\u65b0\u7684 Pydantic V1\uff0c\u8bf7\u53c2\u9605\u4e0b\u9762\u7684 \u7ee7\u7eed\u4f7f\u7528 Pydantic V1 \u529f\u80fd \u90e8\u5206\uff0c\u4e86\u89e3\u6709\u5173\u4ece <code>pydantic.v1</code> \u5b89\u88c5\u548c\u5bfc\u5165\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p>"},{"location":"migration/#_2","title":"\u4ee3\u7801\u8f6c\u6362\u5de5\u5177","text":"<p>\u6211\u4eec\u521b\u5efa\u4e86\u4e00\u4e2a\u5de5\u5177\u6765\u5e2e\u52a9\u60a8\u8fc1\u79fb\u4ee3\u7801\u3002\u8fd9\u4e2a\u5de5\u5177\u4ecd\u5904\u4e8e\u6d4b\u8bd5\u9636\u6bb5\uff0c\u4f46\u6211\u4eec\u5e0c\u671b\u5b83\u80fd\u5e2e\u52a9\u60a8\u66f4\u5feb\u5730\u8fc1\u79fb\u4ee3\u7801\u3002</p> <p>\u60a8\u53ef\u4ee5\u4ece PyPI \u5b89\u88c5\u8be5\u5de5\u5177\uff1a</p> <pre><code>pip install bump-pydantic\n</code></pre> <p>\u4f7f\u7528\u65b9\u6cd5\u5f88\u7b80\u5355\u3002\u5982\u679c\u60a8\u7684\u9879\u76ee\u7ed3\u6784\u662f\uff1a</p> <pre><code>* repo_folder\n    * my_package\n        * &lt;python \u6e90\u6587\u4ef6&gt; ...\n</code></pre> <p>\u90a3\u4e48\u60a8\u9700\u8981\u6267\u884c\uff1a</p> <pre><code>cd /path/to/repo_folder\nbump-pydantic my_package\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Bump Pydantic \u4ed3\u5e93\u3002</p>"},{"location":"migration/#continue-using-pydantic-v1-features","title":"\u7ee7\u7eed\u4f7f\u7528 Pydantic V1 \u529f\u80fd","text":"<p>\u5f53\u60a8\u9700\u8981\u65f6\uff0cPydantic V1 \u4ecd\u7136\u53ef\u7528\uff0c\u4f46\u6211\u4eec\u5efa\u8bae\u8fc1\u79fb\u5230 Pydantic V2 \u4ee5\u83b7\u5f97\u5176\u6539\u8fdb\u548c\u65b0\u529f\u80fd\u3002</p> <p>\u5982\u679c\u60a8\u9700\u8981\u4f7f\u7528\u6700\u65b0\u7684 Pydantic V1\uff0c\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u547d\u4ee4\u5b89\u88c5\uff1a</p> <pre><code>pip install \"pydantic==1.*\"\n</code></pre> <p>Pydantic V2 \u5305\u8fd8\u7ee7\u7eed\u901a\u8fc7 <code>pydantic.v1</code> \u5bfc\u5165\u63d0\u4f9b\u5bf9 Pydantic V1 API \u7684\u8bbf\u95ee\u3002</p> <p>\u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Pydantic V1 \u7684 <code>BaseModel</code> \u7c7b\u800c\u4e0d\u662f Pydantic V2 \u7684 <code>pydantic.BaseModel</code> \u7c7b\uff1a</p> <pre><code>from pydantic.v1 import BaseModel\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u5bfc\u5165\u5df2\u4ece Pydantic V2 \u4e2d\u79fb\u9664\u7684\u51fd\u6570\uff0c\u4f8b\u5982 <code>lenient_isinstance</code>\uff1a</p> <pre><code>from pydantic.v1.utils import lenient_isinstance\n</code></pre> <p>Pydantic V1 \u6587\u6863\u53ef\u5728 https://docs.pydantic.dev/1.10/ \u83b7\u53d6\u3002</p>"},{"location":"migration/#v1v2-pydantic-v1","title":"\u5728 v1/v2 \u73af\u5883\u4e2d\u4f7f\u7528 Pydantic v1 \u529f\u80fd","text":"<p>\u4ece <code>pydantic&gt;=1.10.17</code> \u5f00\u59cb\uff0c<code>pydantic.v1</code> \u547d\u540d\u7a7a\u95f4\u53ef\u4ee5\u5728 V1 \u4e2d\u4f7f\u7528\u3002 \u8fd9\u4f7f\u5f97\u8fc1\u79fb\u5230 V2 \u66f4\u5bb9\u6613\uff0c\u56e0\u4e3a V2 \u4e5f\u652f\u6301 <code>pydantic.v1</code> \u547d\u540d\u7a7a\u95f4\u3002\u4e3a\u4e86\u89e3\u9664 <code>pydantic&lt;2</code> \u4f9d\u8d56\u5e76\u7ee7\u7eed\u4f7f\u7528 V1 \u529f\u80fd\uff0c\u8bf7\u6267\u884c\u4ee5\u4e0b\u6b65\u9aa4\uff1a</p> <ol> <li>\u5c06 <code>pydantic&lt;2</code> \u66ff\u6362\u4e3a <code>pydantic&gt;=1.10.17</code></li> <li>\u67e5\u627e\u5e76\u66ff\u6362\u6240\u6709\u51fa\u73b0\u7684\uff1a</li> </ol> <pre><code>from pydantic.&lt;module&gt; import &lt;object&gt;\n</code></pre> <p>\u66ff\u6362\u4e3a\uff1a</p> <pre><code>from pydantic.v1.&lt;module&gt; import &lt;object&gt;\n</code></pre> <p>\u4ee5\u4e0b\u662f\u60a8\u53ef\u4ee5\u6839\u636e Pydantic \u7248\u672c\u5bfc\u5165 <code>pydantic</code> \u7684 v1 \u529f\u80fd\u7684\u65b9\u5f0f\uff1a</p> <code>pydantic&gt;=1.10.17,&lt;3</code><code>pydantic&lt;3</code> <p>\u4ece <code>v1.10.17</code> \u5f00\u59cb\uff0c<code>.v1</code> \u547d\u540d\u7a7a\u95f4\u5728 V1 \u4e2d\u53ef\u7528\uff0c\u5141\u8bb8\u5982\u4e0b\u5bfc\u5165\uff1a</p> <pre><code>from pydantic.v1.fields import ModelField\n</code></pre> <p>\u6240\u6709\u7248\u672c\u7684 Pydantic V1 \u548c V2 \u90fd\u652f\u6301\u4ee5\u4e0b\u5bfc\u5165\u6a21\u5f0f\uff0c\u4ee5\u9632\u60a8\u4e0d\u77e5\u9053\u6b63\u5728\u4f7f\u7528\u54ea\u4e2a\u7248\u672c\u7684 Pydantic\uff1a</p> <pre><code>try:\n    from pydantic.v1.fields import ModelField\nexcept ImportError:\n    from pydantic.fields import ModelField\n</code></pre> <p>Note</p> <p>\u5f53\u4f7f\u7528 <code>pydantic&gt;=1.10.17,&lt;2</code> \u548c <code>.v1</code> \u547d\u540d\u7a7a\u95f4\u5bfc\u5165\u6a21\u5757\u65f6\uff0c\u8fd9\u4e9b\u6a21\u5757\u5c06\u4e0d\u662f\u4e0e\u6ca1\u6709 <code>.v1</code> \u547d\u540d\u7a7a\u95f4\u7684\u76f8\u540c\u5bfc\u5165\u76f8\u540c\u7684\u6a21\u5757\uff0c\u4f46\u5bfc\u5165\u7684\u7b26\u53f7\u5c06\u662f\u76f8\u540c\u7684\u3002\u4f8b\u5982 <code>pydantic.v1.fields is not pydantic.fields</code>\uff0c\u4f46 <code>pydantic.v1.fields.ModelField is pydantic.fields.ModelField</code>\u3002\u5e78\u8fd0\u7684\u662f\uff0c\u8fd9\u5728\u7edd\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u4e0d\u592a\u53ef\u80fd\u76f8\u5173\u3002\u8fd9\u53ea\u662f\u63d0\u4f9b\u66f4\u5e73\u6ed1\u8fc1\u79fb\u4f53\u9a8c\u7684\u4e0d\u5e78\u540e\u679c\u3002</p>"},{"location":"migration/#_3","title":"\u8fc1\u79fb\u6307\u5357","text":"<p>\u4ee5\u4e0b\u90e8\u5206\u63d0\u4f9b\u4e86 Pydantic V2 \u4e2d\u6700\u91cd\u8981\u53d8\u66f4\u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p>"},{"location":"migration/#changes-to-pydanticbasemodel","title":"<code>pydantic.BaseModel</code> \u7684\u53d8\u66f4","text":"<p>\u5404\u79cd\u65b9\u6cd5\u540d\u79f0\u5df2\u66f4\u6539\uff1b\u6240\u6709\u975e\u5f03\u7528\u7684 <code>BaseModel</code> \u65b9\u6cd5\u73b0\u5728\u90fd\u5177\u6709\u5339\u914d <code>model_.*</code> \u6216 <code>__.*pydantic.*__</code> \u683c\u5f0f\u7684\u540d\u79f0\u3002\u5728\u53ef\u80fd\u7684\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u4fdd\u7559\u4e86\u5177\u6709\u65e7\u540d\u79f0\u7684\u5df2\u5f03\u7528\u65b9\u6cd5\u4ee5\u5e2e\u52a9\u7b80\u5316\u8fc1\u79fb\uff0c\u4f46\u8c03\u7528\u5b83\u4eec\u5c06\u53d1\u51fa <code>DeprecationWarning</code>\u3002</p> Pydantic V1 Pydantic V2 <code>__fields__</code> <code>model_fields</code> <code>__private_attributes__</code> <code>__pydantic_private__</code> <code>__validators__</code> <code>__pydantic_validator__</code> <code>construct()</code> <code>model_construct()</code> <code>copy()</code> <code>model_copy()</code> <code>dict()</code> <code>model_dump()</code> <code>json_schema()</code> <code>model_json_schema()</code> <code>json()</code> <code>model_dump_json()</code> <code>parse_obj()</code> <code>model_validate()</code> <code>update_forward_refs()</code> <code>model_rebuild()</code> <ul> <li>\u4e00\u4e9b\u5185\u7f6e\u7684\u6570\u636e\u52a0\u8f7d\u529f\u80fd\u5df2\u88ab\u8ba1\u5212\u79fb\u9664\u3002\u7279\u522b\u662f\uff0c<code>parse_raw</code> \u548c <code>parse_file</code> \u73b0\u5728\u5df2\u88ab\u5f03\u7528\u3002\u5728 Pydantic V2 \u4e2d\uff0c<code>model_validate_json</code> \u7684\u5de5\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\u4e8e <code>parse_raw</code>\u3002\u5426\u5219\uff0c\u60a8\u5e94\u8be5\u52a0\u8f7d\u6570\u636e\u7136\u540e\u5c06\u5176\u4f20\u9012\u7ed9 <code>model_validate</code>\u3002</li> <li><code>from_orm</code> \u65b9\u6cd5\u5df2\u88ab\u5f03\u7528\uff1b\u60a8\u73b0\u5728\u53ef\u4ee5\u4f7f\u7528 <code>model_validate</code>\uff08\u76f8\u5f53\u4e8e Pydantic V1 \u4e2d\u7684 <code>parse_obj</code>\uff09\u6765\u5b9e\u73b0\u7c7b\u4f3c\u7684\u529f\u80fd\uff0c\u53ea\u8981\u60a8\u5728\u6a21\u578b\u914d\u7f6e\u4e2d\u8bbe\u7f6e\u4e86 <code>from_attributes=True</code>\u3002</li> <li>\u6a21\u578b\u7684 <code>__eq__</code> \u65b9\u6cd5\u5df2\u66f4\u6539\u3002<ul> <li>\u6a21\u578b\u53ea\u80fd\u4e0e\u5176\u4ed6 <code>BaseModel</code> \u5b9e\u4f8b\u76f8\u7b49\u3002</li> <li>\u4e24\u4e2a\u6a21\u578b\u5b9e\u4f8b\u8981\u76f8\u7b49\uff0c\u5b83\u4eec\u5fc5\u987b\u5177\u6709\u76f8\u540c\u7684\uff1a<ul> <li>\u7c7b\u578b\uff08\u6216\u8005\uff0c\u5bf9\u4e8e\u6cdb\u578b\u6a21\u578b\uff0c\u975e\u53c2\u6570\u5316\u7684\u6cdb\u578b\u539f\u59cb\u7c7b\u578b\uff09</li> <li>\u5b57\u6bb5\u503c</li> <li>\u989d\u5916\u503c\uff08\u4ec5\u5f53 <code>model_config['extra'] == 'allow'</code> \u65f6\u76f8\u5173\uff09</li> <li>\u79c1\u6709\u5c5e\u6027\u503c\uff1b\u5177\u6709\u4e0d\u540c\u79c1\u6709\u5c5e\u6027\u503c\u7684\u6a21\u578b\u4e0d\u518d\u76f8\u7b49\u3002</li> <li>\u6a21\u578b\u4e0d\u518d\u7b49\u4e8e\u5305\u542b\u5176\u6570\u636e\u7684\u5b57\u5178\u3002</li> <li>\u4e0d\u540c\u7c7b\u578b\u7684\u975e\u6cdb\u578b\u6a21\u578b\u6c38\u8fdc\u4e0d\u76f8\u7b49\u3002</li> <li>\u5177\u6709\u4e0d\u540c\u539f\u59cb\u7c7b\u578b\u7684\u6cdb\u578b\u6a21\u578b\u6c38\u8fdc\u4e0d\u76f8\u7b49\u3002\u6211\u4eec\u4e0d\u8981\u6c42\u7cbe\u786e\u7684\u7c7b\u578b\u76f8\u7b49\u6027\uff0c\u56e0\u6b64\uff0c\u4f8b\u5982\uff0c<code>MyGenericModel[Any]</code> \u7684\u5b9e\u4f8b\u53ef\u4ee5\u4e0e <code>MyGenericModel[int]</code> \u7684\u5b9e\u4f8b\u76f8\u7b49\u3002</li> </ul> </li> </ul> </li> <li>\u6211\u4eec\u5df2\u66ff\u6362\u4e86\u4f7f\u7528 <code>__root__</code> \u5b57\u6bb5\u6765\u6307\u5b9a\"\u81ea\u5b9a\u4e49\u6839\u6a21\u578b\"\u7684\u65b9\u5f0f\uff0c\u6539\u7528\u540d\u4e3a <code>RootModel</code> \u7684\u65b0\u7c7b\u578b\uff0c\u65e8\u5728\u66ff\u6362 Pydantic V1 \u4e2d\u4f7f\u7528\u540d\u4e3a <code>__root__</code> \u5b57\u6bb5\u7684\u529f\u80fd\u3002\u8bf7\u6ce8\u610f\uff0c<code>RootModel</code> \u7c7b\u578b\u4e0d\u518d\u652f\u6301 <code>arbitrary_types_allowed</code> \u914d\u7f6e\u8bbe\u7f6e\u3002\u6709\u5173\u8bf4\u660e\uff0c\u8bf7\u53c2\u9605\u6b64\u95ee\u9898\u8bc4\u8bba\u3002</li> <li>\u6211\u4eec\u663e\u8457\u6269\u5c55\u4e86 Pydantic \u5728\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u65b9\u9762\u7684\u80fd\u529b\u3002\u7279\u522b\u662f\uff0c\u6211\u4eec\u6dfb\u52a0\u4e86 <code>@field_serializer</code>\u3001<code>@model_serializer</code> \u548c <code>@computed_field</code> \u88c5\u9970\u5668\uff0c\u6bcf\u4e2a\u90fd\u89e3\u51b3\u4e86 Pydantic V1 \u4e2d\u7684\u5404\u79cd\u7f3a\u70b9\u3002<ul> <li>\u6709\u5173\u8fd9\u4e9b\u65b0\u88c5\u9970\u5668\u7684\u4f7f\u7528\u6587\u6863\uff0c\u8bf7\u53c2\u9605\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668\u3002</li> <li>\u7531\u4e8e\u6027\u80fd\u5f00\u9500\u548c\u5b9e\u73b0\u590d\u6742\u6027\uff0c\u6211\u4eec\u73b0\u5728\u5df2\u5f03\u7528\u5728\u6a21\u578b\u914d\u7f6e\u4e2d\u6307\u5b9a <code>json_encoders</code> \u7684\u652f\u6301\u3002\u6b64\u529f\u80fd\u6700\u521d\u662f\u4e3a\u4e86\u5b9e\u73b0\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u903b\u8f91\u800c\u6dfb\u52a0\u7684\uff0c\u6211\u4eec\u8ba4\u4e3a\u65b0\u7684\u5e8f\u5217\u5316\u88c5\u9970\u5668\u5728\u5927\u591a\u6570\u5e38\u89c1\u573a\u666f\u4e2d\u662f\u66f4\u597d\u7684\u9009\u62e9\u3002</li> </ul> </li> <li>\u6211\u4eec\u66f4\u6539\u4e86\u5f53\u6a21\u578b\u5b50\u7c7b\u4f5c\u4e3a\u7236\u6a21\u578b\u4e2d\u7684\u5d4c\u5957\u5b57\u6bb5\u51fa\u73b0\u65f6\u7684\u5e8f\u5217\u5316\u884c\u4e3a\u3002\u5728 V1 \u4e2d\uff0c\u6211\u4eec\u603b\u662f\u5305\u542b\u5b50\u7c7b\u5b9e\u4f8b\u7684\u6240\u6709\u5b57\u6bb5\u3002\u5728 V2 \u4e2d\uff0c\u5f53\u6211\u4eec\u8f6c\u50a8\u6a21\u578b\u65f6\uff0c\u6211\u4eec\u53ea\u5305\u542b\u5728\u5b57\u6bb5\u7684\u6ce8\u91ca\u7c7b\u578b\u4e0a\u5b9a\u4e49\u7684\u5b57\u6bb5\u3002\u8fd9\u6709\u52a9\u4e8e\u9632\u6b62\u4e00\u4e9b\u610f\u5916\u7684\u5b89\u5168\u9519\u8bef\u3002\u60a8\u53ef\u4ee5\u5728\u6a21\u578b\u5bfc\u51fa\u6587\u6863\u7684\u76f8\u5173\u90e8\u5206\u4e2d\u9605\u8bfb\u66f4\u591a\u76f8\u5173\u4fe1\u606f\uff08\u5305\u62ec\u5982\u4f55\u9009\u62e9\u9000\u51fa\u6b64\u884c\u4e3a\uff09\u3002</li> <li><code>GetterDict</code> \u5df2\u88ab\u79fb\u9664\uff0c\u56e0\u4e3a\u5b83\u53ea\u662f <code>orm_mode</code> \u7684\u5b9e\u73b0\u7ec6\u8282\uff0c\u800c <code>orm_mode</code> \u5df2\u88ab\u79fb\u9664\u3002</li> <li>\u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u4f20\u9012\u7ed9\u6784\u9020\u51fd\u6570\u7684\u53c2\u6570\u5c06\u88ab\u590d\u5236\u4ee5\u6267\u884c\u9a8c\u8bc1\uff0c\u5e76\u5728\u5fc5\u8981\u65f6\u8fdb\u884c\u5f3a\u5236\u8f6c\u6362\uff08\u8bf7\u53c2\u9605\u6587\u6863\uff09\u3002   \u8fd9\u5728\u5c06\u53ef\u53d8\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9\u6784\u9020\u51fd\u6570\u65f6\u5c24\u5176\u503c\u5f97\u6ce8\u610f\u3002</li> <li><code>.json()</code> \u65b9\u6cd5\u5df2\u88ab\u5f03\u7528\uff0c\u5c1d\u8bd5\u4f7f\u7528\u6b64\u5f03\u7528\u65b9\u6cd5\u5e76\u5e26\u6709\u53c2\u6570\uff08\u5982 <code>indent</code> \u6216 <code>ensure_ascii</code>\uff09\u53ef\u80fd\u4f1a\u5bfc\u81f4\u6df7\u6dc6\u7684\u9519\u8bef\u3002\u4e3a\u4e86\u83b7\u5f97\u6700\u4f73\u7ed3\u679c\uff0c\u8bf7\u5207\u6362\u5230 V2 \u7684\u7b49\u6548\u65b9\u6cd5 <code>model_dump_json()</code>\u3002 \u5982\u679c\u60a8\u4ecd\u7136\u60f3\u4f7f\u7528\u4e0a\u8ff0\u53c2\u6570\uff0c\u53ef\u4ee5\u4f7f\u7528\u6b64\u89e3\u51b3\u65b9\u6cd5\u3002</li> <li>\u975e\u5b57\u7b26\u4e32\u952e\u503c\u7684 JSON \u5e8f\u5217\u5316\u901a\u5e38\u4f7f\u7528 <code>str(key)</code> \u5b8c\u6210\uff0c\u8fd9\u5bfc\u81f4\u4e86\u4e00\u4e9b\u884c\u4e3a\u53d8\u5316\uff0c\u4f8b\u5982\uff1a</li> </ul> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: dict[Optional[str], int]\n\n\nclass V2Model(V2BaseModel):\n    a: dict[Optional[str], int]\n\n\nv1_model = V1Model(a={None: 123})\nv2_model = V2Model(a={None: 123})\n\n# V1\nprint(v1_model.json())\n#&gt; {\"a\": {\"null\": 123}}\n\n# V2\nprint(v2_model.model_dump_json())\n#&gt; {\"a\":{\"None\":123}}\n</code></pre> <ul> <li><code>model_dump_json()</code> \u7ed3\u679c\u7ecf\u8fc7\u538b\u7f29\u4ee5\u8282\u7701\u7a7a\u95f4\uff0c\u5e76\u4e0d\u603b\u662f\u4e0e <code>json.dumps()</code> \u8f93\u51fa\u5b8c\u5168\u5339\u914d\u3002 \u8bdd\u867d\u5982\u6b64\uff0c\u60a8\u53ef\u4ee5\u8f7b\u677e\u4fee\u6539 <code>json.dumps()</code> \u7ed3\u679c\u4e2d\u4f7f\u7528\u7684\u5206\u9694\u7b26\u4ee5\u4f7f\u4e24\u4e2a\u8f93\u51fa\u5bf9\u9f50\uff1a</li> </ul> <pre><code>import json\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: list[str]\n\n\nclass V2Model(V2BaseModel):\n    a: list[str]\n\n\nv1_model = V1Model(a=['fancy', 'sushi'])\nv2_model = V2Model(a=['fancy', 'sushi'])\n\n# V1\nprint(v1_model.json())\n#&gt; {\"a\": [\"fancy\", \"sushi\"]}\n\n# V2\nprint(v2_model.model_dump_json())\n#&gt; {\"a\":[\"fancy\",\"sushi\"]}\n\n# Plain json.dumps\nprint(json.dumps(v2_model.model_dump()))\n#&gt; {\"a\": [\"fancy\", \"sushi\"]}\n\n# Modified json.dumps\nprint(json.dumps(v2_model.model_dump(), separators=(',', ':')))\n#&gt; {\"a\":[\"fancy\",\"sushi\"]}\n</code></pre>"},{"location":"migration/#pydanticgenericsgenericmodel","title":"<code>pydantic.generics.GenericModel</code> \u7684\u53d8\u66f4","text":"<p><code>GenericModel</code> \u5df2\u88ab\u79fb\u9664\u3002\u76f8\u53cd\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u7ee7\u627f <code>typing.Generic</code> \u6216 <code>typing_extensions.Generic</code>\u3002</p> <p>\u73b0\u5728\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u76f4\u63a5\u5728 <code>BaseModel</code> \u5b50\u7c7b\u4e0a\u6dfb\u52a0 <code>Generic</code> \u4f5c\u4e3a\u7236\u7c7b\u6765\u521b\u5efa\u6cdb\u578b <code>BaseModel</code> \u5b50\u7c7b\u3002 \u8fd9\u770b\u8d77\u6765\u50cf <code>class MyGenericModel(BaseModel, Generic[T]): ...</code>\u3002</p> <p>\u4e0d\u652f\u6301\u6df7\u5408\u4f7f\u7528 V1 \u548c V2 \u6a21\u578b\uff0c\u8fd9\u610f\u5473\u7740\u6b64\u7c7b\u6cdb\u578b <code>BaseModel</code>\uff08V2\uff09\u7684\u7c7b\u578b\u53c2\u6570\u4e0d\u80fd\u662f V1 \u6a21\u578b\u3002</p> <p>\u867d\u7136\u53ef\u80fd\u4e0d\u4f1a\u5f15\u53d1\u9519\u8bef\uff0c\u4f46\u6211\u4eec\u5f3a\u70c8\u5efa\u8bae\u4e0d\u8981\u5728 <code>isinstance</code> \u68c0\u67e5\u4e2d\u4f7f\u7528\u53c2\u6570\u5316\u6cdb\u578b\u3002</p> <ul> <li>\u4f8b\u5982\uff0c\u60a8\u4e0d\u5e94\u8be5\u6267\u884c <code>isinstance(my_model, MyGenericModel[int])</code>\u3002     \u4f46\u662f\uff0c\u6267\u884c <code>isinstance(my_model, MyGenericModel)</code> \u662f\u53ef\u4ee5\u7684\u3002\uff08\u8bf7\u6ce8\u610f\uff0c\u5bf9\u4e8e\u6807\u51c6\u6cdb\u578b\uff0c\u4f7f\u7528\u53c2\u6570\u5316\u6cdb\u578b\u8fdb\u884c\u5b50\u7c7b\u68c0\u67e5\u4f1a\u5f15\u53d1\u9519\u8bef\u3002\uff09</li> <li>\u5982\u679c\u60a8\u9700\u8981\u5bf9\u53c2\u6570\u5316\u6cdb\u578b\u6267\u884c <code>isinstance</code> \u68c0\u67e5\uff0c\u53ef\u4ee5\u901a\u8fc7\u5b50\u7c7b\u5316\u53c2\u6570\u5316\u6cdb\u578b\u7c7b\u6765\u5b9e\u73b0\u3002\u8fd9\u770b\u8d77\u6765\u50cf <code>class MyIntModel(MyGenericModel[int]): ...</code> \u548c     <code>isinstance(my_model, MyIntModel)</code>\u3002</li> </ul> <p>\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u9605\u6cdb\u578b\u6a21\u578b\u6587\u6863\u3002</p>"},{"location":"migration/#pydanticfield","title":"<code>pydantic.Field</code> \u7684\u53d8\u66f4","text":"<p><code>Field</code> \u4e0d\u518d\u652f\u6301\u5411 JSON \u6a21\u5f0f\u6dfb\u52a0\u4efb\u610f\u5173\u952e\u5b57\u53c2\u6570\u3002\u76f8\u53cd\uff0c\u60a8\u60f3\u8981\u6dfb\u52a0\u5230 JSON \u6a21\u5f0f\u7684\u4efb\u4f55\u989d\u5916\u6570\u636e\u90fd\u5e94\u4f5c\u4e3a\u5b57\u5178\u4f20\u9012\u7ed9 <code>json_schema_extra</code> \u5173\u952e\u5b57\u53c2\u6570\u3002</p> <p>\u5728 Pydantic V1 \u4e2d\uff0c\u5f53\u672a\u8bbe\u7f6e\u522b\u540d\u65f6\uff0c<code>alias</code> \u5c5e\u6027\u8fd4\u56de\u5b57\u6bb5\u7684\u540d\u79f0\u3002 \u5728 Pydantic V2 \u4e2d\uff0c\u6b64\u884c\u4e3a\u5df2\u66f4\u6539\u4e3a\u5f53\u672a\u8bbe\u7f6e\u522b\u540d\u65f6\u8fd4\u56de <code>None</code>\u3002</p> <p>\u4ee5\u4e0b\u5c5e\u6027\u5df2\u4ece <code>Field</code> \u4e2d\u79fb\u9664\u6216\u66f4\u6539\uff1a</p> <ul> <li><code>const</code></li> <li><code>min_items</code>\uff08\u6539\u7528 <code>min_length</code>\uff09</li> <li><code>max_items</code>\uff08\u6539\u7528 <code>max_length</code>\uff09</li> <li><code>unique_items</code></li> <li><code>allow_mutation</code>\uff08\u6539\u7528 <code>frozen</code>\uff09</li> <li><code>regex</code>\uff08\u6539\u7528 <code>pattern</code>\uff09</li> <li><code>final</code>\uff08\u6539\u7528 typing.Final \u7c7b\u578b\u63d0\u793a\uff09</li> </ul> <p>\u5b57\u6bb5\u7ea6\u675f\u4e0d\u518d\u81ea\u52a8\u63a8\u9001\u5230\u6cdb\u578b\u7684\u53c2\u6570\u4e2d\u3002\u4f8b\u5982\uff0c\u60a8\u4e0d\u80fd\u518d\u901a\u8fc7\u63d0\u4f9b <code>my_list: list[str] = Field(pattern=\".*\")</code> \u6765\u9a8c\u8bc1\u5217\u8868\u4e2d\u7684\u6bcf\u4e2a\u5143\u7d20\u662f\u5426\u5339\u914d\u6b63\u5219\u8868\u8fbe\u5f0f\u3002\u76f8\u53cd\uff0c\u4f7f\u7528 <code>typing.Annotated</code> \u5728 <code>str</code> \u672c\u8eab\u4e0a\u63d0\u4f9b\u6ce8\u91ca\uff1a<code>my_list: list[Annotated[str, Field(pattern=\".*\")]]</code></p>"},{"location":"migration/#_4","title":"\u6570\u636e\u7c7b\u7684\u53d8\u66f4","text":"<p>Pydantic \u6570\u636e\u7c7b \u7ee7\u7eed\u7528\u4e8e\u4e3a\u6807\u51c6\u6570\u636e\u7c7b\u542f\u7528\u6570\u636e\u9a8c\u8bc1\uff0c\u800c\u65e0\u9700\u5b50\u7c7b\u5316 <code>BaseModel</code>\u3002Pydantic V2 \u5bf9\u6b64\u6570\u636e\u7c7b\u884c\u4e3a\u5f15\u5165\u4e86\u4ee5\u4e0b\u66f4\u6539\uff1a</p> <ul> <li>\u5f53\u7528\u4f5c\u5b57\u6bb5\u65f6\uff0c\u6570\u636e\u7c7b\uff08Pydantic \u6216\u666e\u901a\u6570\u636e\u7c7b\uff09\u4e0d\u518d\u63a5\u53d7\u5143\u7ec4\u4f5c\u4e3a\u9a8c\u8bc1\u8f93\u5165\uff1b\u5e94\u6539\u7528\u5b57\u5178\u3002</li> <li>Pydantic \u6570\u636e\u7c7b\u4e2d\u7684 <code>__post_init__</code> \u73b0\u5728\u5c06\u5728\u9a8c\u8bc1\u4e4b\u540e\u8c03\u7528\uff0c\u800c\u4e0d\u662f\u4e4b\u524d\u3002<ul> <li>\u56e0\u6b64\uff0c<code>__post_init_post_parse__</code> \u65b9\u6cd5\u53d8\u5f97\u5197\u4f59\uff0c\u56e0\u6b64\u5df2\u88ab\u79fb\u9664\u3002</li> </ul> </li> <li>Pydantic \u4e0d\u518d\u652f\u6301 Pydantic \u6570\u636e\u7c7b\u7684 <code>extra='allow'</code>\uff0c\u5176\u4e2d\u4f20\u9012\u7ed9\u521d\u59cb\u5316\u7a0b\u5e8f\u7684\u989d\u5916\u5b57\u6bb5\u5c06\u4f5c\u4e3a\u989d\u5916\u5c5e\u6027\u5b58\u50a8\u5728\u6570\u636e\u7c7b\u4e0a\u3002<code>extra='ignore'</code> \u4ecd\u7136\u652f\u6301\u7528\u4e8e\u5728\u89e3\u6790\u6570\u636e\u65f6\u5ffd\u7565\u610f\u5916\u5b57\u6bb5\uff0c\u53ea\u662f\u5b83\u4eec\u4e0d\u4f1a\u5b58\u50a8\u5728\u5b9e\u4f8b\u4e0a\u3002</li> <li>Pydantic \u6570\u636e\u7c7b\u4e0d\u518d\u5177\u6709\u5c5e\u6027 <code>__pydantic_model__</code>\uff0c\u5e76\u4e14\u4e0d\u518d\u4f7f\u7528\u5e95\u5c42\u7684 <code>BaseModel</code> \u6765\u6267\u884c\u9a8c\u8bc1\u6216\u63d0\u4f9b\u5176\u4ed6\u529f\u80fd\u3002<ul> <li>\u8981\u6267\u884c\u9a8c\u8bc1\u3001\u751f\u6210 JSON \u6a21\u5f0f\u6216\u4f7f\u7528\u4efb\u4f55\u5176\u4ed6\u5728 V1 \u4e2d\u53ef\u80fd\u9700\u8981 <code>__pydantic_model__</code> \u7684\u529f\u80fd\uff0c\u60a8\u73b0\u5728\u5e94\u8be5\u5c06\u6570\u636e\u7c7b\u5305\u88c5\u5728 <code>TypeAdapter</code> \u4e2d\uff08\u4e0b\u9762\u8ba8\u8bba\u66f4\u591a\uff09\u5e76\u4f7f\u7528\u5176\u65b9\u6cd5\u3002</li> </ul> </li> <li>\u5728 Pydantic V1 \u4e2d\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u666e\u901a\uff08\u5373\u975e Pydantic\uff09\u6570\u636e\u7c7b\u4f5c\u4e3a\u5b57\u6bb5\uff0c\u7236\u7c7b\u578b\u7684\u914d\u7f6e\u5c06\u88ab\u7528\u4f5c\u6570\u636e\u7c7b\u672c\u8eab\u7684\u914d\u7f6e\u3002\u5728 Pydantic V2 \u4e2d\uff0c\u60c5\u51b5\u4e0d\u518d\u5982\u6b64\u3002<ul> <li>\u5728 Pydantic V2 \u4e2d\uff0c\u8981\u8986\u76d6\u914d\u7f6e\uff08\u5c31\u50cf\u60a8\u5728 <code>BaseModel</code> \u4e0a\u4f7f\u7528 <code>model_config</code> \u4e00\u6837\uff09\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>@dataclass</code> \u88c5\u9970\u5668\u4e0a\u7684 <code>config</code> \u53c2\u6570\u3002     \u6709\u5173\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605\u6570\u636e\u7c7b\u914d\u7f6e\u3002</li> </ul> </li> </ul>"},{"location":"migration/#_5","title":"\u914d\u7f6e\u7684\u53d8\u66f4","text":"<ul> <li> <p>\u5728 Pydantic V2 \u4e2d\uff0c\u8981\u5728\u6a21\u578b\u4e0a\u6307\u5b9a\u914d\u7f6e\uff0c\u60a8\u5e94\u8be5\u8bbe\u7f6e\u4e00\u4e2a\u540d\u4e3a <code>model_config</code> \u7684\u7c7b\u5c5e\u6027\uff0c\u8be5\u5c5e\u6027\u662f\u4e00\u4e2a\u5305\u542b\u60a8\u60f3\u8981\u7528\u4f5c\u914d\u7f6e\u7684\u952e/\u503c\u5bf9\u7684\u5b57\u5178\u3002Pydantic V1 \u5728\u7236 <code>BaseModel</code> \u5b50\u7c7b\u7684\u547d\u540d\u7a7a\u95f4\u4e2d\u521b\u5efa\u540d\u4e3a <code>Config</code> \u7684\u7c7b\u7684\u884c\u4e3a\u73b0\u5728\u5df2\u88ab\u5f03\u7528\u3002</p> </li> <li> <p>\u5f53\u5b50\u7c7b\u5316\u6a21\u578b\u65f6\uff0c<code>model_config</code> \u5c5e\u6027\u4f1a\u88ab\u7ee7\u627f\u3002\u8fd9\u5728\u60a8\u5e0c\u671b\u4e3a\u8bb8\u591a\u6a21\u578b\u4f7f\u7528\u5177\u6709\u7ed9\u5b9a\u914d\u7f6e\u7684\u57fa\u7c7b\u65f6\u5f88\u6709\u5e2e\u52a9\u3002\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u60a8\u4ece\u591a\u4e2a <code>BaseModel</code> \u5b50\u7c7b\u7ee7\u627f\uff0c\u4f8b\u5982 <code>class MyModel(Model1, Model2)</code>\uff0c\u6765\u81ea\u4e24\u4e2a\u6a21\u578b\u7684 <code>model_config</code> \u5c5e\u6027\u4e2d\u7684\u975e\u9ed8\u8ba4\u8bbe\u7f6e\u5c06\u88ab\u5408\u5e76\uff0c\u5bf9\u4e8e\u5728\u4e24\u4e2a\u6a21\u578b\u4e2d\u5b9a\u4e49\u7684\u4efb\u4f55\u8bbe\u7f6e\uff0c\u6765\u81ea <code>Model2</code> \u7684\u8bbe\u7f6e\u5c06\u8986\u76d6\u6765\u81ea <code>Model1</code> \u7684\u8bbe\u7f6e\u3002</p> </li> <li> <p>\u4ee5\u4e0b\u914d\u7f6e\u8bbe\u7f6e\u5df2\u88ab\u79fb\u9664\uff1a</p> <ul> <li><code>allow_mutation</code> \u2014 \u8fd9\u5df2\u88ab\u79fb\u9664\u3002\u60a8\u5e94\u8be5\u80fd\u591f\u7b49\u6548\u5730\u4f7f\u7528 frozen\uff08\u4e0e\u5f53\u524d\u4f7f\u7528\u76f8\u53cd\uff09\u3002</li> <li><code>error_msg_templates</code></li> <li><code>fields</code> \u2014 \u8fd9\u662f\u5404\u79cd\u9519\u8bef\u7684\u6765\u6e90\uff0c\u56e0\u6b64\u5df2\u88ab\u79fb\u9664\u3002   \u60a8\u5e94\u8be5\u80fd\u591f\u4f7f\u7528 <code>Annotated</code> \u5728\u5b57\u6bb5\u4e0a\u6309\u9700\u4fee\u6539\u5b83\u4eec\u3002</li> <li><code>getter_dict</code> \u2014 <code>orm_mode</code> \u5df2\u88ab\u79fb\u9664\uff0c\u6b64\u5b9e\u73b0\u7ec6\u8282\u4e0d\u518d\u5fc5\u8981\u3002</li> <li><code>smart_union</code> - Pydantic V2 \u4e2d\u7684\u9ed8\u8ba4 <code>union_mode</code> \u662f <code>'smart'</code>\u3002</li> <li><code>underscore_attrs_are_private</code> \u2014 Pydantic V2 \u7684\u884c\u4e3a\u73b0\u5728\u4e0e\u5728 Pydantic V1 \u4e2d\u59cb\u7ec8\u8bbe\u7f6e\u4e3a <code>True</code> \u76f8\u540c\u3002</li> <li><code>json_loads</code></li> <li><code>json_dumps</code></li> <li><code>copy_on_model_validation</code></li> <li><code>post_init_call</code></li> </ul> </li> <li> <p>\u4ee5\u4e0b\u914d\u7f6e\u8bbe\u7f6e\u5df2\u91cd\u547d\u540d\uff1a</p> <ul> <li><code>allow_population_by_field_name</code> \u2192 <code>populate_by_name</code>\uff08\u6216\u4ece v2.11 \u5f00\u59cb\u4f7f\u7528 <code>validate_by_name</code>\uff09</li> <li><code>anystr_lower</code> \u2192 <code>str_to_lower</code></li> <li><code>anystr_strip_whitespace</code> \u2192 <code>str_strip_whitespace</code></li> <li><code>anystr_upper</code> \u2192 <code>str_to_upper</code></li> <li><code>keep_untouched</code> \u2192 <code>ignored_types</code></li> <li><code>max_anystr_length</code> \u2192 <code>str_max_length</code></li> <li><code>min_anystr_length</code> \u2192 <code>str_min_length</code></li> <li><code>orm_mode</code> \u2192 <code>from_attributes</code></li> <li><code>schema_extra</code> \u2192 <code>json_schema_extra</code></li> <li><code>validate_all</code> \u2192 <code>validate_default</code></li> </ul> </li> </ul> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>ConfigDict</code> API \u53c2\u8003\u3002</p>"},{"location":"migration/#_6","title":"\u9a8c\u8bc1\u5668\u7684\u53d8\u66f4","text":""},{"location":"migration/#validator-root_validator","title":"<code>@validator</code> \u548c <code>@root_validator</code> \u5df2\u5f03\u7528","text":"<ul> <li><code>@validator</code> \u5df2\u88ab\u5f03\u7528\uff0c\u5e94\u66ff\u6362\u4e3a <code>@field_validator</code>\uff0c\u5b83\u63d0\u4f9b\u4e86\u5404\u79cd\u65b0\u529f\u80fd\u548c\u6539\u8fdb\u3002<ul> <li>\u65b0\u7684 <code>@field_validator</code> \u88c5\u9970\u5668\u6ca1\u6709 <code>each_item</code> \u5173\u952e\u5b57\u53c2\u6570\uff1b\u60a8\u60f3\u8981\u5e94\u7528\u4e8e\u6cdb\u578b\u5bb9\u5668\u5185\u9879\u76ee\u7684\u9a8c\u8bc1\u5668\u5e94\u901a\u8fc7\u6ce8\u91ca\u7c7b\u578b\u53c2\u6570\u6765\u6dfb\u52a0\u3002\u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605Annotated \u5143\u6570\u636e\u4e2d\u7684\u9a8c\u8bc1\u5668\u3002     \u8fd9\u770b\u8d77\u6765\u50cf <code>list[Annotated[int, Field(ge=0)]]</code></li> <li>\u5373\u4f7f\u60a8\u7ee7\u7eed\u4f7f\u7528\u5df2\u5f03\u7528\u7684 <code>@validator</code> \u88c5\u9970\u5668\uff0c\u60a8\u4e5f\u4e0d\u80fd\u518d\u5411\u9a8c\u8bc1\u5668\u51fd\u6570\u7684\u7b7e\u540d\u6dfb\u52a0 <code>field</code> \u6216 <code>config</code> \u53c2\u6570\u3002\u5982\u679c\u60a8\u9700\u8981\u8bbf\u95ee\u8fd9\u4e9b\u53c2\u6570\uff0c\u60a8\u9700\u8981\u8fc1\u79fb\u5230 <code>@field_validator</code> \u2014 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u4e00\u8282\u3002</li> <li>\u5982\u679c\u60a8\u4f7f\u7528 <code>always=True</code> \u5173\u952e\u5b57\u53c2\u6570\u5230\u9a8c\u8bc1\u5668\u51fd\u6570\uff0c\u8bf7\u6ce8\u610f\u6ce8\u91ca\u7c7b\u578b\u7684\u6807\u51c6\u9a8c\u8bc1\u5668\u4e5f\u5c06\u5e94\u7528\u4e8e\u9ed8\u8ba4\u503c\uff0c\u800c\u4e0d\u4ec5\u4ec5\u662f\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u3002\u4f8b\u5982\uff0c\u5c3d\u7ba1\u4e0b\u9762\u7684\u9a8c\u8bc1\u5668\u6c38\u8fdc\u4e0d\u4f1a\u51fa\u9519\uff0c\u4f46\u4ee5\u4e0b\u4ee3\u7801\u4f1a\u5f15\u53d1 <code>ValidationError</code>\uff1a</li> </ul> </li> </ul> <p>Note</p> <p>\u4e3a\u907f\u514d\u8fd9\u79cd\u60c5\u51b5\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>Field</code> \u51fd\u6570\u4e2d\u7684 <code>validate_default</code> \u53c2\u6570\u3002\u5f53\u8bbe\u7f6e\u4e3a <code>True</code> \u65f6\uff0c\u5b83\u6a21\u62df\u4e86 Pydantic v1 \u4e2d <code>always=True</code> \u7684\u884c\u4e3a\u3002\u4f46\u662f\uff0c\u9f13\u52b1\u4f7f\u7528\u65b0\u7684 <code>validate_default</code> \u65b9\u5f0f\uff0c\u56e0\u4e3a\u5b83\u63d0\u4f9b\u4e86\u66f4\u591a\u7684\u7075\u6d3b\u6027\u548c\u63a7\u5236\u3002</p> <pre><code>from pydantic import BaseModel, validator\n\n\nclass Model(BaseModel):\n    x: str = 1\n\n    @validator('x', always=True)\n    @classmethod\n    def validate_x(cls, v):\n        return v\n\n\nModel()\n</code></pre> <ul> <li><code>@root_validator</code> \u5df2\u88ab\u5f03\u7528\uff0c\u5e94\u66ff\u6362\u4e3a     <code>@model_validator</code>\uff0c\u5b83\u4e5f\u63d0\u4f9b\u4e86\u65b0\u529f\u80fd\u548c\u6539\u8fdb\u3002<ul> <li>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff08\u4f8b\u5982\u5f53 <code>model_config['validate_assignment'] is True</code> \u65f6\u8fdb\u884c\u8d4b\u503c\uff09\uff0c     <code>@model_validator</code> \u88c5\u9970\u5668\u5c06\u63a5\u6536\u6a21\u578b\u7684\u5b9e\u4f8b\uff0c\u800c\u4e0d\u662f\u503c\u7684\u5b57\u5178\u3002\u60a8\u53ef\u80fd\u9700\u8981\u5c0f\u5fc3\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\u3002</li> <li>\u5373\u4f7f\u60a8\u7ee7\u7eed\u4f7f\u7528\u5df2\u5f03\u7528\u7684 <code>@root_validator</code> \u88c5\u9970\u5668\uff0c\u7531\u4e8e\u9a8c\u8bc1\u903b\u8f91\u7684\u91cd\u6784\uff0c     \u60a8\u4e0d\u80fd\u518d\u4f7f\u7528 <code>skip_on_failure=False</code> \u8fd0\u884c\uff08\u8fd9\u662f\u6b64\u5173\u952e\u5b57\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\uff0c\u56e0\u6b64\u5fc5\u987b\u663e\u5f0f\u8bbe\u7f6e\u4e3a <code>True</code>\uff09\u3002</li> </ul> </li> </ul>"},{"location":"migration/#changes-to-validators-allowed-signatures","title":"<code>@validator</code> \u5141\u8bb8\u7b7e\u540d\u7684\u53d8\u66f4","text":"<p>\u5728 Pydantic V1 \u4e2d\uff0c\u7531 <code>@validator</code> \u5305\u88c5\u7684\u51fd\u6570\u53ef\u4ee5\u63a5\u6536\u5e26\u6709\u5173\u4e8e\u6b63\u5728\u9a8c\u8bc1\u5185\u5bb9\u7684\u5143\u6570\u636e\u7684\u5173\u952e\u5b57\u53c2\u6570\u3002\u5176\u4e2d\u4e00\u4e9b\u53c2\u6570\u5df2\u4ece Pydantic V2 \u4e2d\u7684 <code>@field_validator</code> \u4e2d\u79fb\u9664\uff1a</p> <ul> <li><code>config</code>\uff1aPydantic V2 \u7684\u914d\u7f6e\u73b0\u5728\u662f\u4e00\u4e2a\u5b57\u5178\u800c\u4e0d\u662f\u7c7b\uff0c\u8fd9\u610f\u5473\u7740\u6b64\u53c2\u6570\u4e0d\u518d\u5411\u540e\u517c\u5bb9\u3002\u5982\u679c\u60a8\u9700\u8981\u8bbf\u95ee\u914d\u7f6e\uff0c\u60a8\u5e94\u8be5\u8fc1\u79fb\u5230 <code>@field_validator</code> \u5e76\u4f7f\u7528 <code>info.config</code>\u3002</li> <li><code>field</code>\uff1a\u6b64\u53c2\u6570\u8fc7\u53bb\u662f\u4e00\u4e2a <code>ModelField</code> \u5bf9\u8c61\uff0c\u8fd9\u662f\u4e00\u4e2a\u51c6\u5185\u90e8\u7c7b\uff0c\u5728 Pydantic V2 \u4e2d\u4e0d\u518d\u5b58\u5728\u3002     \u901a\u8fc7\u4f7f\u7528 <code>info.field_name</code> \u4e2d\u7684\u5b57\u6bb5\u540d\u7d22\u5f15\u5230 <code>cls.model_fields</code> \u4e2d\uff0c\u4ecd\u7136\u53ef\u4ee5\u8bbf\u95ee\u5927\u90e8\u5206\u6b64\u4fe1\u606f\u3002</li> </ul> <pre><code>from pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int, info: ValidationInfo) -&gt; int:\n        assert info.config is not None\n        print(info.config.get('title'))\n        #&gt; Model\n        print(cls.model_fields[info.field_name].is_required())\n        #&gt; True\n        return v\n\n\nModel(x=1)\n</code></pre>"},{"location":"migration/#typeerror-validationerror","title":"\u9a8c\u8bc1\u5668\u4e2d <code>TypeError</code> \u4e0d\u518d\u8f6c\u6362\u4e3a <code>ValidationError</code>","text":"<p>\u4ee5\u524d\uff0c\u5728\u9a8c\u8bc1\u5668\u51fd\u6570\u4e2d\u5f15\u53d1 <code>TypeError</code> \u65f6\uff0c\u8be5\u9519\u8bef\u5c06\u88ab\u5305\u88c5\u5230 <code>ValidationError</code> \u4e2d\uff0c\u5e76\u4e14\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff08\u4f8b\u5982\u4f7f\u7528 FastAPI\uff09\uff0c\u8fd9\u4e9b\u9519\u8bef\u53ef\u80fd\u4f1a\u663e\u793a\u7ed9\u6700\u7ec8\u7528\u6237\u3002\u8fd9\u5bfc\u81f4\u4e86\u5404\u79cd\u4e0d\u826f\u884c\u4e3a \u2014 \u4f8b\u5982\uff0c\u4f7f\u7528\u9519\u8bef\u7b7e\u540d\u8c03\u7528\u51fd\u6570\u53ef\u80fd\u4f1a\u4ea7\u751f\u9762\u5411\u7528\u6237\u7684 <code>ValidationError</code>\u3002</p> <p>\u7136\u800c\uff0c\u5728 Pydantic V2 \u4e2d\uff0c\u5f53\u5728\u9a8c\u8bc1\u5668\u4e2d\u5f15\u53d1 <code>TypeError</code> \u65f6\uff0c\u5b83\u4e0d\u518d\u8f6c\u6362\u4e3a <code>ValidationError</code>\uff1a</p> <pre><code>import pytest\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int) -&gt; int:\n        return str.lower(v)  # \u5f15\u53d1 TypeError\n\n\nwith pytest.raises(TypeError):\n    Model(x=1)\n</code></pre> <p>\u8fd9\u9002\u7528\u4e8e\u6240\u6709\u9a8c\u8bc1\u88c5\u9970\u5668\u3002</p>"},{"location":"migration/#_7","title":"\u9a8c\u8bc1\u5668\u884c\u4e3a\u53d8\u66f4","text":"<p>Pydantic V2 \u5305\u542b\u4e00\u4e9b\u7c7b\u578b\u5f3a\u5236\u8f6c\u6362\u7684\u66f4\u6539\u3002\u4f8b\u5982\uff1a</p> <ul> <li>\u5c06 <code>int</code>\u3001<code>float</code> \u548c <code>Decimal</code> \u503c\u5f3a\u5236\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u73b0\u5728\u662f\u53ef\u9009\u7684\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u7981\u7528\uff0c\u8bf7\u53c2\u9605   \u5c06\u6570\u5b57\u5f3a\u5236\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u3002</li> <li>\u6210\u5bf9\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61\u4e0d\u518d\u5f3a\u5236\u8f6c\u6362\u4e3a\u5b57\u5178\u3002</li> </ul> <p>\u6709\u5173 Pydantic V2 \u7c7b\u578b\u5f3a\u5236\u8f6c\u6362\u9ed8\u8ba4\u503c\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u8f6c\u6362\u8868\u3002</p>"},{"location":"migration/#allow_reuse","title":"<code>allow_reuse</code> \u5173\u952e\u5b57\u53c2\u6570\u4e0d\u518d\u5fc5\u8981","text":"<p>\u4ee5\u524d\uff0cPydantic \u8ddf\u8e2a\u88c5\u9970\u5668\u4e2d\u7684\"\u91cd\u7528\"\u51fd\u6570\uff0c\u56e0\u4e3a\u8fd9\u662f\u4e00\u4e2a\u5e38\u89c1\u7684\u9519\u8bef\u6765\u6e90\u3002 \u6211\u4eec\u901a\u8fc7\u6bd4\u8f83\u51fd\u6570\u7684\u5b8c\u5168\u9650\u5b9a\u540d\uff08\u6a21\u5757\u540d + \u51fd\u6570\u540d\uff09\u6765\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u8bef\u62a5\u3002 \u5f53\u6709\u610f\u91cd\u7528\u65f6\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>allow_reuse</code> \u5173\u952e\u5b57\u53c2\u6570\u6765\u7981\u7528\u6b64\u529f\u80fd\u3002</p> <p>\u6211\u4eec\u68c0\u6d4b\u91cd\u590d\u5b9a\u4e49\u51fd\u6570\u7684\u65b9\u6cd5\u5df2\u7ecf\u5f7b\u5e95\u6539\u9769\uff0c\u73b0\u5728\u53ea\u5bf9\u5728\u5355\u4e2a\u7c7b\u5185\u91cd\u65b0\u5b9a\u4e49\u62a5\u9519\uff0c \u51cf\u5c11\u4e86\u8bef\u62a5\uff0c\u5e76\u4f7f\u884c\u4e3a\u66f4\u7b26\u5408\u7c7b\u578b\u68c0\u67e5\u5668\u548c linter \u5728\u5355\u4e2a\u7c7b\u5b9a\u4e49\u4e2d\u591a\u6b21\u5b9a\u4e49\u540c\u540d\u65b9\u6cd5\u65f6\u4f1a\u7ed9\u51fa\u7684\u9519\u8bef\u3002</p> <p>\u5728\u51e0\u4e4e\u6240\u6709\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u4e86 <code>allow_reuse=True</code>\uff0c\u60a8\u5e94\u8be5\u80fd\u591f\u7b80\u5355\u5730\u5220\u9664\u8be5\u5173\u952e\u5b57\u53c2\u6570\uff0c \u5e76\u8ba9\u4e00\u5207\u6309\u9884\u671f\u7ee7\u7eed\u5de5\u4f5c\u3002</p>"},{"location":"migration/#validate_arguments-validate_call","title":"<code>@validate_arguments</code> \u5df2\u91cd\u547d\u540d\u4e3a <code>@validate_call</code>","text":"<p>\u5728 Pydantic V2 \u4e2d\uff0c<code>@validate_arguments</code> \u88c5\u9970\u5668\u5df2\u91cd\u547d\u540d\u4e3a <code>@validate_call</code>\u3002</p> <p>\u5728 Pydantic V1 \u4e2d\uff0c\u88c5\u9970\u7684\u51fd\u6570\u6dfb\u52a0\u4e86\u5404\u79cd\u5c5e\u6027\uff0c\u4f8b\u5982 <code>raw_function</code> \u548c <code>validate</code> \uff08\u53ef\u7528\u4e8e\u9a8c\u8bc1\u53c2\u6570\u800c\u65e0\u9700\u5b9e\u9645\u8c03\u7528\u88c5\u9970\u7684\u51fd\u6570\uff09\u3002\u7531\u4e8e\u8fd9\u4e9b\u5c5e\u6027\u7684\u4f7f\u7528\u6709\u9650\uff0c\u4ee5\u53ca\u5b9e\u73b0\u4e2d\u9762\u5411\u6027\u80fd\u7684\u66f4\u6539\uff0c \u6211\u4eec\u672a\u5728 <code>@validate_call</code> \u4e2d\u4fdd\u7559\u6b64\u529f\u80fd\u3002</p>"},{"location":"migration/#_8","title":"\u8f93\u5165\u7c7b\u578b\u4e0d\u4fdd\u7559","text":"<p>\u5728 Pydantic V1 \u4e2d\uff0c\u6211\u4eec\u52aa\u529b\u4fdd\u7559\u6cdb\u578b\u96c6\u5408\u7684\u6240\u6709\u5b57\u6bb5\u8f93\u5165\u7c7b\u578b\uff0c\u5f53\u5b83\u4eec\u662f\u5b57\u6bb5\u6ce8\u91ca\u7684\u9002\u5f53\u5b50\u7c7b\u578b\u65f6\u3002\u4f8b\u5982\uff0c\u7ed9\u5b9a\u6ce8\u91ca <code>Mapping[str, int]</code>\uff0c\u5982\u679c\u60a8\u4f20\u5165 <code>collection.Counter()</code>\uff0c\u60a8\u5c06\u5f97\u5230 <code>collection.Counter()</code> \u4f5c\u4e3a\u503c\u3002</p> <p>\u5728 V2 \u4e2d\u652f\u6301\u6b64\u884c\u4e3a\u5c06\u5bf9\u4e00\u822c\u60c5\u51b5\u4ea7\u751f\u8d1f\u9762\u6027\u80fd\u5f71\u54cd\uff08\u6211\u4eec\u5fc5\u987b\u6bcf\u6b21\u90fd\u68c0\u67e5\u7c7b\u578b\uff09\uff0c\u5e76\u4e14\u4f1a\u7ed9\u9a8c\u8bc1\u589e\u52a0\u5f88\u591a\u590d\u6742\u6027\u3002\u6b64\u5916\uff0c\u5373\u4f7f\u5728 V1 \u4e2d\uff0c\u6b64\u884c\u4e3a\u4e5f\u4e0d\u4e00\u81f4\u4e14\u90e8\u5206\u635f\u574f\uff1a\u5b83\u5bf9\u8bb8\u591a\u7c7b\u578b\uff08<code>str</code>\u3001<code>UUID</code> \u7b49\uff09\u4e0d\u8d77\u4f5c\u7528\uff0c\u5e76\u4e14\u5bf9\u4e8e\u6cdb\u578b\u96c6\u5408\uff0c\u6ca1\u6709\u5927\u91cf\u7279\u6b8a\u60c5\u51b5\u5904\u7406\uff0c\u65e0\u6cd5\u6b63\u786e\u91cd\u5efa\u539f\u59cb\u8f93\u5165\uff08\u8003\u8651 <code>ChainMap</code>\uff1b\u91cd\u5efa\u8f93\u5165\u662f\u5fc5\u8981\u7684\uff0c\u56e0\u4e3a\u6211\u4eec\u9700\u8981\u5728\u9a8c\u8bc1\u540e\u66ff\u6362\u503c\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u5f3a\u5236\u8f6c\u6362\u5b57\u7b26\u4e32\u4e3a\u6574\u6570\uff09\u3002</p> <p>\u5728 Pydantic V2 \u4e2d\uff0c\u6211\u4eec\u4e0d\u518d\u5c1d\u8bd5\u5728\u6240\u6709\u60c5\u51b5\u4e0b\u4fdd\u7559\u8f93\u5165\u7c7b\u578b\uff1b\u76f8\u53cd\uff0c\u6211\u4eec\u53ea\u627f\u8bfa\u8f93\u51fa\u7c7b\u578b\u5c06\u5339\u914d\u7c7b\u578b\u6ce8\u91ca\u3002</p> <p>\u56de\u5230 <code>Mapping</code> \u793a\u4f8b\uff0c\u6211\u4eec\u627f\u8bfa\u8f93\u51fa\u5c06\u662f\u6709\u6548\u7684 <code>Mapping</code>\uff0c\u5b9e\u9645\u4e0a\u5b83\u5c06\u662f\u4e00\u4e2a\u666e\u901a\u7684 <code>dict</code>\uff1a</p> <pre><code>from collections.abc import Mapping\n\nfrom pydantic import TypeAdapter\n\n\nclass MyDict(dict):\n    pass\n\n\nta = TypeAdapter(Mapping[str, int])\nv = ta.validate_python(MyDict())\nprint(type(v))\n#&gt; &lt;class 'dict'&gt;\n</code></pre> <p>\u5982\u679c\u60a8\u5e0c\u671b\u8f93\u51fa\u7c7b\u578b\u662f\u7279\u5b9a\u7c7b\u578b\uff0c\u8bf7\u8003\u8651\u5c06\u5176\u6ce8\u91ca\u4e3a\u7279\u5b9a\u7c7b\u578b\u6216\u5b9e\u73b0\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\uff1a</p> <pre><code>from collections.abc import Mapping\nfrom typing import Annotated, Any, TypeVar\n\nfrom pydantic import (\n    TypeAdapter,\n    ValidationInfo,\n    ValidatorFunctionWrapHandler,\n    WrapValidator,\n)\n\n\ndef restore_input_type(\n    value: Any, handler: ValidatorFunctionWrapHandler, _info: ValidationInfo\n) -&gt; Any:\n    return type(value)(handler(value))\n\n\nT = TypeVar('T')\nPreserveType = Annotated[T, WrapValidator(restore_input_type)]\n\n\nta = TypeAdapter(PreserveType[Mapping[str, int]])\n\n\nclass MyDict(dict):\n    pass\n\n\nv = ta.validate_python(MyDict())\nassert type(v) is MyDict\n</code></pre> <p>\u867d\u7136\u6211\u4eec\u4e0d\u627f\u8bfa\u5728\u6240\u6709\u5730\u65b9\u4fdd\u7559\u8f93\u5165\u7c7b\u578b\uff0c\u4f46\u6211\u4eec\u786e\u5b9e\u4e3a <code>BaseModel</code> \u7684\u5b50\u7c7b\u4ee5\u53ca\u6570\u636e\u7c7b\u4fdd\u7559\u5b83\u4eec\uff1a</p> <pre><code>import pydantic.dataclasses\nfrom pydantic import BaseModel\n\n\nclass InnerModel(BaseModel):\n    x: int\n\n\nclass OuterModel(BaseModel):\n    inner: InnerModel\n\n\nclass SubInnerModel(InnerModel):\n    y: int\n\n\nm = OuterModel(inner=SubInnerModel(x=1, y=2))\nprint(m)\n#&gt; inner=SubInnerModel(x=1, y=2)\n\n\n@pydantic.dataclasses.dataclass\nclass InnerDataclass:\n    x: int\n\n\n@pydantic.dataclasses.dataclass\nclass SubInnerDataclass(InnerDataclass):\n    y: int\n\n\n@pydantic.dataclasses.dataclass\nclass OuterDataclass:\n    inner: InnerDataclass\n\n\nd = OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\nprint(d)\n#&gt; OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\n</code></pre>"},{"location":"migration/#_9","title":"\u6807\u51c6\u7c7b\u578b\u5904\u7406\u7684\u53d8\u66f4","text":""},{"location":"migration/#_10","title":"\u5b57\u5178","text":"<p>\u6210\u5bf9\u7684\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff08\u5305\u62ec\u7a7a\u53ef\u8fed\u4ee3\u5bf9\u8c61\uff09\u4e0d\u518d\u901a\u8fc7 <code>dict</code> \u7c7b\u578b\u5b57\u6bb5\u7684\u9a8c\u8bc1\u3002</p>"},{"location":"migration/#_11","title":"\u8054\u5408\u7c7b\u578b","text":"<p>\u867d\u7136\u8054\u5408\u7c7b\u578b\u4ecd\u4f1a\u4ece\u5de6\u5230\u53f3\u5c1d\u8bd5\u9a8c\u8bc1\u6bcf\u4e2a\u9009\u9879\uff0c\u4f46\u5b83\u4eec\u73b0\u5728\u5c3d\u53ef\u80fd\u4fdd\u7559\u8f93\u5165\u7684\u7c7b\u578b\uff0c \u5373\u4f7f\u6b63\u786e\u7684\u7c7b\u578b\u4e0d\u662f\u8f93\u5165\u4f1a\u901a\u8fc7\u9a8c\u8bc1\u7684\u7b2c\u4e00\u4e2a\u9009\u9879\u3002 \u4f5c\u4e3a\u6f14\u793a\uff0c\u8bf7\u8003\u8651\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: Union[int, str]\n\n\nprint(Model(x='1'))\n#&gt; x='1'\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int | str\n\n\nprint(Model(x='1'))\n#&gt; x='1'\n</code></pre> <p>\u5728 Pydantic V1 \u4e2d\uff0c\u6253\u5370\u7ed3\u679c\u5c06\u662f <code>x=1</code>\uff0c\u56e0\u4e3a\u8be5\u503c\u5c06\u4f5c\u4e3a <code>int</code> \u901a\u8fc7\u9a8c\u8bc1\u3002 \u5728 Pydantic V2 \u4e2d\uff0c\u6211\u4eec\u8bc6\u522b\u8be5\u503c\u662f\u5176\u4e2d\u4e00\u4e2a\u60c5\u51b5\u7684\u5b9e\u4f8b\uff0c\u5e76\u77ed\u8def\u6807\u51c6\u8054\u5408\u9a8c\u8bc1\u3002</p> <p>\u8981\u6062\u590d\u5230 V1 \u7684\u975e\u77ed\u8def\u4ece\u5de6\u5230\u53f3\u884c\u4e3a\uff0c\u8bf7\u4f7f\u7528 <code>Field(union_mode='left_to_right')</code> \u6ce8\u91ca\u8054\u5408\u7c7b\u578b\u3002 \u6709\u5173\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u8054\u5408\u6a21\u5f0f\u3002</p>"},{"location":"migration/#required-optional-and-nullable-fields","title":"\u5fc5\u9700\u3001\u53ef\u9009\u548c\u53ef\u7a7a\u5b57\u6bb5","text":"<p>Pydantic V2 \u66f4\u6539\u4e86\u6307\u5b9a\u6ce8\u91ca\u4e3a <code>Optional</code> \u7684\u5b57\u6bb5\u662f\u5fc5\u9700\uff08\u5373\u6ca1\u6709\u9ed8\u8ba4\u503c\uff09\u8fd8\u662f\u975e\u5fc5\u9700\uff08\u5373\u5177\u6709 <code>None</code> \u9ed8\u8ba4\u503c\u6216\u76f8\u5e94\u7c7b\u578b\u7684\u4efb\u4f55\u5176\u4ed6\u503c\uff09\u7684\u90e8\u5206\u903b\u8f91\uff0c\u73b0\u5728\u66f4\u63a5\u8fd1 <code>dataclasses</code> \u7684\u884c\u4e3a\u3002\u7c7b\u4f3c\u5730\uff0c\u6ce8\u91ca\u4e3a <code>Any</code> \u7684\u5b57\u6bb5\u4e0d\u518d\u5177\u6709 <code>None</code> \u7684\u9ed8\u8ba4\u503c\u3002</p> <p>\u4e0b\u8868\u63cf\u8ff0\u4e86 V2 \u4e2d\u5b57\u6bb5\u6ce8\u91ca\u7684\u884c\u4e3a\uff1a</p> \u72b6\u6001 \u5b57\u6bb5\u5b9a\u4e49 \u5fc5\u9700\uff0c\u4e0d\u80fd\u4e3a <code>None</code> <code>f1: str</code> \u975e\u5fc5\u9700\uff0c\u4e0d\u80fd\u4e3a <code>None</code>\uff0c\u9ed8\u8ba4\u4e3a <code>'abc'</code> <code>f2: str = 'abc'</code> \u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a <code>None</code> <code>f3: Optional[str]</code> \u975e\u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a <code>None</code>\uff0c\u9ed8\u8ba4\u4e3a <code>None</code> <code>f4: Optional[str] = None</code> \u975e\u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a <code>None</code>\uff0c\u9ed8\u8ba4\u4e3a <code>'abc'</code> <code>f5: Optional[str] = 'abc'</code> \u5fc5\u9700\uff0c\u53ef\u4ee5\u662f\u4efb\u4f55\u7c7b\u578b\uff08\u5305\u62ec <code>None</code>\uff09 <code>f6: Any</code> \u975e\u5fc5\u9700\uff0c\u53ef\u4ee5\u662f\u4efb\u4f55\u7c7b\u578b\uff08\u5305\u62ec <code>None</code>\uff09 <code>f7: Any = None</code> <p>Note</p> <p>\u6ce8\u91ca\u4e3a <code>typing.Optional[T]</code> \u7684\u5b57\u6bb5\u5c06\u662f\u5fc5\u9700\u7684\uff0c\u5e76\u4e14\u5141\u8bb8\u503c\u4e3a <code>None</code>\u3002  \u8fd9\u5e76\u4e0d\u610f\u5473\u7740\u8be5\u5b57\u6bb5\u5177\u6709 <code>None</code> \u7684\u9ed8\u8ba4\u503c\u3002\uff08\u8fd9\u662f\u4e0e V1 \u7684\u7834\u574f\u6027\u53d8\u66f4\u3002\uff09</p> <p>Note</p> <p>\u5982\u679c\u63d0\u4f9b\u4e86\u4efb\u4f55\u9ed8\u8ba4\u503c\uff0c\u90fd\u4f1a\u4f7f\u5b57\u6bb5\u53d8\u4e3a\u975e\u5fc5\u9700\u3002</p> <p>\u4ee5\u4e0b\u662f\u6f14\u793a\u4e0a\u8ff0\u5185\u5bb9\u7684\u4ee3\u7801\u793a\u4f8b\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # \u5fc5\u9700\uff0c\u4e0d\u80fd\u4e3a None\n    f2: Optional[str]  # \u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a None - \u4e0e str | None \u76f8\u540c\n    f3: Optional[str] = None  # \u975e\u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a None\n    f4: str = 'Foobar'  # \u975e\u5fc5\u9700\uff0c\u4f46\u4e0d\u80fd\u4e3a None\n\n\ntry:\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    f1\n      Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n    \"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # \u5fc5\u9700\uff0c\u4e0d\u80fd\u4e3a None\n    f2: str | None  # \u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a None - \u4e0e str | None \u76f8\u540c\n    f3: str | None = None  # \u975e\u5fc5\u9700\uff0c\u53ef\u4ee5\u4e3a None\n    f4: str = 'Foobar'  # \u975e\u5fc5\u9700\uff0c\u4f46\u4e0d\u80fd\u4e3a None\n\n\ntry:\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    f1\n      Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n    \"\"\"\n</code></pre>"},{"location":"migration/#_12","title":"\u6a21\u5f0f/\u5b57\u7b26\u4e32\u6b63\u5219\u8868\u8fbe\u5f0f","text":"<p>Pydantic V1 \u4f7f\u7528 Python \u7684 regex \u5e93\u3002Pydantic V2 \u4f7f\u7528 Rust \u7684 regex crate\u3002 \u8fd9\u4e2a crate \u4e0d\u4ec5\u4ec5\u662f\"Rust \u7248\u672c\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\"\uff0c\u5b83\u662f\u4e00\u79cd\u5b8c\u5168\u4e0d\u540c\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u65b9\u6cd5\u3002 \u7279\u522b\u662f\uff0c\u5b83\u627f\u8bfa\u7ebf\u6027\u65f6\u95f4\u5b57\u7b26\u4e32\u641c\u7d22\uff0c\u4ee5\u653e\u5f03\u51e0\u4e2a\u529f\u80fd\u4e3a\u4ee3\u4ef7\uff08\u5373\u73af\u89c6\u548c\u53cd\u5411\u5f15\u7528\uff09\u3002 \u6211\u4eec\u8ba4\u4e3a\u8fd9\u662f\u4e00\u4e2a\u503c\u5f97\u505a\u7684\u6743\u8861\uff0c\u7279\u522b\u662f\u56e0\u4e3a Pydantic \u7528\u4e8e\u9a8c\u8bc1\u4e0d\u53d7\u4fe1\u4efb\u7684\u8f93\u5165\uff0c\u786e\u4fdd\u4e0d\u4f1a\u56e0\u4e0d\u53d7\u4fe1\u4efb\u7684\u8f93\u5165\u800c\u610f\u5916\u8fd0\u884c\u6307\u6570\u65f6\u95f4\u5f88\u91cd\u8981\u3002 \u53e6\u4e00\u65b9\u9762\uff0c\u5bf9\u4e8e\u4e0d\u4f7f\u7528\u8fd9\u4e9b\u529f\u80fd\u7684\u4efb\u4f55\u4eba\u6765\u8bf4\uff0c\u590d\u6742\u7684\u6b63\u5219\u8868\u8fbe\u5f0f\u9a8c\u8bc1\u5e94\u8be5\u5feb\u51e0\u4e2a\u6570\u91cf\u7ea7\uff0c\u56e0\u4e3a\u5b83\u662f\u5728 Rust \u4e2d\u5b8c\u6210\u7684\u5e76\u4e14\u662f\u7ebf\u6027\u65f6\u95f4\u3002</p> <p>\u5982\u679c\u60a8\u4ecd\u60f3\u4f7f\u7528 Python \u7684 regex \u5e93\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>regex_engine</code> \u914d\u7f6e\u8bbe\u7f6e\u3002</p>"},{"location":"migration/#_13","title":"\u6d6e\u70b9\u6570\u5230\u6574\u6570\u7684\u7c7b\u578b\u8f6c\u6362","text":"<p>\u5728 V1 \u4e2d\uff0c\u6bcf\u5f53\u5b57\u6bb5\u88ab\u6ce8\u91ca\u4e3a <code>int</code> \u65f6\uff0c\u4efb\u4f55\u6d6e\u70b9\u6570\u503c\u90fd\u4f1a\u88ab\u63a5\u53d7\uff0c\u5982\u679c\u6d6e\u70b9\u6570\u503c\u5305\u542b\u975e\u96f6\u5c0f\u6570\u90e8\u5206\uff0c\u8fd9\u53ef\u80fd\u5bfc\u81f4\u6f5c\u5728\u7684\u6570\u636e\u4e22\u5931\u3002\u5728 V2 \u4e2d\uff0c\u53ea\u6709\u5f53\u5c0f\u6570\u90e8\u5206\u4e3a\u96f6\u65f6\u624d\u5141\u8bb8\u4ece\u6d6e\u70b9\u6570\u5230\u6574\u6570\u7684\u7c7b\u578b\u8f6c\u6362\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\nprint(Model(x=10.0))\n#&gt; x=10\ntry:\n    Model(x=10.2)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer, got a number with a fractional part [type=int_from_float, input_value=10.2, input_type=float]\n    \"\"\"\n</code></pre>"},{"location":"migration/#introduction-of-typeadapter","title":"<code>TypeAdapter</code> \u7684\u4ecb\u7ecd","text":"<p>Pydantic V1 \u5bf9\u9a8c\u8bc1\u6216\u5e8f\u5217\u5316\u975e <code>BaseModel</code> \u7c7b\u578b\u7684\u652f\u6301\u8f83\u5f31\u3002</p> <p>\u8981\u5904\u7406\u8fd9\u4e9b\u7c7b\u578b\uff0c\u60a8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2a\"\u6839\"\u6a21\u578b\u6216\u4f7f\u7528 <code>pydantic.tools</code> \u4e2d\u7684\u5b9e\u7528\u51fd\u6570 \uff08\u5373 <code>parse_obj_as</code> \u548c <code>schema_of</code>\uff09\u3002</p> <p>\u5728 Pydantic V2 \u4e2d\uff0c\u8fd9\u5bb9\u6613\u5f97\u591a\uff1a<code>TypeAdapter</code> \u7c7b\u5141\u8bb8\u60a8\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c \u8be5\u5bf9\u8c61\u5177\u6709\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u548c\u4e3a\u4efb\u610f\u7c7b\u578b\u751f\u6210 JSON \u6a21\u5f0f\u7684\u65b9\u6cd5\u3002 \u8fd9\u5b8c\u5168\u66ff\u4ee3\u4e86 <code>parse_obj_as</code> \u548c <code>schema_of</code>\uff08\u73b0\u5df2\u5f03\u7528\uff09\uff0c \u5e76\u4e14\u8fd8\u6db5\u76d6\u4e86\u4e00\u4e9b\"\u6839\"\u6a21\u578b\u7684\u4f7f\u7528\u573a\u666f\u3002\uff08<code>RootModel</code>\uff0c \u4e0a\u9762\u8ba8\u8bba\u8fc7\uff0c\u6db5\u76d6\u4e86\u5176\u4ed6\u573a\u666f\u3002\uff09</p> <pre><code>from pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nassert adapter.validate_python(['1', '2', '3']) == [1, 2, 3]\nprint(adapter.json_schema())\n#&gt; {'items': {'type': 'integer'}, 'type': 'array'}\n</code></pre> <p>\u7531\u4e8e\u5e38\u89c1\u7c7b\u578b\u68c0\u67e5\u5668\u63a8\u65ad\u6cdb\u578b\u7c7b\u578b\u7684\u9650\u5236\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u8981\u83b7\u5f97\u6b63\u786e\u7684\u7c7b\u578b\uff0c \u60a8\u53ef\u80fd\u9700\u8981\u663e\u5f0f\u6307\u5b9a\u6cdb\u578b\u53c2\u6570\uff1a</p> <pre><code>from pydantic import TypeAdapter\n\nadapter = TypeAdapter[str | int](str | int)\n...\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u7c7b\u578b\u9002\u914d\u5668\u3002</p>"},{"location":"migration/#_14","title":"\u5b9a\u4e49\u81ea\u5b9a\u4e49\u7c7b\u578b","text":"<p>\u6211\u4eec\u5f7b\u5e95\u6539\u9769\u4e86\u5728 pydantic \u4e2d\u5b9a\u4e49\u81ea\u5b9a\u4e49\u7c7b\u578b\u7684\u65b9\u5f0f\u3002</p> <p>\u6211\u4eec\u516c\u5f00\u4e86\u7528\u4e8e\u751f\u6210 <code>pydantic-core</code> \u548c JSON \u6a21\u5f0f\u7684\u94a9\u5b50\uff0c\u5141\u8bb8\u60a8\u5728\u4f7f\u7528\u81ea\u5df1\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\u65f6\u83b7\u5f97 Pydantic V2 \u7684\u6240\u6709\u6027\u80fd\u4f18\u52bf\u3002</p> <p>\u6211\u4eec\u8fd8\u5f15\u5165\u4e86\u4f7f\u7528 <code>typing.Annotated</code> \u5411\u81ea\u5df1\u7684\u7c7b\u578b\u6dfb\u52a0\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u7684\u65b9\u6cd5\u3002</p> <p>\u4e3b\u8981\u53d8\u66f4\u5305\u62ec\uff1a</p> <ul> <li><code>__get_validators__</code> \u5e94\u66ff\u6362\u4e3a <code>__get_pydantic_core_schema__</code>\u3002   \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\u3002</li> <li><code>__modify_schema__</code> \u53d8\u4e3a <code>__get_pydantic_json_schema__</code>\u3002   \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605JSON \u6a21\u5f0f\u81ea\u5b9a\u4e49\u3002</li> </ul> <p>\u6b64\u5916\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>typing.Annotated</code> \u901a\u8fc7\u6ce8\u91ca\u7c7b\u578b\u6765\u4fee\u6539\u6216\u63d0\u4f9b\u7c7b\u578b\u7684 <code>__get_pydantic_core_schema__</code> \u548c <code>__get_pydantic_json_schema__</code> \u51fd\u6570\uff0c\u800c\u4e0d\u662f\u4fee\u6539\u7c7b\u578b\u672c\u8eab\u3002 \u8fd9\u4e3a\u5c06\u7b2c\u4e09\u65b9\u7c7b\u578b\u4e0e Pydantic \u96c6\u6210\u63d0\u4f9b\u4e86\u5f3a\u5927\u800c\u7075\u6d3b\u7684\u673a\u5236\uff0c\u5e76\u4e14\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b \u53ef\u80fd\u5e2e\u52a9\u60a8\u79fb\u9664 Pydantic V1 \u4e2d\u4e3a\u7ed5\u8fc7\u81ea\u5b9a\u4e49\u7c7b\u578b\u9650\u5236\u800c\u5f15\u5165\u7684 hack\u3002</p> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u81ea\u5b9a\u4e49\u6570\u636e\u7c7b\u578b\u3002</p>"},{"location":"migration/#json","title":"JSON \u6a21\u5f0f\u751f\u6210\u7684\u53d8\u66f4","text":"<p>\u591a\u5e74\u6765\uff0c\u6211\u4eec\u6536\u5230\u4e86\u8bb8\u591a\u5173\u4e8e\u66f4\u6539 pydantic \u751f\u6210\u7684 JSON \u6a21\u5f0f\u7684\u8bf7\u6c42\u3002</p> <p>\u5728 Pydantic V2 \u4e2d\uff0c\u6211\u4eec\u5c1d\u8bd5\u89e3\u51b3\u4e86\u8bb8\u591a\u5e38\u89c1\u8bf7\u6c42\uff1a</p> <ul> <li><code>Optional</code> \u5b57\u6bb5\u7684 JSON \u6a21\u5f0f\u73b0\u5728\u6307\u793a\u5141\u8bb8\u503c <code>null</code>\u3002</li> <li><code>Decimal</code> \u7c7b\u578b\u73b0\u5728\u5728 JSON \u6a21\u5f0f\u4e2d\uff08\u5e76\u5e8f\u5217\u5316\uff09\u4f5c\u4e3a\u5b57\u7b26\u4e32\u516c\u5f00\u3002</li> <li>JSON \u6a21\u5f0f\u4e0d\u518d\u5c06\u547d\u540d\u5143\u7ec4\u4fdd\u7559\u4e3a\u547d\u540d\u5143\u7ec4\u3002</li> <li>\u6211\u4eec\u9ed8\u8ba4\u751f\u6210\u7684 JSON \u6a21\u5f0f\u73b0\u5728\u9488\u5bf9\u8349\u6848 2020-12\uff08\u5e26\u6709\u4e00\u4e9b OpenAPI \u6269\u5c55\uff09\u3002</li> <li>\u5f53\u5b83\u4eec\u4e0d\u540c\u65f6\uff0c\u60a8\u73b0\u5728\u53ef\u4ee5\u6307\u5b9a\u662f\u8981\u8868\u793a\u9a8c\u8bc1\u8f93\u5165\u7684 JSON \u6a21\u5f0f\uff0c\u8fd8\u662f\u5e8f\u5217\u5316\u8f93\u51fa\u7684 JSON \u6a21\u5f0f\u3002</li> </ul> <p>\u7136\u800c\uff0c\u591a\u5e74\u6765\u6709\u8bb8\u591a\u5408\u7406\u7684\u66f4\u6539\u8bf7\u6c42\u6211\u4eec\u9009\u62e9\u4e0d\u5b9e\u73b0\u3002</p> <p>\u5728 Pydantic V1 \u4e2d\uff0c\u5373\u4f7f\u60a8\u613f\u610f\u81ea\u5df1\u5b9e\u73b0\u66f4\u6539\uff0c\u4e5f\u975e\u5e38\u56f0\u96be\uff0c\u56e0\u4e3a JSON \u6a21\u5f0f \u751f\u6210\u8fc7\u7a0b\u6d89\u53ca\u5404\u79cd\u9012\u5f52\u51fd\u6570\u8c03\u7528\uff1b\u8981\u8986\u76d6\u4e00\u4e2a\uff0c\u60a8\u5fc5\u987b\u590d\u5236\u5e76\u4fee\u6539\u6574\u4e2a\u5b9e\u73b0\u3002</p> <p>\u5728 Pydantic V2 \u4e2d\uff0c\u6211\u4eec\u7684\u8bbe\u8ba1\u76ee\u6807\u4e4b\u4e00\u662f\u4f7f\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u751f\u6210\u66f4\u5bb9\u6613\u3002\u4e3a\u6b64\uff0c\u6211\u4eec \u5f15\u5165\u4e86 <code>GenerateJsonSchema</code> \u7c7b\uff0c \u5b83\u5b9e\u73b0\u4e86\u5c06\u7c7b\u578b\u7684 pydantic-core \u6a21\u5f0f\u8f6c\u6362\u4e3a JSON \u6a21\u5f0f\u3002\u901a\u8fc7\u8bbe\u8ba1\uff0c\u8be5\u7c7b\u5c06 JSON \u6a21\u5f0f\u751f\u6210\u8fc7\u7a0b\u5206\u89e3\u4e3a\u66f4\u5c0f\u7684\u65b9\u6cd5\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u53ef\u4ee5 \u5728\u5b50\u7c7b\u4e2d\u8f7b\u677e\u91cd\u5199\u4ee5\u4fee\u6539\u751f\u6210 JSON \u6a21\u5f0f\u7684\"\u5168\u5c40\"\u65b9\u6cd5\u3002</p> <p>\u53ef\u7528\u4e8e\u751f\u6210 JSON \u6a21\u5f0f\u7684\u5404\u79cd\u65b9\u6cd5\uff08\u4f8b\u5982 <code>BaseModel.model_json_schema</code> \u6216 <code>TypeAdapter.json_schema</code>\uff09\u63a5\u53d7\u5173\u952e\u5b57\u53c2\u6570 <code>schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema</code>\uff0c \u60a8\u53ef\u4ee5\u5c06\u81ea\u5b9a\u4e49\u5b50\u7c7b\u4f20\u9012\u7ed9\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u4ee5\u4fbf\u4f7f\u7528\u81ea\u5df1\u7684 JSON \u6a21\u5f0f\u751f\u6210\u65b9\u6cd5\u3002</p> <p>\u5e0c\u671b\u8fd9\u610f\u5473\u7740\u5982\u679c\u60a8\u4e0d\u540c\u610f\u6211\u4eec\u505a\u51fa\u7684\u4efb\u4f55\u9009\u62e9\uff0c\u6216\u8005\u5982\u679c\u60a8\u4f9d\u8d56\u4e8e Pydantic V1 \u4e2d \u5728 Pydantic V2 \u4e2d\u5df2\u66f4\u6539\u7684\u884c\u4e3a\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u81ea\u5b9a\u4e49 <code>schema_generator</code>\uff0c\u6839\u636e\u9700\u8981\u4fee\u6539 <code>GenerateJsonSchema</code> \u7c7b\u4ee5\u9002\u5e94\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002</p>"},{"location":"migration/#basesettings-has-moved-to-pydantic-settings","title":"<code>BaseSettings</code> \u5df2\u8fc1\u79fb\u5230 <code>pydantic-settings</code>","text":"<p><code>BaseSettings</code>\uff0cPydantic \u8bbe\u7f6e\u7ba1\u7406\u7684\u57fa\u7840\u5bf9\u8c61\uff0c\u5df2\u8fc1\u79fb\u5230\u5355\u72ec\u7684\u5305 <code>pydantic-settings</code>\u3002</p> <p>\u6b64\u5916\uff0c<code>parse_env_var</code> \u7c7b\u65b9\u6cd5\u5df2\u88ab\u79fb\u9664\u3002\u56e0\u6b64\uff0c\u60a8\u9700\u8981 \u81ea\u5b9a\u4e49\u8bbe\u7f6e\u6e90 \u4ee5\u62e5\u6709\u81ea\u5df1\u7684\u89e3\u6790\u51fd\u6570\u3002</p>"},{"location":"migration/#color-and-payment-card-numbers-moved-to-pydantic-extra-types","title":"\u989c\u8272\u548c\u652f\u4ed8\u5361\u53f7\u5df2\u8fc1\u79fb\u5230 <code>pydantic-extra-types</code>","text":"<p>\u4ee5\u4e0b\u7279\u6b8a\u7528\u9014\u7c7b\u578b\u5df2\u8fc1\u79fb\u5230 Pydantic Extra Types \u5305\uff0c \u5982\u679c\u9700\u8981\uff0c\u53ef\u4ee5\u5355\u72ec\u5b89\u88c5\u3002</p> <ul> <li>\u989c\u8272\u7c7b\u578b</li> <li>\u652f\u4ed8\u5361\u53f7</li> </ul>"},{"location":"migration/#pydanticnetworks-url-dsn-str","title":"<code>pydantic.networks</code> \u4e2d\u7684 URL \u548c DSN \u7c7b\u578b\u4e0d\u518d\u7ee7\u627f\u81ea <code>str</code>","text":"<p>\u5728 Pydantic V1 \u4e2d\uff0c<code>AnyUrl</code> \u7c7b\u578b\u7ee7\u627f\u81ea <code>str</code>\uff0c\u6240\u6709\u5176\u4ed6 <code>Url</code> \u548c <code>Dsn</code> \u7c7b\u578b\u90fd\u7ee7\u627f\u81ea\u8fd9\u4e9b\u7c7b\u578b\u3002\u5728 Pydantic V2 \u4e2d\uff0c\u8fd9\u4e9b\u7c7b\u578b\u57fa\u4e8e\u4e24\u4e2a\u65b0\u7684 <code>Url</code> \u548c <code>MultiHostUrl</code> \u7c7b\u6784\u5efa\uff0c\u4f7f\u7528 <code>Annotated</code>\u3002</p> <p>\u7ee7\u627f\u81ea <code>str</code> \u6709\u4f18\u70b9\u4e5f\u6709\u7f3a\u70b9\uff0c\u5bf9\u4e8e V2\uff0c\u6211\u4eec\u51b3\u5b9a\u6700\u597d\u79fb\u9664\u8fd9\u4e00\u70b9\u3002\u8981\u5728\u671f\u671b <code>str</code> \u7684 API \u4e2d\u4f7f\u7528\u8fd9\u4e9b \u7c7b\u578b\uff0c\u60a8\u73b0\u5728\u9700\u8981\u8f6c\u6362\u5b83\u4eec\uff08\u4f7f\u7528 <code>str(url)</code>\uff09\u3002</p> <p>Pydantic V2 \u4f7f\u7528 Rust \u7684 Url crate \u8fdb\u884c URL \u9a8c\u8bc1\u3002 \u4e00\u4e9b URL \u9a8c\u8bc1\u4e0e V1 \u4e2d\u7684\u5148\u524d\u884c\u4e3a\u7565\u6709\u4e0d\u540c\u3002 \u4e00\u4e2a\u663e\u8457\u7684\u533a\u522b\u662f\uff0c\u5982\u679c\u4e0d\u5305\u542b\u8def\u5f84\uff0c\u65b0\u7684 <code>Url</code> \u7c7b\u578b\u4f1a\u5728\u9a8c\u8bc1\u7248\u672c\u540e\u9644\u52a0\u659c\u6760\uff0c \u5373\u4f7f\u5728 <code>Url</code> \u7c7b\u578b\u6784\u9020\u51fd\u6570\u7684\u53c2\u6570\u4e2d\u672a\u6307\u5b9a\u659c\u6760\u3002\u8bf7\u53c2\u9605\u4ee5\u4e0b\u793a\u4f8b\u4e86\u89e3\u6b64\u884c\u4e3a\uff1a</p> <pre><code>from pydantic import AnyUrl\n\nassert str(AnyUrl(url='https://google.com')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/api')) == 'https://google.com/api'\nassert str(AnyUrl(url='https://google.com/api/')) == 'https://google.com/api/'\n</code></pre> <p>\u5982\u679c\u60a8\u4ecd\u60f3\u4f7f\u7528\u6ca1\u6709\u9644\u52a0\u659c\u6760\u7684\u65e7\u884c\u4e3a\uff0c\u8bf7\u67e5\u770b\u6b64\u89e3\u51b3\u65b9\u6848\u3002</p>"},{"location":"migration/#_15","title":"\u7ea6\u675f\u7c7b\u578b","text":"<p><code>Constrained*</code> \u7c7b\u5df2\u88ab\u79fb\u9664\uff0c\u60a8\u5e94\u8be5\u4f7f\u7528 <code>Annotated[&lt;type&gt;, Field(...)]</code> \u66ff\u6362\u5b83\u4eec\uff0c\u4f8b\u5982\uff1a</p> <pre><code>from pydantic import BaseModel, ConstrainedInt\n\n\nclass MyInt(ConstrainedInt):\n    ge = 0\n\n\nclass Model(BaseModel):\n    x: MyInt\n</code></pre> <p>...\u53d8\u4e3a\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nMyInt = Annotated[int, Field(ge=0)]\n\n\nclass Model(BaseModel):\n    x: MyInt\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u901a\u8fc7 <code>Annotated</code> \u7ec4\u5408\u7c7b\u578b\u6587\u6863\u3002</p> <p>\u5bf9\u4e8e <code>ConstrainedStr</code>\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>StringConstraints</code> \u4ee3\u66ff\u3002</p>"},{"location":"migration/#mypy","title":"Mypy \u63d2\u4ef6","text":"<p>Pydantic V2 \u5305\u542b\u4e00\u4e2a mypy \u63d2\u4ef6\uff0c\u4f4d\u4e8e <code>pydantic.mypy</code> \u4e2d\u3002</p> <p>\u5f53\u4f7f\u7528 V1 \u529f\u80fd\u65f6\uff0c \u53ef\u80fd\u8fd8\u9700\u8981\u542f\u7528 <code>pydantic.v1.mypy</code> \u63d2\u4ef6\u3002</p> <p>\u914d\u7f6e mypy \u63d2\u4ef6\u7684\u65b9\u6cd5\u5982\u4e0b\uff1a</p> <code>mypy.ini</code><code>pyproject.toml</code> <pre><code>[mypy]\nplugins = pydantic.mypy, pydantic.v1.mypy  # \u5982\u679c\u9700\u8981\uff0c\u5305\u542b `.v1.mypy`\u3002\n</code></pre> <pre><code>[tool.mypy]\nplugins = [\n    \"pydantic.mypy\",\n    \"pydantic.v1.mypy\",  # \u5982\u679c\u9700\u8981\uff0c\u5305\u542b `.v1.mypy`\u3002\n]\n</code></pre>"},{"location":"migration/#_16","title":"\u5176\u4ed6\u53d8\u66f4","text":"<ul> <li>\u653e\u5f03\u4e86\u5bf9 <code>email-validator&lt;2.0.0</code> \u7684\u652f\u6301\u3002\u8bf7\u786e\u4fdd\u4f7f\u7528   <code>pip install -U email-validator</code> \u8fdb\u884c\u66f4\u65b0\u3002</li> </ul>"},{"location":"migration/#pydantic-v2_1","title":"\u5728 Pydantic V2 \u4e2d\u8fc1\u79fb\u7684","text":"Pydantic V1 Pydantic V2 <code>pydantic.BaseSettings</code> <code>pydantic_settings.BaseSettings</code> <code>pydantic.color</code> <code>pydantic_extra_types.color</code> <code>pydantic.types.PaymentCardBrand</code> <code>pydantic_extra_types.PaymentCardBrand</code> <code>pydantic.types.PaymentCardNumber</code> <code>pydantic_extra_types.PaymentCardNumber</code> <code>pydantic.utils.version_info</code> <code>pydantic.version.version_info</code> <code>pydantic.error_wrappers.ValidationError</code> <code>pydantic.ValidationError</code> <code>pydantic.utils.to_camel</code> <code>pydantic.alias_generators.to_pascal</code> <code>pydantic.utils.to_lower_camel</code> <code>pydantic.alias_generators.to_camel</code> <code>pydantic.PyObject</code> <code>pydantic.ImportString</code>"},{"location":"migration/#pydantic-v2_2","title":"\u5df2\u5f03\u7528\u5e76\u5728 Pydantic V2 \u4e2d\u8fc1\u79fb\u7684","text":"Pydantic V1 Pydantic V2 <code>pydantic.tools.schema_of</code> <code>pydantic.deprecated.tools.schema_of</code> <code>pydantic.tools.parse_obj_as</code> <code>pydantic.deprecated.tools.parse_obj_as</code> <code>pydantic.tools.schema_json_of</code> <code>pydantic.deprecated.tools.schema_json_of</code> <code>pydantic.json.pydantic_encoder</code> <code>pydantic.deprecated.json.pydantic_encoder</code> <code>pydantic.validate_arguments</code> <code>pydantic.deprecated.decorator.validate_arguments</code> <code>pydantic.json.custom_pydantic_encoder</code> <code>pydantic.deprecated.json.custom_pydantic_encoder</code> <code>pydantic.json.ENCODERS_BY_TYPE</code> <code>pydantic.deprecated.json.ENCODERS_BY_TYPE</code> <code>pydantic.json.timedelta_isoformat</code> <code>pydantic.deprecated.json.timedelta_isoformat</code> <code>pydantic.decorator.validate_arguments</code> <code>pydantic.deprecated.decorator.validate_arguments</code> <code>pydantic.class_validators.validator</code> <code>pydantic.deprecated.class_validators.validator</code> <code>pydantic.class_validators.root_validator</code> <code>pydantic.deprecated.class_validators.root_validator</code> <code>pydantic.utils.deep_update</code> <code>pydantic.v1.utils.deep_update</code> <code>pydantic.utils.GetterDict</code> <code>pydantic.v1.utils.GetterDict</code> <code>pydantic.utils.lenient_issubclass</code> <code>pydantic.v1.utils.lenient_issubclass</code> <code>pydantic.utils.lenient_isinstance</code> <code>pydantic.v1.utils.lenient_isinstance</code> <code>pydantic.utils.is_valid_field</code> <code>pydantic.v1.utils.is_valid_field</code> <code>pydantic.utils.update_not_none</code> <code>pydantic.v1.utils.update_not_none</code> <code>pydantic.utils.import_string</code> <code>pydantic.v1.utils.import_string</code> <code>pydantic.utils.Representation</code> <code>pydantic.v1.utils.Representation</code> <code>pydantic.utils.ROOT_KEY</code> <code>pydantic.v1.utils.ROOT_KEY</code> <code>pydantic.utils.smart_deepcopy</code> <code>pydantic.v1.utils.smart_deepcopy</code> <code>pydantic.utils.sequence_like</code> <code>pydantic.v1.utils.sequence_like</code>"},{"location":"migration/#pydantic-v2_3","title":"\u5728 Pydantic V2 \u4e2d\u79fb\u9664\u7684","text":"<ul> <li><code>pydantic.ConstrainedBytes</code></li> <li><code>pydantic.ConstrainedDate</code></li> <li><code>pydantic.ConstrainedDecimal</code></li> <li><code>pydantic.ConstrainedFloat</code></li> <li><code>pydantic.ConstrainedFrozenSet</code></li> <li><code>pydantic.ConstrainedInt</code></li> <li><code>pydantic.ConstrainedList</code></li> <li><code>pydantic.ConstrainedSet</code></li> <li><code>pydantic.ConstrainedStr</code></li> <li><code>pydantic.JsonWrapper</code></li> <li><code>pydantic.NoneBytes</code><ul> <li>\u8fd9\u662f <code>None | bytes</code> \u7684\u522b\u540d\u3002</li> </ul> </li> <li><code>pydantic.NoneStr</code><ul> <li>\u8fd9\u662f <code>None | str</code> \u7684\u522b\u540d\u3002</li> </ul> </li> <li><code>pydantic.NoneStrBytes</code><ul> <li>\u8fd9\u662f <code>None | str | bytes</code> \u7684\u522b\u540d\u3002</li> </ul> </li> <li><code>pydantic.Protocol</code></li> <li><code>pydantic.Required</code></li> <li><code>pydantic.StrBytes</code><ul> <li>\u8fd9\u662f <code>str | bytes</code> \u7684\u522b\u540d\u3002</li> </ul> </li> <li><code>pydantic.compiled</code></li> <li><code>pydantic.config.get_config</code></li> <li><code>pydantic.config.inherit_config</code></li> <li><code>pydantic.config.prepare_config</code></li> <li><code>pydantic.create_model_from_namedtuple</code></li> <li><code>pydantic.create_model_from_typeddict</code></li> <li><code>pydantic.dataclasses.create_pydantic_model_from_dataclass</code></li> <li><code>pydantic.dataclasses.make_dataclass_validator</code></li> <li><code>pydantic.dataclasses.set_validation</code></li> <li><code>pydantic.datetime_parse.parse_date</code></li> <li><code>pydantic.datetime_parse.parse_time</code></li> <li><code>pydantic.datetime_parse.parse_datetime</code></li> <li><code>pydantic.datetime_parse.parse_duration</code></li> <li><code>pydantic.error_wrappers.ErrorWrapper</code></li> <li><code>pydantic.errors.AnyStrMaxLengthError</code></li> <li><code>pydantic.errors.AnyStrMinLengthError</code></li> <li><code>pydantic.errors.ArbitraryTypeError</code></li> <li><code>pydantic.errors.BoolError</code></li> <li><code>pydantic.errors.BytesError</code></li> <li><code>pydantic.errors.CallableError</code></li> <li><code>pydantic.errors.ClassError</code></li> <li><code>pydantic.errors.ColorError</code></li> <li><code>pydantic.errors.ConfigError</code></li> <li><code>pydantic.errors.DataclassTypeError</code></li> <li><code>pydantic.errors.DateError</code></li> <li><code>pydantic.errors.DateNotInTheFutureError</code></li> <li><code>pydantic.errors.DateNotInThePastError</code></li> <li><code>pydantic.errors.DateTimeError</code></li> <li><code>pydantic.errors.DecimalError</code></li> <li><code>pydantic.errors.DecimalIsNotFiniteError</code></li> <li><code>pydantic.errors.DecimalMaxDigitsError</code></li> <li><code>pydantic.errors.DecimalMaxPlacesError</code></li> <li><code>pydantic.errors.DecimalWholeDigitsError</code></li> <li><code>pydantic.errors.DictError</code></li> <li><code>pydantic.errors.DurationError</code></li> <li><code>pydantic.errors.EmailError</code></li> <li><code>pydantic.errors.EnumError</code></li> <li><code>pydantic.errors.EnumMemberError</code></li> <li><code>pydantic.errors.ExtraError</code></li> <li><code>pydantic.errors.FloatError</code></li> <li><code>pydantic.errors.FrozenSetError</code></li> <li><code>pydantic.errors.FrozenSetMaxLengthError</code></li> <li><code>pydantic.errors.FrozenSetMinLengthError</code></li> <li><code>pydantic.errors.HashableError</code></li> <li><code>pydantic.errors.IPv4AddressError</code></li> <li><code>pydantic.errors.IPv4InterfaceError</code></li> <li><code>pydantic.errors.IPv4NetworkError</code></li> <li><code>pydantic.errors.IPv6AddressError</code></li> <li><code>pydantic.errors.IPv6InterfaceError</code></li> <li><code>pydantic.errors.IPv6NetworkError</code></li> <li><code>pydantic.errors.IPvAnyAddressError</code></li> <li><code>pydantic.errors.IPvAnyInterfaceError</code></li> <li><code>pydantic.errors.IPvAnyNetworkError</code></li> <li><code>pydantic.errors.IntEnumError</code></li> <li><code>pydantic.errors.IntegerError</code></li> <li><code>pydantic.errors.InvalidByteSize</code></li> <li><code>pydantic.errors.InvalidByteSizeUnit</code></li> <li><code>pydantic.errors.InvalidDiscriminator</code></li> <li><code>pydantic.errors.InvalidLengthForBrand</code></li> <li><code>pydantic.errors.JsonError</code></li> <li><code>pydantic.errors.JsonTypeError</code></li> <li><code>pydantic.errors.ListError</code></li> <li><code>pydantic.errors.ListMaxLengthError</code></li> <li><code>pydantic.errors.ListMinLengthError</code></li> <li><code>pydantic.errors.ListUniqueItemsError</code></li> <li><code>pydantic.errors.LuhnValidationError</code></li> <li><code>pydantic.errors.MissingDiscriminator</code></li> <li><code>pydantic.errors.MissingError</code></li> <li><code>pydantic.errors.NoneIsAllowedError</code></li> <li><code>pydantic.errors.NoneIsNotAllowedError</code></li> <li><code>pydantic.errors.NotDigitError</code></li> <li><code>pydantic.errors.NotNoneError</code></li> <li><code>pydantic.errors.NumberNotGeError</code></li> <li><code>pydantic.errors.NumberNotGtError</code></li> <li><code>pydantic.errors.NumberNotLeError</code></li> <li><code>pydantic.errors.NumberNotLtError</code></li> <li><code>pydantic.errors.NumberNotMultipleError</code></li> <li><code>pydantic.errors.PathError</code></li> <li><code>pydantic.errors.PathNotADirectoryError</code></li> <li><code>pydantic.errors.PathNotAFileError</code></li> <li><code>pydantic.errors.PathNotExistsError</code></li> <li><code>pydantic.errors.PatternError</code></li> <li><code>pydantic.errors.PyObjectError</code></li> <li><code>pydantic.errors.PydanticTypeError</code></li> <li><code>pydantic.errors.PydanticValueError</code></li> <li><code>pydantic.errors.SequenceError</code></li> <li><code>pydantic.errors.SetError</code></li> <li><code>pydantic.errors.SetMaxLengthError</code></li> <li><code>pydantic.errors.SetMinLengthError</code></li> <li><code>pydantic.errors.StrError</code></li> <li><code>pydantic.errors.StrRegexError</code></li> <li><code>pydantic.errors.StrictBoolError</code></li> <li><code>pydantic.errors.SubclassError</code></li> <li><code>pydantic.errors.TimeError</code></li> <li><code>pydantic.errors.TupleError</code></li> <li><code>pydantic.errors.TupleLengthError</code></li> <li><code>pydantic.errors.UUIDError</code></li> <li><code>pydantic.errors.UUIDVersionError</code></li> <li><code>pydantic.errors.UrlError</code></li> <li><code>pydantic.errors.UrlExtraError</code></li> <li><code>pydantic.errors.UrlHostError</code></li> <li><code>pydantic.errors.UrlHostTldError</code></li> <li><code>pydantic.errors.UrlPortError</code></li> <li><code>pydantic.errors.UrlSchemeError</code></li> <li><code>pydantic.errors.UrlSchemePermittedError</code></li> <li><code>pydantic.errors.UrlUserInfoError</code></li> <li><code>pydantic.errors.WrongConstantError</code></li> <li><code>pydantic.main.validate_model</code></li> <li><code>pydantic.networks.stricturl</code></li> <li><code>pydantic.parse_file_as</code></li> <li><code>pydantic.parse_raw_as</code></li> <li><code>pydantic.stricturl</code></li> <li><code>pydantic.tools.parse_file_as</code></li> <li><code>pydantic.tools.parse_raw_as</code></li> <li><code>pydantic.types.JsonWrapper</code></li> <li><code>pydantic.types.NoneBytes</code></li> <li><code>pydantic.types.NoneStr</code></li> <li><code>pydantic.types.NoneStrBytes</code></li> <li><code>pydantic.types.PyObject</code></li> <li><code>pydantic.types.StrBytes</code></li> <li><code>pydantic.typing.evaluate_forwardref</code></li> <li><code>pydantic.typing.AbstractSetIntStr</code></li> <li><code>pydantic.typing.AnyCallable</code></li> <li><code>pydantic.typing.AnyClassMethod</code></li> <li><code>pydantic.typing.CallableGenerator</code></li> <li><code>pydantic.typing.DictAny</code></li> <li><code>pydantic.typing.DictIntStrAny</code></li> <li><code>pydantic.typing.DictStrAny</code></li> <li><code>pydantic.typing.IntStr</code></li> <li><code>pydantic.typing.ListStr</code></li> <li><code>pydantic.typing.MappingIntStrAny</code></li> <li><code>pydantic.typing.NoArgAnyCallable</code></li> <li><code>pydantic.typing.NoneType</code></li> <li><code>pydantic.typing.ReprArgs</code></li> <li><code>pydantic.typing.SetStr</code></li> <li><code>pydantic.typing.StrPath</code></li> <li><code>pydantic.typing.TupleGenerator</code></li> <li><code>pydantic.typing.WithArgsTypes</code></li> <li><code>pydantic.typing.all_literal_values</code></li> <li><code>pydantic.typing.display_as_type</code></li> <li><code>pydantic.typing.get_all_type_hints</code></li> <li><code>pydantic.typing.get_args</code></li> <li><code>pydantic.typing.get_origin</code></li> <li><code>pydantic.typing.get_sub_types</code></li> <li><code>pydantic.typing.is_callable_type</code></li> <li><code>pydantic.typing.is_classvar</code></li> <li><code>pydantic.typing.is_finalvar</code></li> <li><code>pydantic.typing.is_literal_type</code></li> <li><code>pydantic.typing.is_namedtuple</code></li> <li><code>pydantic.typing.is_new_type</code></li> <li><code>pydantic.typing.is_none_type</code></li> <li><code>pydantic.typing.is_typeddict</code></li> <li><code>pydantic.typing.is_typeddict_special</code></li> <li><code>pydantic.typing.is_union</code></li> <li><code>pydantic.typing.new_type_supertype</code></li> <li><code>pydantic.typing.resolve_annotations</code></li> <li><code>pydantic.typing.typing_base</code></li> <li><code>pydantic.typing.update_field_forward_refs</code></li> <li><code>pydantic.typing.update_model_forward_refs</code></li> <li><code>pydantic.utils.ClassAttribute</code></li> <li><code>pydantic.utils.DUNDER_ATTRIBUTES</code></li> <li><code>pydantic.utils.PyObjectStr</code></li> <li><code>pydantic.utils.ValueItems</code></li> <li><code>pydantic.utils.almost_equal_floats</code></li> <li><code>pydantic.utils.get_discriminator_alias_and_values</code></li> <li><code>pydantic.utils.get_model</code></li> <li><code>pydantic.utils.get_unique_discriminator_alias</code></li> <li><code>pydantic.utils.in_ipython</code></li> <li><code>pydantic.utils.is_valid_identifier</code></li> <li><code>pydantic.utils.path_type</code></li> <li><code>pydantic.utils.validate_field_name</code></li> <li><code>pydantic.validate_model</code></li> </ul>"},{"location":"version-policy/","title":"\u7248\u672c\u7b56\u7565","text":"<p>\u9996\u5148\uff0c\u6211\u4eec\u8ba4\u8bc6\u5230\u4ece Pydantic V1 \u5230 V2 \u7684\u8fc7\u6e21\u5bf9\u67d0\u4e9b\u7528\u6237\u6765\u8bf4\u5df2\u7ecf\u5e76\u5c06\u7ee7\u7eed\u662f\u75db\u82e6\u7684\u3002 \u6211\u4eec\u5bf9\u8fd9\u79cd\u75db\u82e6\u8868\u793a\u6b49\u610f \uff0c\u8fd9\u662f\u7ea0\u6b63 V1 \u8bbe\u8ba1\u9519\u8bef\u7684\u4e0d\u5e78\u4f46\u5fc5\u8981\u7684\u6b65\u9aa4\u3002</p> <p>\u4e0d\u4f1a\u518d\u51fa\u73b0\u8fd9\u79cd\u89c4\u6a21\u7684\u4e2d\u65ad\u6027\u53d8\u66f4\uff01</p>"},{"location":"version-policy/#pydantic-v1","title":"Pydantic V1","text":"<p>V1 \u7684\u79ef\u6781\u5f00\u53d1\u5df2\u7ecf\u505c\u6b62\uff0c\u4f46\u5173\u952e\u7684\u9519\u8bef\u4fee\u590d\u548c\u5b89\u5168\u6f0f\u6d1e\u5c06\u5728 V1 \u4e2d\u4fee\u590d\uff0c\u76f4\u5230 Pydantic V3 \u53d1\u5e03\u3002</p>"},{"location":"version-policy/#pydantic-v2","title":"Pydantic V2","text":"<p>\u6211\u4eec\u4e0d\u4f1a\u5728 V2 \u7684\u6b21\u8981\u7248\u672c\u4e2d\u6545\u610f\u8fdb\u884c\u4e2d\u65ad\u6027\u53d8\u66f4\u3002</p> <p>\u6807\u8bb0\u4e3a\u5df2\u5f03\u7528\u7684\u529f\u80fd\u5c06\u4e0d\u4f1a\u5728\u4e0b\u4e00\u4e2a\u4e3b\u8981\u7248\u672c V3 \u53d1\u5e03\u4e4b\u524d\u88ab\u79fb\u9664\u3002</p> <p>\u5f53\u7136\uff0c\u4e00\u4e9b\u770b\u4f3c\u5b89\u5168\u7684\u66f4\u6539\u548c\u9519\u8bef\u4fee\u590d\u4e0d\u53ef\u907f\u514d\u5730\u4f1a\u7834\u574f\u67d0\u4e9b\u7528\u6237\u7684\u4ee3\u7801 \u2014 \u5fc5\u987b\u94fe\u63a5\u5230 xkcd\u3002</p> <p>\u4ee5\u4e0b\u66f4\u6539\u5c06\u4e0d\u4f1a\u88ab\u89c6\u4e3a\u4e2d\u65ad\u6027\u53d8\u66f4\uff0c\u5e76\u4e14\u53ef\u80fd\u5728\u6b21\u8981\u7248\u672c\u4e2d\u53d1\u751f\uff1a</p> <ul> <li>\u53ef\u80fd\u5bfc\u81f4\u73b0\u6709\u4ee3\u7801\u7834\u574f\u7684\u9519\u8bef\u4fee\u590d\uff0c\u524d\u63d0\u662f\u8be5\u4ee3\u7801\u4f9d\u8d56\u4e8e\u672a\u8bb0\u5f55\u7684\u529f\u80fd/\u6784\u9020\u3002</li> <li>\u66f4\u6539 JSON Schema \u5f15\u7528\u7684\u683c\u5f0f\u3002</li> <li>\u66f4\u6539 <code>ValidationError</code> \u5f02\u5e38\u7684 <code>msg</code>\u3001<code>ctx</code> \u548c <code>loc</code> \u5b57\u6bb5\u3002<code>type</code> \u4e0d\u4f1a\u66f4\u6539 \u2014 \u5982\u679c\u60a8\u4ee5\u7f16\u7a0b\u65b9\u5f0f\u89e3\u6790\u9519\u8bef\u6d88\u606f\uff0c\u5e94\u8be5\u4f7f\u7528 <code>type</code>\u3002</li> <li>\u5411 <code>ValidationError</code> \u5f02\u5e38\u6dfb\u52a0\u65b0\u952e \u2014 \u4f8b\u5982\uff0c\u4e00\u65e6\u6211\u4eec\u8fc1\u79fb\u5230\u65b0\u7684 JSON \u89e3\u6790\u5668\uff0c\u6211\u4eec\u6253\u7b97\u5728\u9a8c\u8bc1 JSON \u65f6\u5411\u9519\u8bef\u6dfb\u52a0 <code>line_number</code> \u548c <code>column_number</code>\u3002</li> <li>\u6dfb\u52a0\u65b0\u7684 <code>ValidationError</code> \u9519\u8bef\u3002</li> <li>\u66f4\u6539 <code>__repr__</code> \u7684\u884c\u4e3a\uff0c\u5373\u4f7f\u662f\u516c\u5171\u7c7b\u4e5f\u662f\u5982\u6b64\u3002</li> <li>\u6838\u5fc3\u6a21\u5f0f\u7684\u5185\u5bb9\uff08\u901a\u5e38\u53ef\u5728 Pydantic \u6a21\u578b\u7684 <code>__pydantic_core_schema__</code> \u5c5e\u6027\u548c\u7c7b\u578b\u9002\u914d\u5668\u7684 <code>core_schema</code> \u4e0b\u83b7\u5f97\uff09\u53ef\u80fd\u5728\u7248\u672c\u4e4b\u95f4\u66f4\u6539\uff08\u8fd9\u662f Pydantic \u7528\u4e8e\u89c4\u5212\u5982\u4f55\u6267\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u7684\u4f4e\u7ea7\u683c\u5f0f\uff09\u3002</li> </ul> <p>\u5728\u6240\u6709\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5c06\u65e8\u5728\u6700\u5c0f\u5316\u53d8\u52a8\uff0c\u5e76\u4e14\u4ec5\u5728\u63d0\u9ad8 Pydantic \u5bf9\u7528\u6237\u7684\u8d28\u91cf\u6709\u5145\u5206\u7406\u7531\u65f6\u624d\u8fd9\u6837\u505a\u3002</p>"},{"location":"version-policy/#pydantic-v3","title":"Pydantic V3 \u53ca\u4ee5\u540e","text":"<p>\u6211\u4eec\u9884\u8ba1\u672a\u6765\u5927\u7ea6\u6bcf\u5e74\u53d1\u5e03\u4e00\u6b21\u65b0\u7684\u4e3b\u8981\u7248\u672c\uff0c\u5c3d\u7ba1\u5982\u4e0a\u6240\u8ff0\uff0c\u4efb\u4f55\u76f8\u5173\u7684\u4e2d\u65ad\u6027\u53d8\u66f4\u4e0e V1 \u5230 V2 \u7684\u8fc7\u6e21\u76f8\u6bd4\u5e94\u8be5\u5f88\u5bb9\u6613\u4fee\u590d\u3002</p>"},{"location":"version-policy/#experimental-features","title":"\u5b9e\u9a8c\u6027\u529f\u80fd","text":"<p>\u5728 Pydantic\uff0c\u6211\u4eec\u559c\u6b22\u5feb\u901f\u884c\u52a8\u548c\u521b\u65b0\uff01\u4e3a\u6b64\uff0c\u6211\u4eec\u53ef\u80fd\u5728\u6b21\u8981\u7248\u672c\u4e2d\u5f15\u5165\u5b9e\u9a8c\u6027\u529f\u80fd\u3002</p> <p>\u4f7f\u7528\u6587\u6863</p> <p>\u8981\u4e86\u89e3\u6211\u4eec\u5f53\u524d\u7684\u5b9e\u9a8c\u6027\u529f\u80fd\uff0c\u8bf7\u53c2\u9605\u5b9e\u9a8c\u6027\u529f\u80fd\u6587\u6863\u3002</p> <p>\u8bf7\u8bb0\u4f4f\uff0c\u5b9e\u9a8c\u6027\u529f\u80fd\u662f\u6b63\u5728\u8fdb\u884c\u4e2d\u7684\u5de5\u4f5c\u3002\u5982\u679c\u8fd9\u4e9b\u529f\u80fd\u6210\u529f\uff0c\u5b83\u4eec\u6700\u7ec8\u5c06\u6210\u4e3a Pydantic \u7684\u4e00\u90e8\u5206\u3002\u5982\u679c\u4e0d\u6210\u529f\uff0c\u8fd9\u4e9b\u529f\u80fd\u5c06\u5728\u5f88\u5c11\u901a\u77e5\u7684\u60c5\u51b5\u4e0b\u88ab\u79fb\u9664\u3002\u5728\u5b9e\u9a8c\u9636\u6bb5\uff0c\u529f\u80fd\u7684 API \u548c\u884c\u4e3a\u53ef\u80fd\u4e0d\u7a33\u5b9a\uff0c\u5e76\u4e14\u5bf9\u8be5\u529f\u80fd\u6240\u505a\u7684\u66f4\u6539\u5f88\u53ef\u80fd\u4e0d\u4f1a\u5411\u540e\u517c\u5bb9\u3002</p>"},{"location":"version-policy/#_2","title":"\u547d\u540d\u7ea6\u5b9a","text":"<p>\u6211\u4eec\u4f7f\u7528\u4ee5\u4e0b\u547d\u540d\u7ea6\u5b9a\u4e4b\u4e00\u6765\u6307\u793a\u67d0\u4e2a\u529f\u80fd\u662f\u5b9e\u9a8c\u6027\u7684\uff1a</p> <ol> <li> <p>\u8be5\u529f\u80fd\u4f4d\u4e8e <code>experimental</code> \u6a21\u5757\u4e2d\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u8fd9\u6837\u8bbf\u95ee\u8be5\u529f\u80fd\uff1a</p> <pre><code>from pydantic.experimental import feature_name\n</code></pre> </li> <li> <p>\u8be5\u529f\u80fd\u4f4d\u4e8e\u4e3b\u6a21\u5757\u4e2d\uff0c\u4f46\u524d\u7f00\u4e3a <code>experimental_</code>\u3002\u8fd9\u79cd\u60c5\u51b5\u53d1\u751f\u5728\u6211\u4eec\u5411\u4e3b <code>pydantic</code> \u6a21\u5757\u4e2d\u5df2\u6709\u7684\u73b0\u6709\u6570\u636e\u7ed3\u6784\u6dfb\u52a0\u65b0\u5b57\u6bb5\u3001\u53c2\u6570\u6216\u65b9\u6cd5\u65f6\u3002</p> </li> </ol> <p>\u5177\u6709\u8fd9\u4e9b\u547d\u540d\u7ea6\u5b9a\u7684\u65b0\u529f\u80fd\u53ef\u80fd\u4f1a\u66f4\u6539\u6216\u79fb\u9664\uff0c\u6211\u4eec\u6b63\u5728\u5bfb\u6c42\u53cd\u9988\u548c\u5efa\u8bae\uff0c\u7136\u540e\u518d\u5c06\u5b83\u4eec\u4f5c\u4e3a Pydantic \u7684\u6c38\u4e45\u90e8\u5206\u3002\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u53cd\u9988\u90e8\u5206\u3002</p>"},{"location":"version-policy/#_3","title":"\u5b9e\u9a8c\u6027\u529f\u80fd\u7684\u751f\u547d\u5468\u671f","text":"<ol> <li>\u6dfb\u52a0\u4e00\u4e2a\u65b0\u529f\u80fd\uff0c\u8981\u4e48\u5728 <code>experimental</code> \u6a21\u5757\u4e2d\uff0c\u8981\u4e48\u5e26\u6709 <code>experimental_</code> \u524d\u7f00\u3002</li> <li>\u5728\u8865\u4e01/\u6b21\u8981\u7248\u672c\u671f\u95f4\u901a\u5e38\u4f1a\u4fee\u6539\u884c\u4e3a\uff0c\u53ef\u80fd\u4f1a\u6709 API/\u884c\u4e3a\u66f4\u6539\u3002</li> <li> <p>\u5982\u679c\u8be5\u529f\u80fd\u6210\u529f\uff0c\u6211\u4eec\u901a\u8fc7\u4ee5\u4e0b\u6b65\u9aa4\u5c06\u5176\u63d0\u5347\u5230 Pydantic\uff1a</p> <p>a. \u5982\u679c\u5b83\u5728 <code>experimental</code> \u6a21\u5757\u4e2d\uff0c\u8be5\u529f\u80fd\u5c06\u88ab\u514b\u9686\u5230 Pydantic \u7684\u4e3b\u6a21\u5757\u3002\u539f\u59cb\u5b9e\u9a8c\u6027\u529f\u80fd\u4ecd\u7136\u4fdd\u7559\u5728 <code>experimental</code> \u6a21\u5757\u4e2d\uff0c\u4f46\u5728\u4f7f\u7528\u65f6\u5c06\u663e\u793a\u8b66\u544a\u3002\u5982\u679c\u8be5\u529f\u80fd\u5df2\u7ecf\u5728\u4e3b Pydantic \u6a21\u5757\u4e2d\uff0c\u6211\u4eec\u521b\u5efa\u8be5\u529f\u80fd\u7684\u526f\u672c\u800c\u4e0d\u5e26 <code>experimental_</code> \u524d\u7f00\uff0c\u56e0\u6b64\u8be5\u529f\u80fd\u540c\u65f6\u5b58\u5728\u5b98\u65b9\u540d\u79f0\u548c\u5b9e\u9a8c\u6027\u540d\u79f0\u3002\u5f03\u7528\u8b66\u544a\u9644\u52a0\u5230\u5b9e\u9a8c\u7248\u672c\u3002</p> <p>b. \u5728\u67d0\u4e2a\u65f6\u5019\uff0c\u5b9e\u9a8c\u6027\u529f\u80fd\u7684\u4ee3\u7801\u88ab\u79fb\u9664\uff0c\u4f46\u8be5\u529f\u80fd\u7684\u5b58\u6839\u4ecd\u7136\u5b58\u5728\uff0c\u63d0\u4f9b\u5e26\u6709\u9002\u5f53\u8bf4\u660e\u7684\u9519\u8bef\u6d88\u606f\u3002</p> <p>c. \u4f5c\u4e3a\u6700\u540e\u4e00\u6b65\uff0c\u5b9e\u9a8c\u7248\u672c\u7684\u529f\u80fd\u5b8c\u5168\u4ece\u4ee3\u7801\u5e93\u4e2d\u79fb\u9664\u3002</p> </li> </ol> <p>\u5982\u679c\u8be5\u529f\u80fd\u4e0d\u6210\u529f\u6216\u4e0d\u53d7\u6b22\u8fce\uff0c\u5b83\u5c06\u5728\u5f88\u5c11\u901a\u77e5\u7684\u60c5\u51b5\u4e0b\u88ab\u79fb\u9664\u3002\u5f03\u7528\u529f\u80fd\u7684\u4f4d\u7f6e\u5c06\u4fdd\u7559\u4e00\u4e2a\u5b58\u6839\uff0c\u5176\u4e2d\u5305\u542b\u9519\u8bef\u6d88\u606f\u3002</p> <p>\u611f\u8c22 streamlit \u4e3a\u6211\u4eec\u65b0\u7684\u5b9e\u9a8c\u6027\u529f\u80fd\u6a21\u5f0f\u7684\u751f\u547d\u5468\u671f\u548c\u547d\u540d\u7ea6\u5b9a\u63d0\u4f9b\u4e86\u7075\u611f\u3002</p>"},{"location":"version-policy/#python","title":"\u5bf9 Python \u7248\u672c\u7684\u652f\u6301","text":"<p>\u5f53\u6ee1\u8db3\u4ee5\u4e0b\u6761\u4ef6\u65f6\uff0cPydantic \u5c06\u505c\u6b62\u5bf9 Python \u7248\u672c\u7684\u652f\u6301\uff1a</p> <ul> <li>Python \u7248\u672c\u5df2\u8fbe\u5230\u5176\u9884\u671f\u751f\u547d\u5468\u671f\u7ed3\u675f\u3002</li> <li>\u6700\u8fd1\u6b21\u8981\u7248\u672c\u7684\u4e0b\u8f7d\u91cf\u4e2d\uff0c\u4f7f\u7528\u8be5\u7248\u672c\u7684\u4e0b\u8f7d\u91cf\u5c11\u4e8e 5%\u3002</li> </ul>"},{"location":"why/","title":"\u4e3a\u4ec0\u4e48\u4f7f\u7528 Pydantic Validation\uff1f","text":"<p>\u5982\u4eca\uff0cPydantic \u6bcf\u6708\u88ab\u4e0b\u8f7d\u8bb8\u591a\u6b21\uff0c\u5e76\u88ab\u4e16\u754c\u4e0a\u4e00\u4e9b\u6700\u5927\u548c\u6700\u77e5\u540d\u7684\u7ec4\u7ec7\u4f7f\u7528\u3002</p> <p>\u5f88\u96be\u786e\u5207\u77e5\u9053\u4e3a\u4ec0\u4e48\u81ea\u516d\u5e74\u524d\u8bde\u751f\u4ee5\u6765\uff0c\u6709\u8fd9\u4e48\u591a\u4eba\u91c7\u7528\u4e86 Pydantic\uff0c\u4f46\u8fd9\u91cc\u6709\u4e00\u4e9b\u731c\u6d4b\u3002</p>"},{"location":"why/#type-hints","title":"\u7c7b\u578b\u63d0\u793a\u9a71\u52a8\u7684\u6a21\u5f0f\u9a8c\u8bc1","text":"<p>Pydantic \u9a8c\u8bc1\u7684\u6a21\u5f0f\u901a\u5e38\u7531 Python \u7c7b\u578b\u63d0\u793a\u5b9a\u4e49\u3002</p> <p>\u7c7b\u578b\u63d0\u793a\u975e\u5e38\u9002\u5408\u8fd9\u4e2a\u7528\u9014\uff0c\u56e0\u4e3a\u5982\u679c\u4f60\u6b63\u5728\u7f16\u5199\u73b0\u4ee3 Python\uff0c\u4f60\u5df2\u7ecf\u77e5\u9053\u5982\u4f55\u4f7f\u7528\u5b83\u4eec\u3002 \u4f7f\u7528\u7c7b\u578b\u63d0\u793a\u4e5f\u610f\u5473\u7740 Pydantic \u4e0e\u9759\u6001\u7c7b\u578b\u5de5\u5177\uff08\u5982 mypy \u548c Pyright\uff09 \u4ee5\u53ca IDE\uff08\u5982 PyCharm \u548c VSCode\uff09\u96c6\u6210\u826f\u597d\u3002</p> \u793a\u4f8b - \u4ec5\u4f7f\u7528\u7c7b\u578b\u63d0\u793a <pre><code>from typing import Annotated, Literal\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\n\nclass Fruit(BaseModel):\n    name: str  # (1)!\n    color: Literal['red', 'green']  # (2)!\n    weight: Annotated[float, Gt(0)]  # (3)!\n    bazam: dict[str, list[tuple[int, bool, float]]]  # (4)!\n\n\nprint(\n    Fruit(\n        name='Apple',\n        color='red',\n        weight=4.2,\n        bazam={'foobar': [(1, True, 0.1)]},\n    )\n)\n#&gt; name='Apple' color='red' weight=4.2 bazam={'foobar': [(1, True, 0.1)]}\n</code></pre> <ol> <li><code>name</code> \u5b57\u6bb5\u7b80\u5355\u5730\u7528 <code>str</code> \u6ce8\u89e3 \u2014 \u5141\u8bb8\u4efb\u4f55\u5b57\u7b26\u4e32\u3002</li> <li><code>Literal</code> \u7c7b\u578b\u7528\u4e8e\u5f3a\u5236 <code>color</code> \u4e3a <code>'red'</code> \u6216 <code>'green'</code>\u3002</li> <li>\u5373\u4f7f\u6211\u4eec\u60f3\u8981\u5e94\u7528 Python \u7c7b\u578b\u672a\u5c01\u88c5\u7684\u7ea6\u675f\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>Annotated</code>    \u548c <code>annotated-types</code> \u6765\u5f3a\u5236\u6267\u884c\u7ea6\u675f\uff0c\u540c\u65f6\u4fdd\u6301\u7c7b\u578b\u652f\u6301\u3002</li> <li>\u6211\u5e76\u4e0d\u662f\u58f0\u79f0 \"bazam\" \u771f\u7684\u662f\u6c34\u679c\u7684\u5c5e\u6027\uff0c\u800c\u662f\u4e3a\u4e86\u5c55\u793a\u4efb\u610f\u590d\u6742\u7684\u7c7b\u578b\u53ef\u4ee5\u8f7b\u677e\u9a8c\u8bc1\u3002</li> </ol> <p>\u4e86\u89e3\u66f4\u591a</p> <p>\u53c2\u89c1\u652f\u6301\u7c7b\u578b\u7684\u6587\u6863\u3002</p>"},{"location":"why/#performance","title":"\u6027\u80fd","text":"<p>Pydantic \u7684\u6838\u5fc3\u9a8c\u8bc1\u903b\u8f91\u5728\u4e00\u4e2a\u5355\u72ec\u7684\u5305 (<code>pydantic-core</code>) \u4e2d\u5b9e\u73b0\uff0c \u5176\u4e2d\u5927\u591a\u6570\u7c7b\u578b\u7684\u9a8c\u8bc1\u662f\u7528 Rust \u5b9e\u73b0\u7684\u3002</p> <p>\u56e0\u6b64\uff0cPydantic \u662f Python \u4e2d\u6700\u5feb\u7684\u6570\u636e\u9a8c\u8bc1\u5e93\u4e4b\u4e00\u3002</p> \u6027\u80fd\u793a\u4f8b - Pydantic vs. \u4e13\u7528\u4ee3\u7801 <p>\u4e00\u822c\u6765\u8bf4\uff0c\u4e13\u7528\u4ee3\u7801\u5e94\u8be5\u6bd4\u901a\u7528\u9a8c\u8bc1\u5668\u5feb\u5f97\u591a\uff0c\u4f46\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c \u5f53\u89e3\u6790 JSON \u548c\u9a8c\u8bc1 URL \u65f6\uff0cPydantic \u6bd4\u4e13\u7528\u4ee3\u7801\u5feb &gt;300%\u3002</p> \u6027\u80fd\u793a\u4f8b<pre><code>import json\nimport timeit\nfrom urllib.parse import urlparse\n\nimport requests\n\nfrom pydantic import HttpUrl, TypeAdapter\n\nreps = 7\nnumber = 100\nr = requests.get('https://api.github.com/emojis')\nr.raise_for_status()\nemojis_json = r.content\n\n\ndef emojis_pure_python(raw_data):\n    data = json.loads(raw_data)\n    output = {}\n    for key, value in data.items():\n        assert isinstance(key, str)\n        url = urlparse(value)\n        assert url.scheme in ('https', 'http')\n        output[key] = url\n\n\nemojis_pure_python_times = timeit.repeat(\n    'emojis_pure_python(emojis_json)',\n    globals={\n        'emojis_pure_python': emojis_pure_python,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pure python: {min(emojis_pure_python_times) / number * 1000:0.2f}ms')\n#&gt; pure python: 5.32ms\n\ntype_adapter = TypeAdapter(dict[str, HttpUrl])\nemojis_pydantic_times = timeit.repeat(\n    'type_adapter.validate_json(emojis_json)',\n    globals={\n        'type_adapter': type_adapter,\n        'HttpUrl': HttpUrl,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pydantic: {min(emojis_pydantic_times) / number * 1000:0.2f}ms')\n#&gt; pydantic: 1.54ms\n\nprint(\n    f'Pydantic {min(emojis_pure_python_times) / min(emojis_pydantic_times):0.2f}x faster'\n)\n#&gt; Pydantic 3.45x faster\n</code></pre> <p>\u4e0e\u5176\u4ed6\u7528\u7f16\u8bd1\u8bed\u8a00\u7f16\u5199\u7684\u6027\u80fd\u4e2d\u5fc3\u5e93\u4e0d\u540c\uff0cPydantic \u8fd8\u901a\u8fc7\u51fd\u6570\u5f0f\u9a8c\u8bc1\u5668\u63d0\u4f9b\u4e86\u51fa\u8272\u7684\u9a8c\u8bc1\u5b9a\u5236\u652f\u6301\u3002</p> <p>\u4e86\u89e3\u66f4\u591a</p> <p>Samuel Colvin \u5728 PyCon 2023 \u7684\u6f14\u8bb2 \u89e3\u91ca\u4e86 <code>pydantic-core</code> \u7684\u5de5\u4f5c\u539f\u7406\u4ee5\u53ca\u5b83\u5982\u4f55\u4e0e Pydantic \u96c6\u6210\u3002</p>"},{"location":"why/#_1","title":"\u5e8f\u5217\u5316","text":"<p>Pydantic \u63d0\u4f9b\u4e86\u4e09\u79cd\u5e8f\u5217\u5316\u6a21\u578b\u7684\u65b9\u5f0f\uff1a</p> <ol> <li>\u8f6c\u6362\u4e3a\u7531\u5173\u8054\u7684 Python \u5bf9\u8c61\u7ec4\u6210\u7684 Python <code>dict</code>\u3002</li> <li>\u8f6c\u6362\u4e3a\u4ec5\u7531 \"jsonable\" \u7c7b\u578b\u7ec4\u6210\u7684 Python <code>dict</code>\u3002</li> <li>\u8f6c\u6362\u4e3a JSON \u5b57\u7b26\u4e32\u3002</li> </ol> <p>\u5728\u6240\u6709\u4e09\u79cd\u6a21\u5f0f\u4e2d\uff0c\u8f93\u51fa\u53ef\u4ee5\u901a\u8fc7\u6392\u9664\u7279\u5b9a\u5b57\u6bb5\u3001\u6392\u9664\u672a\u8bbe\u7f6e\u5b57\u6bb5\u3001\u6392\u9664\u9ed8\u8ba4\u503c\u548c\u6392\u9664 <code>None</code> \u503c\u6765\u81ea\u5b9a\u4e49\u3002</p> \u793a\u4f8b - \u4e09\u79cd\u5e8f\u5217\u5316\u65b9\u5f0f <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n    why: str = 'No idea'\n\n\nm = Meeting(when='2020-01-01T12:00', where='home')\nprint(m.model_dump(exclude_unset=True))\n#&gt; {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nprint(m.model_dump(exclude={'where'}, mode='json'))\n#&gt; {'when': '2020-01-01T12:00:00', 'why': 'No idea'}\nprint(m.model_dump_json(exclude_defaults=True))\n#&gt; {\"when\":\"2020-01-01T12:00:00\",\"where\":\"home\"}\n</code></pre> <p>\u4e86\u89e3\u66f4\u591a</p> <p>\u53c2\u89c1\u5e8f\u5217\u5316\u6587\u6863\u3002</p>"},{"location":"why/#json-schema","title":"JSON Schema","text":"<p>\u53ef\u4ee5\u4e3a\u4efb\u4f55 Pydantic \u6a21\u5f0f\u751f\u6210 JSON Schema \u2014 \u5141\u8bb8\u81ea\u6587\u6863\u5316 API \u5e76\u4e0e\u652f\u6301 JSON Schema \u683c\u5f0f\u7684\u5404\u79cd\u5de5\u5177\u96c6\u6210\u3002</p> \u793a\u4f8b - JSON Schema <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zipcode: str\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: Address\n    why: str = 'No idea'\n\n\nprint(Meeting.model_json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Address': {\n            'properties': {\n                'street': {'title': 'Street', 'type': 'string'},\n                'city': {'title': 'City', 'type': 'string'},\n                'zipcode': {'title': 'Zipcode', 'type': 'string'},\n            },\n            'required': ['street', 'city', 'zipcode'],\n            'title': 'Address',\n            'type': 'object',\n        }\n    },\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'$ref': '#/$defs/Address'},\n        'why': {'default': 'No idea', 'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <p>Pydantic \u7b26\u5408\u6700\u65b0\u7248\u672c\u7684 JSON Schema \u89c4\u8303 (2020-12)\uff0c\u8be5\u89c4\u8303 \u4e0e OpenAPI 3.1 \u517c\u5bb9\u3002</p> <p>\u4e86\u89e3\u66f4\u591a</p> <p>\u53c2\u89c1 JSON Schema \u6587\u6863\u3002</p>"},{"location":"why/#strict-lax","title":"\u4e25\u683c\u6a21\u5f0f\u548c\u6570\u636e\u5f3a\u5236\u8f6c\u6362","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u5bf9\u5e38\u89c1\u7684\u4e0d\u6b63\u786e\u7c7b\u578b\u662f\u5bbd\u5bb9\u7684\uff0c\u5e76\u5c06\u6570\u636e\u5f3a\u5236\u8f6c\u6362\u4e3a\u6b63\u786e\u7684\u7c7b\u578b \u2014 \u4f8b\u5982\uff0c\u4f20\u9012\u7ed9 <code>int</code> \u5b57\u6bb5\u7684\u6570\u5b57\u5b57\u7b26\u4e32\u5c06\u88ab\u89e3\u6790\u4e3a <code>int</code>\u3002</p> <p>Pydantic \u4e5f\u6709\u4e25\u683c\u6a21\u5f0f\uff0c\u5728\u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0c\u7c7b\u578b\u4e0d\u4f1a\u88ab\u5f3a\u5236\u8f6c\u6362\uff0c\u9664\u975e\u8f93\u5165\u6570\u636e\u5b8c\u5168\u5339\u914d\u9884\u671f\u7684\u6a21\u5f0f\uff0c\u5426\u5219\u4f1a\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\u3002</p> <p>\u4f46\u5728\u9a8c\u8bc1 JSON \u6570\u636e\u65f6\uff0c\u4e25\u683c\u6a21\u5f0f\u4f1a\u76f8\u5f53\u65e0\u7528\uff0c\u56e0\u4e3a JSON \u6ca1\u6709\u5339\u914d\u8bb8\u591a\u5e38\u89c1 Python \u7c7b\u578b\u7684\u7c7b\u578b\uff0c \u5982 <code>datetime</code>\u3001<code>UUID</code> \u6216 <code>bytes</code>\u3002</p> <p>\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0cPydantic \u53ef\u4ee5\u4e00\u6b65\u89e3\u6790\u548c\u9a8c\u8bc1 JSON\u3002\u8fd9\u5141\u8bb8\u5408\u7406\u7684\u6570\u636e\u8f6c\u6362 \uff08\u4f8b\u5982\uff0c\u5728\u5c06\u5b57\u7b26\u4e32\u89e3\u6790\u4e3a <code>datetime</code> \u5bf9\u8c61\u65f6\uff09\u3002\u7531\u4e8e JSON \u89e3\u6790\u662f \u7528 Rust \u5b9e\u73b0\u7684\uff0c\u5b83\u4e5f\u975e\u5e38\u9ad8\u6548\u3002</p> \u793a\u4f8b - \u771f\u6b63\u6709\u7528\u7684\u4e25\u683c\u6a21\u5f0f <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n\n\nm = Meeting.model_validate({'when': '2020-01-01T12:00', 'where': 'home'})\nprint(m)\n#&gt; when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\ntry:\n    m = Meeting.model_validate(\n        {'when': '2020-01-01T12:00', 'where': 'home'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Meeting\n    when\n      Input should be a valid datetime [type=datetime_type, input_value='2020-01-01T12:00', input_type=str]\n    where\n      Input should be a valid bytes [type=bytes_type, input_value='home', input_type=str]\n    \"\"\"\n\nm_json = Meeting.model_validate_json(\n    '{\"when\": \"2020-01-01T12:00\", \"where\": \"home\"}'\n)\nprint(m_json)\n#&gt; when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\n</code></pre> <p>\u4e86\u89e3\u66f4\u591a</p> <p>\u53c2\u89c1\u4e25\u683c\u6a21\u5f0f\u6587\u6863\u3002</p>"},{"location":"why/#dataclasses-typeddict-more","title":"Dataclasses\u3001TypedDicts \u7b49","text":"<p>Pydantic \u63d0\u4f9b\u4e86\u56db\u79cd\u521b\u5efa\u6a21\u5f0f\u548c\u6267\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u7684\u65b9\u5f0f\uff1a</p> <ol> <li><code>BaseModel</code> \u2014 Pydantic \u81ea\u5df1\u7684\u8d85\u7c7b\uff0c\u901a\u8fc7\u5b9e\u4f8b\u65b9\u6cd5\u63d0\u4f9b\u8bb8\u591a\u5e38\u7528\u5b9e\u7528\u7a0b\u5e8f\u3002</li> <li>Pydantic dataclasses \u2014 \u6807\u51c6\u6570\u636e\u7c7b\u7684\u5305\u88c5\u5668\uff0c\u6267\u884c\u989d\u5916\u7684\u9a8c\u8bc1\u3002</li> <li><code>TypeAdapter</code> \u2014 \u4e00\u79cd\u901a\u7528\u7684\u65b9\u5f0f\u6765\u9002\u914d\u4efb\u4f55\u7c7b\u578b\u4ee5\u8fdb\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u3002    \u8fd9\u5141\u8bb8\u9a8c\u8bc1\u50cf <code>TypedDict</code> \u548c <code>NamedTuple</code>    \u8fd9\u6837\u7684\u7c7b\u578b\uff0c\u4ee5\u53ca\u7b80\u5355\u7c7b\u578b\uff08\u5982 <code>int</code> \u6216 <code>timedelta</code>\uff09\u2014 \u6240\u6709\u652f\u6301\u7684\u7c7b\u578b    \u90fd\u53ef\u4ee5\u4e0e <code>TypeAdapter</code> \u4e00\u8d77\u4f7f\u7528\u3002</li> <li><code>validate_call</code> \u2014 \u5728\u8c03\u7528\u51fd\u6570\u65f6\u6267\u884c\u9a8c\u8bc1\u7684\u88c5\u9970\u5668\u3002</li> </ol> \u793a\u4f8b - \u57fa\u4e8e <code>TypedDict</code> \u7684\u6a21\u5f0f <pre><code>from datetime import datetime\n\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Meeting(TypedDict):\n    when: datetime\n    where: bytes\n    why: NotRequired[str]\n\n\nmeeting_adapter = TypeAdapter(Meeting)\nm = meeting_adapter.validate_python(  # (1)!\n    {'when': '2020-01-01T12:00', 'where': 'home'}\n)\nprint(m)\n#&gt; {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nmeeting_adapter.dump_python(m, exclude={'where'})  # (2)!\n\nprint(meeting_adapter.json_schema())  # (3)!\n\"\"\"\n{\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'format': 'binary', 'title': 'Where', 'type': 'string'},\n        'why': {'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <ol> <li><code>TypeAdapter</code> \u7528\u4e8e\u6267\u884c\u9a8c\u8bc1\u7684 <code>TypedDict</code>\uff0c    \u5b83\u4e5f\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 <code>validate_json</code> \u9a8c\u8bc1 JSON \u6570\u636e\u3002</li> <li><code>dump_python</code> \u5c06 <code>TypedDict</code>    \u5e8f\u5217\u5316\u4e3a python \u5bf9\u8c61\uff0c\u5b83\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>dump_json</code> \u5e8f\u5217\u5316\u4e3a JSON\u3002</li> <li><code>TypeAdapter</code> \u4e5f\u53ef\u4ee5\u751f\u6210 JSON Schema\u3002</li> </ol>"},{"location":"why/#customisation","title":"\u81ea\u5b9a\u4e49","text":"<p>\u51fd\u6570\u5f0f\u9a8c\u8bc1\u5668\u548c\u5e8f\u5217\u5316\u5668\uff0c\u4ee5\u53ca\u81ea\u5b9a\u4e49\u7c7b\u578b\u7684\u5f3a\u5927\u534f\u8bae\uff0c\u610f\u5473\u7740 Pydantic \u7684\u64cd\u4f5c\u65b9\u5f0f\u53ef\u4ee5\u5728\u6bcf\u4e2a\u5b57\u6bb5\u6216\u6bcf\u4e2a\u7c7b\u578b\u7684\u57fa\u7840\u4e0a\u8fdb\u884c\u5b9a\u5236\u3002</p> \u81ea\u5b9a\u4e49\u793a\u4f8b - \u5305\u88c5\u9a8c\u8bc1\u5668 <p>\"\u5305\u88c5\u9a8c\u8bc1\u5668\" \u662f Pydantic V2 \u4e2d\u7684\u65b0\u529f\u80fd\uff0c\u662f\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u7684\u6700\u5f3a\u5927\u65b9\u5f0f\u4e4b\u4e00\u3002</p> <pre><code>from datetime import datetime, timezone\nfrom typing import Any\n\nfrom pydantic_core.core_schema import ValidatorFunctionWrapHandler\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Meeting(BaseModel):\n    when: datetime\n\n    @field_validator('when', mode='wrap')\n    def when_now(\n        cls, input_value: Any, handler: ValidatorFunctionWrapHandler\n    ) -&gt; datetime:\n        if input_value == 'now':\n            return datetime.now()\n        when = handler(input_value)\n        # \u5728\u8fd9\u4e2a\u7279\u5b9a\u7684\u5e94\u7528\u7a0b\u5e8f\u4e2d\uff0c\u6211\u4eec\u77e5\u9053\u65e0\u65f6\u533a\u4fe1\u606f\u7684\u65e5\u671f\u65f6\u95f4\u662f\u5728 UTC \u4e2d\n        if when.tzinfo is None:\n            when = when.replace(tzinfo=timezone.utc)\n        return when\n\n\nprint(Meeting(when='2020-01-01T12:00+01:00'))\n#&gt; when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=TzInfo(3600))\nprint(Meeting(when='now'))\n#&gt; when=datetime.datetime(2032, 1, 2, 3, 4, 5, 6)\nprint(Meeting(when='2020-01-01T12:00'))\n#&gt; when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=datetime.timezone.utc)\n</code></pre> <p>\u4e86\u89e3\u66f4\u591a</p> <p>\u53c2\u89c1\u9a8c\u8bc1\u5668\u3001\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668 \u548c\u81ea\u5b9a\u4e49\u7c7b\u578b\u7684\u6587\u6863\u3002</p>"},{"location":"why/#ecosystem","title":"\u751f\u6001\u7cfb\u7edf","text":"<p>\u5728\u64b0\u5199\u672c\u6587\u65f6\uff0cGitHub \u4e0a\u6709 466,400 \u4e2a\u4ed3\u5e93\uff0cPyPI \u4e0a\u6709 8,119 \u4e2a\u5305\u4f9d\u8d56 Pydantic\u3002</p> <p>\u4e00\u4e9b\u4f9d\u8d56 Pydantic \u7684\u8457\u540d\u5e93\uff1a</p> <ul> <li><code>huggingface/transformers</code> 138,570 stars</li> <li><code>hwchase17/langchain</code> 99,542 stars</li> <li><code>tiangolo/fastapi</code> 80,497 stars</li> <li><code>apache/airflow</code> 38,577 stars</li> <li><code>lm-sys/FastChat</code> 37,650 stars</li> <li><code>microsoft/DeepSpeed</code> 36,521 stars</li> <li><code>OpenBB-finance/OpenBBTerminal</code> 35,971 stars</li> <li><code>gradio-app/gradio</code> 35,740 stars</li> <li><code>ray-project/ray</code> 35,176 stars</li> <li><code>pola-rs/polars</code> 31,698 stars</li> <li><code>Lightning-AI/lightning</code> 28,902 stars</li> <li><code>mindsdb/mindsdb</code> 27,141 stars</li> <li><code>embedchain/embedchain</code> 24,379 stars</li> <li><code>pynecone-io/reflex</code> 21,558 stars</li> <li><code>heartexlabs/label-studio</code> 20,571 stars</li> <li><code>Sanster/lama-cleaner</code> 20,313 stars</li> <li><code>mlflow/mlflow</code> 19,393 stars</li> <li><code>RasaHQ/rasa</code> 19,337 stars</li> <li><code>spotDL/spotify-downloader</code> 18,604 stars</li> <li><code>chroma-core/chroma</code> 17,393 stars</li> <li><code>airbytehq/airbyte</code> 17,120 stars</li> <li><code>openai/evals</code> 15,437 stars</li> <li><code>tiangolo/sqlmodel</code> 15,127 stars</li> <li><code>ydataai/ydata-profiling</code> 12,687 stars</li> <li><code>pyodide/pyodide</code> 12,653 stars</li> <li><code>dagster-io/dagster</code> 12,440 stars</li> <li><code>PaddlePaddle/PaddleNLP</code> 12,312 stars</li> <li><code>matrix-org/synapse</code> 11,857 stars</li> <li><code>lucidrains/DALLE2-pytorch</code> 11,207 stars</li> <li><code>great-expectations/great_expectations</code> 10,164 stars</li> <li><code>modin-project/modin</code> 10,002 stars</li> <li><code>aws/serverless-application-model</code> 9,402 stars</li> <li><code>sqlfluff/sqlfluff</code> 8,535 stars</li> <li><code>replicate/cog</code> 8,344 stars</li> <li><code>autogluon/autogluon</code> 8,326 stars</li> <li><code>lucidrains/imagen-pytorch</code> 8,164 stars</li> <li><code>brycedrennan/imaginAIry</code> 8,050 stars</li> <li><code>vitalik/django-ninja</code> 7,685 stars</li> <li><code>NVlabs/SPADE</code> 7,632 stars</li> <li><code>bridgecrewio/checkov</code> 7,340 stars</li> <li><code>bentoml/BentoML</code> 7,322 stars</li> <li><code>skypilot-org/skypilot</code> 7,113 stars</li> <li><code>apache/iceberg</code> 6,853 stars</li> <li><code>deeppavlov/DeepPavlov</code> 6,777 stars</li> <li><code>PrefectHQ/marvin</code> 5,454 stars</li> <li><code>NVIDIA/NeMo-Guardrails</code> 4,383 stars</li> <li><code>microsoft/FLAML</code> 4,035 stars</li> <li><code>jina-ai/discoart</code> 3,846 stars</li> <li><code>docarray/docarray</code> 3,007 stars</li> <li><code>aws-powertools/powertools-lambda-python</code> 2,980 stars</li> <li><code>roman-right/beanie</code> 2,172 stars</li> <li><code>art049/odmantic</code> 1,096 stars</li> </ul> <p>\u66f4\u591a\u4f7f\u7528 Pydantic \u7684\u5e93\u53ef\u4ee5\u5728 <code>Kludex/awesome-pydantic</code> \u627e\u5230\u3002</p>"},{"location":"why/#using-pydantic","title":"\u4f7f\u7528 Pydantic \u7684\u7ec4\u7ec7","text":"<p>\u4e00\u4e9b\u4f7f\u7528 Pydantic \u7684\u8457\u540d\u516c\u53f8\u548c\u7ec4\u7ec7\uff0c\u4ee5\u53ca\u5173\u4e8e\u6211\u4eec\u5982\u4f55\u77e5\u9053\u4ed6\u4eec\u4f7f\u7528 Pydantic \u7684\u8bc4\u8bba\u3002</p> <p>\u4e0b\u9762\u7684\u7ec4\u7ec7\u88ab\u5305\u62ec\u5728\u5185\uff0c\u662f\u56e0\u4e3a\u5b83\u4eec\u7b26\u5408\u4ee5\u4e0b\u4e00\u4e2a\u6216\u591a\u4e2a\u6807\u51c6\uff1a</p> <ul> <li>\u5728\u516c\u5171\u4ed3\u5e93\u4e2d\u4f7f\u7528 Pydantic \u4f5c\u4e3a\u4f9d\u8d56\u9879\u3002</li> <li>\u4ece\u7ec4\u7ec7\u5185\u90e8\u57df\u5f15\u7528 Pydantic \u6587\u6863\u7ad9\u70b9\u7684\u6d41\u91cf \u2014 \u5177\u4f53\u7684\u5f15\u7528\u8005\u4e0d\u5305\u62ec\u5728\u5185\uff0c\u56e0\u4e3a\u5b83\u4eec\u901a\u5e38\u4e0d\u5728\u516c\u5171\u9886\u57df\u3002</li> <li>Pydantic \u56e2\u961f\u4e0e\u53d7\u96c7\u4e8e\u8be5\u7ec4\u7ec7\u7684\u5de5\u7a0b\u5e08\u4e4b\u95f4\u5173\u4e8e\u5728\u8be5\u7ec4\u7ec7\u5185\u4f7f\u7528 Pydantic \u7684\u76f4\u63a5\u6c9f\u901a\u3002</li> </ul> <p>\u6211\u4eec\u5728\u9002\u5f53\u4e14\u5df2\u5728\u516c\u5171\u9886\u57df\u7684\u60c5\u51b5\u4e0b\u5305\u542b\u4e86\u4e00\u4e9b\u989d\u5916\u7ec6\u8282\u3002</p>"},{"location":"why/#org-adobe","title":"Adobe","text":"<p><code>adobe/dy-sql</code> uses Pydantic.</p>"},{"location":"why/#org-amazon","title":"Amazon and AWS","text":"<ul> <li>powertools-lambda-python</li> <li>awslabs/gluonts</li> <li>AWS sponsored Samuel Colvin $5,000 to work on Pydantic in 2022</li> </ul>"},{"location":"why/#org-anthropic","title":"Anthropic","text":"<p><code>anthropics/anthropic-sdk-python</code> uses Pydantic.</p>"},{"location":"why/#org-apple","title":"Apple","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-asml","title":"ASML","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-astrazeneca","title":"AstraZeneca","text":"<p>Multiple repos in the <code>AstraZeneca</code> GitHub org depend on Pydantic.</p>"},{"location":"why/#org-cisco","title":"Cisco Systems","text":"<ul> <li>Pydantic is listed in their report of Open Source Used In RADKit.</li> <li><code>cisco/webex-assistant-sdk</code></li> </ul>"},{"location":"why/#org-comcast","title":"Comcast","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-datadog","title":"Datadog","text":"<ul> <li>Extensive use of Pydantic in <code>DataDog/integrations-core</code> and other repos</li> <li>Communication with engineers from Datadog about how they use Pydantic.</li> </ul>"},{"location":"why/#org-facebook","title":"Facebook","text":"<p>Multiple repos in the <code>facebookresearch</code> GitHub org depend on Pydantic.</p>"},{"location":"why/#org-github","title":"GitHub","text":"<p>GitHub sponsored Pydantic $750 in 2022</p>"},{"location":"why/#org-google","title":"Google","text":"<p>Extensive use of Pydantic in <code>google/turbinia</code> and other repos.</p>"},{"location":"why/#org-hsbc","title":"HSBC","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-ibm","title":"IBM","text":"<p>Multiple repos in the <code>IBM</code> GitHub org depend on Pydantic.</p>"},{"location":"why/#org-intel","title":"Intel","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-intuit","title":"Intuit","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-ipcc","title":"Intergovernmental Panel on Climate Change","text":"<p>Tweet explaining how the IPCC use Pydantic.</p>"},{"location":"why/#org-jpmorgan","title":"JPMorgan","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-jupyter","title":"Jupyter","text":"<ul> <li>The developers of the Jupyter notebook are using Pydantic for subprojects</li> <li>Through the FastAPI-based Jupyter server Jupyverse</li> <li>FPS's configuration management.</li> </ul>"},{"location":"why/#org-microsoft","title":"Microsoft","text":"<ul> <li>DeepSpeed deep learning optimisation library uses Pydantic extensively</li> <li>Multiple repos in the <code>microsoft</code> GitHub org depend on Pydantic, in particular their</li> <li>Pydantic is also used in the <code>Azure</code> GitHub org</li> <li>Comments on GitHub show Microsoft engineers using Pydantic as part of Windows and Office</li> </ul>"},{"location":"why/#org-molssi","title":"Molecular Science Software Institute","text":"<p>Multiple repos in the <code>MolSSI</code> GitHub org depend on Pydantic.</p>"},{"location":"why/#org-nasa","title":"NASA","text":"<p>Multiple repos in the <code>NASA</code> GitHub org depend on Pydantic.</p> <p>NASA are also using Pydantic via FastAPI in their JWST project to process images from the James Webb Space Telescope, see this tweet.</p>"},{"location":"why/#org-netflix","title":"Netflix","text":"<p>Multiple repos in the <code>Netflix</code> GitHub org depend on Pydantic.</p>"},{"location":"why/#org-nsa","title":"NSA","text":"<p>The <code>nsacyber/WALKOFF</code> repo depends on Pydantic.</p>"},{"location":"why/#org-nvidia","title":"NVIDIA","text":"<p>Multiple repositories in the <code>NVIDIA</code> GitHub org depend on Pydantic.</p> <p>Their \"Omniverse Services\" depends on Pydantic according to their documentation.</p>"},{"location":"why/#org-openai","title":"OpenAI","text":"<p>OpenAI use Pydantic for their ChatCompletions API, as per this discussion on GitHub.</p> <p>Anecdotally, OpenAI use Pydantic extensively for their internal services.</p>"},{"location":"why/#org-oracle","title":"Oracle","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-palantir","title":"Palantir","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-qualcomm","title":"Qualcomm","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-redhat","title":"Red Hat","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-revolut","title":"Revolut","text":"<p>Anecdotally, all internal services at Revolut are built with FastAPI and therefore Pydantic.</p>"},{"location":"why/#org-robusta","title":"Robusta","text":"<p>The <code>robusta-dev/robusta</code> repo depends on Pydantic.</p>"},{"location":"why/#org-salesforce","title":"Salesforce","text":"<p>Salesforce sponsored Samuel Colvin $10,000 to work on Pydantic in 2022.</p>"},{"location":"why/#org-starbucks","title":"Starbucks","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-ti","title":"Texas Instruments","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-twilio","title":"Twilio","text":"<p>(Based on the criteria described above)</p>"},{"location":"why/#org-twitter","title":"Twitter","text":"<p>Twitter's <code>the-algorithm</code> repo where they open sourced their recommendation engine uses Pydantic.</p>"},{"location":"why/#org-ukhomeoffice","title":"UK Home Office","text":"<p>(Based on the criteria described above)</p>"},{"location":"api/aliases/","title":"Aliases","text":"<p>Support for alias configurations.</p>"},{"location":"api/aliases/#pydantic.aliases.AliasPath","title":"AliasPath  <code>dataclass</code>","text":"<pre><code>AliasPath(first_arg: str, *args: str | int)\n</code></pre> <p>Usage Documentation</p> <p><code>AliasPath</code> and <code>AliasChoices</code></p> <p>A data class used by <code>validation_alias</code> as a convenience to create aliases.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>path</code> <code>list[int | str]</code> <p>A list of string or integer aliases.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/aliases.py</code> <pre><code>def __init__(self, first_arg: str, *args: str | int) -&gt; None:\n    self.path = [first_arg] + list(args)\n</code></pre>"},{"location":"api/aliases/#pydantic.aliases.AliasPath.convert_to_aliases","title":"convert_to_aliases","text":"<pre><code>convert_to_aliases() -&gt; list[str | int]\n</code></pre> <p>Converts arguments to a list of string or integer aliases.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>list[str | int]</code> <p>The list of aliases.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/aliases.py</code> <pre><code>def convert_to_aliases(self) -&gt; list[str | int]:\n    \"\"\"Converts arguments to a list of string or integer aliases.\n\n    Returns:\n        The list of aliases.\n    \"\"\"\n    return self.path\n</code></pre>"},{"location":"api/aliases/#pydantic.aliases.AliasPath.search_dict_for_path","title":"search_dict_for_path","text":"<pre><code>search_dict_for_path(d: dict) -&gt; Any\n</code></pre> <p>Searches a dictionary for the path specified by the alias.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The value at the specified path, or <code>PydanticUndefined</code> if the path is not found.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/aliases.py</code> <pre><code>def search_dict_for_path(self, d: dict) -&gt; Any:\n    \"\"\"Searches a dictionary for the path specified by the alias.\n\n    Returns:\n        The value at the specified path, or `PydanticUndefined` if the path is not found.\n    \"\"\"\n    v = d\n    for k in self.path:\n        if isinstance(v, str):\n            # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n            return PydanticUndefined\n        try:\n            v = v[k]\n        except (KeyError, IndexError, TypeError):\n            return PydanticUndefined\n    return v\n</code></pre>"},{"location":"api/aliases/#pydantic.aliases.AliasChoices","title":"AliasChoices  <code>dataclass</code>","text":"<pre><code>AliasChoices(first_choice: str | AliasPath, *choices: str | AliasPath)\n</code></pre> <p>Usage Documentation</p> <p><code>AliasPath</code> and <code>AliasChoices</code></p> <p>A data class used by <code>validation_alias</code> as a convenience to create aliases.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>choices</code> <code>list[str | AliasPath]</code> <p>A list containing a string or <code>AliasPath</code>.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/aliases.py</code> <pre><code>def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -&gt; None:\n    self.choices = [first_choice] + list(choices)\n</code></pre>"},{"location":"api/aliases/#pydantic.aliases.AliasChoices.convert_to_aliases","title":"convert_to_aliases","text":"<pre><code>convert_to_aliases() -&gt; list[list[str | int]]\n</code></pre> <p>Converts arguments to a list of lists containing string or integer aliases.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>list[list[str | int]]</code> <p>The list of aliases.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/aliases.py</code> <pre><code>def convert_to_aliases(self) -&gt; list[list[str | int]]:\n    \"\"\"Converts arguments to a list of lists containing string or integer aliases.\n\n    Returns:\n        The list of aliases.\n    \"\"\"\n    aliases: list[list[str | int]] = []\n    for c in self.choices:\n        if isinstance(c, AliasPath):\n            aliases.append(c.convert_to_aliases())\n        else:\n            aliases.append([c])\n    return aliases\n</code></pre>"},{"location":"api/aliases/#pydantic.aliases.AliasGenerator","title":"AliasGenerator  <code>dataclass</code>","text":"<pre><code>AliasGenerator(alias: Callable[[str], str] | None = None, validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None, serialization_alias: Callable[[str], str] | None = None)\n</code></pre> <p>Usage Documentation</p> <p>Using an <code>AliasGenerator</code></p> <p>A data class used by <code>alias_generator</code> as a convenience to create various aliases.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>alias</code> <code>Callable[[str], str] | None</code> <p>A callable that takes a field name and returns an alias for it.</p> <code>validation_alias</code> <code>Callable[[str], str | AliasPath | AliasChoices] | None</code> <p>A callable that takes a field name and returns a validation alias for it.</p> <code>serialization_alias</code> <code>Callable[[str], str] | None</code> <p>A callable that takes a field name and returns a serialization alias for it.</p>"},{"location":"api/aliases/#pydantic.aliases.AliasGenerator.generate_aliases","title":"generate_aliases","text":"<pre><code>generate_aliases(field_name: str) -&gt; tuple[str | None, str | AliasPath | AliasChoices | None, str | None]\n</code></pre> <p>Generate <code>alias</code>, <code>validation_alias</code>, and <code>serialization_alias</code> for a field.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[str | None, str | AliasPath | AliasChoices | None, str | None]</code> <p>A tuple of three aliases - validation, alias, and serialization.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/aliases.py</code> <pre><code>def generate_aliases(self, field_name: str) -&gt; tuple[str | None, str | AliasPath | AliasChoices | None, str | None]:\n    \"\"\"Generate `alias`, `validation_alias`, and `serialization_alias` for a field.\n\n    Returns:\n        A tuple of three aliases - validation, alias, and serialization.\n    \"\"\"\n    alias = self._generate_alias('alias', (str,), field_name)\n    validation_alias = self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)\n    serialization_alias = self._generate_alias('serialization_alias', (str,), field_name)\n\n    return alias, validation_alias, serialization_alias  # type: ignore\n</code></pre>"},{"location":"api/annotated_handlers/","title":"Annotated Handlers","text":"<p>Type annotations to use with <code>__get_pydantic_core_schema__</code> and <code>__get_pydantic_json_schema__</code>.</p>"},{"location":"api/annotated_handlers/#pydantic.annotated_handlers.GetJsonSchemaHandler","title":"GetJsonSchemaHandler","text":"<p>Handler to call into the next JSON schema generation function.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>mode</code> <code>JsonSchemaMode</code> <p>Json schema mode, can be <code>validation</code> or <code>serialization</code>.</p>"},{"location":"api/annotated_handlers/#pydantic.annotated_handlers.GetJsonSchemaHandler.resolve_ref_schema","title":"resolve_ref_schema","text":"<pre><code>resolve_ref_schema(maybe_ref_json_schema: JsonSchemaValue) -&gt; JsonSchemaValue\n</code></pre> <p>Get the real schema for a <code>{\"$ref\": ...}</code> schema. If the schema given is not a <code>$ref</code> schema, it will be returned as is. This means you don't have to check before calling this function.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>maybe_ref_json_schema</code> <code>JsonSchemaValue</code> <p>A JsonSchemaValue which may be a <code>$ref</code> schema.</p> \u5fc5\u9700 <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>LookupError</code> <p>If the ref is not found.</p> <p>\u8fd4\u56de\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <code>JsonSchemaValue</code> <p>A JsonSchemaValue that has no <code>$ref</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/annotated_handlers.py</code> <pre><code>def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /) -&gt; JsonSchemaValue:\n    \"\"\"Get the real schema for a `{\"$ref\": ...}` schema.\n    If the schema given is not a `$ref` schema, it will be returned as is.\n    This means you don't have to check before calling this function.\n\n    Args:\n        maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema.\n\n    Raises:\n        LookupError: If the ref is not found.\n\n    Returns:\n        JsonSchemaValue: A JsonSchemaValue that has no `$ref`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/annotated_handlers/#pydantic.annotated_handlers.GetCoreSchemaHandler","title":"GetCoreSchemaHandler","text":"<p>Handler to call into the next CoreSchema schema generation function.</p>"},{"location":"api/annotated_handlers/#pydantic.annotated_handlers.GetCoreSchemaHandler.field_name","title":"field_name  <code>property</code>","text":"<pre><code>field_name: str | None\n</code></pre> <p>Get the name of the closest field to this validator.</p>"},{"location":"api/annotated_handlers/#pydantic.annotated_handlers.GetCoreSchemaHandler.generate_schema","title":"generate_schema","text":"<pre><code>generate_schema(source_type: Any) -&gt; CoreSchema\n</code></pre> <p>Generate a schema unrelated to the current context. Use this function if e.g. you are handling schema generation for a sequence and want to generate a schema for its items. Otherwise, you may end up doing something like applying a <code>min_length</code> constraint that was intended for the sequence itself to its items!</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>source_type</code> <code>Any</code> <p>The input type.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>CoreSchema</code> <code>CoreSchema</code> <p>The <code>pydantic-core</code> CoreSchema generated.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/annotated_handlers.py</code> <pre><code>def generate_schema(self, source_type: Any, /) -&gt; core_schema.CoreSchema:\n    \"\"\"Generate a schema unrelated to the current context.\n    Use this function if e.g. you are handling schema generation for a sequence\n    and want to generate a schema for its items.\n    Otherwise, you may end up doing something like applying a `min_length` constraint\n    that was intended for the sequence itself to its items!\n\n    Args:\n        source_type: The input type.\n\n    Returns:\n        CoreSchema: The `pydantic-core` CoreSchema generated.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/annotated_handlers/#pydantic.annotated_handlers.GetCoreSchemaHandler.resolve_ref_schema","title":"resolve_ref_schema","text":"<pre><code>resolve_ref_schema(maybe_ref_schema: CoreSchema) -&gt; CoreSchema\n</code></pre> <p>Get the real schema for a <code>definition-ref</code> schema. If the schema given is not a <code>definition-ref</code> schema, it will be returned as is. This means you don't have to check before calling this function.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>maybe_ref_schema</code> <code>CoreSchema</code> <p>A <code>CoreSchema</code>, <code>ref</code>-based or not.</p> \u5fc5\u9700 <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>LookupError</code> <p>If the <code>ref</code> is not found.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>CoreSchema</code> <p>A concrete <code>CoreSchema</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/annotated_handlers.py</code> <pre><code>def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -&gt; core_schema.CoreSchema:\n    \"\"\"Get the real schema for a `definition-ref` schema.\n    If the schema given is not a `definition-ref` schema, it will be returned as is.\n    This means you don't have to check before calling this function.\n\n    Args:\n        maybe_ref_schema: A `CoreSchema`, `ref`-based or not.\n\n    Raises:\n        LookupError: If the `ref` is not found.\n\n    Returns:\n        A concrete `CoreSchema`.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"api/base_model/","title":"BaseModel","text":"<p>Pydantic models are simply classes which inherit from <code>BaseModel</code> and define fields as annotated attributes.</p>"},{"location":"api/base_model/#pydantic.BaseModel","title":"pydantic.BaseModel","text":"<p>Usage Documentation</p> <p>Models</p> <p>A base class for creating Pydantic models.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>__class_vars__</code> <code>set[str]</code> <p>The names of the class variables defined on the model.</p> <code>__private_attributes__</code> <code>Dict[str, ModelPrivateAttr]</code> <p>Metadata about the private attributes of the model.</p> <code>__signature__</code> <code>Signature</code> <p>The synthesized <code>__init__</code> <code>Signature</code> of the model.</p> <code>__pydantic_complete__</code> <code>bool</code> <p>Whether model building is completed, or if there are still undefined fields.</p> <code>__pydantic_core_schema__</code> <code>CoreSchema</code> <p>The core schema of the model.</p> <code>__pydantic_custom_init__</code> <code>bool</code> <p>Whether the model has a custom <code>__init__</code> function.</p> <code>__pydantic_decorators__</code> <code>DecoratorInfos</code> <p>Metadata containing the decorators defined on the model. This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</p> <code>__pydantic_generic_metadata__</code> <code>PydanticGenericMetadata</code> <p>Metadata for generic models; contains data used for a similar purpose to args, origin, parameters in typing-module generics. May eventually be replaced by these.</p> <code>__pydantic_parent_namespace__</code> <code>Dict[str, Any] | None</code> <p>Parent namespace of the model, used for automatic rebuilding of models.</p> <code>__pydantic_post_init__</code> <code>None | Literal['model_post_init']</code> <p>The name of the post-init method for the model, if defined.</p> <code>__pydantic_root_model__</code> <code>bool</code> <p>Whether the model is a <code>RootModel</code>.</p> <code>__pydantic_serializer__</code> <code>SchemaSerializer</code> <p>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</p> <code>__pydantic_validator__</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</p> <code>__pydantic_fields__</code> <code>Dict[str, FieldInfo]</code> <p>A dictionary of field names and their corresponding <code>FieldInfo</code> objects.</p> <code>__pydantic_computed_fields__</code> <code>Dict[str, ComputedFieldInfo]</code> <p>A dictionary of computed field names and their corresponding <code>ComputedFieldInfo</code> objects.</p> <code>__pydantic_extra__</code> <code>Dict[str, Any] | None</code> <p>A dictionary containing extra values, if <code>extra</code> is set to <code>'allow'</code>.</p> <code>__pydantic_fields_set__</code> <code>set[str]</code> <p>The names of fields explicitly set during instantiation.</p> <code>__pydantic_private__</code> <code>Dict[str, Any] | None</code> <p>Values of private attributes set on the model instance.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>class BaseModel(metaclass=_model_construction.ModelMetaclass):\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Models](../concepts/models.md)\n\n    A base class for creating Pydantic models.\n\n    Attributes:\n        __class_vars__: The names of the class variables defined on the model.\n        __private_attributes__: Metadata about the private attributes of the model.\n        __signature__: The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\n\n        __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n        __pydantic_core_schema__: The core schema of the model.\n        __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n        __pydantic_decorators__: Metadata containing the decorators defined on the model.\n            This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n        __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n            __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n        __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n        __pydantic_post_init__: The name of the post-init method for the model, if defined.\n        __pydantic_root_model__: Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\n        __pydantic_serializer__: The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\n        __pydantic_validator__: The `pydantic-core` `SchemaValidator` used to validate instances of the model.\n\n        __pydantic_fields__: A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n        __pydantic_computed_fields__: A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\n\n        __pydantic_extra__: A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra]\n            is set to `'allow'`.\n        __pydantic_fields_set__: The names of fields explicitly set during instantiation.\n        __pydantic_private__: Values of private attributes set on the model instance.\n    \"\"\"\n\n    # Note: Many of the below class vars are defined in the metaclass, but we define them here for type checking purposes.\n\n    model_config: ClassVar[ConfigDict] = ConfigDict()\n    \"\"\"\n    Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n    \"\"\"\n\n    __class_vars__: ClassVar[set[str]]\n    \"\"\"The names of the class variables defined on the model.\"\"\"\n\n    __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]  # noqa: UP006\n    \"\"\"Metadata about the private attributes of the model.\"\"\"\n\n    __signature__: ClassVar[Signature]\n    \"\"\"The synthesized `__init__` [`Signature`][inspect.Signature] of the model.\"\"\"\n\n    __pydantic_complete__: ClassVar[bool] = False\n    \"\"\"Whether model building is completed, or if there are still undefined fields.\"\"\"\n\n    __pydantic_core_schema__: ClassVar[CoreSchema]\n    \"\"\"The core schema of the model.\"\"\"\n\n    __pydantic_custom_init__: ClassVar[bool]\n    \"\"\"Whether the model has a custom `__init__` method.\"\"\"\n\n    # Must be set for `GenerateSchema.model_schema` to work for a plain `BaseModel` annotation.\n    __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos] = _decorators.DecoratorInfos()\n    \"\"\"Metadata containing the decorators defined on the model.\n    This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\"\"\"\n\n    __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n    \"\"\"Metadata for generic models; contains data used for a similar purpose to\n    __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\"\"\"\n\n    __pydantic_parent_namespace__: ClassVar[Dict[str, Any] | None] = None  # noqa: UP006\n    \"\"\"Parent namespace of the model, used for automatic rebuilding of models.\"\"\"\n\n    __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n    \"\"\"The name of the post-init method for the model, if defined.\"\"\"\n\n    __pydantic_root_model__: ClassVar[bool] = False\n    \"\"\"Whether the model is a [`RootModel`][pydantic.root_model.RootModel].\"\"\"\n\n    __pydantic_serializer__: ClassVar[SchemaSerializer]\n    \"\"\"The `pydantic-core` `SchemaSerializer` used to dump instances of the model.\"\"\"\n\n    __pydantic_validator__: ClassVar[SchemaValidator | PluggableSchemaValidator]\n    \"\"\"The `pydantic-core` `SchemaValidator` used to validate instances of the model.\"\"\"\n\n    __pydantic_fields__: ClassVar[Dict[str, FieldInfo]]  # noqa: UP006\n    \"\"\"A dictionary of field names and their corresponding [`FieldInfo`][pydantic.fields.FieldInfo] objects.\n    This replaces `Model.__fields__` from Pydantic V1.\n    \"\"\"\n\n    __pydantic_setattr_handlers__: ClassVar[Dict[str, Callable[[BaseModel, str, Any], None]]]  # noqa: UP006\n    \"\"\"`__setattr__` handlers. Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\"\"\"\n\n    __pydantic_computed_fields__: ClassVar[Dict[str, ComputedFieldInfo]]  # noqa: UP006\n    \"\"\"A dictionary of computed field names and their corresponding [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] objects.\"\"\"\n\n    __pydantic_extra__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)  # noqa: UP006\n    \"\"\"A dictionary containing extra values, if [`extra`][pydantic.config.ConfigDict.extra] is set to `'allow'`.\"\"\"\n\n    __pydantic_fields_set__: set[str] = _model_construction.NoInitField(init=False)\n    \"\"\"The names of fields explicitly set during instantiation.\"\"\"\n\n    __pydantic_private__: Dict[str, Any] | None = _model_construction.NoInitField(init=False)  # noqa: UP006\n    \"\"\"Values of private attributes set on the model instance.\"\"\"\n\n    if not TYPE_CHECKING:\n        # Prevent `BaseModel` from being instantiated directly\n        # (defined in an `if not TYPE_CHECKING` block for clarity and to avoid type checking errors):\n        __pydantic_core_schema__ = _mock_val_ser.MockCoreSchema(\n            'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',\n            code='base-model-instantiated',\n        )\n        __pydantic_validator__ = _mock_val_ser.MockValSer(\n            'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',\n            val_or_ser='validator',\n            code='base-model-instantiated',\n        )\n        __pydantic_serializer__ = _mock_val_ser.MockValSer(\n            'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',\n            val_or_ser='serializer',\n            code='base-model-instantiated',\n        )\n\n    __slots__ = '__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__'\n\n    def __init__(self, /, **data: Any) -&gt; None:\n        \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n        Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n        validated to form a valid model.\n\n        `self` is explicitly positional-only to allow `self` as a field name.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n        if self is not validated_self:\n            warnings.warn(\n                'A custom validator is returning a value other than `self`.\\n'\n                \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n                'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n                stacklevel=2,\n            )\n\n    # The following line sets a flag that we use to determine when `__init__` gets overridden by the user\n    __init__.__pydantic_base_init__ = True  # pyright: ignore[reportFunctionMemberAccess]\n\n    @_utils.deprecated_instance_property\n    @classmethod\n    def model_fields(cls) -&gt; dict[str, FieldInfo]:\n        \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n        !!! warning\n            Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n            Instead, you should access this attribute from the model class.\n        \"\"\"\n        return getattr(cls, '__pydantic_fields__', {})\n\n    @_utils.deprecated_instance_property\n    @classmethod\n    def model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n        \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n        !!! warning\n            Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n            Instead, you should access this attribute from the model class.\n        \"\"\"\n        return getattr(cls, '__pydantic_computed_fields__', {})\n\n    @property\n    def model_extra(self) -&gt; dict[str, Any] | None:\n        \"\"\"Get extra fields set during validation.\n\n        Returns:\n            A dictionary of extra fields, or `None` if `config.extra` is not set to `\"allow\"`.\n        \"\"\"\n        return self.__pydantic_extra__\n\n    @property\n    def model_fields_set(self) -&gt; set[str]:\n        \"\"\"Returns the set of fields that have been explicitly set on this model instance.\n\n        Returns:\n            A set of strings representing the fields that have been set,\n                i.e. that were not filled from defaults.\n        \"\"\"\n        return self.__pydantic_fields_set__\n\n    @classmethod\n    def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n        \"\"\"Creates a new instance of the `Model` class with validated data.\n\n        Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n        Default values are respected, but no other validation is performed.\n\n        !!! note\n            `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n            That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n            and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n            Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n            an error if extra values are passed, but they will be ignored.\n\n        Args:\n            _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n                this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n                Otherwise, the field names from the `values` argument will be used.\n            values: Trusted or pre-validated data dictionary.\n\n        Returns:\n            A new instance of the `Model` class with validated data.\n        \"\"\"\n        m = cls.__new__(cls)\n        fields_values: dict[str, Any] = {}\n        fields_set = set()\n\n        for name, field in cls.__pydantic_fields__.items():\n            if field.alias is not None and field.alias in values:\n                fields_values[name] = values.pop(field.alias)\n                fields_set.add(name)\n\n            if (name not in fields_set) and (field.validation_alias is not None):\n                validation_aliases: list[str | AliasPath] = (\n                    field.validation_alias.choices\n                    if isinstance(field.validation_alias, AliasChoices)\n                    else [field.validation_alias]\n                )\n\n                for alias in validation_aliases:\n                    if isinstance(alias, str) and alias in values:\n                        fields_values[name] = values.pop(alias)\n                        fields_set.add(name)\n                        break\n                    elif isinstance(alias, AliasPath):\n                        value = alias.search_dict_for_path(values)\n                        if value is not PydanticUndefined:\n                            fields_values[name] = value\n                            fields_set.add(name)\n                            break\n\n            if name not in fields_set:\n                if name in values:\n                    fields_values[name] = values.pop(name)\n                    fields_set.add(name)\n                elif not field.is_required():\n                    fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n        if _fields_set is None:\n            _fields_set = fields_set\n\n        _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n        _object_setattr(m, '__dict__', fields_values)\n        _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n        if not cls.__pydantic_root_model__:\n            _object_setattr(m, '__pydantic_extra__', _extra)\n\n        if cls.__pydantic_post_init__:\n            m.model_post_init(None)\n            # update private attributes with values set\n            if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n                for k, v in values.items():\n                    if k in m.__private_attributes__:\n                        m.__pydantic_private__[k] = v\n\n        elif not cls.__pydantic_root_model__:\n            # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n            # Since it doesn't, that means that `__pydantic_private__` should be set to None\n            _object_setattr(m, '__pydantic_private__', None)\n\n        return m\n\n    def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n        \"\"\"!!! abstract \"Usage Documentation\"\n            [`model_copy`](../concepts/models.md#model-copy)\n\n        Returns a copy of the model.\n\n        !!! note\n            The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n            might have unexpected side effects if you store anything in it, on top of the model\n            fields (e.g. the value of [cached properties][functools.cached_property]).\n\n        Args:\n            update: Values to change/add in the new model. Note: the data is not validated\n                before creating the new model. You should trust this data.\n            deep: Set to `True` to make a deep copy of the model.\n\n        Returns:\n            New model instance.\n        \"\"\"\n        copied = self.__deepcopy__() if deep else self.__copy__()\n        if update:\n            if self.model_config.get('extra') == 'allow':\n                for k, v in update.items():\n                    if k in self.__pydantic_fields__:\n                        copied.__dict__[k] = v\n                    else:\n                        if copied.__pydantic_extra__ is None:\n                            copied.__pydantic_extra__ = {}\n                        copied.__pydantic_extra__[k] = v\n            else:\n                copied.__dict__.update(update)\n            copied.__pydantic_fields_set__.update(update.keys())\n        return copied\n\n    def model_dump(\n        self,\n        *,\n        mode: Literal['json', 'python'] | str = 'python',\n        include: IncEx | None = None,\n        exclude: IncEx | None = None,\n        context: Any | None = None,\n        by_alias: bool | None = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_computed_fields: bool = False,\n        round_trip: bool = False,\n        warnings: bool | Literal['none', 'warn', 'error'] = True,\n        fallback: Callable[[Any], Any] | None = None,\n        serialize_as_any: bool = False,\n    ) -&gt; dict[str, Any]:\n        \"\"\"!!! abstract \"Usage Documentation\"\n            [`model_dump`](../concepts/serialization.md#python-mode)\n\n        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n        Args:\n            mode: The mode in which `to_python` should run.\n                If mode is 'json', the output will only contain JSON serializable types.\n                If mode is 'python', the output may contain non-JSON-serializable Python objects.\n            include: A set of fields to include in the output.\n            exclude: A set of fields to exclude from the output.\n            context: Additional context to pass to the serializer.\n            by_alias: Whether to use the field's alias in the dictionary key if defined.\n            exclude_unset: Whether to exclude fields that have not been explicitly set.\n            exclude_defaults: Whether to exclude fields that are set to their default value.\n            exclude_none: Whether to exclude fields that have a value of `None`.\n            exclude_computed_fields: Whether to exclude computed fields.\n                While this can be useful for round-tripping, it is usually recommended tu use the dedicated\n                `round_trip` parameter instead.\n            round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n            warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            fallback: A function to call when an unknown value is encountered. If not provided,\n                a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n        Returns:\n            A dictionary representation of the model.\n        \"\"\"\n        return self.__pydantic_serializer__.to_python(\n            self,\n            mode=mode,\n            by_alias=by_alias,\n            include=include,\n            exclude=exclude,\n            context=context,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_computed_fields=exclude_computed_fields,\n            round_trip=round_trip,\n            warnings=warnings,\n            fallback=fallback,\n            serialize_as_any=serialize_as_any,\n        )\n\n    def model_dump_json(\n        self,\n        *,\n        indent: int | None = None,\n        ensure_ascii: bool = False,\n        include: IncEx | None = None,\n        exclude: IncEx | None = None,\n        context: Any | None = None,\n        by_alias: bool | None = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        exclude_computed_fields: bool = False,\n        round_trip: bool = False,\n        warnings: bool | Literal['none', 'warn', 'error'] = True,\n        fallback: Callable[[Any], Any] | None = None,\n        serialize_as_any: bool = False,\n    ) -&gt; str:\n        \"\"\"!!! abstract \"Usage Documentation\"\n            [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n        Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n        Args:\n            indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n            ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n                If `False` (the default), these characters will be output as-is.\n            include: Field(s) to include in the JSON output.\n            exclude: Field(s) to exclude from the JSON output.\n            context: Additional context to pass to the serializer.\n            by_alias: Whether to serialize using field aliases.\n            exclude_unset: Whether to exclude fields that have not been explicitly set.\n            exclude_defaults: Whether to exclude fields that are set to their default value.\n            exclude_none: Whether to exclude fields that have a value of `None`.\n            exclude_computed_fields: Whether to exclude computed fields.\n                While this can be useful for round-tripping, it is usually recommended to use the dedicated\n                `round_trip` parameter instead.\n            round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n            warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            fallback: A function to call when an unknown value is encountered. If not provided,\n                a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n        Returns:\n            A JSON string representation of the model.\n        \"\"\"\n        return self.__pydantic_serializer__.to_json(\n            self,\n            indent=indent,\n            ensure_ascii=ensure_ascii,\n            include=include,\n            exclude=exclude,\n            context=context,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            exclude_computed_fields=exclude_computed_fields,\n            round_trip=round_trip,\n            warnings=warnings,\n            fallback=fallback,\n            serialize_as_any=serialize_as_any,\n        ).decode()\n\n    @classmethod\n    def model_json_schema(\n        cls,\n        by_alias: bool = True,\n        ref_template: str = DEFAULT_REF_TEMPLATE,\n        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n        mode: JsonSchemaMode = 'validation',\n        *,\n        union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n    ) -&gt; dict[str, Any]:\n        \"\"\"Generates a JSON schema for a model class.\n\n        Args:\n            by_alias: Whether to use attribute aliases or not.\n            ref_template: The reference template.\n            union_format: The format to use when combining schemas from unions together. Can be one of:\n\n                - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n                keyword to combine schemas (the default).\n                - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n                keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n                type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n                `any_of`.\n            schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n                `GenerateJsonSchema` with your desired modifications\n            mode: The mode in which to generate the schema.\n\n        Returns:\n            The JSON schema for the given model class.\n        \"\"\"\n        return model_json_schema(\n            cls,\n            by_alias=by_alias,\n            ref_template=ref_template,\n            union_format=union_format,\n            schema_generator=schema_generator,\n            mode=mode,\n        )\n\n    @classmethod\n    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n        \"\"\"Compute the class name for parametrizations of generic classes.\n\n        This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n        Args:\n            params: Tuple of types of the class. Given a generic class\n                `Model` with 2 type variables and a concrete model `Model[str, int]`,\n                the value `(str, int)` would be passed to `params`.\n\n        Returns:\n            String representing the new class where `params` are passed to `cls` as type variables.\n\n        Raises:\n            TypeError: Raised when trying to generate concrete names for non-generic models.\n        \"\"\"\n        if not issubclass(cls, Generic):\n            raise TypeError('Concrete names should only be generated for generic models.')\n\n        # Any strings received should represent forward references, so we handle them specially below.\n        # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n        # we may be able to remove this special case.\n        param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n        params_component = ', '.join(param_names)\n        return f'{cls.__name__}[{params_component}]'\n\n    def model_post_init(self, context: Any, /) -&gt; None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n\n    @classmethod\n    def model_rebuild(\n        cls,\n        *,\n        force: bool = False,\n        raise_errors: bool = True,\n        _parent_namespace_depth: int = 2,\n        _types_namespace: MappingNamespace | None = None,\n    ) -&gt; bool | None:\n        \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n        the initial attempt to build the schema, and automatic rebuilding fails.\n\n        Args:\n            force: Whether to force the rebuilding of the model schema, defaults to `False`.\n            raise_errors: Whether to raise errors, defaults to `True`.\n            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n            _types_namespace: The types namespace, defaults to `None`.\n\n        Returns:\n            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n        \"\"\"\n        already_complete = cls.__pydantic_complete__\n        if already_complete and not force:\n            return None\n\n        cls.__pydantic_complete__ = False\n\n        for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n            if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n                # Deleting the validator/serializer is necessary as otherwise they can get reused in\n                # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n                # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n                # Same applies for the core schema that can be reused in schema generation.\n                delattr(cls, attr)\n\n        if _types_namespace is not None:\n            rebuild_ns = _types_namespace\n        elif _parent_namespace_depth &gt; 0:\n            rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n        else:\n            rebuild_ns = {}\n\n        parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n        ns_resolver = _namespace_utils.NsResolver(\n            parent_namespace={**rebuild_ns, **parent_ns},\n        )\n\n        return _model_construction.complete_model_class(\n            cls,\n            _config.ConfigWrapper(cls.model_config, check=False),\n            ns_resolver,\n            raise_errors=raise_errors,\n            # If the model was already complete, we don't need to call the hook again.\n            call_on_complete_hook=not already_complete,\n        )\n\n    @classmethod\n    def model_validate(\n        cls,\n        obj: Any,\n        *,\n        strict: bool | None = None,\n        extra: ExtraValues | None = None,\n        from_attributes: bool | None = None,\n        context: Any | None = None,\n        by_alias: bool | None = None,\n        by_name: bool | None = None,\n    ) -&gt; Self:\n        \"\"\"Validate a pydantic model instance.\n\n        Args:\n            obj: The object to validate.\n            strict: Whether to enforce types strictly.\n            extra: Whether to ignore, allow, or forbid extra data during model validation.\n                See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n            from_attributes: Whether to extract data from object attributes.\n            context: Additional context to pass to the validator.\n            by_alias: Whether to use the field's alias when validating against the provided input data.\n            by_name: Whether to use the field's name when validating against the provided input data.\n\n        Raises:\n            ValidationError: If the object could not be validated.\n\n        Returns:\n            The validated model instance.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n\n        if by_alias is False and by_name is not True:\n            raise PydanticUserError(\n                'At least one of `by_alias` or `by_name` must be set to True.',\n                code='validate-by-alias-and-name-false',\n            )\n\n        return cls.__pydantic_validator__.validate_python(\n            obj,\n            strict=strict,\n            extra=extra,\n            from_attributes=from_attributes,\n            context=context,\n            by_alias=by_alias,\n            by_name=by_name,\n        )\n\n    @classmethod\n    def model_validate_json(\n        cls,\n        json_data: str | bytes | bytearray,\n        *,\n        strict: bool | None = None,\n        extra: ExtraValues | None = None,\n        context: Any | None = None,\n        by_alias: bool | None = None,\n        by_name: bool | None = None,\n    ) -&gt; Self:\n        \"\"\"!!! abstract \"Usage Documentation\"\n            [JSON Parsing](../concepts/json.md#json-parsing)\n\n        Validate the given JSON data against the Pydantic model.\n\n        Args:\n            json_data: The JSON data to validate.\n            strict: Whether to enforce types strictly.\n            extra: Whether to ignore, allow, or forbid extra data during model validation.\n                See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n            context: Extra variables to pass to the validator.\n            by_alias: Whether to use the field's alias when validating against the provided input data.\n            by_name: Whether to use the field's name when validating against the provided input data.\n\n        Returns:\n            The validated Pydantic model.\n\n        Raises:\n            ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n\n        if by_alias is False and by_name is not True:\n            raise PydanticUserError(\n                'At least one of `by_alias` or `by_name` must be set to True.',\n                code='validate-by-alias-and-name-false',\n            )\n\n        return cls.__pydantic_validator__.validate_json(\n            json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n        )\n\n    @classmethod\n    def model_validate_strings(\n        cls,\n        obj: Any,\n        *,\n        strict: bool | None = None,\n        extra: ExtraValues | None = None,\n        context: Any | None = None,\n        by_alias: bool | None = None,\n        by_name: bool | None = None,\n    ) -&gt; Self:\n        \"\"\"Validate the given object with string data against the Pydantic model.\n\n        Args:\n            obj: The object containing string data to validate.\n            strict: Whether to enforce types strictly.\n            extra: Whether to ignore, allow, or forbid extra data during model validation.\n                See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n            context: Extra variables to pass to the validator.\n            by_alias: Whether to use the field's alias when validating against the provided input data.\n            by_name: Whether to use the field's name when validating against the provided input data.\n\n        Returns:\n            The validated Pydantic model.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n\n        if by_alias is False and by_name is not True:\n            raise PydanticUserError(\n                'At least one of `by_alias` or `by_name` must be set to True.',\n                code='validate-by-alias-and-name-false',\n            )\n\n        return cls.__pydantic_validator__.validate_strings(\n            obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n        )\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -&gt; CoreSchema:\n        # This warning is only emitted when calling `super().__get_pydantic_core_schema__` from a model subclass.\n        # In the generate schema logic, this method (`BaseModel.__get_pydantic_core_schema__`) is special cased to\n        # *not* be called if not overridden.\n        warnings.warn(\n            'The `__get_pydantic_core_schema__` method of the `BaseModel` class is deprecated. If you are calling '\n            '`super().__get_pydantic_core_schema__` when overriding the method on a Pydantic model, consider using '\n            '`handler(source)` instead. However, note that overriding this method on models can lead to unexpected '\n            'side effects.',\n            PydanticDeprecatedSince211,\n            stacklevel=2,\n        )\n        # Logic copied over from `GenerateSchema._model_schema`:\n        schema = cls.__dict__.get('__pydantic_core_schema__')\n        if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n            return cls.__pydantic_core_schema__\n\n        return handler(source)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        core_schema: CoreSchema,\n        handler: GetJsonSchemaHandler,\n        /,\n    ) -&gt; JsonSchemaValue:\n        \"\"\"Hook into generating the model's JSON schema.\n\n        Args:\n            core_schema: A `pydantic-core` CoreSchema.\n                You can ignore this argument and call the handler with a new CoreSchema,\n                wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n                or just call the handler with the original schema.\n            handler: Call into Pydantic's internal JSON schema generation.\n                This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n                generation fails.\n                Since this gets called by `BaseModel.model_json_schema` you can override the\n                `schema_generator` argument to that function to change JSON schema generation globally\n                for a type.\n\n        Returns:\n            A JSON schema, as a Python object.\n        \"\"\"\n        return handler(core_schema)\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs: Any) -&gt; None:\n        \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n        only after basic class initialization is complete. In particular, attributes like `model_fields` will\n        be present when this is called, but forward annotations are not guaranteed to be resolved yet,\n        meaning that creating an instance of the class may fail.\n\n        This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n        and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n        `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n        This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n        any kwargs passed to the class definition that aren't used internally by Pydantic.\n\n        Args:\n            **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n                by Pydantic.\n\n        Note:\n            You may want to override [`__pydantic_on_complete__()`][pydantic.main.BaseModel.__pydantic_on_complete__]\n            instead, which is called once the class and its fields are fully initialized and ready for validation.\n        \"\"\"\n\n    @classmethod\n    def __pydantic_on_complete__(cls) -&gt; None:\n        \"\"\"This is called once the class and its fields are fully initialized and ready to be used.\n\n        This typically happens when the class is created (just before\n        [`__pydantic_init_subclass__()`][pydantic.main.BaseModel.__pydantic_init_subclass__] is called on the superclass),\n        except when forward annotations are used that could not immediately be resolved.\n        In that case, it will be called later, when the model is rebuilt automatically or explicitly using\n        [`model_rebuild()`][pydantic.main.BaseModel.model_rebuild].\n        \"\"\"\n\n    def __class_getitem__(\n        cls, typevar_values: type[Any] | tuple[type[Any], ...]\n    ) -&gt; type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n        cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n        if cached is not None:\n            return cached\n\n        if cls is BaseModel:\n            raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n        if not hasattr(cls, '__parameters__'):\n            raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n        if not cls.__pydantic_generic_metadata__['parameters'] and Generic not in cls.__bases__:\n            raise TypeError(f'{cls} is not a generic class')\n\n        if not isinstance(typevar_values, tuple):\n            typevar_values = (typevar_values,)\n\n        # For a model `class Model[T, U, V = int](BaseModel): ...` parametrized with `(str, bool)`,\n        # this gives us `{T: str, U: bool, V: int}`:\n        typevars_map = _generics.map_generic_model_arguments(cls, typevar_values)\n        # We also update the provided args to use defaults values (`(str, bool)` becomes `(str, bool, int)`):\n        typevar_values = tuple(v for v in typevars_map.values())\n\n        if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n            submodel = cls  # if arguments are equal to parameters it's the same object\n            _generics.set_cached_generic_type(cls, typevar_values, submodel)\n        else:\n            parent_args = cls.__pydantic_generic_metadata__['args']\n            if not parent_args:\n                args = typevar_values\n            else:\n                args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n            origin = cls.__pydantic_generic_metadata__['origin'] or cls\n            model_name = origin.model_parametrized_name(args)\n            params = tuple(\n                dict.fromkeys(_generics.iter_contained_typevars(typevars_map.values()))\n            )  # use dict as ordered set\n\n            with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n                cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n                if cached is not None:\n                    return cached\n\n                if maybe_self_type is not None:\n                    return maybe_self_type\n\n                # Attempt to rebuild the origin in case new types have been defined\n                try:\n                    # depth 2 gets you above this __class_getitem__ call.\n                    # Note that we explicitly provide the parent ns, otherwise\n                    # `model_rebuild` will use the parent ns no matter if it is the ns of a module.\n                    # We don't want this here, as this has unexpected effects when a model\n                    # is being parametrized during a forward annotation evaluation.\n                    parent_ns = _typing_extra.parent_frame_namespace(parent_depth=2) or {}\n                    origin.model_rebuild(_types_namespace=parent_ns)\n                except PydanticUndefinedAnnotation:\n                    # It's okay if it fails, it just means there are still undefined types\n                    # that could be evaluated later.\n                    pass\n\n                submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n                _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n        return submodel\n\n    def __copy__(self) -&gt; Self:\n        \"\"\"Returns a shallow copy of the model.\"\"\"\n        cls = type(self)\n        m = cls.__new__(cls)\n        _object_setattr(m, '__dict__', copy(self.__dict__))\n        _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n        _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n        if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n            _object_setattr(m, '__pydantic_private__', None)\n        else:\n            _object_setattr(\n                m,\n                '__pydantic_private__',\n                {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n            )\n\n        return m\n\n    def __deepcopy__(self, memo: dict[int, Any] | None = None) -&gt; Self:\n        \"\"\"Returns a deep copy of the model.\"\"\"\n        cls = type(self)\n        m = cls.__new__(cls)\n        _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n        _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n        # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n        # and attempting a deepcopy would be marginally slower.\n        _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n        if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n            _object_setattr(m, '__pydantic_private__', None)\n        else:\n            _object_setattr(\n                m,\n                '__pydantic_private__',\n                deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n            )\n\n        return m\n\n    if not TYPE_CHECKING:\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n        # The same goes for __setattr__ and __delattr__, see: https://github.com/pydantic/pydantic/issues/8643\n\n        def __getattr__(self, item: str) -&gt; Any:\n            private_attributes = object.__getattribute__(self, '__private_attributes__')\n            if item in private_attributes:\n                attribute = private_attributes[item]\n                if hasattr(attribute, '__get__'):\n                    return attribute.__get__(self, type(self))  # type: ignore\n\n                try:\n                    # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n                    return self.__pydantic_private__[item]  # type: ignore\n                except KeyError as exc:\n                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n            else:\n                # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n                # See `BaseModel.__repr_args__` for more details\n                try:\n                    pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n                except AttributeError:\n                    pydantic_extra = None\n\n                if pydantic_extra and item in pydantic_extra:\n                    return pydantic_extra[item]\n                else:\n                    if hasattr(self.__class__, item):\n                        return super().__getattribute__(item)  # Raises AttributeError if appropriate\n                    else:\n                        # this is the current error\n                        raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n\n        def __setattr__(self, name: str, value: Any) -&gt; None:\n            if (setattr_handler := self.__pydantic_setattr_handlers__.get(name)) is not None:\n                setattr_handler(self, name, value)\n            # if None is returned from _setattr_handler, the attribute was set directly\n            elif (setattr_handler := self._setattr_handler(name, value)) is not None:\n                setattr_handler(self, name, value)  # call here to not memo on possibly unknown fields\n                self.__pydantic_setattr_handlers__[name] = setattr_handler  # memoize the handler for faster access\n\n        def _setattr_handler(self, name: str, value: Any) -&gt; Callable[[BaseModel, str, Any], None] | None:\n            \"\"\"Get a handler for setting an attribute on the model instance.\n\n            Returns:\n                A handler for setting an attribute on the model instance. Used for memoization of the handler.\n                Memoizing the handlers leads to a dramatic performance improvement in `__setattr__`\n                Returns `None` when memoization is not safe, then the attribute is set directly.\n            \"\"\"\n            cls = self.__class__\n            if name in cls.__class_vars__:\n                raise AttributeError(\n                    f'{name!r} is a ClassVar of `{cls.__name__}` and cannot be set on an instance. '\n                    f'If you want to set a value on the class, use `{cls.__name__}.{name} = value`.'\n                )\n            elif not _fields.is_valid_field_name(name):\n                if (attribute := cls.__private_attributes__.get(name)) is not None:\n                    if hasattr(attribute, '__set__'):\n                        return lambda model, _name, val: attribute.__set__(model, val)\n                    else:\n                        return _SIMPLE_SETATTR_HANDLERS['private']\n                else:\n                    _object_setattr(self, name, value)\n                    return None  # Can not return memoized handler with possibly freeform attr names\n\n            attr = getattr(cls, name, None)\n            # NOTE: We currently special case properties and `cached_property`, but we might need\n            # to generalize this to all data/non-data descriptors at some point. For non-data descriptors\n            # (such as `cached_property`), it isn't obvious though. `cached_property` caches the value\n            # to the instance's `__dict__`, but other non-data descriptors might do things differently.\n            if isinstance(attr, cached_property):\n                return _SIMPLE_SETATTR_HANDLERS['cached_property']\n\n            _check_frozen(cls, name, value)\n\n            # We allow properties to be set only on non frozen models for now (to match dataclasses).\n            # This can be changed if it ever gets requested.\n            if isinstance(attr, property):\n                return lambda model, _name, val: attr.__set__(model, val)\n            elif cls.model_config.get('validate_assignment'):\n                return _SIMPLE_SETATTR_HANDLERS['validate_assignment']\n            elif name not in cls.__pydantic_fields__:\n                if cls.model_config.get('extra') != 'allow':\n                    # TODO - matching error\n                    raise ValueError(f'\"{cls.__name__}\" object has no field \"{name}\"')\n                elif attr is None:\n                    # attribute does not exist, so put it in extra\n                    self.__pydantic_extra__[name] = value\n                    return None  # Can not return memoized handler with possibly freeform attr names\n                else:\n                    # attribute _does_ exist, and was not in extra, so update it\n                    return _SIMPLE_SETATTR_HANDLERS['extra_known']\n            else:\n                return _SIMPLE_SETATTR_HANDLERS['model_field']\n\n        def __delattr__(self, item: str) -&gt; Any:\n            cls = self.__class__\n\n            if item in self.__private_attributes__:\n                attribute = self.__private_attributes__[item]\n                if hasattr(attribute, '__delete__'):\n                    attribute.__delete__(self)  # type: ignore\n                    return\n\n                try:\n                    # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n                    del self.__pydantic_private__[item]  # type: ignore\n                    return\n                except KeyError as exc:\n                    raise AttributeError(f'{cls.__name__!r} object has no attribute {item!r}') from exc\n\n            # Allow cached properties to be deleted (even if the class is frozen):\n            attr = getattr(cls, item, None)\n            if isinstance(attr, cached_property):\n                return object.__delattr__(self, item)\n\n            _check_frozen(cls, name=item, value=None)\n\n            if item in self.__pydantic_fields__:\n                object.__delattr__(self, item)\n            elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n                del self.__pydantic_extra__[item]\n            else:\n                try:\n                    object.__delattr__(self, item)\n                except AttributeError:\n                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n\n        # Because we make use of `@dataclass_transform()`, `__replace__` is already synthesized by\n        # type checkers, so we define the implementation in this `if not TYPE_CHECKING:` block:\n        def __replace__(self, **changes: Any) -&gt; Self:\n            return self.model_copy(update=changes)\n\n    def __getstate__(self) -&gt; dict[Any, Any]:\n        private = self.__pydantic_private__\n        if private:\n            private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n        return {\n            '__dict__': self.__dict__,\n            '__pydantic_extra__': self.__pydantic_extra__,\n            '__pydantic_fields_set__': self.__pydantic_fields_set__,\n            '__pydantic_private__': private,\n        }\n\n    def __setstate__(self, state: dict[Any, Any]) -&gt; None:\n        _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n        _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n        _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n        _object_setattr(self, '__dict__', state.get('__dict__', {}))\n\n    if not TYPE_CHECKING:\n\n        def __eq__(self, other: Any) -&gt; bool:\n            if isinstance(other, BaseModel):\n                # When comparing instances of generic types for equality, as long as all field values are equal,\n                # only require their generic origin types to be equal, rather than exact type equality.\n                # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n                self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n                other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n                # Perform common checks first\n                if not (\n                    self_type == other_type\n                    and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n                    and self.__pydantic_extra__ == other.__pydantic_extra__\n                ):\n                    return False\n\n                # We only want to compare pydantic fields but ignoring fields is costly.\n                # We'll perform a fast check first, and fallback only when needed\n                # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n                # First, do the fast (and sometimes faulty) __dict__ comparison\n                if self.__dict__ == other.__dict__:\n                    # If the check above passes, then pydantic fields are equal, we can return early\n                    return True\n\n                # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n                # early if there are no keys to ignore (we would just return False later on anyway)\n                model_fields = type(self).__pydantic_fields__.keys()\n                if self.__dict__.keys() &lt;= model_fields and other.__dict__.keys() &lt;= model_fields:\n                    return False\n\n                # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n                # Resort to costly filtering of the __dict__ objects\n                # We use operator.itemgetter because it is much faster than dict comprehensions\n                # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n                # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n                # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n                # So we can use operator.itemgetter() instead of operator.attrgetter()\n                getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n                try:\n                    return getter(self.__dict__) == getter(other.__dict__)\n                except KeyError:\n                    # In rare cases (such as when using the deprecated BaseModel.copy() method),\n                    # the __dict__ may not contain all model fields, which is how we can get here.\n                    # getter(self.__dict__) is much faster than any 'safe' method that accounts\n                    # for missing keys, and wrapping it in a `try` doesn't slow things down much\n                    # in the common case.\n                    self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n                    other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n                    return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n            # other instance is not a BaseModel\n            else:\n                return NotImplemented  # delegate to the other item in the comparison\n\n    if TYPE_CHECKING:\n        # We put `__init_subclass__` in a TYPE_CHECKING block because, even though we want the type-checking benefits\n        # described in the signature of `__init_subclass__` below, we don't want to modify the default behavior of\n        # subclass initialization.\n\n        def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n            \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n            provides a way to conveniently set model_config key/value pairs.\n\n            ```python\n            from pydantic import BaseModel\n\n            class MyModel(BaseModel, extra='allow'): ...\n            ```\n\n            However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n            of the config arguments, and will only receive any keyword arguments passed during class initialization\n            that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n            Args:\n                **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n            Note:\n                You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n                *after* the class is fully initialized.\n            \"\"\"\n\n    def __iter__(self) -&gt; TupleGenerator:\n        \"\"\"So `dict(model)` works.\"\"\"\n        yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n        extra = self.__pydantic_extra__\n        if extra:\n            yield from extra.items()\n\n    def __repr__(self) -&gt; str:\n        return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n\n    def __repr_args__(self) -&gt; _repr.ReprArgs:\n        # Eagerly create the repr of computed fields, as this may trigger access of cached properties and as such\n        # modify the instance's `__dict__`. If we don't do it now, it could happen when iterating over the `__dict__`\n        # below if the instance happens to be referenced in a field, and would modify the `__dict__` size *during* iteration.\n        computed_fields_repr_args = [\n            (k, getattr(self, k)) for k, v in self.__pydantic_computed_fields__.items() if v.repr\n        ]\n\n        for k, v in self.__dict__.items():\n            field = self.__pydantic_fields__.get(k)\n            if field and field.repr:\n                if v is not self:\n                    yield k, v\n                else:\n                    yield k, self.__repr_recursion__(v)\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # This can happen if a `ValidationError` is raised during initialization and the instance's\n        # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n        # with a fallback, even though the type hints indicate the attribute will always be present.\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra is not None:\n            yield from ((k, v) for k, v in pydantic_extra.items())\n        yield from computed_fields_repr_args\n\n    # take logic from `_repr.Representation` without the side effects of inheritance, see #5740\n    __repr_name__ = _repr.Representation.__repr_name__\n    __repr_recursion__ = _repr.Representation.__repr_recursion__\n    __repr_str__ = _repr.Representation.__repr_str__\n    __pretty__ = _repr.Representation.__pretty__\n    __rich_repr__ = _repr.Representation.__rich_repr__\n\n    def __str__(self) -&gt; str:\n        return self.__repr_str__(' ')\n\n    # ##### Deprecated methods from v1 #####\n    @property\n    @typing_extensions.deprecated(\n        'The `__fields__` attribute is deprecated, use the `model_fields` class property instead.', category=None\n    )\n    def __fields__(self) -&gt; dict[str, FieldInfo]:\n        warnings.warn(\n            'The `__fields__` attribute is deprecated, use the `model_fields` class property instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return getattr(type(self), '__pydantic_fields__', {})\n\n    @property\n    @typing_extensions.deprecated(\n        'The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.',\n        category=None,\n    )\n    def __fields_set__(self) -&gt; set[str]:\n        warnings.warn(\n            'The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return self.__pydantic_fields_set__\n\n    @typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\n    def dict(  # noqa: D102\n        self,\n        *,\n        include: IncEx | None = None,\n        exclude: IncEx | None = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -&gt; Dict[str, Any]:  # noqa UP006\n        warnings.warn(\n            'The `dict` method is deprecated; use `model_dump` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return self.model_dump(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n\n    @typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\n    def json(  # noqa: D102\n        self,\n        *,\n        include: IncEx | None = None,\n        exclude: IncEx | None = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n        models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n        **dumps_kwargs: Any,\n    ) -&gt; str:\n        warnings.warn(\n            'The `json` method is deprecated; use `model_dump_json` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if encoder is not PydanticUndefined:\n            raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n        if models_as_dict is not PydanticUndefined:\n            raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n        if dumps_kwargs:\n            raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n        return self.model_dump_json(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n\n    @classmethod\n    @typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\n    def parse_obj(cls, obj: Any) -&gt; Self:  # noqa: D102\n        warnings.warn(\n            'The `parse_obj` method is deprecated; use `model_validate` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return cls.model_validate(obj)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=None,\n    )\n    def parse_raw(  # noqa: D102\n        cls,\n        b: str | bytes,\n        *,\n        content_type: str | None = None,\n        encoding: str = 'utf8',\n        proto: DeprecatedParseProtocol | None = None,\n        allow_pickle: bool = False,\n    ) -&gt; Self:  # pragma: no cover\n        warnings.warn(\n            'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n            'otherwise load the data then use `model_validate` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import parse\n\n        try:\n            obj = parse.load_str_bytes(\n                b,\n                proto=proto,\n                content_type=content_type,\n                encoding=encoding,\n                allow_pickle=allow_pickle,\n            )\n        except (ValueError, TypeError) as exc:\n            import json\n\n            # try to match V1\n            if isinstance(exc, UnicodeDecodeError):\n                type_str = 'value_error.unicodedecode'\n            elif isinstance(exc, json.JSONDecodeError):\n                type_str = 'value_error.jsondecode'\n            elif isinstance(exc, ValueError):\n                type_str = 'value_error'\n            else:\n                type_str = 'type_error'\n\n            # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n            error: pydantic_core.InitErrorDetails = {\n                # The type: ignore on the next line is to ignore the requirement of LiteralString\n                'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n                'loc': ('__root__',),\n                'input': b,\n            }\n            raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n        return cls.model_validate(obj)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=None,\n    )\n    def parse_file(  # noqa: D102\n        cls,\n        path: str | Path,\n        *,\n        content_type: str | None = None,\n        encoding: str = 'utf8',\n        proto: DeprecatedParseProtocol | None = None,\n        allow_pickle: bool = False,\n    ) -&gt; Self:\n        warnings.warn(\n            'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n            'use `model_validate_json`, otherwise `model_validate` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import parse\n\n        obj = parse.load_file(\n            path,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n        return cls.parse_obj(obj)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=None,\n    )\n    def from_orm(cls, obj: Any) -&gt; Self:  # noqa: D102\n        warnings.warn(\n            'The `from_orm` method is deprecated; set '\n            \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if not cls.model_config.get('from_attributes', None):\n            raise PydanticUserError(\n                'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n            )\n        return cls.model_validate(obj)\n\n    @classmethod\n    @typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\n    def construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: D102\n        warnings.warn(\n            'The `construct` method is deprecated; use `model_construct` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return cls.model_construct(_fields_set=_fields_set, **values)\n\n    @typing_extensions.deprecated(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=None,\n    )\n    def copy(\n        self,\n        *,\n        include: AbstractSetIntStr | MappingIntStrAny | None = None,\n        exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n        update: Dict[str, Any] | None = None,  # noqa UP006\n        deep: bool = False,\n    ) -&gt; Self:  # pragma: no cover\n        \"\"\"Returns a copy of the model.\n\n        !!! warning \"Deprecated\"\n            This method is now deprecated; use `model_copy` instead.\n\n        If you need `include` or `exclude`, use:\n\n        ```python {test=\"skip\" lint=\"skip\"}\n        data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n        data = {**data, **(update or {})}\n        copied = self.model_validate(data)\n        ```\n\n        Args:\n            include: Optional set or mapping specifying which fields to include in the copied model.\n            exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n            update: Optional dictionary of field-value pairs to override field values in the copied model.\n            deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n        Returns:\n            A copy of the model with included, excluded and updated fields as specified.\n        \"\"\"\n        warnings.warn(\n            'The `copy` method is deprecated; use `model_copy` instead. '\n            'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import copy_internals\n\n        values = dict(\n            copy_internals._iter(\n                self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n            ),\n            **(update or {}),\n        )\n        if self.__pydantic_private__ is None:\n            private = None\n        else:\n            private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n        if self.__pydantic_extra__ is None:\n            extra: dict[str, Any] | None = None\n        else:\n            extra = self.__pydantic_extra__.copy()\n            for k in list(self.__pydantic_extra__):\n                if k not in values:  # k was in the exclude\n                    extra.pop(k)\n            for k in list(values):\n                if k in self.__pydantic_extra__:  # k must have come from extra\n                    extra[k] = values.pop(k)\n\n        # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n        if update:\n            fields_set = self.__pydantic_fields_set__ | update.keys()\n        else:\n            fields_set = set(self.__pydantic_fields_set__)\n\n        # removing excluded fields from `__pydantic_fields_set__`\n        if exclude:\n            fields_set -= set(exclude)\n\n        return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n\n    @classmethod\n    @typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\n    def schema(  # noqa: D102\n        cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n    ) -&gt; Dict[str, Any]:  # noqa UP006\n        warnings.warn(\n            'The `schema` method is deprecated; use `model_json_schema` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=None,\n    )\n    def schema_json(  # noqa: D102\n        cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n    ) -&gt; str:  # pragma: no cover\n        warnings.warn(\n            'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        import json\n\n        from .deprecated.json import pydantic_encoder\n\n        return json.dumps(\n            cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n            default=pydantic_encoder,\n            **dumps_kwargs,\n        )\n\n    @classmethod\n    @typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\n    def validate(cls, value: Any) -&gt; Self:  # noqa: D102\n        warnings.warn(\n            'The `validate` method is deprecated; use `model_validate` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        return cls.model_validate(value)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=None,\n    )\n    def update_forward_refs(cls, **localns: Any) -&gt; None:  # noqa: D102\n        warnings.warn(\n            'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if localns:  # pragma: no cover\n            raise TypeError('`localns` arguments are not longer accepted.')\n        cls.model_rebuild(force=True)\n\n    @typing_extensions.deprecated(\n        'The private method `_iter` will be removed and should no longer be used.', category=None\n    )\n    def _iter(self, *args: Any, **kwargs: Any) -&gt; Any:\n        warnings.warn(\n            'The private method `_iter` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._iter(self, *args, **kwargs)\n\n    @typing_extensions.deprecated(\n        'The private method `_copy_and_set_values` will be removed and should no longer be used.',\n        category=None,\n    )\n    def _copy_and_set_values(self, *args: Any, **kwargs: Any) -&gt; Any:\n        warnings.warn(\n            'The private method `_copy_and_set_values` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._copy_and_set_values(self, *args, **kwargs)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The private method `_get_value` will be removed and should no longer be used.',\n        category=None,\n    )\n    def _get_value(cls, *args: Any, **kwargs: Any) -&gt; Any:\n        warnings.warn(\n            'The private method `_get_value` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._get_value(cls, *args, **kwargs)\n\n    @typing_extensions.deprecated(\n        'The private method `_calculate_keys` will be removed and should no longer be used.',\n        category=None,\n    )\n    def _calculate_keys(self, *args: Any, **kwargs: Any) -&gt; Any:\n        warnings.warn(\n            'The private method `_calculate_keys` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._calculate_keys(self, *args, **kwargs)\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.__init__","title":"__init__","text":"<pre><code>__init__(**data: Any) -&gt; None\n</code></pre> <p>Raises <code>ValidationError</code> if the input data cannot be validated to form a valid model.</p> <p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>def __init__(self, /, **data: Any) -&gt; None:\n    \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n    validated_self = self.__pydantic_validator__.validate_python(data, self_instance=self)\n    if self is not validated_self:\n        warnings.warn(\n            'A custom validator is returning a value other than `self`.\\n'\n            \"Returning anything other than `self` from a top level model validator isn't supported when validating via `__init__`.\\n\"\n            'See the `model_validator` docs (https://docs.pydantic.dev/latest/concepts/validators/#model-validators) for more details.',\n            stacklevel=2,\n        )\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_config","title":"model_config  <code>class-attribute</code>","text":"<pre><code>model_config: ConfigDict = ConfigDict()\n</code></pre> <p>Configuration for the model, should be a dictionary conforming to <code>ConfigDict</code>.</p>"},{"location":"api/base_model/#pydantic.BaseModel.model_fields","title":"model_fields  <code>classmethod</code>","text":"<pre><code>model_fields() -&gt; dict[str, FieldInfo]\n</code></pre> <p>A mapping of field names to their respective <code>FieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_fields(cls) -&gt; dict[str, FieldInfo]:\n    \"\"\"A mapping of field names to their respective [`FieldInfo`][pydantic.fields.FieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_fields__', {})\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_computed_fields","title":"model_computed_fields  <code>classmethod</code>","text":"<pre><code>model_computed_fields() -&gt; dict[str, ComputedFieldInfo]\n</code></pre> <p>A mapping of computed field names to their respective <code>ComputedFieldInfo</code> instances.</p> <p>Warning</p> <p>Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3. Instead, you should access this attribute from the model class.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@_utils.deprecated_instance_property\n@classmethod\ndef model_computed_fields(cls) -&gt; dict[str, ComputedFieldInfo]:\n    \"\"\"A mapping of computed field names to their respective [`ComputedFieldInfo`][pydantic.fields.ComputedFieldInfo] instances.\n\n    !!! warning\n        Accessing this attribute from a model instance is deprecated, and will not work in Pydantic V3.\n        Instead, you should access this attribute from the model class.\n    \"\"\"\n    return getattr(cls, '__pydantic_computed_fields__', {})\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.__pydantic_core_schema__","title":"__pydantic_core_schema__  <code>class-attribute</code>","text":"<pre><code>__pydantic_core_schema__: CoreSchema\n</code></pre> <p>The core schema of the model.</p>"},{"location":"api/base_model/#pydantic.BaseModel.model_extra","title":"model_extra  <code>property</code>","text":"<pre><code>model_extra: dict[str, Any] | None\n</code></pre> <p>Get extra fields set during validation.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any] | None</code> <p>A dictionary of extra fields, or <code>None</code> if <code>config.extra</code> is not set to <code>\"allow\"</code>.</p>"},{"location":"api/base_model/#pydantic.BaseModel.model_fields_set","title":"model_fields_set  <code>property</code>","text":"<pre><code>model_fields_set: set[str]\n</code></pre> <p>Returns the set of fields that have been explicitly set on this model instance.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>set[str]</code> <p>A set of strings representing the fields that have been set, i.e. that were not filled from defaults.</p>"},{"location":"api/base_model/#pydantic.BaseModel.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(_fields_set: set[str] | None = None, **values: Any) -&gt; Self\n</code></pre> <p>Creates a new instance of the <code>Model</code> class with validated data.</p> <p>Creates a new model setting <code>__dict__</code> and <code>__pydantic_fields_set__</code> from trusted or pre-validated data. Default values are respected, but no other validation is performed.</p> <p>Note</p> <p><code>model_construct()</code> generally respects the <code>model_config.extra</code> setting on the provided model. That is, if <code>model_config.extra == 'allow'</code>, then all extra passed values are added to the model instance's <code>__dict__</code> and <code>__pydantic_extra__</code> fields. If <code>model_config.extra == 'ignore'</code> (the default), then all extra passed values are ignored. Because no validation is performed with a call to <code>model_construct()</code>, having <code>model_config.extra == 'forbid'</code> does not result in an error if extra values are passed, but they will be ignored.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>_fields_set</code> <code>set[str] | None</code> <p>A set of field names that were originally explicitly set during instantiation. If provided, this is directly used for the <code>model_fields_set</code> attribute. Otherwise, the field names from the <code>values</code> argument will be used.</p> <code>None</code> <code>values</code> <code>Any</code> <p>Trusted or pre-validated data dictionary.</p> <code>{}</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>A new instance of the <code>Model</code> class with validated data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -&gt; Self:  # noqa: C901\n    \"\"\"Creates a new instance of the `Model` class with validated data.\n\n    Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n    Default values are respected, but no other validation is performed.\n\n    !!! note\n        `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n        That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n        and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n        Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n        an error if extra values are passed, but they will be ignored.\n\n    Args:\n        _fields_set: A set of field names that were originally explicitly set during instantiation. If provided,\n            this is directly used for the [`model_fields_set`][pydantic.BaseModel.model_fields_set] attribute.\n            Otherwise, the field names from the `values` argument will be used.\n        values: Trusted or pre-validated data dictionary.\n\n    Returns:\n        A new instance of the `Model` class with validated data.\n    \"\"\"\n    m = cls.__new__(cls)\n    fields_values: dict[str, Any] = {}\n    fields_set = set()\n\n    for name, field in cls.__pydantic_fields__.items():\n        if field.alias is not None and field.alias in values:\n            fields_values[name] = values.pop(field.alias)\n            fields_set.add(name)\n\n        if (name not in fields_set) and (field.validation_alias is not None):\n            validation_aliases: list[str | AliasPath] = (\n                field.validation_alias.choices\n                if isinstance(field.validation_alias, AliasChoices)\n                else [field.validation_alias]\n            )\n\n            for alias in validation_aliases:\n                if isinstance(alias, str) and alias in values:\n                    fields_values[name] = values.pop(alias)\n                    fields_set.add(name)\n                    break\n                elif isinstance(alias, AliasPath):\n                    value = alias.search_dict_for_path(values)\n                    if value is not PydanticUndefined:\n                        fields_values[name] = value\n                        fields_set.add(name)\n                        break\n\n        if name not in fields_set:\n            if name in values:\n                fields_values[name] = values.pop(name)\n                fields_set.add(name)\n            elif not field.is_required():\n                fields_values[name] = field.get_default(call_default_factory=True, validated_data=fields_values)\n    if _fields_set is None:\n        _fields_set = fields_set\n\n    _extra: dict[str, Any] | None = values if cls.model_config.get('extra') == 'allow' else None\n    _object_setattr(m, '__dict__', fields_values)\n    _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n    if not cls.__pydantic_root_model__:\n        _object_setattr(m, '__pydantic_extra__', _extra)\n\n    if cls.__pydantic_post_init__:\n        m.model_post_init(None)\n        # update private attributes with values set\n        if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n            for k, v in values.items():\n                if k in m.__private_attributes__:\n                    m.__pydantic_private__[k] = v\n\n    elif not cls.__pydantic_root_model__:\n        # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n        # Since it doesn't, that means that `__pydantic_private__` should be set to None\n        _object_setattr(m, '__pydantic_private__', None)\n\n    return m\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_copy","title":"model_copy","text":"<pre><code>model_copy(*, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p><code>model_copy</code></p> <p>Returns a copy of the model.</p> <p>Note</p> <p>The underlying instance's <code>__dict__</code> attribute is copied. This might have unexpected side effects if you store anything in it, on top of the model fields (e.g. the value of cached properties).</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>update</code> <code>Mapping[str, Any] | None</code> <p>Values to change/add in the new model. Note: the data is not validated before creating the new model. You should trust this data.</p> <code>None</code> <code>deep</code> <code>bool</code> <p>Set to <code>True</code> to make a deep copy of the model.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>New model instance.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>def model_copy(self, *, update: Mapping[str, Any] | None = None, deep: bool = False) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_copy`](../concepts/models.md#model-copy)\n\n    Returns a copy of the model.\n\n    !!! note\n        The underlying instance's [`__dict__`][object.__dict__] attribute is copied. This\n        might have unexpected side effects if you store anything in it, on top of the model\n        fields (e.g. the value of [cached properties][functools.cached_property]).\n\n    Args:\n        update: Values to change/add in the new model. Note: the data is not validated\n            before creating the new model. You should trust this data.\n        deep: Set to `True` to make a deep copy of the model.\n\n    Returns:\n        New model instance.\n    \"\"\"\n    copied = self.__deepcopy__() if deep else self.__copy__()\n    if update:\n        if self.model_config.get('extra') == 'allow':\n            for k, v in update.items():\n                if k in self.__pydantic_fields__:\n                    copied.__dict__[k] = v\n                else:\n                    if copied.__pydantic_extra__ is None:\n                        copied.__pydantic_extra__ = {}\n                    copied.__pydantic_extra__[k] = v\n        else:\n            copied.__dict__.update(update)\n        copied.__pydantic_fields_set__.update(update.keys())\n    return copied\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; dict[str, Any]\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump</code></p> <p>Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>mode</code> <code>Literal['json', 'python'] | str</code> <p>The mode in which <code>to_python</code> should run. If mode is 'json', the output will only contain JSON serializable types. If mode is 'python', the output may contain non-JSON-serializable Python objects.</p> <code>'python'</code> <code>include</code> <code>IncEx | None</code> <p>A set of fields to include in the output.</p> <code>None</code> <code>exclude</code> <code>IncEx | None</code> <p>A set of fields to exclude from the output.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias in the dictionary key if defined.</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>exclude_defaults</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>exclude_computed_fields</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended tu use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>warnings</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any]</code> <p>A dictionary representation of the model.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>def model_dump(\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; dict[str, Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump`](../concepts/serialization.md#python-mode)\n\n    Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n    Args:\n        mode: The mode in which `to_python` should run.\n            If mode is 'json', the output will only contain JSON serializable types.\n            If mode is 'python', the output may contain non-JSON-serializable Python objects.\n        include: A set of fields to include in the output.\n        exclude: A set of fields to exclude from the output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to use the field's alias in the dictionary key if defined.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended tu use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A dictionary representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_python(\n        self,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        context=context,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    )\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_dump_json","title":"model_dump_json","text":"<pre><code>model_dump_json(*, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, context: Any | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False) -&gt; str\n</code></pre> <p>Usage Documentation</p> <p><code>model_dump_json</code></p> <p>Generates a JSON representation of the model using Pydantic's <code>to_json</code> method.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>indent</code> <code>int | None</code> <p>Indentation to use in the JSON output. If None is passed, the output will be compact.</p> <code>None</code> <code>ensure_ascii</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>include</code> <code>IncEx | None</code> <p>Field(s) to include in the JSON output.</p> <code>None</code> <code>exclude</code> <code>IncEx | None</code> <p>Field(s) to exclude from the JSON output.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to serialize using field aliases.</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude fields that have not been explicitly set.</p> <code>False</code> <code>exclude_defaults</code> <code>bool</code> <p>Whether to exclude fields that are set to their default value.</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>exclude_computed_fields</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>If True, dumped values should be valid as input for non-idempotent types such as Json[T].</p> <code>False</code> <code>warnings</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>A JSON string representation of the model.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>def model_dump_json(\n    self,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n) -&gt; str:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`model_dump_json`](../concepts/serialization.md#json-mode)\n\n    Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n    Args:\n        indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Field(s) to include in the JSON output.\n        exclude: Field(s) to exclude from the JSON output.\n        context: Additional context to pass to the serializer.\n        by_alias: Whether to serialize using field aliases.\n        exclude_unset: Whether to exclude fields that have not been explicitly set.\n        exclude_defaults: Whether to exclude fields that are set to their default value.\n        exclude_none: Whether to exclude fields that have a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n    Returns:\n        A JSON string representation of the model.\n    \"\"\"\n    return self.__pydantic_serializer__.to_json(\n        self,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        context=context,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n    ).decode()\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_json_schema","title":"model_json_schema  <code>classmethod</code>","text":"<pre><code>model_json_schema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation', *, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of') -&gt; dict[str, Any]\n</code></pre> <p>Generates a JSON schema for a model class.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>by_alias</code> <code>bool</code> <p>Whether to use attribute aliases or not.</p> <code>True</code> <code>ref_template</code> <code>str</code> <p>The reference template.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>union_format</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>schema_generator</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>mode</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any]</code> <p>The JSON schema for the given model class.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_json_schema(\n    cls,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n    *,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; dict[str, Any]:\n    \"\"\"Generates a JSON schema for a model class.\n\n    Args:\n        by_alias: Whether to use attribute aliases or not.\n        ref_template: The reference template.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n\n    Returns:\n        The JSON schema for the given model class.\n    \"\"\"\n    return model_json_schema(\n        cls,\n        by_alias=by_alias,\n        ref_template=ref_template,\n        union_format=union_format,\n        schema_generator=schema_generator,\n        mode=mode,\n    )\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_parametrized_name","title":"model_parametrized_name  <code>classmethod</code>","text":"<pre><code>model_parametrized_name(params: tuple[type[Any], ...]) -&gt; str\n</code></pre> <p>Compute the class name for parametrizations of generic classes.</p> <p>This method can be overridden to achieve a custom naming scheme for generic BaseModels.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>params</code> <code>tuple[type[Any], ...]</code> <p>Tuple of types of the class. Given a generic class <code>Model</code> with 2 type variables and a concrete model <code>Model[str, int]</code>, the value <code>(str, int)</code> would be passed to <code>params</code>.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>String representing the new class where <code>params</code> are passed to <code>cls</code> as type variables.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>TypeError</code> <p>Raised when trying to generate concrete names for non-generic models.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n    \"\"\"Compute the class name for parametrizations of generic classes.\n\n    This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n    Args:\n        params: Tuple of types of the class. Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n\n    Returns:\n        String representing the new class where `params` are passed to `cls` as type variables.\n\n    Raises:\n        TypeError: Raised when trying to generate concrete names for non-generic models.\n    \"\"\"\n    if not issubclass(cls, Generic):\n        raise TypeError('Concrete names should only be generated for generic models.')\n\n    # Any strings received should represent forward references, so we handle them specially below.\n    # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n    # we may be able to remove this special case.\n    param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n    params_component = ', '.join(param_names)\n    return f'{cls.__name__}[{params_component}]'\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_post_init","title":"model_post_init","text":"<pre><code>model_post_init(context: Any) -&gt; None\n</code></pre> <p>Override this method to perform additional initialization after <code>__init__</code> and <code>model_construct</code>. This is useful if you want to do some validation that requires the entire model to be initialized.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>def model_post_init(self, context: Any, /) -&gt; None:\n    \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n    This is useful if you want to do some validation that requires the entire model to be initialized.\n    \"\"\"\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_rebuild","title":"model_rebuild  <code>classmethod</code>","text":"<pre><code>model_rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the model.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>force</code> <code>bool</code> <p>Whether to force the rebuilding of the model schema, defaults to <code>False</code>.</p> <code>False</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>_parent_namespace_depth</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>_types_namespace</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.</p> <code>bool | None</code> <p>If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_rebuild(\n    cls,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the model schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    already_complete = cls.__pydantic_complete__\n    if already_complete and not force:\n        return None\n\n    cls.__pydantic_complete__ = False\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__ and not isinstance(getattr(cls, attr), _mock_val_ser.MockValSer):\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. We do so only if they aren't mock instances, otherwise \u2014 as `model_rebuild()`\n            # isn't thread-safe \u2014 concurrent model instantiations can lead to the parent validator being used.\n            # Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    parent_ns = _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace={**rebuild_ns, **parent_ns},\n    )\n\n    return _model_construction.complete_model_class(\n        cls,\n        _config.ConfigWrapper(cls.model_config, check=False),\n        ns_resolver,\n        raise_errors=raise_errors,\n        # If the model was already complete, we don't need to call the hook again.\n        call_on_complete_hook=not already_complete,\n    )\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_validate","title":"model_validate  <code>classmethod</code>","text":"<pre><code>model_validate(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate a pydantic model instance.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>obj</code> <code>Any</code> <p>The object to validate.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>extra</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the <code>extra</code> configuration value for details.</p> <code>None</code> <code>from_attributes</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If the object could not be validated.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>The validated model instance.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate a pydantic model instance.\n\n    Args:\n        obj: The object to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Raises:\n        ValidationError: If the object could not be validated.\n\n    Returns:\n        The validated model instance.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_python(\n        obj,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_validate_json","title":"model_validate_json  <code>classmethod</code>","text":"<pre><code>model_validate_json(json_data: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate the given JSON data against the Pydantic model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>json_data</code> <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>extra</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the <code>extra</code> configuration value for details.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>The validated Pydantic model.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If <code>json_data</code> is not a JSON string or the object could not be validated.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_json(\n    cls,\n    json_data: str | bytes | bytearray,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate the given JSON data against the Pydantic model.\n\n    Args:\n        json_data: The JSON data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n\n    Raises:\n        ValidationError: If `json_data` is not a JSON string or the object could not be validated.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_json(\n        json_data, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/base_model/#pydantic.BaseModel.model_validate_strings","title":"model_validate_strings  <code>classmethod</code>","text":"<pre><code>model_validate_strings(obj: Any, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Self\n</code></pre> <p>Validate the given object with string data against the Pydantic model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>obj</code> <code>Any</code> <p>The object containing string data to validate.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to enforce types strictly.</p> <code>None</code> <code>extra</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the <code>extra</code> configuration value for details.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Extra variables to pass to the validator.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>The validated Pydantic model.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>@classmethod\ndef model_validate_strings(\n    cls,\n    obj: Any,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; Self:\n    \"\"\"Validate the given object with string data against the Pydantic model.\n\n    Args:\n        obj: The object containing string data to validate.\n        strict: Whether to enforce types strictly.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Extra variables to pass to the validator.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated Pydantic model.\n    \"\"\"\n    # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n    __tracebackhide__ = True\n\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return cls.__pydantic_validator__.validate_strings(\n        obj, strict=strict, extra=extra, context=context, by_alias=by_alias, by_name=by_name\n    )\n</code></pre>"},{"location":"api/base_model/#pydantic.create_model","title":"pydantic.create_model","text":"<pre><code>create_model(model_name: str, /, *, __config__: ConfigDict | None = None, __doc__: str | None = None, __base__: None = None, __module__: str = __name__, __validators__: dict[str, Callable[..., Any]] | None = None, __cls_kwargs__: dict[str, Any] | None = None, __qualname__: str | None = None, **field_definitions: Any | tuple[str, Any]) -&gt; type[BaseModel]\n</code></pre><pre><code>create_model(model_name: str, /, *, __config__: ConfigDict | None = None, __doc__: str | None = None, __base__: type[ModelT] | tuple[type[ModelT], ...], __module__: str = __name__, __validators__: dict[str, Callable[..., Any]] | None = None, __cls_kwargs__: dict[str, Any] | None = None, __qualname__: str | None = None, **field_definitions: Any | tuple[str, Any]) -&gt; type[ModelT]\n</code></pre> <pre><code>create_model(model_name: str, /, *, __config__: ConfigDict | None = None, __doc__: str | None = None, __base__: type[ModelT] | tuple[type[ModelT], ...] | None = None, __module__: str | None = None, __validators__: dict[str, Callable[..., Any]] | None = None, __cls_kwargs__: dict[str, Any] | None = None, __qualname__: str | None = None, **field_definitions: Any | tuple[str, Any]) -&gt; type[ModelT]\n</code></pre> <p>Usage Documentation</p> <p>Dynamic Model Creation</p> <p>Dynamically creates and returns a new Pydantic model, in other words, <code>create_model</code> dynamically creates a subclass of <code>BaseModel</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>model_name</code> <code>str</code> <p>The name of the newly created model.</p> \u5fc5\u9700 <code>__config__</code> <code>ConfigDict | None</code> <p>The configuration of the new model.</p> <code>None</code> <code>__doc__</code> <code>str | None</code> <p>The docstring of the new model.</p> <code>None</code> <code>__base__</code> <code>type[ModelT] | tuple[type[ModelT], ...] | None</code> <p>The base class or classes for the new model.</p> <code>None</code> <code>__module__</code> <code>str | None</code> <p>The name of the module that the model belongs to; if <code>None</code>, the value is taken from <code>sys._getframe(1)</code></p> <code>None</code> <code>__validators__</code> <code>dict[str, Callable[..., Any]] | None</code> <p>A dictionary of methods that validate fields. The keys are the names of the validation methods to be added to the model, and the values are the validation methods themselves. You can read more about functional validators here.</p> <code>None</code> <code>__cls_kwargs__</code> <code>dict[str, Any] | None</code> <p>A dictionary of keyword arguments for class creation, such as <code>metaclass</code>.</p> <code>None</code> <code>__qualname__</code> <code>str | None</code> <p>The qualified name of the newly created model.</p> <code>None</code> <code>**field_definitions</code> <code>Any | tuple[str, Any]</code> <p>Field definitions of the new model. Either:</p> <ul> <li>a single element, representing the type annotation of the field.</li> <li>a two-tuple, the first element being the type and the second element the assigned value   (either a default or the <code>Field()</code> function).</li> </ul> <code>{}</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[ModelT]</code> <p>The new model.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticUserError</code> <p>If <code>__base__</code> and <code>__config__</code> are both passed.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/main.py</code> <pre><code>def create_model(  # noqa: C901\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: type[ModelT] | tuple[type[ModelT], ...] | None = None,\n    __module__: str | None = None,\n    __validators__: dict[str, Callable[..., Any]] | None = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    __qualname__: str | None = None,\n    # TODO PEP 747: replace `Any` by the TypeForm:\n    **field_definitions: Any | tuple[str, Any],\n) -&gt; type[ModelT]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Dynamic Model Creation](../concepts/models.md#dynamic-model-creation)\n\n    Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a\n    subclass of [`BaseModel`][pydantic.BaseModel].\n\n    Args:\n        model_name: The name of the newly created model.\n        __config__: The configuration of the new model.\n        __doc__: The docstring of the new model.\n        __base__: The base class or classes for the new model.\n        __module__: The name of the module that the model belongs to;\n            if `None`, the value is taken from `sys._getframe(1)`\n        __validators__: A dictionary of methods that validate fields. The keys are the names of the validation methods to\n            be added to the model, and the values are the validation methods themselves. You can read more about functional\n            validators [here](https://docs.pydantic.dev/2.9/concepts/validators/#field-validators).\n        __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.\n        __qualname__: The qualified name of the newly created model.\n        **field_definitions: Field definitions of the new model. Either:\n\n            - a single element, representing the type annotation of the field.\n            - a two-tuple, the first element being the type and the second element the assigned value\n              (either a default or the [`Field()`][pydantic.Field] function).\n\n    Returns:\n        The new [model][pydantic.BaseModel].\n\n    Raises:\n        PydanticUserError: If `__base__` and `__config__` are both passed.\n    \"\"\"\n    if __base__ is None:\n        __base__ = (cast('type[ModelT]', BaseModel),)\n    elif not isinstance(__base__, tuple):\n        __base__ = (__base__,)\n\n    __cls_kwargs__ = __cls_kwargs__ or {}\n\n    fields: dict[str, Any] = {}\n    annotations: dict[str, Any] = {}\n\n    for f_name, f_def in field_definitions.items():\n        if isinstance(f_def, tuple):\n            if len(f_def) != 2:\n                raise PydanticUserError(\n                    f'Field definition for {f_name!r} should a single element representing the type or a two-tuple, the first element '\n                    'being the type and the second element the assigned value (either a default or the `Field()` function).',\n                    code='create-model-field-definitions',\n                )\n\n            annotations[f_name] = f_def[0]\n            fields[f_name] = f_def[1]\n        else:\n            annotations[f_name] = f_def\n\n    if __module__ is None:\n        f = sys._getframe(1)\n        __module__ = f.f_globals['__name__']\n\n    namespace: dict[str, Any] = {'__annotations__': annotations, '__module__': __module__}\n    if __doc__:\n        namespace['__doc__'] = __doc__\n    if __qualname__ is not None:\n        namespace['__qualname__'] = __qualname__\n    if __validators__:\n        namespace.update(__validators__)\n    namespace.update(fields)\n    if __config__:\n        namespace['model_config'] = __config__\n    resolved_bases = types.resolve_bases(__base__)\n    meta, ns, kwds = types.prepare_class(model_name, resolved_bases, kwds=__cls_kwargs__)\n    if resolved_bases is not __base__:\n        ns['__orig_bases__'] = __base__\n    namespace.update(ns)\n\n    return meta(\n        model_name,\n        resolved_bases,\n        namespace,\n        __pydantic_reset_parent_namespace__=False,\n        _create_model_module=__module__,\n        **kwds,\n    )\n</code></pre>"},{"location":"api/config/","title":"Configuration","text":"<p>Configuration for Pydantic models.</p>"},{"location":"api/config/#pydantic.config.ConfigDict","title":"ConfigDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>A TypedDict for configuring Pydantic behaviour.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.title","title":"title  <code>instance-attribute</code>","text":"<pre><code>title: str | None\n</code></pre> <p>The title for the generated JSON schema, defaults to the model's name</p>"},{"location":"api/config/#pydantic.config.ConfigDict.model_title_generator","title":"model_title_generator  <code>instance-attribute</code>","text":"<pre><code>model_title_generator: Callable[[type], str] | None\n</code></pre> <p>A callable that takes a model class and returns the title for it. Defaults to <code>None</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.field_title_generator","title":"field_title_generator  <code>instance-attribute</code>","text":"<pre><code>field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None\n</code></pre> <p>A callable that takes a field's name and info and returns title for it. Defaults to <code>None</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.str_to_lower","title":"str_to_lower  <code>instance-attribute</code>","text":"<pre><code>str_to_lower: bool\n</code></pre> <p>Whether to convert all characters to lowercase for str types. Defaults to <code>False</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.str_to_upper","title":"str_to_upper  <code>instance-attribute</code>","text":"<pre><code>str_to_upper: bool\n</code></pre> <p>Whether to convert all characters to uppercase for str types. Defaults to <code>False</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.str_strip_whitespace","title":"str_strip_whitespace  <code>instance-attribute</code>","text":"<pre><code>str_strip_whitespace: bool\n</code></pre> <p>Whether to strip leading and trailing whitespace for str types.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.str_min_length","title":"str_min_length  <code>instance-attribute</code>","text":"<pre><code>str_min_length: int\n</code></pre> <p>The minimum length for str types. Defaults to <code>None</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.str_max_length","title":"str_max_length  <code>instance-attribute</code>","text":"<pre><code>str_max_length: int | None\n</code></pre> <p>The maximum length for str types. Defaults to <code>None</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.extra","title":"extra  <code>instance-attribute</code>","text":"<pre><code>extra: ExtraValues | None\n</code></pre> <p>Whether to ignore, allow, or forbid extra data during model initialization. Defaults to <code>'ignore'</code>.</p> <p>Three configuration values are available:</p> <ul> <li> <p><code>'ignore'</code>: Providing extra data is ignored (the default):   <pre><code>from pydantic import BaseModel, ConfigDict\n\nclass User(BaseModel):\n    model_config = ConfigDict(extra='ignore')  # (1)!\n\n    name: str\n\nuser = User(name='John Doe', age=20)  # (2)!\nprint(user)\n#&gt; name='John Doe'\n</code></pre></p> <ol> <li>This is the default behaviour.</li> <li>The <code>age</code> argument is ignored.</li> </ol> </li> <li> <p><code>'forbid'</code>: Providing extra data is not permitted, and a <code>ValidationError</code>   will be raised if this is the case:   <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='forbid')\n\n\ntry:\n    Model(x=1, y='a')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    y\n      Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]\n    \"\"\"\n</code></pre></p> </li> <li> <p><code>'allow'</code>: Providing extra data is allowed and stored in the <code>__pydantic_extra__</code> dictionary attribute:   <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\nm = Model(x=1, y='a')\nassert m.__pydantic_extra__ == {'y': 'a'}\n</code></pre>   By default, no validation will be applied to these extra items, but you can set a type for the values by overriding   the type annotation for <code>__pydantic_extra__</code>:   <pre><code>from pydantic import BaseModel, ConfigDict, Field, ValidationError\n\n\nclass Model(BaseModel):\n    __pydantic_extra__: dict[str, int] = Field(init=False)  # (1)!\n\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\ntry:\n    Model(x=1, y='a')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    y\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\nm = Model(x=1, y='2')\nassert m.x == 1\nassert m.y == 2\nassert m.model_dump() == {'x': 1, 'y': 2}\nassert m.__pydantic_extra__ == {'y': 2}\n</code></pre></p> <ol> <li>The <code>= Field(init=False)</code> does not have any effect at runtime, but prevents the <code>__pydantic_extra__</code> field from    being included as a parameter to the model's <code>__init__</code> method by type checkers.</li> </ol> </li> </ul> <p>As well as specifying an <code>extra</code> configuration value on the model, you can also provide it as an argument to the validation methods. This will override any <code>extra</code> configuration value set on the model: <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\nclass Model(BaseModel):\n    x: int\n    model_config = ConfigDict(extra=\"allow\")\n\ntry:\n    # Override model config and forbid extra fields just this time\n    Model.model_validate({\"x\": 1, \"y\": 2}, extra=\"forbid\")\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    y\n      Extra inputs are not permitted [type=extra_forbidden, input_value=2, input_type=int]\n    \"\"\"\n</code></pre></p>"},{"location":"api/config/#pydantic.config.ConfigDict.frozen","title":"frozen  <code>instance-attribute</code>","text":"<pre><code>frozen: bool\n</code></pre> <p>Whether models are faux-immutable, i.e. whether <code>__setattr__</code> is allowed, and also generates a <code>__hash__()</code> method for the model. This makes instances of the model potentially hashable if all the attributes are hashable. Defaults to <code>False</code>.</p> Note <p>On V1, the inverse of this setting was called <code>allow_mutation</code>, and was <code>True</code> by default.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.populate_by_name","title":"populate_by_name  <code>instance-attribute</code>","text":"<pre><code>populate_by_name: bool\n</code></pre> <p>Whether an aliased field may be populated by its name as given by the model attribute, as well as the alias. Defaults to <code>False</code>.</p> <p>Warning</p> <p><code>populate_by_name</code> usage is not recommended in v2.11+ and will be deprecated in v3. Instead, you should use the <code>validate_by_name</code> configuration setting.</p> <p>When <code>validate_by_name=True</code> and <code>validate_by_alias=True</code>, this is strictly equivalent to the previous behavior of <code>populate_by_name=True</code>.</p> <p>In v2.11, we also introduced a <code>validate_by_alias</code> setting that introduces more fine grained control for validation behavior.</p> <p>Here's how you might go about using the new settings to achieve the same behavior:</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n    my_field: str = Field(alias='my_alias')  # (1)!\n\nm = Model(my_alias='foo')  # (2)!\nprint(m)\n#&gt; my_field='foo'\n\nm = Model(my_field='foo')  # (3)!\nprint(m)\n#&gt; my_field='foo'\n</code></pre> <ol> <li>The field <code>'my_field'</code> has an alias <code>'my_alias'</code>.</li> <li>The model is populated by the alias <code>'my_alias'</code>.</li> <li>The model is populated by the attribute name <code>'my_field'</code>.</li> </ol>"},{"location":"api/config/#pydantic.config.ConfigDict.use_enum_values","title":"use_enum_values  <code>instance-attribute</code>","text":"<pre><code>use_enum_values: bool\n</code></pre> <p>Whether to populate models with the <code>value</code> property of enums, rather than the raw enum. This may be useful if you want to serialize <code>model.model_dump()</code> later. Defaults to <code>False</code>.</p> <p>Note</p> <p>If you have an <code>Optional[Enum]</code> value that you set a default for, you need to use <code>validate_default=True</code> for said Field to ensure that the <code>use_enum_values</code> flag takes effect on the default, as extracting an enum's value occurs during validation, not serialization.</p> <pre><code>from enum import Enum\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\nclass SomeEnum(Enum):\n    FOO = 'foo'\n    BAR = 'bar'\n    BAZ = 'baz'\n\nclass SomeModel(BaseModel):\n    model_config = ConfigDict(use_enum_values=True)\n\n    some_enum: SomeEnum\n    another_enum: Optional[SomeEnum] = Field(\n        default=SomeEnum.FOO, validate_default=True\n    )\n\nmodel1 = SomeModel(some_enum=SomeEnum.BAR)\nprint(model1.model_dump())\n#&gt; {'some_enum': 'bar', 'another_enum': 'foo'}\n\nmodel2 = SomeModel(some_enum=SomeEnum.BAR, another_enum=SomeEnum.BAZ)\nprint(model2.model_dump())\n#&gt; {'some_enum': 'bar', 'another_enum': 'baz'}\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.validate_assignment","title":"validate_assignment  <code>instance-attribute</code>","text":"<pre><code>validate_assignment: bool\n</code></pre> <p>Whether to validate the data when the model is changed. Defaults to <code>False</code>.</p> <p>The default behavior of Pydantic is to validate the data when the model is created.</p> <p>In case the user changes the data after the model is created, the model is not revalidated.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel):\n    name: str\n\nuser = User(name='John Doe')  # (1)!\nprint(user)\n#&gt; name='John Doe'\nuser.name = 123  # (1)!\nprint(user)\n#&gt; name=123\n</code></pre> <ol> <li>The validation happens only when the model is created.</li> <li>The validation does not happen when the data is changed.</li> </ol> <p>In case you want to revalidate the model when the data is changed, you can use <code>validate_assignment=True</code>:</p> <pre><code>from pydantic import BaseModel, ValidationError\n\nclass User(BaseModel, validate_assignment=True):  # (1)!\n    name: str\n\nuser = User(name='John Doe')  # (2)!\nprint(user)\n#&gt; name='John Doe'\ntry:\n    user.name = 123  # (3)!\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    '''\n</code></pre> <ol> <li>You can either use class keyword arguments, or <code>model_config</code> to set <code>validate_assignment=True</code>.</li> <li>The validation happens when the model is created.</li> <li>The validation also happens when the data is changed.</li> </ol>"},{"location":"api/config/#pydantic.config.ConfigDict.arbitrary_types_allowed","title":"arbitrary_types_allowed  <code>instance-attribute</code>","text":"<pre><code>arbitrary_types_allowed: bool\n</code></pre> <p>Whether arbitrary types are allowed for field types. Defaults to <code>False</code>.</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n# This is not a pydantic model, it's an arbitrary class\nclass Pet:\n    def __init__(self, name: str):\n        self.name = name\n\nclass Model(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    pet: Pet\n    owner: str\n\npet = Pet(name='Hedwig')\n# A simple check of instance type is used to validate the data\nmodel = Model(owner='Harry', pet=pet)\nprint(model)\n#&gt; pet=&lt;__main__.Pet object at 0x0123456789ab&gt; owner='Harry'\nprint(model.pet)\n#&gt; &lt;__main__.Pet object at 0x0123456789ab&gt;\nprint(model.pet.name)\n#&gt; Hedwig\nprint(type(model.pet))\n#&gt; &lt;class '__main__.Pet'&gt;\ntry:\n    # If the value is not an instance of the type, it's invalid\n    Model(owner='Harry', pet='Hedwig')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    pet\n      Input should be an instance of Pet [type=is_instance_of, input_value='Hedwig', input_type=str]\n    '''\n\n# Nothing in the instance of the arbitrary type is checked\n# Here name probably should have been a str, but it's not validated\npet2 = Pet(name=42)\nmodel2 = Model(owner='Harry', pet=pet2)\nprint(model2)\n#&gt; pet=&lt;__main__.Pet object at 0x0123456789ab&gt; owner='Harry'\nprint(model2.pet)\n#&gt; &lt;__main__.Pet object at 0x0123456789ab&gt;\nprint(model2.pet.name)\n#&gt; 42\nprint(type(model2.pet))\n#&gt; &lt;class '__main__.Pet'&gt;\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.from_attributes","title":"from_attributes  <code>instance-attribute</code>","text":"<pre><code>from_attributes: bool\n</code></pre> <p>Whether to build models and look up discriminators of tagged unions using python object attributes.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.loc_by_alias","title":"loc_by_alias  <code>instance-attribute</code>","text":"<pre><code>loc_by_alias: bool\n</code></pre> <p>Whether to use the actual key provided in the data (e.g. alias) for error <code>loc</code>s rather than the field's name. Defaults to <code>True</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.alias_generator","title":"alias_generator  <code>instance-attribute</code>","text":"<pre><code>alias_generator: Callable[[str], str] | AliasGenerator | None\n</code></pre> <p>A callable that takes a field name and returns an alias for it or an instance of <code>AliasGenerator</code>. Defaults to <code>None</code>.</p> <p>When using a callable, the alias generator is used for both validation and serialization. If you want to use different alias generators for validation and serialization, you can use <code>AliasGenerator</code> instead.</p> <p>If data source field names do not match your code style (e.g. CamelCase fields), you can automatically generate aliases using <code>alias_generator</code>. Here's an example with a basic callable:</p> <pre><code>from pydantic import BaseModel, ConfigDict\nfrom pydantic.alias_generators import to_pascal\n\nclass Voice(BaseModel):\n    model_config = ConfigDict(alias_generator=to_pascal)\n\n    name: str\n    language_code: str\n\nvoice = Voice(Name='Filiz', LanguageCode='tr-TR')\nprint(voice.language_code)\n#&gt; tr-TR\nprint(voice.model_dump(by_alias=True))\n#&gt; {'Name': 'Filiz', 'LanguageCode': 'tr-TR'}\n</code></pre> <p>If you want to use different alias generators for validation and serialization, you can use <code>AliasGenerator</code>.</p> <pre><code>from pydantic import AliasGenerator, BaseModel, ConfigDict\nfrom pydantic.alias_generators import to_camel, to_pascal\n\nclass Athlete(BaseModel):\n    first_name: str\n    last_name: str\n    sport: str\n\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=to_camel,\n            serialization_alias=to_pascal,\n        )\n    )\n\nathlete = Athlete(firstName='John', lastName='Doe', sport='track')\nprint(athlete.model_dump(by_alias=True))\n#&gt; {'FirstName': 'John', 'LastName': 'Doe', 'Sport': 'track'}\n</code></pre> Note <p>Pydantic offers three built-in alias generators: <code>to_pascal</code>, <code>to_camel</code>, and <code>to_snake</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.ignored_types","title":"ignored_types  <code>instance-attribute</code>","text":"<pre><code>ignored_types: tuple[type, ...]\n</code></pre> <p>A tuple of types that may occur as values of class attributes without annotations. This is typically used for custom descriptors (classes that behave like <code>property</code>). If an attribute is set on a class without an annotation and has a type that is not in this tuple (or otherwise recognized by pydantic), an error will be raised. Defaults to <code>()</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.allow_inf_nan","title":"allow_inf_nan  <code>instance-attribute</code>","text":"<pre><code>allow_inf_nan: bool\n</code></pre> <p>Whether to allow infinity (<code>+inf</code> an <code>-inf</code>) and NaN values to float and decimal fields. Defaults to <code>True</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.json_schema_extra","title":"json_schema_extra  <code>instance-attribute</code>","text":"<pre><code>json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n</code></pre> <p>A dict or callable to provide extra JSON schema properties. Defaults to <code>None</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.json_encoders","title":"json_encoders  <code>instance-attribute</code>","text":"<pre><code>json_encoders: dict[type[object], JsonEncoder] | None\n</code></pre> <p>A <code>dict</code> of custom JSON encoders for specific types. Defaults to <code>None</code>.</p> <p>Deprecated</p> <p>This config option is a carryover from v1. We originally planned to remove it in v2 but didn't have a 1:1 replacement so we are keeping it for now. It is still deprecated and will likely be removed in the future.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.strict","title":"strict  <code>instance-attribute</code>","text":"<pre><code>strict: bool\n</code></pre> <p>(new in V2) If <code>True</code>, strict validation is applied to all fields on the model.</p> <p>By default, Pydantic attempts to coerce values to the correct type, when possible.</p> <p>There are situations in which you may want to disable this behavior, and instead raise an error if a value's type does not match the field's type annotation.</p> <p>To configure strict mode for all fields on a model, you can set <code>strict=True</code> on the model.</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\nclass Model(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int\n</code></pre> <p>See Strict Mode for more details.</p> <p>See the Conversion Table for more details on how Pydantic converts data in both strict and lax modes.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.revalidate_instances","title":"revalidate_instances  <code>instance-attribute</code>","text":"<pre><code>revalidate_instances: Literal['always', 'never', 'subclass-instances']\n</code></pre> <p>When and how to revalidate models and dataclasses during validation. Accepts the string values of <code>'never'</code>, <code>'always'</code> and <code>'subclass-instances'</code>. Defaults to <code>'never'</code>.</p> <ul> <li><code>'never'</code> will not revalidate models and dataclasses during validation</li> <li><code>'always'</code> will revalidate models and dataclasses during validation</li> <li><code>'subclass-instances'</code> will revalidate models and dataclasses during validation if the instance is a     subclass of the model or dataclass</li> </ul> <p>By default, model and dataclass instances are not revalidated during validation.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel, revalidate_instances='never'):  # (1)!\n    hobbies: list[str]\n\nclass SubUser(User):\n    sins: list[str]\n\nclass Transaction(BaseModel):\n    user: User\n\nmy_user = User(hobbies=['reading'])\nt = Transaction(user=my_user)\nprint(t)\n#&gt; user=User(hobbies=['reading'])\n\nmy_user.hobbies = [1]  # (2)!\nt = Transaction(user=my_user)  # (3)!\nprint(t)\n#&gt; user=User(hobbies=[1])\n\nmy_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\nt = Transaction(user=my_sub_user)\nprint(t)\n#&gt; user=SubUser(hobbies=['scuba diving'], sins=['lying'])\n</code></pre> <ol> <li><code>revalidate_instances</code> is set to <code>'never'</code> by **default.</li> <li>The assignment is not validated, unless you set <code>validate_assignment</code> to <code>True</code> in the model's config.</li> <li>Since <code>revalidate_instances</code> is set to <code>never</code>, this is not revalidated.</li> </ol> <p>If you want to revalidate instances during validation, you can set <code>revalidate_instances</code> to <code>'always'</code> in the model's config.</p> <pre><code>from pydantic import BaseModel, ValidationError\n\nclass User(BaseModel, revalidate_instances='always'):  # (1)!\n    hobbies: list[str]\n\nclass SubUser(User):\n    sins: list[str]\n\nclass Transaction(BaseModel):\n    user: User\n\nmy_user = User(hobbies=['reading'])\nt = Transaction(user=my_user)\nprint(t)\n#&gt; user=User(hobbies=['reading'])\n\nmy_user.hobbies = [1]\ntry:\n    t = Transaction(user=my_user)  # (2)!\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Transaction\n    user.hobbies.0\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    '''\n\nmy_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\nt = Transaction(user=my_sub_user)\nprint(t)  # (3)!\n#&gt; user=User(hobbies=['scuba diving'])\n</code></pre> <ol> <li><code>revalidate_instances</code> is set to <code>'always'</code>.</li> <li>The model is revalidated, since <code>revalidate_instances</code> is set to <code>'always'</code>.</li> <li>Using <code>'never'</code> we would have gotten <code>user=SubUser(hobbies=['scuba diving'], sins=['lying'])</code>.</li> </ol> <p>It's also possible to set <code>revalidate_instances</code> to <code>'subclass-instances'</code> to only revalidate instances of subclasses of the model.</p> <pre><code>from pydantic import BaseModel\n\nclass User(BaseModel, revalidate_instances='subclass-instances'):  # (1)!\n    hobbies: list[str]\n\nclass SubUser(User):\n    sins: list[str]\n\nclass Transaction(BaseModel):\n    user: User\n\nmy_user = User(hobbies=['reading'])\nt = Transaction(user=my_user)\nprint(t)\n#&gt; user=User(hobbies=['reading'])\n\nmy_user.hobbies = [1]\nt = Transaction(user=my_user)  # (2)!\nprint(t)\n#&gt; user=User(hobbies=[1])\n\nmy_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\nt = Transaction(user=my_sub_user)\nprint(t)  # (3)!\n#&gt; user=User(hobbies=['scuba diving'])\n</code></pre> <ol> <li><code>revalidate_instances</code> is set to <code>'subclass-instances'</code>.</li> <li>This is not revalidated, since <code>my_user</code> is not a subclass of <code>User</code>.</li> <li>Using <code>'never'</code> we would have gotten <code>user=SubUser(hobbies=['scuba diving'], sins=['lying'])</code>.</li> </ol>"},{"location":"api/config/#pydantic.config.ConfigDict.ser_json_timedelta","title":"ser_json_timedelta  <code>instance-attribute</code>","text":"<pre><code>ser_json_timedelta: Literal['iso8601', 'float']\n</code></pre> <p>The format of JSON serialized timedeltas. Accepts the string values of <code>'iso8601'</code> and <code>'float'</code>. Defaults to <code>'iso8601'</code>.</p> <ul> <li><code>'iso8601'</code> will serialize timedeltas to ISO 8601 text format.</li> <li><code>'float'</code> will serialize timedeltas to the total number of seconds.</li> </ul> <p>Warning</p> <p>Starting in v2.12, it is recommended to use the <code>ser_json_temporal</code> setting instead of <code>ser_json_timedelta</code>. This setting will be deprecated in v3.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.ser_json_temporal","title":"ser_json_temporal  <code>instance-attribute</code>","text":"<pre><code>ser_json_temporal: Literal['iso8601', 'seconds', 'milliseconds']\n</code></pre> <p>The format of JSON serialized temporal types from the <code>datetime</code> module. This includes:</p> <ul> <li><code>datetime.datetime</code></li> <li><code>datetime.date</code></li> <li><code>datetime.time</code></li> <li><code>datetime.timedelta</code></li> </ul> <p>Can be one of:</p> <ul> <li><code>'iso8601'</code> will serialize date-like types to ISO 8601 text format.</li> <li><code>'milliseconds'</code> will serialize date-like types to a floating point number of milliseconds since the epoch.</li> <li><code>'seconds'</code> will serialize date-like types to a floating point number of seconds since the epoch.</li> </ul> <p>Defaults to <code>'iso8601'</code>.</p> <p>Note</p> <p>This setting was introduced in v2.12. It overlaps with the <code>ser_json_timedelta</code> setting which will be deprecated in v3. It also adds more configurability for the other temporal types.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.val_temporal_unit","title":"val_temporal_unit  <code>instance-attribute</code>","text":"<pre><code>val_temporal_unit: Literal['seconds', 'milliseconds', 'infer']\n</code></pre> <p>The unit to assume for validating numeric input for datetime-like types (<code>datetime.datetime</code> and <code>datetime.date</code>). Can be one of:</p> <ul> <li><code>'seconds'</code> will validate date or time numeric inputs as seconds since the epoch.</li> <li><code>'milliseconds'</code> will validate date or time numeric inputs as milliseconds since the epoch.</li> <li> <p><code>'infer'</code> will infer the unit from the string numeric input on unix time as:</p> <ul> <li>seconds since the epoch if \\(-2^{10} &lt;= v &lt;= 2^{10}\\)</li> <li>milliseconds since the epoch (if \\(v &lt; -2^{10}\\) or \\(v &gt; 2^{10}\\)).</li> </ul> </li> </ul> <p>Defaults to <code>'infer'</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.ser_json_bytes","title":"ser_json_bytes  <code>instance-attribute</code>","text":"<pre><code>ser_json_bytes: Literal['utf8', 'base64', 'hex']\n</code></pre> <p>The encoding of JSON serialized bytes. Defaults to <code>'utf8'</code>. Set equal to <code>val_json_bytes</code> to get back an equal value after serialization round trip.</p> <ul> <li><code>'utf8'</code> will serialize bytes to UTF-8 strings.</li> <li><code>'base64'</code> will serialize bytes to URL safe base64 strings.</li> <li><code>'hex'</code> will serialize bytes to hexadecimal strings.</li> </ul>"},{"location":"api/config/#pydantic.config.ConfigDict.val_json_bytes","title":"val_json_bytes  <code>instance-attribute</code>","text":"<pre><code>val_json_bytes: Literal['utf8', 'base64', 'hex']\n</code></pre> <p>The encoding of JSON serialized bytes to decode. Defaults to <code>'utf8'</code>. Set equal to <code>ser_json_bytes</code> to get back an equal value after serialization round trip.</p> <ul> <li><code>'utf8'</code> will deserialize UTF-8 strings to bytes.</li> <li><code>'base64'</code> will deserialize URL safe base64 strings to bytes.</li> <li><code>'hex'</code> will deserialize hexadecimal strings to bytes.</li> </ul>"},{"location":"api/config/#pydantic.config.ConfigDict.ser_json_inf_nan","title":"ser_json_inf_nan  <code>instance-attribute</code>","text":"<pre><code>ser_json_inf_nan: Literal['null', 'constants', 'strings']\n</code></pre> <p>The encoding of JSON serialized infinity and NaN float values. Defaults to <code>'null'</code>.</p> <ul> <li><code>'null'</code> will serialize infinity and NaN values as <code>null</code>.</li> <li><code>'constants'</code> will serialize infinity and NaN values as <code>Infinity</code> and <code>NaN</code>.</li> <li><code>'strings'</code> will serialize infinity as string <code>\"Infinity\"</code> and NaN as string <code>\"NaN\"</code>.</li> </ul>"},{"location":"api/config/#pydantic.config.ConfigDict.validate_default","title":"validate_default  <code>instance-attribute</code>","text":"<pre><code>validate_default: bool\n</code></pre> <p>Whether to validate default values during validation. Defaults to <code>False</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.validate_return","title":"validate_return  <code>instance-attribute</code>","text":"<pre><code>validate_return: bool\n</code></pre> <p>Whether to validate the return value from call validators. Defaults to <code>False</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.protected_namespaces","title":"protected_namespaces  <code>instance-attribute</code>","text":"<pre><code>protected_namespaces: tuple[str | Pattern[str], ...]\n</code></pre> <p>A <code>tuple</code> of strings and/or patterns that prevent models from having fields with names that conflict with them. For strings, we match on a prefix basis. Ex, if 'dog' is in the protected namespace, 'dog_name' will be protected. For patterns, we match on the entire field name. Ex, if <code>re.compile(r'^dog$')</code> is in the protected namespace, 'dog' will be protected, but 'dog_name' will not be. Defaults to <code>('model_validate', 'model_dump',)</code>.</p> <p>The reason we've selected these is to prevent collisions with other validation / dumping formats in the future - ex, <code>model_validate_{some_newly_supported_format}</code>.</p> <p>Before v2.10, Pydantic used <code>('model_',)</code> as the default value for this setting to prevent collisions between model attributes and <code>BaseModel</code>'s own methods. This was changed in v2.10 given feedback that this restriction was limiting in AI and data science contexts, where it is common to have fields with names like <code>model_id</code>, <code>model_input</code>, <code>model_output</code>, etc.</p> <p>For more details, see https://github.com/pydantic/pydantic/issues/10315.</p> <pre><code>import warnings\n\nfrom pydantic import BaseModel\n\nwarnings.filterwarnings('error')  # Raise warnings as errors\n\ntry:\n\n    class Model(BaseModel):\n        model_dump_something: str\n\nexcept UserWarning as e:\n    print(e)\n    '''\n    Field 'model_dump_something' in 'Model' conflicts with protected namespace 'model_dump'.\n\n    You may be able to solve this by setting the 'protected_namespaces' configuration to ('model_validate',).\n    '''\n</code></pre> <p>You can customize this behavior using the <code>protected_namespaces</code> setting:</p> <pre><code>import re\nimport warnings\n\nfrom pydantic import BaseModel, ConfigDict\n\nwith warnings.catch_warnings(record=True) as caught_warnings:\n    warnings.simplefilter('always')  # Catch all warnings\n\n    class Model(BaseModel):\n        safe_field: str\n        also_protect_field: str\n        protect_this: str\n\n        model_config = ConfigDict(\n            protected_namespaces=(\n                'protect_me_',\n                'also_protect_',\n                re.compile('^protect_this$'),\n            )\n        )\n\nfor warning in caught_warnings:\n    print(f'{warning.message}')\n    '''\n    Field 'also_protect_field' in 'Model' conflicts with protected namespace 'also_protect_'.\n    You may be able to solve this by setting the 'protected_namespaces' configuration to ('protect_me_', re.compile('^protect_this$'))`.\n\n    Field 'protect_this' in 'Model' conflicts with protected namespace 're.compile('^protect_this$')'.\n    You may be able to solve this by setting the 'protected_namespaces' configuration to ('protect_me_', 'also_protect_')`.\n    '''\n</code></pre> <p>While Pydantic will only emit a warning when an item is in a protected namespace but does not actually have a collision, an error is raised if there is an actual collision with an existing attribute:</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\ntry:\n\n    class Model(BaseModel):\n        model_validate: str\n\n        model_config = ConfigDict(protected_namespaces=('model_',))\n\nexcept ValueError as e:\n    print(e)\n    '''\n    Field 'model_validate' conflicts with member &lt;bound method BaseModel.model_validate of &lt;class 'pydantic.main.BaseModel'&gt;&gt; of protected namespace 'model_'.\n    '''\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.hide_input_in_errors","title":"hide_input_in_errors  <code>instance-attribute</code>","text":"<pre><code>hide_input_in_errors: bool\n</code></pre> <p>Whether to hide inputs when printing errors. Defaults to <code>False</code>.</p> <p>Pydantic shows the input value and type when it raises <code>ValidationError</code> during the validation.</p> <pre><code>from pydantic import BaseModel, ValidationError\n\nclass Model(BaseModel):\n    a: str\n\ntry:\n    Model(a=123)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    a\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    '''\n</code></pre> <p>You can hide the input value and type by setting the <code>hide_input_in_errors</code> config to <code>True</code>.</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\nclass Model(BaseModel):\n    a: str\n    model_config = ConfigDict(hide_input_in_errors=True)\n\ntry:\n    Model(a=123)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    a\n      Input should be a valid string [type=string_type]\n    '''\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.defer_build","title":"defer_build  <code>instance-attribute</code>","text":"<pre><code>defer_build: bool\n</code></pre> <p>Whether to defer model validator and serializer construction until the first model validation. Defaults to False.</p> <p>This can be useful to avoid the overhead of building models which are only used nested within other models, or when you want to manually define type namespace via <code>Model.model_rebuild(_types_namespace=...)</code>.</p> <p>Since v2.10, this setting also applies to pydantic dataclasses and TypeAdapter instances.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.plugin_settings","title":"plugin_settings  <code>instance-attribute</code>","text":"<pre><code>plugin_settings: dict[str, object] | None\n</code></pre> <p>A <code>dict</code> of settings for plugins. Defaults to <code>None</code>.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.schema_generator","title":"schema_generator  <code>instance-attribute</code>","text":"<pre><code>schema_generator: type[GenerateSchema] | None\n</code></pre> <p>Warning</p> <p><code>schema_generator</code> is deprecated in v2.10.</p> <p>Prior to v2.10, this setting was advertised as highly subject to change. It's possible that this interface may once again become public once the internal core schema generation API is more stable, but that will likely come after significant performance improvements have been made.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.json_schema_serialization_defaults_required","title":"json_schema_serialization_defaults_required  <code>instance-attribute</code>","text":"<pre><code>json_schema_serialization_defaults_required: bool\n</code></pre> <p>Whether fields with default values should be marked as required in the serialization schema. Defaults to <code>False</code>.</p> <p>This ensures that the serialization schema will reflect the fact a field with a default will always be present when serializing the model, even though it is not required for validation.</p> <p>However, there are scenarios where this may be undesirable \u2014 in particular, if you want to share the schema between validation and serialization, and don't mind fields with defaults being marked as not required during serialization. See #7209 for more details.</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\nclass Model(BaseModel):\n    a: str = 'a'\n\n    model_config = ConfigDict(json_schema_serialization_defaults_required=True)\n\nprint(Model.model_json_schema(mode='validation'))\n'''\n{\n    'properties': {'a': {'default': 'a', 'title': 'A', 'type': 'string'}},\n    'title': 'Model',\n    'type': 'object',\n}\n'''\nprint(Model.model_json_schema(mode='serialization'))\n'''\n{\n    'properties': {'a': {'default': 'a', 'title': 'A', 'type': 'string'}},\n    'required': ['a'],\n    'title': 'Model',\n    'type': 'object',\n}\n'''\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.json_schema_mode_override","title":"json_schema_mode_override  <code>instance-attribute</code>","text":"<pre><code>json_schema_mode_override: Literal['validation', 'serialization', None]\n</code></pre> <p>If not <code>None</code>, the specified mode will be used to generate the JSON schema regardless of what <code>mode</code> was passed to the function call. Defaults to <code>None</code>.</p> <p>This provides a way to force the JSON schema generation to reflect a specific mode, e.g., to always use the validation schema.</p> <p>It can be useful when using frameworks (such as FastAPI) that may generate different schemas for validation and serialization that must both be referenced from the same schema; when this happens, we automatically append <code>-Input</code> to the definition reference for the validation schema and <code>-Output</code> to the definition reference for the serialization schema. By specifying a <code>json_schema_mode_override</code> though, this prevents the conflict between the validation and serialization schemas (since both will use the specified schema), and so prevents the suffixes from being added to the definition references.</p> <pre><code>from pydantic import BaseModel, ConfigDict, Json\n\nclass Model(BaseModel):\n    a: Json[int]  # requires a string to validate, but will dump an int\n\nprint(Model.model_json_schema(mode='serialization'))\n'''\n{\n    'properties': {'a': {'title': 'A', 'type': 'integer'}},\n    'required': ['a'],\n    'title': 'Model',\n    'type': 'object',\n}\n'''\n\nclass ForceInputModel(Model):\n    # the following ensures that even with mode='serialization', we\n    # will get the schema that would be generated for validation.\n    model_config = ConfigDict(json_schema_mode_override='validation')\n\nprint(ForceInputModel.model_json_schema(mode='serialization'))\n'''\n{\n    'properties': {\n        'a': {\n            'contentMediaType': 'application/json',\n            'contentSchema': {'type': 'integer'},\n            'title': 'A',\n            'type': 'string',\n        }\n    },\n    'required': ['a'],\n    'title': 'ForceInputModel',\n    'type': 'object',\n}\n'''\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.coerce_numbers_to_str","title":"coerce_numbers_to_str  <code>instance-attribute</code>","text":"<pre><code>coerce_numbers_to_str: bool\n</code></pre> <p>If <code>True</code>, enables automatic coercion of any <code>Number</code> type to <code>str</code> in \"lax\" (non-strict) mode. Defaults to <code>False</code>.</p> <p>Pydantic doesn't allow number types (<code>int</code>, <code>float</code>, <code>Decimal</code>) to be coerced as type <code>str</code> by default.</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\nclass Model(BaseModel):\n    value: str\n\ntry:\n    print(Model(value=42))\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    value\n      Input should be a valid string [type=string_type, input_value=42, input_type=int]\n    '''\n\nclass Model(BaseModel):\n    model_config = ConfigDict(coerce_numbers_to_str=True)\n\n    value: str\n\nrepr(Model(value=42).value)\n#&gt; \"42\"\nrepr(Model(value=42.13).value)\n#&gt; \"42.13\"\nrepr(Model(value=Decimal('42.13')).value)\n#&gt; \"42.13\"\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.regex_engine","title":"regex_engine  <code>instance-attribute</code>","text":"<pre><code>regex_engine: Literal['rust-regex', 'python-re']\n</code></pre> <p>The regex engine to be used for pattern validation. Defaults to <code>'rust-regex'</code>.</p> <ul> <li><code>'rust-regex'</code> uses the <code>regex</code> Rust crate,   which is non-backtracking and therefore more DDoS resistant, but does not support all regex features.</li> <li><code>'python-re'</code> use the <code>re</code> module, which supports all regex features, but may be slower.</li> </ul> <p>Note</p> <p>If you use a compiled regex pattern, the <code>'python-re'</code> engine will be used regardless of this setting. This is so that flags such as <code>re.IGNORECASE</code> are respected.</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field, ValidationError\n\nclass Model(BaseModel):\n    model_config = ConfigDict(regex_engine='python-re')\n\n    value: str = Field(pattern=r'^abc(?=def)')\n\nprint(Model(value='abcdef').value)\n#&gt; abcdef\n\ntry:\n    print(Model(value='abxyzcdef'))\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    value\n      String should match pattern '^abc(?=def)' [type=string_pattern_mismatch, input_value='abxyzcdef', input_type=str]\n    '''\n</code></pre>"},{"location":"api/config/#pydantic.config.ConfigDict.validation_error_cause","title":"validation_error_cause  <code>instance-attribute</code>","text":"<pre><code>validation_error_cause: bool\n</code></pre> <p>If <code>True</code>, Python exceptions that were part of a validation failure will be shown as an exception group as a cause. Can be useful for debugging. Defaults to <code>False</code>.</p> Note <p>Python 3.10 and older don't support exception groups natively. &lt;=3.10, backport must be installed: <code>pip install exceptiongroup</code>.</p> Note <p>The structure of validation errors are likely to change in future Pydantic versions. Pydantic offers no guarantees about their structure. Should be used for visual traceback debugging only.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.use_attribute_docstrings","title":"use_attribute_docstrings  <code>instance-attribute</code>","text":"<pre><code>use_attribute_docstrings: bool\n</code></pre> <p>Whether docstrings of attributes (bare string literals immediately following the attribute declaration) should be used for field descriptions. Defaults to <code>False</code>.</p> <p>Available in Pydantic v2.7+.</p> <p><pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    model_config = ConfigDict(use_attribute_docstrings=True)\n\n    x: str\n    \"\"\"\n    Example of an attribute docstring\n    \"\"\"\n\n    y: int = Field(description=\"Description in Field\")\n    \"\"\"\n    Description in Field overrides attribute docstring\n    \"\"\"\n\n\nprint(Model.model_fields[\"x\"].description)\n# &gt; Example of an attribute docstring\nprint(Model.model_fields[\"y\"].description)\n# &gt; Description in Field\n</code></pre> This requires the source code of the class to be available at runtime.</p> <p>Usage with <code>TypedDict</code> and stdlib dataclasses</p> <p>Due to current limitations, attribute docstrings detection may not work as expected when using <code>TypedDict</code> and stdlib dataclasses, in particular when:</p> <ul> <li>inheritance is being used.</li> <li>multiple classes have the same name in the same source file (unless Python 3.13 or greater is used).</li> </ul>"},{"location":"api/config/#pydantic.config.ConfigDict.cache_strings","title":"cache_strings  <code>instance-attribute</code>","text":"<pre><code>cache_strings: bool | Literal['all', 'keys', 'none']\n</code></pre> <p>Whether to cache strings to avoid constructing new Python objects. Defaults to True.</p> <p>Enabling this setting should significantly improve validation performance while increasing memory usage slightly.</p> <ul> <li><code>True</code> or <code>'all'</code> (the default): cache all strings</li> <li><code>'keys'</code>: cache only dictionary keys</li> <li><code>False</code> or <code>'none'</code>: no caching</li> </ul> <p>Note</p> <p><code>True</code> or <code>'all'</code> is required to cache strings during general validation because validators don't know if they're in a key or a value.</p> <p>Tip</p> <p>If repeated strings are rare, it's recommended to use <code>'keys'</code> or <code>'none'</code> to reduce memory usage, as the performance difference is minimal if repeated strings are rare.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.validate_by_alias","title":"validate_by_alias  <code>instance-attribute</code>","text":"<pre><code>validate_by_alias: bool\n</code></pre> <p>Whether an aliased field may be populated by its alias. Defaults to <code>True</code>.</p> <p>Note</p> <p>In v2.11, <code>validate_by_alias</code> was introduced in conjunction with <code>validate_by_name</code> to empower users with more fine grained validation control. In &lt;v2.11, disabling validation by alias was not possible.</p> <p>Here's an example of disabling validation by alias:</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=False)\n\n    my_field: str = Field(validation_alias='my_alias')  # (1)!\n\nm = Model(my_field='foo')  # (2)!\nprint(m)\n#&gt; my_field='foo'\n</code></pre> <ol> <li>The field <code>'my_field'</code> has an alias <code>'my_alias'</code>.</li> <li>The model can only be populated by the attribute name <code>'my_field'</code>.</li> </ol> <p>Warning</p> <p>You cannot set both <code>validate_by_alias</code> and <code>validate_by_name</code> to <code>False</code>. This would make it impossible to populate an attribute.</p> <p>See usage errors for an example.</p> <p>If you set <code>validate_by_alias</code> to <code>False</code>, under the hood, Pydantic dynamically sets <code>validate_by_name</code> to <code>True</code> to ensure that validation can still occur.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.validate_by_name","title":"validate_by_name  <code>instance-attribute</code>","text":"<pre><code>validate_by_name: bool\n</code></pre> <p>Whether an aliased field may be populated by its name as given by the model attribute. Defaults to <code>False</code>.</p> <p>Note</p> <p>In v2.0-v2.10, the <code>populate_by_name</code> configuration setting was used to specify whether or not a field could be populated by its name and alias.</p> <p>In v2.11, <code>validate_by_name</code> was introduced in conjunction with <code>validate_by_alias</code> to empower users with more fine grained validation behavior control.</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n    my_field: str = Field(validation_alias='my_alias')  # (1)!\n\nm = Model(my_alias='foo')  # (2)!\nprint(m)\n#&gt; my_field='foo'\n\nm = Model(my_field='foo')  # (3)!\nprint(m)\n#&gt; my_field='foo'\n</code></pre> <ol> <li>The field <code>'my_field'</code> has an alias <code>'my_alias'</code>.</li> <li>The model is populated by the alias <code>'my_alias'</code>.</li> <li>The model is populated by the attribute name <code>'my_field'</code>.</li> </ol> <p>Warning</p> <p>You cannot set both <code>validate_by_alias</code> and <code>validate_by_name</code> to <code>False</code>. This would make it impossible to populate an attribute.</p> <p>See usage errors for an example.</p>"},{"location":"api/config/#pydantic.config.ConfigDict.serialize_by_alias","title":"serialize_by_alias  <code>instance-attribute</code>","text":"<pre><code>serialize_by_alias: bool\n</code></pre> <p>Whether an aliased field should be serialized by its alias. Defaults to <code>False</code>.</p> <p>Note: In v2.11, <code>serialize_by_alias</code> was introduced to address the popular request for consistency with alias behavior for validation and serialization settings. In v3, the default value is expected to change to <code>True</code> for consistency with the validation default.</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    model_config = ConfigDict(serialize_by_alias=True)\n\n    my_field: str = Field(serialization_alias='my_alias')  # (1)!\n\nm = Model(my_field='foo')\nprint(m.model_dump())  # (2)!\n#&gt; {'my_alias': 'foo'}\n</code></pre> <ol> <li>The field <code>'my_field'</code> has an alias <code>'my_alias'</code>.</li> <li>The model is serialized using the alias <code>'my_alias'</code> for the <code>'my_field'</code> attribute.</li> </ol>"},{"location":"api/config/#pydantic.config.ConfigDict.url_preserve_empty_path","title":"url_preserve_empty_path  <code>instance-attribute</code>","text":"<pre><code>url_preserve_empty_path: bool\n</code></pre> <p>Whether to preserve empty URL paths when validating values for a URL type. Defaults to <code>False</code>.</p> <pre><code>from pydantic import AnyUrl, BaseModel, ConfigDict\n\nclass Model(BaseModel):\n    model_config = ConfigDict(url_preserve_empty_path=True)\n\n    url: AnyUrl\n\nm = Model(url='http://example.com')\nprint(m.url)\n#&gt; http://example.com\n</code></pre>"},{"location":"api/config/#pydantic.config.with_config","title":"with_config","text":"<pre><code>with_config(*, config: ConfigDict) -&gt; Callable[[_TypeT], _TypeT]\n</code></pre><pre><code>with_config(config: ConfigDict) -&gt; Callable[[_TypeT], _TypeT]\n</code></pre><pre><code>with_config(**config: Unpack[ConfigDict]) -&gt; Callable[[_TypeT], _TypeT]\n</code></pre> <pre><code>with_config(config: ConfigDict | None = None, /, **kwargs: Any) -&gt; Callable[[_TypeT], _TypeT]\n</code></pre> <p>Usage Documentation</p> <p>Configuration with other types</p> <p>A convenience decorator to set a Pydantic configuration on a <code>TypedDict</code> or a <code>dataclass</code> from the standard library.</p> <p>Although the configuration can be set using the <code>__pydantic_config__</code> attribute, it does not play well with type checkers, especially with <code>TypedDict</code>.</p> <p>Usage</p> <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter, with_config\n\n@with_config(ConfigDict(str_to_lower=True))\nclass TD(TypedDict):\n    x: str\n\nta = TypeAdapter(TD)\n\nprint(ta.validate_python({'x': 'ABC'}))\n#&gt; {'x': 'abc'}\n</code></pre> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/config.py</code> <pre><code>def with_config(config: ConfigDict | None = None, /, **kwargs: Any) -&gt; Callable[[_TypeT], _TypeT]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Configuration with other types](../concepts/config.md#configuration-on-other-supported-types)\n\n    A convenience decorator to set a [Pydantic configuration](config.md) on a `TypedDict` or a `dataclass` from the standard library.\n\n    Although the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\n    especially with `TypedDict`.\n\n    !!! example \"Usage\"\n\n        ```python\n        from typing_extensions import TypedDict\n\n        from pydantic import ConfigDict, TypeAdapter, with_config\n\n        @with_config(ConfigDict(str_to_lower=True))\n        class TD(TypedDict):\n            x: str\n\n        ta = TypeAdapter(TD)\n\n        print(ta.validate_python({'x': 'ABC'}))\n        #&gt; {'x': 'abc'}\n        ```\n    \"\"\"\n    if config is not None and kwargs:\n        raise ValueError('Cannot specify both `config` and keyword arguments')\n\n    if len(kwargs) == 1 and (kwargs_conf := kwargs.get('config')) is not None:\n        warnings.warn(\n            'Passing `config` as a keyword argument is deprecated. Pass `config` as a positional argument instead',\n            category=PydanticDeprecatedSince211,\n            stacklevel=2,\n        )\n        final_config = cast(ConfigDict, kwargs_conf)\n    else:\n        final_config = config if config is not None else cast(ConfigDict, kwargs)\n\n    def inner(class_: _TypeT, /) -&gt; _TypeT:\n        # Ideally, we would check for `class_` to either be a `TypedDict` or a stdlib dataclass.\n        # However, the `@with_config` decorator can be applied *after* `@dataclass`. To avoid\n        # common mistakes, we at least check for `class_` to not be a Pydantic model.\n        from ._internal._utils import is_model_class\n\n        if is_model_class(class_):\n            raise PydanticUserError(\n                f'Cannot use `with_config` on {class_.__name__} as it is a Pydantic model',\n                code='with-config-on-model',\n            )\n        class_.__pydantic_config__ = final_config\n        return class_\n\n    return inner\n</code></pre>"},{"location":"api/config/#pydantic.config.ExtraValues","title":"ExtraValues  <code>module-attribute</code>","text":"<pre><code>ExtraValues = Literal['allow', 'ignore', 'forbid']\n</code></pre>"},{"location":"api/config/#pydantic.alias_generators","title":"pydantic.alias_generators","text":"<p>Alias generators for converting between different capitalization conventions.</p>"},{"location":"api/config/#pydantic.alias_generators.to_pascal","title":"to_pascal","text":"<pre><code>to_pascal(snake: str) -&gt; str\n</code></pre> <p>Convert a snake_case string to PascalCase.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>snake</code> <code>str</code> <p>The string to convert.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The PascalCase string.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/alias_generators.py</code> <pre><code>def to_pascal(snake: str) -&gt; str:\n    \"\"\"Convert a snake_case string to PascalCase.\n\n    Args:\n        snake: The string to convert.\n\n    Returns:\n        The PascalCase string.\n    \"\"\"\n    camel = snake.title()\n    return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel)\n</code></pre>"},{"location":"api/config/#pydantic.alias_generators.to_camel","title":"to_camel","text":"<pre><code>to_camel(snake: str) -&gt; str\n</code></pre> <p>Convert a snake_case string to camelCase.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>snake</code> <code>str</code> <p>The string to convert.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The converted camelCase string.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/alias_generators.py</code> <pre><code>def to_camel(snake: str) -&gt; str:\n    \"\"\"Convert a snake_case string to camelCase.\n\n    Args:\n        snake: The string to convert.\n\n    Returns:\n        The converted camelCase string.\n    \"\"\"\n    # If the string is already in camelCase and does not contain a digit followed\n    # by a lowercase letter, return it as it is\n    if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r'\\d[a-z]', snake):\n        return snake\n\n    camel = to_pascal(snake)\n    return re.sub('(^_*[A-Z])', lambda m: m.group(1).lower(), camel)\n</code></pre>"},{"location":"api/config/#pydantic.alias_generators.to_snake","title":"to_snake","text":"<pre><code>to_snake(camel: str) -&gt; str\n</code></pre> <p>Convert a PascalCase, camelCase, or kebab-case string to snake_case.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>camel</code> <code>str</code> <p>The string to convert.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The converted string in snake_case.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/alias_generators.py</code> <pre><code>def to_snake(camel: str) -&gt; str:\n    \"\"\"Convert a PascalCase, camelCase, or kebab-case string to snake_case.\n\n    Args:\n        camel: The string to convert.\n\n    Returns:\n        The converted string in snake_case.\n    \"\"\"\n    # Handle the sequence of uppercase letters followed by a lowercase letter\n    snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)\n    # Insert an underscore between a lowercase letter and an uppercase letter\n    snake = re.sub(r'([a-z])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n    # Insert an underscore between a digit and an uppercase letter\n    snake = re.sub(r'([0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n    # Insert an underscore between a lowercase letter and a digit\n    snake = re.sub(r'([a-z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n    # Replace hyphens with underscores to handle kebab-case\n    snake = snake.replace('-', '_')\n    return snake.lower()\n</code></pre>"},{"location":"api/dataclasses/","title":"Pydantic Dataclasses","text":"<p>Provide an enhanced dataclass that performs validation.</p>"},{"location":"api/dataclasses/#pydantic.dataclasses.dataclass","title":"dataclass","text":"<pre><code>dataclass(*, init: Literal[False] = False, repr: bool = True, eq: bool = True, order: bool = False, unsafe_hash: bool = False, frozen: bool = False, config: ConfigDict | type[object] | None = None, validate_on_init: bool | None = None, kw_only: bool = ..., slots: bool = ...) -&gt; Callable[[type[_T]], type[PydanticDataclass]]\n</code></pre><pre><code>dataclass(_cls: type[_T], *, init: Literal[False] = False, repr: bool = True, eq: bool = True, order: bool = False, unsafe_hash: bool = False, frozen: bool | None = None, config: ConfigDict | type[object] | None = None, validate_on_init: bool | None = None, kw_only: bool = ..., slots: bool = ...) -&gt; type[PydanticDataclass]\n</code></pre><pre><code>dataclass(*, init: Literal[False] = False, repr: bool = True, eq: bool = True, order: bool = False, unsafe_hash: bool = False, frozen: bool | None = None, config: ConfigDict | type[object] | None = None, validate_on_init: bool | None = None) -&gt; Callable[[type[_T]], type[PydanticDataclass]]\n</code></pre><pre><code>dataclass(_cls: type[_T], *, init: Literal[False] = False, repr: bool = True, eq: bool = True, order: bool = False, unsafe_hash: bool = False, frozen: bool | None = None, config: ConfigDict | type[object] | None = None, validate_on_init: bool | None = None) -&gt; type[PydanticDataclass]\n</code></pre> <pre><code>dataclass(_cls: type[_T] | None = None, *, init: Literal[False] = False, repr: bool = True, eq: bool = True, order: bool = False, unsafe_hash: bool = False, frozen: bool | None = None, config: ConfigDict | type[object] | None = None, validate_on_init: bool | None = None, kw_only: bool = False, slots: bool = False) -&gt; Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]\n</code></pre> <p>Usage Documentation</p> <p><code>dataclasses</code></p> <p>A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python <code>dataclass</code>, but with added validation.</p> <p>This function should be used similarly to <code>dataclasses.dataclass</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>_cls</code> <code>type[_T] | None</code> <p>The target <code>dataclass</code>.</p> <code>None</code> <code>init</code> <code>Literal[False]</code> <p>Included for signature compatibility with <code>dataclasses.dataclass</code>, and is passed through to <code>dataclasses.dataclass</code> when appropriate. If specified, must be set to <code>False</code>, as pydantic inserts its own  <code>__init__</code> function.</p> <code>False</code> <code>repr</code> <code>bool</code> <p>A boolean indicating whether to include the field in the <code>__repr__</code> output.</p> <code>True</code> <code>eq</code> <code>bool</code> <p>Determines if a <code>__eq__</code> method should be generated for the class.</p> <code>True</code> <code>order</code> <code>bool</code> <p>Determines if comparison magic methods should be generated, such as <code>__lt__</code>, but not <code>__eq__</code>.</p> <code>False</code> <code>unsafe_hash</code> <code>bool</code> <p>Determines if a <code>__hash__</code> method should be included in the class, as in <code>dataclasses.dataclass</code>.</p> <code>False</code> <code>frozen</code> <code>bool | None</code> <p>Determines if the generated class should be a 'frozen' <code>dataclass</code>, which does not allow its attributes to be modified after it has been initialized. If not set, the value from the provided <code>config</code> argument will be used (and will default to <code>False</code> otherwise).</p> <code>None</code> <code>config</code> <code>ConfigDict | type[object] | None</code> <p>The Pydantic config to use for the <code>dataclass</code>.</p> <code>None</code> <code>validate_on_init</code> <code>bool | None</code> <p>A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses are validated on init.</p> <code>None</code> <code>kw_only</code> <code>bool</code> <p>Determines if <code>__init__</code> method parameters must be specified by keyword only. Defaults to <code>False</code>.</p> <code>False</code> <code>slots</code> <code>bool</code> <p>Determines if the generated class should be a 'slots' <code>dataclass</code>, which does not allow the addition of new attributes after instantiation.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]</code> <p>A decorator that accepts a class as its argument and returns a Pydantic <code>dataclass</code>.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>AssertionError</code> <p>Raised if <code>init</code> is not <code>False</code> or <code>validate_on_init</code> is <code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/dataclasses.py</code> <pre><code>@dataclass_transform(field_specifiers=(dataclasses.field, Field, PrivateAttr))\ndef dataclass(\n    _cls: type[_T] | None = None,\n    *,\n    init: Literal[False] = False,\n    repr: bool = True,\n    eq: bool = True,\n    order: bool = False,\n    unsafe_hash: bool = False,\n    frozen: bool | None = None,\n    config: ConfigDict | type[object] | None = None,\n    validate_on_init: bool | None = None,\n    kw_only: bool = False,\n    slots: bool = False,\n) -&gt; Callable[[type[_T]], type[PydanticDataclass]] | type[PydanticDataclass]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [`dataclasses`](../concepts/dataclasses.md)\n\n    A decorator used to create a Pydantic-enhanced dataclass, similar to the standard Python `dataclass`,\n    but with added validation.\n\n    This function should be used similarly to `dataclasses.dataclass`.\n\n    Args:\n        _cls: The target `dataclass`.\n        init: Included for signature compatibility with `dataclasses.dataclass`, and is passed through to\n            `dataclasses.dataclass` when appropriate. If specified, must be set to `False`, as pydantic inserts its\n            own  `__init__` function.\n        repr: A boolean indicating whether to include the field in the `__repr__` output.\n        eq: Determines if a `__eq__` method should be generated for the class.\n        order: Determines if comparison magic methods should be generated, such as `__lt__`, but not `__eq__`.\n        unsafe_hash: Determines if a `__hash__` method should be included in the class, as in `dataclasses.dataclass`.\n        frozen: Determines if the generated class should be a 'frozen' `dataclass`, which does not allow its\n            attributes to be modified after it has been initialized. If not set, the value from the provided `config` argument will be used (and will default to `False` otherwise).\n        config: The Pydantic config to use for the `dataclass`.\n        validate_on_init: A deprecated parameter included for backwards compatibility; in V2, all Pydantic dataclasses\n            are validated on init.\n        kw_only: Determines if `__init__` method parameters must be specified by keyword only. Defaults to `False`.\n        slots: Determines if the generated class should be a 'slots' `dataclass`, which does not allow the addition of\n            new attributes after instantiation.\n\n    Returns:\n        A decorator that accepts a class as its argument and returns a Pydantic `dataclass`.\n\n    Raises:\n        AssertionError: Raised if `init` is not `False` or `validate_on_init` is `False`.\n    \"\"\"\n    assert init is False, 'pydantic.dataclasses.dataclass only supports init=False'\n    assert validate_on_init is not False, 'validate_on_init=False is no longer supported'\n\n    if sys.version_info &gt;= (3, 10):\n        kwargs = {'kw_only': kw_only, 'slots': slots}\n    else:\n        kwargs = {}\n\n    def create_dataclass(cls: type[Any]) -&gt; type[PydanticDataclass]:\n        \"\"\"Create a Pydantic dataclass from a regular dataclass.\n\n        Args:\n            cls: The class to create the Pydantic dataclass from.\n\n        Returns:\n            A Pydantic dataclass.\n        \"\"\"\n        from ._internal._utils import is_model_class\n\n        if is_model_class(cls):\n            raise PydanticUserError(\n                f'Cannot create a Pydantic dataclass from {cls.__name__} as it is already a Pydantic model',\n                code='dataclass-on-model',\n            )\n\n        original_cls = cls\n\n        # we warn on conflicting config specifications, but only if the class doesn't have a dataclass base\n        # because a dataclass base might provide a __pydantic_config__ attribute that we don't want to warn about\n        has_dataclass_base = any(dataclasses.is_dataclass(base) for base in cls.__bases__)\n        if not has_dataclass_base and config is not None and hasattr(cls, '__pydantic_config__'):\n            warn(\n                f'`config` is set via both the `dataclass` decorator and `__pydantic_config__` for dataclass {cls.__name__}. '\n                f'The `config` specification from `dataclass` decorator will take priority.',\n                category=UserWarning,\n                stacklevel=2,\n            )\n\n        # if config is not explicitly provided, try to read it from the type\n        config_dict = config if config is not None else getattr(cls, '__pydantic_config__', None)\n        config_wrapper = _config.ConfigWrapper(config_dict)\n        decorators = _decorators.DecoratorInfos.build(cls)\n        decorators.update_from_config(config_wrapper)\n\n        # Keep track of the original __doc__ so that we can restore it after applying the dataclasses decorator\n        # Otherwise, classes with no __doc__ will have their signature added into the JSON schema description,\n        # since dataclasses.dataclass will set this as the __doc__\n        original_doc = cls.__doc__\n\n        if _pydantic_dataclasses.is_stdlib_dataclass(cls):\n            # Vanilla dataclasses include a default docstring (representing the class signature),\n            # which we don't want to preserve.\n            original_doc = None\n\n            # We don't want to add validation to the existing std lib dataclass, so we will subclass it\n            #   If the class is generic, we need to make sure the subclass also inherits from Generic\n            #   with all the same parameters.\n            bases = (cls,)\n            if issubclass(cls, Generic):\n                generic_base = Generic[cls.__parameters__]  # type: ignore\n                bases = bases + (generic_base,)\n            cls = types.new_class(cls.__name__, bases)\n\n        # Respect frozen setting from dataclass constructor and fallback to config setting if not provided\n        if frozen is not None:\n            frozen_ = frozen\n            if config_wrapper.frozen:\n                # It's not recommended to define both, as the setting from the dataclass decorator will take priority.\n                warn(\n                    f'`frozen` is set via both the `dataclass` decorator and `config` for dataclass {cls.__name__!r}.'\n                    'This is not recommended. The `frozen` specification on `dataclass` will take priority.',\n                    category=UserWarning,\n                    stacklevel=2,\n                )\n        else:\n            frozen_ = config_wrapper.frozen or False\n\n        # Make Pydantic's `Field()` function compatible with stdlib dataclasses. As we'll decorate\n        # `cls` with the stdlib `@dataclass` decorator first, there are two attributes, `kw_only` and\n        # `repr` that need to be understood *during* the stdlib creation. We do so in two steps:\n\n        # 1. On the decorated class, wrap `Field()` assignment with `dataclass.field()`, with the\n        # two attributes set (done in `as_dataclass_field()`)\n        cls_anns = _typing_extra.safe_get_annotations(cls)\n        for field_name in cls_anns:\n            # We should look for assignments in `__dict__` instead, but for now we follow\n            # the same behavior as stdlib dataclasses (see https://github.com/python/cpython/issues/88609)\n            field_value = getattr(cls, field_name, None)\n            if isinstance(field_value, FieldInfo):\n                setattr(cls, field_name, _pydantic_dataclasses.as_dataclass_field(field_value))\n\n        # 2. For bases of `cls` that are stdlib dataclasses, we temporarily patch their fields\n        # (see the docstring of the context manager):\n        with _pydantic_dataclasses.patch_base_fields(cls):\n            cls = dataclasses.dataclass(  # pyright: ignore[reportCallIssue]\n                cls,\n                # the value of init here doesn't affect anything except that it makes it easier to generate a signature\n                init=True,\n                repr=repr,\n                eq=eq,\n                order=order,\n                unsafe_hash=unsafe_hash,\n                frozen=frozen_,\n                **kwargs,\n            )\n\n        if config_wrapper.validate_assignment:\n            original_setattr = cls.__setattr__\n\n            @functools.wraps(cls.__setattr__)\n            def validated_setattr(instance: PydanticDataclass, name: str, value: Any, /) -&gt; None:\n                if frozen_:\n                    return original_setattr(instance, name, value)  # pyright: ignore[reportCallIssue]\n                inst_cls = type(instance)\n                attr = getattr(inst_cls, name, None)\n\n                if isinstance(attr, property):\n                    attr.__set__(instance, value)\n                elif isinstance(attr, functools.cached_property):\n                    instance.__dict__.__setitem__(name, value)\n                else:\n                    inst_cls.__pydantic_validator__.validate_assignment(instance, name, value)\n\n            cls.__setattr__ = validated_setattr.__get__(None, cls)  # type: ignore\n\n            if slots and not hasattr(cls, '__setstate__'):\n                # If slots is set, `pickle` (relied on by `copy.copy()`) will use\n                # `__setattr__()` to reconstruct the dataclass. However, the custom\n                # `__setattr__()` set above relies on `validate_assignment()`, which\n                # in turn expects all the field values to be already present on the\n                # instance, resulting in attribute errors.\n                # As such, we make use of `object.__setattr__()` instead.\n                # Note that we do so only if `__setstate__()` isn't already set (this is the\n                # case if on top of `slots`, `frozen` is used).\n\n                # Taken from `dataclasses._dataclass_get/setstate()`:\n                def _dataclass_getstate(self: Any) -&gt; list[Any]:\n                    return [getattr(self, f.name) for f in dataclasses.fields(self)]\n\n                def _dataclass_setstate(self: Any, state: list[Any]) -&gt; None:\n                    for field, value in zip(dataclasses.fields(self), state):\n                        object.__setattr__(self, field.name, value)\n\n                cls.__getstate__ = _dataclass_getstate  # pyright: ignore[reportAttributeAccessIssue]\n                cls.__setstate__ = _dataclass_setstate  # pyright: ignore[reportAttributeAccessIssue]\n\n        # This is an undocumented attribute to distinguish stdlib/Pydantic dataclasses.\n        # It should be set as early as possible:\n        cls.__is_pydantic_dataclass__ = True\n        cls.__pydantic_decorators__ = decorators  # type: ignore\n        cls.__doc__ = original_doc\n        # Can be non-existent for dynamically created classes:\n        firstlineno = getattr(original_cls, '__firstlineno__', None)\n        cls.__module__ = original_cls.__module__\n        if sys.version_info &gt;= (3, 13) and firstlineno is not None:\n            # As per https://docs.python.org/3/reference/datamodel.html#type.__firstlineno__:\n            # Setting the `__module__` attribute removes the `__firstlineno__` item from the type\u2019s dictionary.\n            original_cls.__firstlineno__ = firstlineno\n            cls.__firstlineno__ = firstlineno\n        cls.__qualname__ = original_cls.__qualname__\n        cls.__pydantic_fields_complete__ = classmethod(_pydantic_fields_complete)\n        cls.__pydantic_complete__ = False  # `complete_dataclass` will set it to `True` if successful.\n        # TODO `parent_namespace` is currently None, but we could do the same thing as Pydantic models:\n        # fetch the parent ns using `parent_frame_namespace` (if the dataclass was defined in a function),\n        # and possibly cache it (see the `__pydantic_parent_namespace__` logic for models).\n        _pydantic_dataclasses.complete_dataclass(cls, config_wrapper, raise_errors=False)\n        return cls\n\n    return create_dataclass if _cls is None else create_dataclass(_cls)\n</code></pre>"},{"location":"api/dataclasses/#pydantic.dataclasses.rebuild_dataclass","title":"rebuild_dataclass","text":"<pre><code>rebuild_dataclass(cls: type[PydanticDataclass], *, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the dataclass.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>This is analogous to <code>BaseModel.model_rebuild</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>type[PydanticDataclass]</code> <p>The class to rebuild the pydantic-core schema for.</p> \u5fc5\u9700 <code>force</code> <code>bool</code> <p>Whether to force the rebuilding of the schema, defaults to <code>False</code>.</p> <code>False</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>_parent_namespace_depth</code> <code>int</code> <p>The depth level of the parent namespace, defaults to 2.</p> <code>2</code> <code>_types_namespace</code> <code>MappingNamespace | None</code> <p>The types namespace, defaults to <code>None</code>.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.</p> <code>bool | None</code> <p>If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/dataclasses.py</code> <pre><code>def rebuild_dataclass(\n    cls: type[PydanticDataclass],\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the dataclass.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    This is analogous to `BaseModel.model_rebuild`.\n\n    Args:\n        cls: The class to rebuild the pydantic-core schema for.\n        force: Whether to force the rebuilding of the schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n        _types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    if not force and cls.__pydantic_complete__:\n        return None\n\n    for attr in ('__pydantic_core_schema__', '__pydantic_validator__', '__pydantic_serializer__'):\n        if attr in cls.__dict__:\n            # Deleting the validator/serializer is necessary as otherwise they can get reused in\n            # pydantic-core. Same applies for the core schema that can be reused in schema generation.\n            delattr(cls, attr)\n\n    cls.__pydantic_complete__ = False\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    ns_resolver = _namespace_utils.NsResolver(\n        parent_namespace=rebuild_ns,\n    )\n\n    return _pydantic_dataclasses.complete_dataclass(\n        cls,\n        _config.ConfigWrapper(cls.__pydantic_config__, check=False),\n        raise_errors=raise_errors,\n        ns_resolver=ns_resolver,\n        # We could provide a different config instead (with `'defer_build'` set to `True`)\n        # of this explicit `_force_build` argument, but because config can come from the\n        # decorator parameter or the `__pydantic_config__` attribute, `complete_dataclass`\n        # will overwrite `__pydantic_config__` with the provided config above:\n        _force_build=True,\n    )\n</code></pre>"},{"location":"api/dataclasses/#pydantic.dataclasses.is_pydantic_dataclass","title":"is_pydantic_dataclass","text":"<pre><code>is_pydantic_dataclass(class_: type[Any]) -&gt; TypeGuard[type[PydanticDataclass]]\n</code></pre> <p>Whether a class is a pydantic dataclass.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>class_</code> <code>type[Any]</code> <p>The class.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>TypeGuard[type[PydanticDataclass]]</code> <p><code>True</code> if the class is a pydantic dataclass, <code>False</code> otherwise.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/dataclasses.py</code> <pre><code>def is_pydantic_dataclass(class_: type[Any], /) -&gt; TypeGuard[type[PydanticDataclass]]:\n    \"\"\"Whether a class is a pydantic dataclass.\n\n    Args:\n        class_: The class.\n\n    Returns:\n        `True` if the class is a pydantic dataclass, `False` otherwise.\n    \"\"\"\n    try:\n        return '__is_pydantic_dataclass__' in class_.__dict__ and dataclasses.is_dataclass(class_)\n    except AttributeError:\n        return False\n</code></pre>"},{"location":"api/errors/","title":"Errors","text":"<p>Pydantic-specific errors.</p>"},{"location":"api/errors/#pydantic.errors.PydanticErrorMixin","title":"PydanticErrorMixin","text":"<pre><code>PydanticErrorMixin(message: str, *, code: PydanticErrorCodes | None)\n</code></pre> <p>A mixin class for common functionality shared by all Pydantic-specific errors.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>message</code> <p>A message describing the error.</p> <code>code</code> <p>An optional error code from PydanticErrorCodes enum.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, message: str, *, code: PydanticErrorCodes | None) -&gt; None:\n    self.message = message\n    self.code = code\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticUserError","title":"PydanticUserError","text":"<pre><code>PydanticUserError(message: str, *, code: PydanticErrorCodes | None)\n</code></pre> <p>               Bases: <code>PydanticErrorMixin</code>, <code>TypeError</code></p> <p>An error raised due to incorrect use of Pydantic.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, message: str, *, code: PydanticErrorCodes | None) -&gt; None:\n    self.message = message\n    self.code = code\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticUndefinedAnnotation","title":"PydanticUndefinedAnnotation","text":"<pre><code>PydanticUndefinedAnnotation(name: str, message: str)\n</code></pre> <p>               Bases: <code>PydanticErrorMixin</code>, <code>NameError</code></p> <p>A subclass of <code>NameError</code> raised when handling undefined annotations during <code>CoreSchema</code> generation.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>name</code> <p>Name of the error.</p> <code>message</code> <p>Description of the error.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, name: str, message: str) -&gt; None:\n    self.name = name\n    super().__init__(message=message, code='undefined-annotation')\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticUndefinedAnnotation.from_name_error","title":"from_name_error  <code>classmethod</code>","text":"<pre><code>from_name_error(name_error: NameError) -&gt; Self\n</code></pre> <p>Convert a <code>NameError</code> to a <code>PydanticUndefinedAnnotation</code> error.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>name_error</code> <code>NameError</code> <p><code>NameError</code> to be converted.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>Converted <code>PydanticUndefinedAnnotation</code> error.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>@classmethod\ndef from_name_error(cls, name_error: NameError) -&gt; Self:\n    \"\"\"Convert a `NameError` to a `PydanticUndefinedAnnotation` error.\n\n    Args:\n        name_error: `NameError` to be converted.\n\n    Returns:\n        Converted `PydanticUndefinedAnnotation` error.\n    \"\"\"\n    try:\n        name = name_error.name  # type: ignore  # python &gt; 3.10\n    except AttributeError:\n        name = re.search(r\".*'(.+?)'\", str(name_error)).group(1)  # type: ignore[union-attr]\n    return cls(name=name, message=str(name_error))\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticImportError","title":"PydanticImportError","text":"<pre><code>PydanticImportError(message: str)\n</code></pre> <p>               Bases: <code>PydanticErrorMixin</code>, <code>ImportError</code></p> <p>An error raised when an import fails due to module changes between V1 and V2.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>message</code> <p>Description of the error.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message, code='import-error')\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticSchemaGenerationError","title":"PydanticSchemaGenerationError","text":"<pre><code>PydanticSchemaGenerationError(message: str)\n</code></pre> <p>               Bases: <code>PydanticUserError</code></p> <p>An error raised during failures to generate a <code>CoreSchema</code> for some type.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>message</code> <p>Description of the error.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message, code='schema-for-unknown-type')\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticInvalidForJsonSchema","title":"PydanticInvalidForJsonSchema","text":"<pre><code>PydanticInvalidForJsonSchema(message: str)\n</code></pre> <p>               Bases: <code>PydanticUserError</code></p> <p>An error raised during failures to generate a JSON schema for some <code>CoreSchema</code>.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>message</code> <p>Description of the error.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    super().__init__(message, code='invalid-for-json-schema')\n</code></pre>"},{"location":"api/errors/#pydantic.errors.PydanticForbiddenQualifier","title":"PydanticForbiddenQualifier","text":"<pre><code>PydanticForbiddenQualifier(qualifier: Qualifier, annotation: Any)\n</code></pre> <p>               Bases: <code>PydanticUserError</code></p> <p>An error raised if a forbidden type qualifier is found in a type annotation.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/errors.py</code> <pre><code>def __init__(self, qualifier: Qualifier, annotation: Any) -&gt; None:\n    super().__init__(\n        message=(\n            f'The annotation {_repr.display_as_type(annotation)!r} contains the {self._qualifier_repr_map[qualifier]!r} '\n            f'type qualifier, which is invalid in the context it is defined.'\n        ),\n        code=None,\n    )\n</code></pre>"},{"location":"api/experimental/","title":"Experimental API","text":""},{"location":"api/experimental/#pipeline-api","title":"Pipeline API","text":"<p>Experimental pipeline API functionality. Be careful with this API, it's subject to change.</p>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline","title":"_Pipeline  <code>dataclass</code>","text":"<pre><code>_Pipeline(_steps: tuple[_Step, ...])\n</code></pre> <p>               Bases: <code>Generic[_InT, _OutT]</code></p> <p>Abstract representation of a chain of validation, transformation, and parsing steps.</p>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.transform","title":"transform","text":"<pre><code>transform(func: Callable[[_OutT], _NewOutT]) -&gt; _Pipeline[_InT, _NewOutT]\n</code></pre> <p>Transform the output of the previous step.</p> <p>If used as the first step in a pipeline, the type of the field is used. That is, the transformation is applied to after the value is parsed to the field's type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def transform(\n    self,\n    func: Callable[[_OutT], _NewOutT],\n) -&gt; _Pipeline[_InT, _NewOutT]:\n    \"\"\"Transform the output of the previous step.\n\n    If used as the first step in a pipeline, the type of the field is used.\n    That is, the transformation is applied to after the value is parsed to the field's type.\n    \"\"\"\n    return _Pipeline[_InT, _NewOutT](self._steps + (_Transform(func),))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.validate_as","title":"validate_as","text":"<pre><code>validate_as(tp: type[_NewOutT], *, strict: bool = ...) -&gt; _Pipeline[_InT, _NewOutT]\n</code></pre><pre><code>validate_as(tp: EllipsisType, *, strict: bool = ...) -&gt; _Pipeline[_InT, Any]\n</code></pre> <pre><code>validate_as(tp: type[_NewOutT] | EllipsisType, *, strict: bool = False) -&gt; _Pipeline[_InT, Any]\n</code></pre> <p>Validate / parse the input into a new type.</p> <p>If no type is provided, the type of the field is used.</p> <p>Types are parsed in Pydantic's <code>lax</code> mode by default, but you can enable <code>strict</code> mode by passing <code>strict=True</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def validate_as(self, tp: type[_NewOutT] | EllipsisType, *, strict: bool = False) -&gt; _Pipeline[_InT, Any]:  # type: ignore\n    \"\"\"Validate / parse the input into a new type.\n\n    If no type is provided, the type of the field is used.\n\n    Types are parsed in Pydantic's `lax` mode by default,\n    but you can enable `strict` mode by passing `strict=True`.\n    \"\"\"\n    if isinstance(tp, EllipsisType):\n        return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))\n    return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAs(tp, strict=strict),))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.validate_as_deferred","title":"validate_as_deferred","text":"<pre><code>validate_as_deferred(func: Callable[[], type[_NewOutT]]) -&gt; _Pipeline[_InT, _NewOutT]\n</code></pre> <p>Parse the input into a new type, deferring resolution of the type until the current class is fully defined.</p> <p>This is useful when you need to reference the class in it's own type annotations.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -&gt; _Pipeline[_InT, _NewOutT]:\n    \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n    is fully defined.\n\n    This is useful when you need to reference the class in it's own type annotations.\n    \"\"\"\n    return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAsDefer(func),))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.constrain","title":"constrain","text":"<pre><code>constrain(constraint: Ge) -&gt; _Pipeline[_InT, _NewOutGe]\n</code></pre><pre><code>constrain(constraint: Gt) -&gt; _Pipeline[_InT, _NewOutGt]\n</code></pre><pre><code>constrain(constraint: Le) -&gt; _Pipeline[_InT, _NewOutLe]\n</code></pre><pre><code>constrain(constraint: Lt) -&gt; _Pipeline[_InT, _NewOutLt]\n</code></pre><pre><code>constrain(constraint: Len) -&gt; _Pipeline[_InT, _NewOutLen]\n</code></pre><pre><code>constrain(constraint: MultipleOf) -&gt; _Pipeline[_InT, _NewOutT]\n</code></pre><pre><code>constrain(constraint: Timezone) -&gt; _Pipeline[_InT, _NewOutDatetime]\n</code></pre><pre><code>constrain(constraint: Predicate) -&gt; _Pipeline[_InT, _OutT]\n</code></pre><pre><code>constrain(constraint: Interval) -&gt; _Pipeline[_InT, _NewOutInterval]\n</code></pre><pre><code>constrain(constraint: _Eq) -&gt; _Pipeline[_InT, _OutT]\n</code></pre><pre><code>constrain(constraint: _NotEq) -&gt; _Pipeline[_InT, _OutT]\n</code></pre><pre><code>constrain(constraint: _In) -&gt; _Pipeline[_InT, _OutT]\n</code></pre><pre><code>constrain(constraint: _NotIn) -&gt; _Pipeline[_InT, _OutT]\n</code></pre><pre><code>constrain(constraint: Pattern[str]) -&gt; _Pipeline[_InT, _NewOutT]\n</code></pre> <pre><code>constrain(constraint: _ConstraintAnnotation) -&gt; Any\n</code></pre> <p>Constrain a value to meet a certain condition.</p> <p>We support most conditions from <code>annotated_types</code>, as well as regular expressions.</p> <p>Most of the time you'll be calling a shortcut method like <code>gt</code>, <code>lt</code>, <code>len</code>, etc so you don't need to call this directly.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def constrain(self, constraint: _ConstraintAnnotation) -&gt; Any:\n    \"\"\"Constrain a value to meet a certain condition.\n\n    We support most conditions from `annotated_types`, as well as regular expressions.\n\n    Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n    so you don't need to call this directly.\n    \"\"\"\n    return _Pipeline[_InT, _OutT](self._steps + (_Constraint(constraint),))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.predicate","title":"predicate","text":"<pre><code>predicate(func: Callable[[_NewOutT], bool]) -&gt; _Pipeline[_InT, _NewOutT]\n</code></pre> <p>Constrain a value to meet a certain predicate.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -&gt; _Pipeline[_InT, _NewOutT]:\n    \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n    return self.constrain(annotated_types.Predicate(func))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.gt","title":"gt","text":"<pre><code>gt(gt: _NewOutGt) -&gt; _Pipeline[_InT, _NewOutGt]\n</code></pre> <p>Constrain a value to be greater than a certain value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -&gt; _Pipeline[_InT, _NewOutGt]:\n    \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n    return self.constrain(annotated_types.Gt(gt))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.lt","title":"lt","text":"<pre><code>lt(lt: _NewOutLt) -&gt; _Pipeline[_InT, _NewOutLt]\n</code></pre> <p>Constrain a value to be less than a certain value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -&gt; _Pipeline[_InT, _NewOutLt]:\n    \"\"\"Constrain a value to be less than a certain value.\"\"\"\n    return self.constrain(annotated_types.Lt(lt))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.ge","title":"ge","text":"<pre><code>ge(ge: _NewOutGe) -&gt; _Pipeline[_InT, _NewOutGe]\n</code></pre> <p>Constrain a value to be greater than or equal to a certain value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -&gt; _Pipeline[_InT, _NewOutGe]:\n    \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n    return self.constrain(annotated_types.Ge(ge))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.le","title":"le","text":"<pre><code>le(le: _NewOutLe) -&gt; _Pipeline[_InT, _NewOutLe]\n</code></pre> <p>Constrain a value to be less than or equal to a certain value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -&gt; _Pipeline[_InT, _NewOutLe]:\n    \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n    return self.constrain(annotated_types.Le(le))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.len","title":"len","text":"<pre><code>len(min_len: int, max_len: int | None = None) -&gt; _Pipeline[_InT, _NewOutLen]\n</code></pre> <p>Constrain a value to have a certain length.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -&gt; _Pipeline[_InT, _NewOutLen]:\n    \"\"\"Constrain a value to have a certain length.\"\"\"\n    return self.constrain(annotated_types.Len(min_len, max_len))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.multiple_of","title":"multiple_of","text":"<pre><code>multiple_of(multiple_of: _NewOutDiv) -&gt; _Pipeline[_InT, _NewOutDiv]\n</code></pre><pre><code>multiple_of(multiple_of: _NewOutMod) -&gt; _Pipeline[_InT, _NewOutMod]\n</code></pre> <pre><code>multiple_of(multiple_of: Any) -&gt; _Pipeline[_InT, Any]\n</code></pre> <p>Constrain a value to be a multiple of a certain number.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def multiple_of(self: _Pipeline[_InT, Any], multiple_of: Any) -&gt; _Pipeline[_InT, Any]:\n    \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n    return self.constrain(annotated_types.MultipleOf(multiple_of))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.eq","title":"eq","text":"<pre><code>eq(value: _OutT) -&gt; _Pipeline[_InT, _OutT]\n</code></pre> <p>Constrain a value to be equal to a certain value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt; _Pipeline[_InT, _OutT]:\n    \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n    return self.constrain(_Eq(value))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.not_eq","title":"not_eq","text":"<pre><code>not_eq(value: _OutT) -&gt; _Pipeline[_InT, _OutT]\n</code></pre> <p>Constrain a value to not be equal to a certain value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -&gt; _Pipeline[_InT, _OutT]:\n    \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n    return self.constrain(_NotEq(value))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.in_","title":"in_","text":"<pre><code>in_(values: Container[_OutT]) -&gt; _Pipeline[_InT, _OutT]\n</code></pre> <p>Constrain a value to be in a certain set.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -&gt; _Pipeline[_InT, _OutT]:\n    \"\"\"Constrain a value to be in a certain set.\"\"\"\n    return self.constrain(_In(values))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.not_in","title":"not_in","text":"<pre><code>not_in(values: Container[_OutT]) -&gt; _Pipeline[_InT, _OutT]\n</code></pre> <p>Constrain a value to not be in a certain set.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -&gt; _Pipeline[_InT, _OutT]:\n    \"\"\"Constrain a value to not be in a certain set.\"\"\"\n    return self.constrain(_NotIn(values))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.otherwise","title":"otherwise","text":"<pre><code>otherwise(other: _Pipeline[_OtherIn, _OtherOut]) -&gt; _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]\n</code></pre> <p>Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -&gt; _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n    \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n    return _Pipeline((_PipelineOr(self, other),))\n</code></pre>"},{"location":"api/experimental/#pydantic.experimental.pipeline._Pipeline.then","title":"then","text":"<pre><code>then(other: _Pipeline[_OutT, _OtherOut]) -&gt; _Pipeline[_InT, _OtherOut]\n</code></pre> <p>Pipe the result of one validation chain into another.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/pipeline.py</code> <pre><code>def then(self, other: _Pipeline[_OutT, _OtherOut]) -&gt; _Pipeline[_InT, _OtherOut]:\n    \"\"\"Pipe the result of one validation chain into another.\"\"\"\n    return _Pipeline((_PipelineAnd(self, other),))\n</code></pre>"},{"location":"api/experimental/#arguments-schema-api","title":"Arguments schema API","text":"<p>Experimental module exposing a function to generate a core schema that validates callable arguments.</p>"},{"location":"api/experimental/#pydantic.experimental.arguments_schema.generate_arguments_schema","title":"generate_arguments_schema","text":"<pre><code>generate_arguments_schema(func: Callable[..., Any], schema_type: Literal['arguments', 'arguments-v3'] = 'arguments-v3', parameters_callback: Callable[[int, str, Any], Literal['skip'] | None] | None = None, config: ConfigDict | None = None) -&gt; CoreSchema\n</code></pre> <p>Generate the schema for the arguments of a function.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>func</code> <code>Callable[..., Any]</code> <p>The function to generate the schema for.</p> \u5fc5\u9700 <code>schema_type</code> <code>Literal['arguments', 'arguments-v3']</code> <p>The type of schema to generate.</p> <code>'arguments-v3'</code> <code>parameters_callback</code> <code>Callable[[int, str, Any], Literal['skip'] | None] | None</code> <p>A callable that will be invoked for each parameter. The callback should take three required arguments: the index, the name and the type annotation (or <code>Parameter.empty</code> if not annotated) of the parameter. The callback can optionally return <code>'skip'</code>, so that the parameter gets excluded from the resulting schema.</p> <code>None</code> <code>config</code> <code>ConfigDict | None</code> <p>The configuration to use.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>CoreSchema</code> <p>The generated schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/experimental/arguments_schema.py</code> <pre><code>def generate_arguments_schema(\n    func: Callable[..., Any],\n    schema_type: Literal['arguments', 'arguments-v3'] = 'arguments-v3',\n    parameters_callback: Callable[[int, str, Any], Literal['skip'] | None] | None = None,\n    config: ConfigDict | None = None,\n) -&gt; CoreSchema:\n    \"\"\"Generate the schema for the arguments of a function.\n\n    Args:\n        func: The function to generate the schema for.\n        schema_type: The type of schema to generate.\n        parameters_callback: A callable that will be invoked for each parameter. The callback\n            should take three required arguments: the index, the name and the type annotation\n            (or [`Parameter.empty`][inspect.Parameter.empty] if not annotated) of the parameter.\n            The callback can optionally return `'skip'`, so that the parameter gets excluded\n            from the resulting schema.\n        config: The configuration to use.\n\n    Returns:\n        The generated schema.\n    \"\"\"\n    generate_schema = _generate_schema.GenerateSchema(\n        _config.ConfigWrapper(config),\n        ns_resolver=_namespace_utils.NsResolver(namespaces_tuple=_namespace_utils.ns_for_function(func)),\n    )\n\n    if schema_type == 'arguments':\n        schema = generate_schema._arguments_schema(func, parameters_callback)  # pyright: ignore[reportArgumentType]\n    else:\n        schema = generate_schema._arguments_v3_schema(func, parameters_callback)  # pyright: ignore[reportArgumentType]\n    return generate_schema.clean_schema(schema)\n</code></pre>"},{"location":"api/fields/","title":"Fields","text":"<p>Defining fields on models.</p>"},{"location":"api/fields/#pydantic.fields.Field","title":"Field","text":"<pre><code>Field(default: ellipsis, *, alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: bool | None = _Unset, repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; Any\n</code></pre><pre><code>Field(default: Any, *, alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: Literal[True], repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; Any\n</code></pre><pre><code>Field(default: _T, *, alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: Literal[False] = ..., repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; _T\n</code></pre><pre><code>Field(*, default_factory: Callable[[], Any] | Callable[[dict[str, Any]], Any], alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: Literal[True], repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; Any\n</code></pre><pre><code>Field(*, default_factory: Callable[[], _T] | Callable[[dict[str, Any]], _T], alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: Literal[False] | None = _Unset, repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; _T\n</code></pre><pre><code>Field(*, alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: bool | None = _Unset, repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; Any\n</code></pre> <pre><code>Field(default: Any = PydanticUndefined, *, default_factory: Callable[[], Any] | Callable[[dict[str, Any]], Any] | None = _Unset, alias: str | None = _Unset, alias_priority: int | None = _Unset, validation_alias: str | AliasPath | AliasChoices | None = _Unset, serialization_alias: str | None = _Unset, title: str | None = _Unset, field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset, description: str | None = _Unset, examples: list[Any] | None = _Unset, exclude: bool | None = _Unset, exclude_if: Callable[[Any], bool] | None = _Unset, discriminator: str | Discriminator | None = _Unset, deprecated: Deprecated | str | bool | None = _Unset, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset, frozen: bool | None = _Unset, validate_default: bool | None = _Unset, repr: bool = _Unset, init: bool | None = _Unset, init_var: bool | None = _Unset, kw_only: bool | None = _Unset, pattern: str | Pattern[str] | None = _Unset, strict: bool | None = _Unset, coerce_numbers_to_str: bool | None = _Unset, gt: SupportsGt | None = _Unset, ge: SupportsGe | None = _Unset, lt: SupportsLt | None = _Unset, le: SupportsLe | None = _Unset, multiple_of: float | None = _Unset, allow_inf_nan: bool | None = _Unset, max_digits: int | None = _Unset, decimal_places: int | None = _Unset, min_length: int | None = _Unset, max_length: int | None = _Unset, union_mode: Literal['smart', 'left_to_right'] = _Unset, fail_fast: bool | None = _Unset, **extra: Unpack[_EmptyKwargs]) -&gt; Any\n</code></pre> <p>Usage Documentation</p> <p>Fields</p> <p>Create a field for objects that can be configured.</p> <p>Used to provide extra information about a field, either for the model schema or complex validation. Some arguments apply only to number fields (<code>int</code>, <code>float</code>, <code>Decimal</code>) and some apply only to <code>str</code>.</p> Note <ul> <li>Any <code>_Unset</code> objects will be replaced by the corresponding value defined in the <code>_DefaultValues</code> dictionary. If a key for the <code>_Unset</code> object is not found in the <code>_DefaultValues</code> dictionary, it will default to <code>None</code></li> </ul> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>default</code> <code>Any</code> <p>Default value if the field is not set.</p> <code>PydanticUndefined</code> <code>default_factory</code> <code>Callable[[], Any] | Callable[[dict[str, Any]], Any] | None</code> <p>A callable to generate the default value. The callable can either take 0 arguments (in which case it is called as is) or a single argument containing the already validated data.</p> <code>_Unset</code> <code>alias</code> <code>str | None</code> <p>The name to use for the attribute when validating or serializing by alias. This is often used for things like converting between snake and camel case.</p> <code>_Unset</code> <code>alias_priority</code> <code>int | None</code> <p>Priority of the alias. This affects whether an alias generator is used.</p> <code>_Unset</code> <code>validation_alias</code> <code>str | AliasPath | AliasChoices | None</code> <p>Like <code>alias</code>, but only affects validation, not serialization.</p> <code>_Unset</code> <code>serialization_alias</code> <code>str | None</code> <p>Like <code>alias</code>, but only affects serialization, not validation.</p> <code>_Unset</code> <code>title</code> <code>str | None</code> <p>Human-readable title.</p> <code>_Unset</code> <code>field_title_generator</code> <code>Callable[[str, FieldInfo], str] | None</code> <p>A callable that takes a field name and returns title for it.</p> <code>_Unset</code> <code>description</code> <code>str | None</code> <p>Human-readable description.</p> <code>_Unset</code> <code>examples</code> <code>list[Any] | None</code> <p>Example values for this field.</p> <code>_Unset</code> <code>exclude</code> <code>bool | None</code> <p>Whether to exclude the field from the model serialization.</p> <code>_Unset</code> <code>exclude_if</code> <code>Callable[[Any], bool] | None</code> <p>A callable that determines whether to exclude a field during serialization based on its value.</p> <code>_Unset</code> <code>discriminator</code> <code>str | Discriminator | None</code> <p>Field name or Discriminator for discriminating the type in a tagged union.</p> <code>_Unset</code> <code>deprecated</code> <code>Deprecated | str | bool | None</code> <p>A deprecation message, an instance of <code>warnings.deprecated</code> or the <code>typing_extensions.deprecated</code> backport, or a boolean. If <code>True</code>, a default deprecation message will be emitted when accessing the field.</p> <code>_Unset</code> <code>json_schema_extra</code> <code>JsonDict | Callable[[JsonDict], None] | None</code> <p>A dict or callable to provide extra JSON schema properties.</p> <code>_Unset</code> <code>frozen</code> <code>bool | None</code> <p>Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.</p> <code>_Unset</code> <code>validate_default</code> <code>bool | None</code> <p>If <code>True</code>, apply validation to the default value every time you create an instance. Otherwise, for performance reasons, the default value of the field is trusted and not validated.</p> <code>_Unset</code> <code>repr</code> <code>bool</code> <p>A boolean indicating whether to include the field in the <code>__repr__</code> output.</p> <code>_Unset</code> <code>init</code> <code>bool | None</code> <p>Whether the field should be included in the constructor of the dataclass. (Only applies to dataclasses.)</p> <code>_Unset</code> <code>init_var</code> <code>bool | None</code> <p>Whether the field should only be included in the constructor of the dataclass. (Only applies to dataclasses.)</p> <code>_Unset</code> <code>kw_only</code> <code>bool | None</code> <p>Whether the field should be a keyword-only argument in the constructor of the dataclass. (Only applies to dataclasses.)</p> <code>_Unset</code> <code>coerce_numbers_to_str</code> <code>bool | None</code> <p>Whether to enable coercion of any <code>Number</code> type to <code>str</code> (not applicable in <code>strict</code> mode).</p> <code>_Unset</code> <code>strict</code> <code>bool | None</code> <p>If <code>True</code>, strict validation is applied to the field. See Strict Mode for details.</p> <code>_Unset</code> <code>gt</code> <code>SupportsGt | None</code> <p>Greater than. If set, value must be greater than this. Only applicable to numbers.</p> <code>_Unset</code> <code>ge</code> <code>SupportsGe | None</code> <p>Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.</p> <code>_Unset</code> <code>lt</code> <code>SupportsLt | None</code> <p>Less than. If set, value must be less than this. Only applicable to numbers.</p> <code>_Unset</code> <code>le</code> <code>SupportsLe | None</code> <p>Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.</p> <code>_Unset</code> <code>multiple_of</code> <code>float | None</code> <p>Value must be a multiple of this. Only applicable to numbers.</p> <code>_Unset</code> <code>min_length</code> <code>int | None</code> <p>Minimum length for iterables.</p> <code>_Unset</code> <code>max_length</code> <code>int | None</code> <p>Maximum length for iterables.</p> <code>_Unset</code> <code>pattern</code> <code>str | Pattern[str] | None</code> <p>Pattern for strings (a regular expression).</p> <code>_Unset</code> <code>allow_inf_nan</code> <code>bool | None</code> <p>Allow <code>inf</code>, <code>-inf</code>, <code>nan</code>. Only applicable to float and <code>Decimal</code> numbers.</p> <code>_Unset</code> <code>max_digits</code> <code>int | None</code> <p>Maximum number of allow digits for strings.</p> <code>_Unset</code> <code>decimal_places</code> <code>int | None</code> <p>Maximum number of decimal places allowed for numbers.</p> <code>_Unset</code> <code>union_mode</code> <code>Literal['smart', 'left_to_right']</code> <p>The strategy to apply when validating a union. Can be <code>smart</code> (the default), or <code>left_to_right</code>. See Union Mode for details.</p> <code>_Unset</code> <code>fail_fast</code> <code>bool | None</code> <p>If <code>True</code>, validation will stop on the first error. If <code>False</code>, all validation errors will be collected. This option can be applied only to iterable types (list, tuple, set, and frozenset).</p> <code>_Unset</code> <code>extra</code> <code>Unpack[_EmptyKwargs]</code> <p>(Deprecated) Extra fields that will be included in the JSON schema.</p> <p>Warning</p> <p>The <code>extra</code> kwargs is deprecated. Use <code>json_schema_extra</code> instead.</p> <code>{}</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>A new <code>FieldInfo</code>. The return annotation is <code>Any</code> so <code>Field</code> can be used on type-annotated fields without causing a type error.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def Field(  # noqa: C901\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: Callable[[], Any] | Callable[[dict[str, Any]], Any] | None = _Unset,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: str | AliasPath | AliasChoices | None = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: Callable[[str, FieldInfo], str] | None = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    exclude_if: Callable[[Any], bool] | None = _Unset,\n    discriminator: str | types.Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: bool | None = _Unset,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | re.Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: annotated_types.SupportsGt | None = _Unset,\n    ge: annotated_types.SupportsGe | None = _Unset,\n    lt: annotated_types.SupportsLt | None = _Unset,\n    le: annotated_types.SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal['smart', 'left_to_right'] = _Unset,\n    fail_fast: bool | None = _Unset,\n    **extra: Unpack[_EmptyKwargs],\n) -&gt; Any:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Fields](../concepts/fields.md)\n\n    Create a field for objects that can be configured.\n\n    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments\n    apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.\n\n    Note:\n        - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`\n\n    Args:\n        default: Default value if the field is not set.\n        default_factory: A callable to generate the default value. The callable can either take 0 arguments\n            (in which case it is called as is) or a single argument containing the already validated data.\n        alias: The name to use for the attribute when validating or serializing by alias.\n            This is often used for things like converting between snake and camel case.\n        alias_priority: Priority of the alias. This affects whether an alias generator is used.\n        validation_alias: Like `alias`, but only affects validation, not serialization.\n        serialization_alias: Like `alias`, but only affects serialization, not validation.\n        title: Human-readable title.\n        field_title_generator: A callable that takes a field name and returns title for it.\n        description: Human-readable description.\n        examples: Example values for this field.\n        exclude: Whether to exclude the field from the model serialization.\n        exclude_if: A callable that determines whether to exclude a field during serialization based on its value.\n        discriminator: Field name or Discriminator for discriminating the type in a tagged union.\n        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n        json_schema_extra: A dict or callable to provide extra JSON schema properties.\n        frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.\n        validate_default: If `True`, apply validation to the default value every time you create an instance.\n            Otherwise, for performance reasons, the default value of the field is trusted and not validated.\n        repr: A boolean indicating whether to include the field in the `__repr__` output.\n        init: Whether the field should be included in the constructor of the dataclass.\n            (Only applies to dataclasses.)\n        init_var: Whether the field should _only_ be included in the constructor of the dataclass.\n            (Only applies to dataclasses.)\n        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n            (Only applies to dataclasses.)\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n        strict: If `True`, strict validation is applied to the field.\n            See [Strict Mode](../concepts/strict_mode.md) for details.\n        gt: Greater than. If set, value must be greater than this. Only applicable to numbers.\n        ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.\n        lt: Less than. If set, value must be less than this. Only applicable to numbers.\n        le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.\n        multiple_of: Value must be a multiple of this. Only applicable to numbers.\n        min_length: Minimum length for iterables.\n        max_length: Maximum length for iterables.\n        pattern: Pattern for strings (a regular expression).\n        allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to float and [`Decimal`][decimal.Decimal] numbers.\n        max_digits: Maximum number of allow digits for strings.\n        decimal_places: Maximum number of decimal places allowed for numbers.\n        union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.\n            See [Union Mode](../concepts/unions.md#union-modes) for details.\n        fail_fast: If `True`, validation will stop on the first error. If `False`, all validation errors will be collected.\n            This option can be applied only to iterable types (list, tuple, set, and frozenset).\n        extra: (Deprecated) Extra fields that will be included in the JSON schema.\n\n            !!! warning Deprecated\n                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on\n            type-annotated fields without causing a type error.\n    \"\"\"\n    # Check deprecated and removed params from V1. This logic should eventually be removed.\n    const = extra.pop('const', None)  # type: ignore\n    if const is not None:\n        raise PydanticUserError('`const` is removed, use `Literal` instead', code='removed-kwargs')\n\n    min_items = extra.pop('min_items', None)  # type: ignore\n    if min_items is not None:\n        warn(\n            '`min_items` is deprecated and will be removed, use `min_length` instead',\n            PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if min_length in (None, _Unset):\n            min_length = min_items  # type: ignore\n\n    max_items = extra.pop('max_items', None)  # type: ignore\n    if max_items is not None:\n        warn(\n            '`max_items` is deprecated and will be removed, use `max_length` instead',\n            PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if max_length in (None, _Unset):\n            max_length = max_items  # type: ignore\n\n    unique_items = extra.pop('unique_items', None)  # type: ignore\n    if unique_items is not None:\n        raise PydanticUserError(\n            (\n                '`unique_items` is removed, use `Set` instead'\n                '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'\n            ),\n            code='removed-kwargs',\n        )\n\n    allow_mutation = extra.pop('allow_mutation', None)  # type: ignore\n    if allow_mutation is not None:\n        warn(\n            '`allow_mutation` is deprecated and will be removed. use `frozen` instead',\n            PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if allow_mutation is False:\n            frozen = True\n\n    regex = extra.pop('regex', None)  # type: ignore\n    if regex is not None:\n        raise PydanticUserError('`regex` is removed. use `pattern` instead', code='removed-kwargs')\n\n    if extra:\n        warn(\n            'Using extra keyword arguments on `Field` is deprecated and will be removed.'\n            ' Use `json_schema_extra` instead.'\n            f' (Extra keys: {\", \".join(k.__repr__() for k in extra.keys())})',\n            PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n        if not json_schema_extra or json_schema_extra is _Unset:\n            json_schema_extra = extra  # type: ignore\n\n    if (\n        validation_alias\n        and validation_alias is not _Unset\n        and not isinstance(validation_alias, (str, AliasChoices, AliasPath))\n    ):\n        raise TypeError('Invalid `validation_alias` type. it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, None):\n        validation_alias = alias\n\n    include = extra.pop('include', None)  # type: ignore\n    if include is not None:\n        warn(\n            '`include` is deprecated and does nothing. It will be removed, use `exclude` instead',\n            PydanticDeprecatedSince20,\n            stacklevel=2,\n        )\n\n    return FieldInfo.from_field(\n        default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        field_title_generator=field_title_generator,\n        description=description,\n        examples=examples,\n        exclude=exclude,\n        exclude_if=exclude_if,\n        discriminator=discriminator,\n        deprecated=deprecated,\n        json_schema_extra=json_schema_extra,\n        frozen=frozen,\n        pattern=pattern,\n        validate_default=validate_default,\n        repr=repr,\n        init=init,\n        init_var=init_var,\n        kw_only=kw_only,\n        coerce_numbers_to_str=coerce_numbers_to_str,\n        strict=strict,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        min_length=min_length,\n        max_length=max_length,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        union_mode=union_mode,\n        fail_fast=fail_fast,\n    )\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo","title":"FieldInfo","text":"<pre><code>FieldInfo(**kwargs: Unpack[_FieldInfoInputs])\n</code></pre> <p>               Bases: <code>Representation</code></p> <p>This class holds information about a field.</p> <p><code>FieldInfo</code> is used for any field definition regardless of whether the <code>Field()</code> function is explicitly used.</p> <p>Warning</p> <p>You generally shouldn't be creating <code>FieldInfo</code> directly, you'll only need to use it when accessing <code>BaseModel</code> <code>.model_fields</code> internals.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>annotation</code> <code>type[Any] | None</code> <p>The type annotation of the field.</p> <code>default</code> <code>Any</code> <p>The default value of the field.</p> <code>default_factory</code> <code>Callable[[], Any] | Callable[[dict[str, Any]], Any] | None</code> <p>A callable to generate the default value. The callable can either take 0 arguments (in which case it is called as is) or a single argument containing the already validated data.</p> <code>alias</code> <code>str | None</code> <p>The alias name of the field.</p> <code>alias_priority</code> <code>int | None</code> <p>The priority of the field's alias.</p> <code>validation_alias</code> <code>str | AliasPath | AliasChoices | None</code> <p>The validation alias of the field.</p> <code>serialization_alias</code> <code>str | None</code> <p>The serialization alias of the field.</p> <code>title</code> <code>str | None</code> <p>The title of the field.</p> <code>field_title_generator</code> <code>Callable[[str, FieldInfo], str] | None</code> <p>A callable that takes a field name and returns title for it.</p> <code>description</code> <code>str | None</code> <p>The description of the field.</p> <code>examples</code> <code>list[Any] | None</code> <p>List of examples of the field.</p> <code>exclude</code> <code>bool | None</code> <p>Whether to exclude the field from the model serialization.</p> <code>exclude_if</code> <code>Callable[[Any], bool] | None</code> <p>A callable that determines whether to exclude a field during serialization based on its value.</p> <code>discriminator</code> <code>str | Discriminator | None</code> <p>Field name or Discriminator for discriminating the type in a tagged union.</p> <code>deprecated</code> <code>Deprecated | str | bool | None</code> <p>A deprecation message, an instance of <code>warnings.deprecated</code> or the <code>typing_extensions.deprecated</code> backport, or a boolean. If <code>True</code>, a default deprecation message will be emitted when accessing the field.</p> <code>json_schema_extra</code> <code>JsonDict | Callable[[JsonDict], None] | None</code> <p>A dict or callable to provide extra JSON schema properties.</p> <code>frozen</code> <code>bool | None</code> <p>Whether the field is frozen.</p> <code>validate_default</code> <code>bool | None</code> <p>Whether to validate the default value of the field.</p> <code>repr</code> <code>bool</code> <p>Whether to include the field in representation of the model.</p> <code>init</code> <code>bool | None</code> <p>Whether the field should be included in the constructor of the dataclass.</p> <code>init_var</code> <code>bool | None</code> <p>Whether the field should only be included in the constructor of the dataclass, and not stored.</p> <code>kw_only</code> <code>bool | None</code> <p>Whether the field should be a keyword-only argument in the constructor of the dataclass.</p> <code>metadata</code> <code>list[Any]</code> <p>List of metadata constraints.</p> <p>See the signature of <code>pydantic.fields.Field</code> for more details about the expected arguments.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -&gt; None:\n    \"\"\"This class should generally not be initialized directly; instead, use the `pydantic.fields.Field` function\n    or one of the constructor classmethods.\n\n    See the signature of `pydantic.fields.Field` for more details about the expected arguments.\n    \"\"\"\n    self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset and k not in self.metadata_lookup}\n    kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n    self.annotation = kwargs.get('annotation')\n\n    default = kwargs.pop('default', PydanticUndefined)\n    if default is Ellipsis:\n        self.default = PydanticUndefined\n        self._attributes_set.pop('default', None)\n    else:\n        self.default = default\n\n    self.default_factory = kwargs.pop('default_factory', None)\n\n    if self.default is not PydanticUndefined and self.default_factory is not None:\n        raise TypeError('cannot specify both default and default_factory')\n\n    self.alias = kwargs.pop('alias', None)\n    self.validation_alias = kwargs.pop('validation_alias', None)\n    self.serialization_alias = kwargs.pop('serialization_alias', None)\n    alias_is_set = any(alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias))\n    self.alias_priority = kwargs.pop('alias_priority', None) or 2 if alias_is_set else None\n    self.title = kwargs.pop('title', None)\n    self.field_title_generator = kwargs.pop('field_title_generator', None)\n    self.description = kwargs.pop('description', None)\n    self.examples = kwargs.pop('examples', None)\n    self.exclude = kwargs.pop('exclude', None)\n    self.exclude_if = kwargs.pop('exclude_if', None)\n    self.discriminator = kwargs.pop('discriminator', None)\n    # For compatibility with FastAPI&lt;=0.110.0, we preserve the existing value if it is not overridden\n    self.deprecated = kwargs.pop('deprecated', getattr(self, 'deprecated', None))\n    self.repr = kwargs.pop('repr', True)\n    self.json_schema_extra = kwargs.pop('json_schema_extra', None)\n    self.validate_default = kwargs.pop('validate_default', None)\n    self.frozen = kwargs.pop('frozen', None)\n    # currently only used on dataclasses\n    self.init = kwargs.pop('init', None)\n    self.init_var = kwargs.pop('init_var', None)\n    self.kw_only = kwargs.pop('kw_only', None)\n\n    self.metadata = self._collect_metadata(kwargs)  # type: ignore\n\n    # Private attributes:\n    self._qualifiers: set[Qualifier] = set()\n    # Used to rebuild FieldInfo instances:\n    self._complete = True\n    self._original_annotation: Any = PydanticUndefined\n    self._original_assignment: Any = PydanticUndefined\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.from_field","title":"from_field  <code>staticmethod</code>","text":"<pre><code>from_field(default: Any = PydanticUndefined, **kwargs: Unpack[_FromFieldInfoInputs]) -&gt; FieldInfo\n</code></pre> <p>Create a new <code>FieldInfo</code> object with the <code>Field</code> function.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>default</code> <code>Any</code> <p>The default value for the field. Defaults to Undefined.</p> <code>PydanticUndefined</code> <code>**kwargs</code> <code>Unpack[_FromFieldInfoInputs]</code> <p>Additional arguments dictionary.</p> <code>{}</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>TypeError</code> <p>If 'annotation' is passed as a keyword argument.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>FieldInfo</code> <p>A new FieldInfo object with the given parameters.</p> Example <p>This is how you can create a field with default value like this:</p> <pre><code>import pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: int = pydantic.Field(4)\n</code></pre> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>@staticmethod\ndef from_field(default: Any = PydanticUndefined, **kwargs: Unpack[_FromFieldInfoInputs]) -&gt; FieldInfo:\n    \"\"\"Create a new `FieldInfo` object with the `Field` function.\n\n    Args:\n        default: The default value for the field. Defaults to Undefined.\n        **kwargs: Additional arguments dictionary.\n\n    Raises:\n        TypeError: If 'annotation' is passed as a keyword argument.\n\n    Returns:\n        A new FieldInfo object with the given parameters.\n\n    Example:\n        This is how you can create a field with default value like this:\n\n        ```python\n        import pydantic\n\n        class MyModel(pydantic.BaseModel):\n            foo: int = pydantic.Field(4)\n        ```\n    \"\"\"\n    if 'annotation' in kwargs:\n        raise TypeError('\"annotation\" is not permitted as a Field keyword argument')\n    return FieldInfo(default=default, **kwargs)\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.from_annotation","title":"from_annotation  <code>staticmethod</code>","text":"<pre><code>from_annotation(annotation: type[Any], *, _source: AnnotationSource = ANY) -&gt; FieldInfo\n</code></pre> <p>Creates a <code>FieldInfo</code> instance from a bare annotation.</p> <p>This function is used internally to create a <code>FieldInfo</code> from a bare annotation like this:</p> <pre><code>import pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: int  # &lt;-- like this\n</code></pre> <p>We also account for the case where the annotation can be an instance of <code>Annotated</code> and where one of the (not first) arguments in <code>Annotated</code> is an instance of <code>FieldInfo</code>, e.g.:</p> <pre><code>from typing import Annotated\n\nimport annotated_types\n\nimport pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: Annotated[int, annotated_types.Gt(42)]\n    bar: Annotated[int, pydantic.Field(gt=42)]\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>annotation</code> <code>type[Any]</code> <p>An annotation object.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>FieldInfo</code> <p>An instance of the field metadata.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>@staticmethod\ndef from_annotation(annotation: type[Any], *, _source: AnnotationSource = AnnotationSource.ANY) -&gt; FieldInfo:\n    \"\"\"Creates a `FieldInfo` instance from a bare annotation.\n\n    This function is used internally to create a `FieldInfo` from a bare annotation like this:\n\n    ```python\n    import pydantic\n\n    class MyModel(pydantic.BaseModel):\n        foo: int  # &lt;-- like this\n    ```\n\n    We also account for the case where the annotation can be an instance of `Annotated` and where\n    one of the (not first) arguments in `Annotated` is an instance of `FieldInfo`, e.g.:\n\n    ```python\n    from typing import Annotated\n\n    import annotated_types\n\n    import pydantic\n\n    class MyModel(pydantic.BaseModel):\n        foo: Annotated[int, annotated_types.Gt(42)]\n        bar: Annotated[int, pydantic.Field(gt=42)]\n    ```\n\n    Args:\n        annotation: An annotation object.\n\n    Returns:\n        An instance of the field metadata.\n    \"\"\"\n    try:\n        inspected_ann = inspect_annotation(\n            annotation,\n            annotation_source=_source,\n            unpack_type_aliases='skip',\n        )\n    except ForbiddenQualifier as e:\n        raise PydanticForbiddenQualifier(e.qualifier, annotation)\n\n    # TODO check for classvar and error?\n\n    # No assigned value, this happens when using a bare `Final` qualifier (also for other\n    # qualifiers, but they shouldn't appear here). In this case we infer the type as `Any`\n    # because we don't have any assigned value.\n    type_expr: Any = Any if inspected_ann.type is UNKNOWN else inspected_ann.type\n    final = 'final' in inspected_ann.qualifiers\n    metadata = inspected_ann.metadata\n\n    attr_overrides = {'annotation': type_expr}\n    if final:\n        attr_overrides['frozen'] = True\n    field_info = FieldInfo._construct(metadata, **attr_overrides)\n    field_info._qualifiers = inspected_ann.qualifiers\n    return field_info\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.from_annotated_attribute","title":"from_annotated_attribute  <code>staticmethod</code>","text":"<pre><code>from_annotated_attribute(annotation: type[Any], default: Any, *, _source: AnnotationSource = ANY) -&gt; FieldInfo\n</code></pre> <p>Create <code>FieldInfo</code> from an annotation with a default value.</p> <p>This is used in cases like the following:</p> <pre><code>from typing import Annotated\n\nimport annotated_types\n\nimport pydantic\n\nclass MyModel(pydantic.BaseModel):\n    foo: int = 4  # &lt;-- like this\n    bar: Annotated[int, annotated_types.Gt(4)] = 4  # &lt;-- or this\n    spam: Annotated[int, pydantic.Field(gt=4)] = 4  # &lt;-- or this\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>annotation</code> <code>type[Any]</code> <p>The type annotation of the field.</p> \u5fc5\u9700 <code>default</code> <code>Any</code> <p>The default value of the field.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>FieldInfo</code> <p>A field object with the passed values.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>@staticmethod\ndef from_annotated_attribute(\n    annotation: type[Any], default: Any, *, _source: AnnotationSource = AnnotationSource.ANY\n) -&gt; FieldInfo:\n    \"\"\"Create `FieldInfo` from an annotation with a default value.\n\n    This is used in cases like the following:\n\n    ```python\n    from typing import Annotated\n\n    import annotated_types\n\n    import pydantic\n\n    class MyModel(pydantic.BaseModel):\n        foo: int = 4  # &lt;-- like this\n        bar: Annotated[int, annotated_types.Gt(4)] = 4  # &lt;-- or this\n        spam: Annotated[int, pydantic.Field(gt=4)] = 4  # &lt;-- or this\n    ```\n\n    Args:\n        annotation: The type annotation of the field.\n        default: The default value of the field.\n\n    Returns:\n        A field object with the passed values.\n    \"\"\"\n    if annotation is not MISSING and annotation is default:\n        raise PydanticUserError(\n            'Error when building FieldInfo from annotated attribute. '\n            \"Make sure you don't have any field name clashing with a type annotation.\",\n            code='unevaluable-type-annotation',\n        )\n\n    try:\n        inspected_ann = inspect_annotation(\n            annotation,\n            annotation_source=_source,\n            unpack_type_aliases='skip',\n        )\n    except ForbiddenQualifier as e:\n        raise PydanticForbiddenQualifier(e.qualifier, annotation)\n\n    # TODO check for classvar and error?\n\n    # TODO infer from the default, this can be done in v3 once we treat final fields with\n    # a default as proper fields and not class variables:\n    type_expr: Any = Any if inspected_ann.type is UNKNOWN else inspected_ann.type\n    final = 'final' in inspected_ann.qualifiers\n    metadata = inspected_ann.metadata\n\n    # HACK 1: the order in which the metadata is merged is inconsistent; we need to prepend\n    # metadata from the assignment at the beginning of the metadata. Changing this is only\n    # possible in v3 (at least). See https://github.com/pydantic/pydantic/issues/10507\n    prepend_metadata: list[Any] | None = None\n    attr_overrides = {'annotation': type_expr}\n    if final:\n        attr_overrides['frozen'] = True\n\n    # HACK 2: FastAPI is subclassing `FieldInfo` and historically expected the actual\n    # instance's type to be preserved when constructing new models with its subclasses as assignments.\n    # This code is never reached by Pydantic itself, and in an ideal world this shouldn't be necessary.\n    if not metadata and isinstance(default, FieldInfo) and type(default) is not FieldInfo:\n        field_info = default._copy()\n        field_info._attributes_set.update(attr_overrides)\n        for k, v in attr_overrides.items():\n            setattr(field_info, k, v)\n        return field_info\n\n    if isinstance(default, FieldInfo):\n        default_copy = default._copy()  # Copy unnecessary when we remove HACK 1.\n        prepend_metadata = default_copy.metadata\n        default_copy.metadata = []\n        metadata = metadata + [default_copy]\n    elif isinstance(default, dataclasses.Field):\n        from_field = FieldInfo._from_dataclass_field(default)\n        prepend_metadata = from_field.metadata  # Unnecessary when we remove HACK 1.\n        from_field.metadata = []\n        metadata = metadata + [from_field]\n        if 'init_var' in inspected_ann.qualifiers:\n            attr_overrides['init_var'] = True\n        if (init := getattr(default, 'init', None)) is not None:\n            attr_overrides['init'] = init\n        if (kw_only := getattr(default, 'kw_only', None)) is not None:\n            attr_overrides['kw_only'] = kw_only\n    else:\n        # `default` is the actual default value\n        attr_overrides['default'] = default\n\n    field_info = FieldInfo._construct(\n        prepend_metadata + metadata if prepend_metadata is not None else metadata, **attr_overrides\n    )\n    field_info._qualifiers = inspected_ann.qualifiers\n    return field_info\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.merge_field_infos","title":"merge_field_infos  <code>staticmethod</code>","text":"<pre><code>merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -&gt; FieldInfo\n</code></pre> <p>Merge <code>FieldInfo</code> instances keeping only explicitly set attributes.</p> <p>Later <code>FieldInfo</code> instances override earlier ones.</p> <p>\u8fd4\u56de\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>FieldInfo</code> <code>FieldInfo</code> <p>A merged FieldInfo instance.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>@staticmethod\n@typing_extensions.deprecated(\n    \"The 'merge_field_infos()' method is deprecated and will be removed in a future version. \"\n    'If you relied on this method, please open an issue in the Pydantic issue tracker.',\n    category=None,\n)\ndef merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -&gt; FieldInfo:\n    \"\"\"Merge `FieldInfo` instances keeping only explicitly set attributes.\n\n    Later `FieldInfo` instances override earlier ones.\n\n    Returns:\n        FieldInfo: A merged FieldInfo instance.\n    \"\"\"\n    if len(field_infos) == 1:\n        # No merging necessary, but we still need to make a copy and apply the overrides\n        field_info = field_infos[0]._copy()\n        field_info._attributes_set.update(overrides)\n\n        default_override = overrides.pop('default', PydanticUndefined)\n        if default_override is Ellipsis:\n            default_override = PydanticUndefined\n        if default_override is not PydanticUndefined:\n            field_info.default = default_override\n\n        for k, v in overrides.items():\n            setattr(field_info, k, v)\n        return field_info  # type: ignore\n\n    merged_field_info_kwargs: dict[str, Any] = {}\n    metadata = {}\n    for field_info in field_infos:\n        attributes_set = field_info._attributes_set.copy()\n\n        try:\n            json_schema_extra = attributes_set.pop('json_schema_extra')\n            existing_json_schema_extra = merged_field_info_kwargs.get('json_schema_extra')\n\n            if existing_json_schema_extra is None:\n                merged_field_info_kwargs['json_schema_extra'] = json_schema_extra\n            if isinstance(existing_json_schema_extra, dict):\n                if isinstance(json_schema_extra, dict):\n                    merged_field_info_kwargs['json_schema_extra'] = {\n                        **existing_json_schema_extra,\n                        **json_schema_extra,\n                    }\n                if callable(json_schema_extra):\n                    warn(\n                        'Composing `dict` and `callable` type `json_schema_extra` is not supported.'\n                        'The `callable` type is being ignored.'\n                        \"If you'd like support for this behavior, please open an issue on pydantic.\",\n                        PydanticJsonSchemaWarning,\n                    )\n            elif callable(json_schema_extra):\n                # if ever there's a case of a callable, we'll just keep the last json schema extra spec\n                merged_field_info_kwargs['json_schema_extra'] = json_schema_extra\n        except KeyError:\n            pass\n\n        # later FieldInfo instances override everything except json_schema_extra from earlier FieldInfo instances\n        merged_field_info_kwargs.update(attributes_set)\n\n        for x in field_info.metadata:\n            if not isinstance(x, FieldInfo):\n                metadata[type(x)] = x\n\n    merged_field_info_kwargs.update(overrides)\n    field_info = FieldInfo(**merged_field_info_kwargs)\n    field_info.metadata = list(metadata.values())\n    return field_info\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.deprecation_message","title":"deprecation_message  <code>property</code>","text":"<pre><code>deprecation_message: str | None\n</code></pre> <p>The deprecation message to be emitted, or <code>None</code> if not set.</p>"},{"location":"api/fields/#pydantic.fields.FieldInfo.default_factory_takes_validated_data","title":"default_factory_takes_validated_data  <code>property</code>","text":"<pre><code>default_factory_takes_validated_data: bool | None\n</code></pre> <p>Whether the provided default factory callable has a validated data parameter.</p> <p>Returns <code>None</code> if no default factory is set.</p>"},{"location":"api/fields/#pydantic.fields.FieldInfo.get_default","title":"get_default","text":"<pre><code>get_default(*, call_default_factory: Literal[True], validated_data: dict[str, Any] | None = None) -&gt; Any\n</code></pre><pre><code>get_default(*, call_default_factory: Literal[False] = ...) -&gt; Any\n</code></pre> <pre><code>get_default(*, call_default_factory: bool = False, validated_data: dict[str, Any] | None = None) -&gt; Any\n</code></pre> <p>Get the default value.</p> <p>We expose an option for whether to call the default_factory (if present), as calling it may result in side effects that we want to avoid. However, there are times when it really should be called (namely, when instantiating a model via <code>model_construct</code>).</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>call_default_factory</code> <code>bool</code> <p>Whether to call the default factory or not.</p> <code>False</code> <code>validated_data</code> <code>dict[str, Any] | None</code> <p>The already validated data to be passed to the default factory.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The default value, calling the default factory if requested or <code>None</code> if not set.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def get_default(self, *, call_default_factory: bool = False, validated_data: dict[str, Any] | None = None) -&gt; Any:\n    \"\"\"Get the default value.\n\n    We expose an option for whether to call the default_factory (if present), as calling it may\n    result in side effects that we want to avoid. However, there are times when it really should\n    be called (namely, when instantiating a model via `model_construct`).\n\n    Args:\n        call_default_factory: Whether to call the default factory or not.\n        validated_data: The already validated data to be passed to the default factory.\n\n    Returns:\n        The default value, calling the default factory if requested or `None` if not set.\n    \"\"\"\n    if self.default_factory is None:\n        return _utils.smart_deepcopy(self.default)\n    elif call_default_factory:\n        if self.default_factory_takes_validated_data:\n            fac = cast('Callable[[dict[str, Any]], Any]', self.default_factory)\n            if validated_data is None:\n                raise ValueError(\n                    \"The default factory requires the 'validated_data' argument, which was not provided when calling 'get_default'.\"\n                )\n            return fac(validated_data)\n        else:\n            fac = cast('Callable[[], Any]', self.default_factory)\n            return fac()\n    else:\n        return None\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.is_required","title":"is_required","text":"<pre><code>is_required() -&gt; bool\n</code></pre> <p>Check if the field is required (i.e., does not have a default value or factory).</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool</code> <p><code>True</code> if the field is required, <code>False</code> otherwise.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def is_required(self) -&gt; bool:\n    \"\"\"Check if the field is required (i.e., does not have a default value or factory).\n\n    Returns:\n        `True` if the field is required, `False` otherwise.\n    \"\"\"\n    return self.default is PydanticUndefined and self.default_factory is None\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.rebuild_annotation","title":"rebuild_annotation","text":"<pre><code>rebuild_annotation() -&gt; Any\n</code></pre> <p>Attempts to rebuild the original annotation for use in function signatures.</p> <p>If metadata is present, it adds it to the original annotation using <code>Annotated</code>. Otherwise, it returns the original annotation as-is.</p> <p>Note that because the metadata has been flattened, the original annotation may not be reconstructed exactly as originally provided, e.g. if the original type had unrecognized annotations, or was annotated with a call to <code>pydantic.Field</code>.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The rebuilt annotation.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def rebuild_annotation(self) -&gt; Any:\n    \"\"\"Attempts to rebuild the original annotation for use in function signatures.\n\n    If metadata is present, it adds it to the original annotation using\n    `Annotated`. Otherwise, it returns the original annotation as-is.\n\n    Note that because the metadata has been flattened, the original annotation\n    may not be reconstructed exactly as originally provided, e.g. if the original\n    type had unrecognized annotations, or was annotated with a call to `pydantic.Field`.\n\n    Returns:\n        The rebuilt annotation.\n    \"\"\"\n    if not self.metadata:\n        return self.annotation\n    else:\n        # Annotated arguments must be a tuple\n        return Annotated[(self.annotation, *self.metadata)]  # type: ignore\n</code></pre>"},{"location":"api/fields/#pydantic.fields.FieldInfo.apply_typevars_map","title":"apply_typevars_map","text":"<pre><code>apply_typevars_map(typevars_map: Mapping[TypeVar, Any] | None, globalns: GlobalsNamespace | None = None, localns: MappingNamespace | None = None) -&gt; None\n</code></pre> <p>Apply a <code>typevars_map</code> to the annotation.</p> <p>This method is used when analyzing parametrized generic types to replace typevars with their concrete types.</p> <p>This method applies the <code>typevars_map</code> to the annotation in place.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>typevars_map</code> <code>Mapping[TypeVar, Any] | None</code> <p>A dictionary mapping type variables to their concrete types.</p> \u5fc5\u9700 <code>globalns</code> <code>GlobalsNamespace | None</code> <p>The globals namespace to use during type annotation evaluation.</p> <code>None</code> <code>localns</code> <code>MappingNamespace | None</code> <p>The locals namespace to use during type annotation evaluation.</p> <code>None</code> See Also <p>pydantic._internal._generics.replace_types is used for replacing the typevars with     their concrete types.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def apply_typevars_map(\n    self,\n    typevars_map: Mapping[TypeVar, Any] | None,\n    globalns: GlobalsNamespace | None = None,\n    localns: MappingNamespace | None = None,\n) -&gt; None:\n    \"\"\"Apply a `typevars_map` to the annotation.\n\n    This method is used when analyzing parametrized generic types to replace typevars with their concrete types.\n\n    This method applies the `typevars_map` to the annotation in place.\n\n    Args:\n        typevars_map: A dictionary mapping type variables to their concrete types.\n        globalns: The globals namespace to use during type annotation evaluation.\n        localns: The locals namespace to use during type annotation evaluation.\n\n    See Also:\n        pydantic._internal._generics.replace_types is used for replacing the typevars with\n            their concrete types.\n    \"\"\"\n    annotation = _generics.replace_types(self.annotation, typevars_map)\n    annotation, evaluated = _typing_extra.try_eval_type(annotation, globalns, localns)\n    self.annotation = annotation\n    if not evaluated:\n        self._complete = False\n        self._original_annotation = self.annotation\n</code></pre>"},{"location":"api/fields/#pydantic.fields.PrivateAttr","title":"PrivateAttr","text":"<pre><code>PrivateAttr(default: _T, *, init: Literal[False] = False) -&gt; _T\n</code></pre><pre><code>PrivateAttr(*, default_factory: Callable[[], _T], init: Literal[False] = False) -&gt; _T\n</code></pre><pre><code>PrivateAttr(*, init: Literal[False] = False) -&gt; Any\n</code></pre> <pre><code>PrivateAttr(default: Any = PydanticUndefined, *, default_factory: Callable[[], Any] | None = None, init: Literal[False] = False) -&gt; Any\n</code></pre> <p>Usage Documentation</p> <p>Private Model Attributes</p> <p>Indicates that an attribute is intended for private use and not handled during normal validation/serialization.</p> <p>Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.</p> <p>Private attributes are stored in <code>__private_attributes__</code> on the model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>default</code> <code>Any</code> <p>The attribute's default value. Defaults to Undefined.</p> <code>PydanticUndefined</code> <code>default_factory</code> <code>Callable[[], Any] | None</code> <p>Callable that will be called when a default value is needed for this attribute. If both <code>default</code> and <code>default_factory</code> are set, an error will be raised.</p> <code>None</code> <code>init</code> <code>Literal[False]</code> <p>Whether the attribute should be included in the constructor of the dataclass. Always <code>False</code>.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>An instance of <code>ModelPrivateAttr</code> class.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValueError</code> <p>If both <code>default</code> and <code>default_factory</code> are set.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def PrivateAttr(\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: Callable[[], Any] | None = None,\n    init: Literal[False] = False,\n) -&gt; Any:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Private Model Attributes](../concepts/models.md#private-model-attributes)\n\n    Indicates that an attribute is intended for private use and not handled during normal validation/serialization.\n\n    Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.\n\n    Private attributes are stored in `__private_attributes__` on the model.\n\n    Args:\n        default: The attribute's default value. Defaults to Undefined.\n        default_factory: Callable that will be\n            called when a default value is needed for this attribute.\n            If both `default` and `default_factory` are set, an error will be raised.\n        init: Whether the attribute should be included in the constructor of the dataclass. Always `False`.\n\n    Returns:\n        An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.\n\n    Raises:\n        ValueError: If both `default` and `default_factory` are set.\n    \"\"\"\n    if default is not PydanticUndefined and default_factory is not None:\n        raise TypeError('cannot specify both default and default_factory')\n\n    return ModelPrivateAttr(\n        default,\n        default_factory=default_factory,\n    )\n</code></pre>"},{"location":"api/fields/#pydantic.fields.ModelPrivateAttr","title":"ModelPrivateAttr","text":"<pre><code>ModelPrivateAttr(default: Any = PydanticUndefined, *, default_factory: Callable[[], Any] | None = None)\n</code></pre> <p>               Bases: <code>Representation</code></p> <p>A descriptor for private attributes in class models.</p> <p>Warning</p> <p>You generally shouldn't be creating <code>ModelPrivateAttr</code> instances directly, instead use <code>pydantic.fields.PrivateAttr</code>. (This is similar to <code>FieldInfo</code> vs. <code>Field</code>.)</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>default</code> <p>The default value of the attribute if not provided.</p> <code>default_factory</code> <p>A callable function that generates the default value of the attribute if not provided.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def __init__(self, default: Any = PydanticUndefined, *, default_factory: Callable[[], Any] | None = None) -&gt; None:\n    if default is Ellipsis:\n        self.default = PydanticUndefined\n    else:\n        self.default = default\n    self.default_factory = default_factory\n</code></pre>"},{"location":"api/fields/#pydantic.fields.ModelPrivateAttr.get_default","title":"get_default","text":"<pre><code>get_default() -&gt; Any\n</code></pre> <p>Retrieve the default value of the object.</p> <p>If <code>self.default_factory</code> is <code>None</code>, the method will return a deep copy of the <code>self.default</code> object.</p> <p>If <code>self.default_factory</code> is not <code>None</code>, it will call <code>self.default_factory</code> and return the value returned.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The default value of the object.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def get_default(self) -&gt; Any:\n    \"\"\"Retrieve the default value of the object.\n\n    If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.\n\n    If `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.\n\n    Returns:\n        The default value of the object.\n    \"\"\"\n    return _utils.smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()\n</code></pre>"},{"location":"api/fields/#pydantic.fields.computed_field","title":"computed_field","text":"<pre><code>computed_field(func: PropertyT) -&gt; PropertyT\n</code></pre><pre><code>computed_field(*, alias: str | None = None, alias_priority: int | None = None, title: str | None = None, field_title_generator: Callable[[str, ComputedFieldInfo], str] | None = None, description: str | None = None, deprecated: Deprecated | str | bool | None = None, examples: list[Any] | None = None, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = None, repr: bool = True, return_type: Any = PydanticUndefined) -&gt; Callable[[PropertyT], PropertyT]\n</code></pre> <pre><code>computed_field(func: PropertyT | None = None, /, *, alias: str | None = None, alias_priority: int | None = None, title: str | None = None, field_title_generator: Callable[[str, ComputedFieldInfo], str] | None = None, description: str | None = None, deprecated: Deprecated | str | bool | None = None, examples: list[Any] | None = None, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = None, repr: bool | None = None, return_type: Any = PydanticUndefined) -&gt; PropertyT | Callable[[PropertyT], PropertyT]\n</code></pre> <p>Usage Documentation</p> <p>The <code>computed_field</code> decorator</p> <p>Decorator to include <code>property</code> and <code>cached_property</code> when serializing models or dataclasses.</p> <p>This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.</p> <pre><code>from pydantic import BaseModel, computed_field\n\nclass Rectangle(BaseModel):\n    width: int\n    length: int\n\n    @computed_field\n    @property\n    def area(self) -&gt; int:\n        return self.width * self.length\n\nprint(Rectangle(width=3, length=2).model_dump())\n#&gt; {'width': 3, 'length': 2, 'area': 6}\n</code></pre> <p>If applied to functions not yet decorated with <code>@property</code> or <code>@cached_property</code>, the function is automatically wrapped with <code>property</code>. Although this is more concise, you will lose IntelliSense in your IDE, and confuse static type checkers, thus explicit use of <code>@property</code> is recommended.</p> <p>Mypy Warning</p> <p>Even with the <code>@property</code> or <code>@cached_property</code> applied to your function before <code>@computed_field</code>, mypy may throw a <code>Decorated property not supported</code> error. See mypy issue #1362, for more information. To avoid this error message, add <code># type: ignore[prop-decorator]</code> to the <code>@computed_field</code> line.</p> <p>pyright supports <code>@computed_field</code> without error.</p> <pre><code>import random\n\nfrom pydantic import BaseModel, computed_field\n\nclass Square(BaseModel):\n    width: float\n\n    @computed_field\n    def area(self) -&gt; float:  # converted to a `property` by `computed_field`\n        return round(self.width**2, 2)\n\n    @area.setter\n    def area(self, new_area: float) -&gt; None:\n        self.width = new_area**0.5\n\n    @computed_field(alias='the magic number', repr=False)\n    def random_number(self) -&gt; int:\n        return random.randint(0, 1_000)\n\nsquare = Square(width=1.3)\n\n# `random_number` does not appear in representation\nprint(repr(square))\n#&gt; Square(width=1.3, area=1.69)\n\nprint(square.random_number)\n#&gt; 3\n\nsquare.area = 4\n\nprint(square.model_dump_json(by_alias=True))\n#&gt; {\"width\":2.0,\"area\":4.0,\"the magic number\":3}\n</code></pre> <p>Overriding with <code>computed_field</code></p> <p>You can't override a field from a parent class with a <code>computed_field</code> in the child class. <code>mypy</code> complains about this behavior if allowed, and <code>dataclasses</code> doesn't allow this pattern either. See the example below:</p> <pre><code>from pydantic import BaseModel, computed_field\n\nclass Parent(BaseModel):\n    a: str\n\ntry:\n\n    class Child(Parent):\n        @computed_field\n        @property\n        def a(self) -&gt; str:\n            return 'new a'\n\nexcept TypeError as e:\n    print(e)\n    '''\n    Field 'a' of class 'Child' overrides symbol of same name in a parent class. This override with a computed_field is incompatible.\n    '''\n</code></pre> <p>Private properties decorated with <code>@computed_field</code> have <code>repr=False</code> by default.</p> <pre><code>from functools import cached_property\n\nfrom pydantic import BaseModel, computed_field\n\nclass Model(BaseModel):\n    foo: int\n\n    @computed_field\n    @cached_property\n    def _private_cached_property(self) -&gt; int:\n        return -self.foo\n\n    @computed_field\n    @property\n    def _private_property(self) -&gt; int:\n        return -self.foo\n\nm = Model(foo=1)\nprint(repr(m))\n#&gt; Model(foo=1)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>func</code> <code>PropertyT | None</code> <p>the function to wrap.</p> <code>None</code> <code>alias</code> <code>str | None</code> <p>alias to use when serializing this computed field, only used when <code>by_alias=True</code></p> <code>None</code> <code>alias_priority</code> <code>int | None</code> <p>priority of the alias. This affects whether an alias generator is used</p> <code>None</code> <code>title</code> <code>str | None</code> <p>Title to use when including this computed field in JSON Schema</p> <code>None</code> <code>field_title_generator</code> <code>Callable[[str, ComputedFieldInfo], str] | None</code> <p>A callable that takes a field name and returns title for it.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>Description to use when including this computed field in JSON Schema, defaults to the function's docstring</p> <code>None</code> <code>deprecated</code> <code>Deprecated | str | bool | None</code> <p>A deprecation message (or an instance of <code>warnings.deprecated</code> or the <code>typing_extensions.deprecated</code> backport). to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the <code>deprecated</code> decorator.</p> <code>None</code> <code>examples</code> <code>list[Any] | None</code> <p>Example values to use when including this computed field in JSON Schema</p> <code>None</code> <code>json_schema_extra</code> <code>JsonDict | Callable[[JsonDict], None] | None</code> <p>A dict or callable to provide extra JSON schema properties.</p> <code>None</code> <code>repr</code> <code>bool | None</code> <p>whether to include this computed field in model repr. Default is <code>False</code> for private properties and <code>True</code> for public properties.</p> <code>None</code> <code>return_type</code> <code>Any</code> <p>optional return for serialization logic to expect when serializing to JSON, if included this must be correct, otherwise a <code>TypeError</code> is raised. If you don't include a return type Any is used, which does runtime introspection to handle arbitrary objects.</p> <code>PydanticUndefined</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PropertyT | Callable[[PropertyT], PropertyT]</code> <p>A proxy wrapper for the property.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/fields.py</code> <pre><code>def computed_field(\n    func: PropertyT | None = None,\n    /,\n    *,\n    alias: str | None = None,\n    alias_priority: int | None = None,\n    title: str | None = None,\n    field_title_generator: Callable[[str, ComputedFieldInfo], str] | None = None,\n    description: str | None = None,\n    deprecated: Deprecated | str | bool | None = None,\n    examples: list[Any] | None = None,\n    json_schema_extra: JsonDict | Callable[[JsonDict], None] | None = None,\n    repr: bool | None = None,\n    return_type: Any = PydanticUndefined,\n) -&gt; PropertyT | Callable[[PropertyT], PropertyT]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [The `computed_field` decorator](../concepts/fields.md#the-computed_field-decorator)\n\n    Decorator to include `property` and `cached_property` when serializing models or dataclasses.\n\n    This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.\n\n    ```python\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -&gt; int:\n            return self.width * self.length\n\n    print(Rectangle(width=3, length=2).model_dump())\n    #&gt; {'width': 3, 'length': 2, 'area': 6}\n    ```\n\n    If applied to functions not yet decorated with `@property` or `@cached_property`, the function is\n    automatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,\n    and confuse static type checkers, thus explicit use of `@property` is recommended.\n\n    !!! warning \"Mypy Warning\"\n        Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,\n        mypy may throw a `Decorated property not supported` error.\n        See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.\n        To avoid this error message, add `# type: ignore[prop-decorator]` to the `@computed_field` line.\n\n        [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.\n\n    ```python\n    import random\n\n    from pydantic import BaseModel, computed_field\n\n    class Square(BaseModel):\n        width: float\n\n        @computed_field\n        def area(self) -&gt; float:  # converted to a `property` by `computed_field`\n            return round(self.width**2, 2)\n\n        @area.setter\n        def area(self, new_area: float) -&gt; None:\n            self.width = new_area**0.5\n\n        @computed_field(alias='the magic number', repr=False)\n        def random_number(self) -&gt; int:\n            return random.randint(0, 1_000)\n\n    square = Square(width=1.3)\n\n    # `random_number` does not appear in representation\n    print(repr(square))\n    #&gt; Square(width=1.3, area=1.69)\n\n    print(square.random_number)\n    #&gt; 3\n\n    square.area = 4\n\n    print(square.model_dump_json(by_alias=True))\n    #&gt; {\"width\":2.0,\"area\":4.0,\"the magic number\":3}\n    ```\n\n    !!! warning \"Overriding with `computed_field`\"\n        You can't override a field from a parent class with a `computed_field` in the child class.\n        `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.\n        See the example below:\n\n    ```python\n    from pydantic import BaseModel, computed_field\n\n    class Parent(BaseModel):\n        a: str\n\n    try:\n\n        class Child(Parent):\n            @computed_field\n            @property\n            def a(self) -&gt; str:\n                return 'new a'\n\n    except TypeError as e:\n        print(e)\n        '''\n        Field 'a' of class 'Child' overrides symbol of same name in a parent class. This override with a computed_field is incompatible.\n        '''\n    ```\n\n    Private properties decorated with `@computed_field` have `repr=False` by default.\n\n    ```python\n    from functools import cached_property\n\n    from pydantic import BaseModel, computed_field\n\n    class Model(BaseModel):\n        foo: int\n\n        @computed_field\n        @cached_property\n        def _private_cached_property(self) -&gt; int:\n            return -self.foo\n\n        @computed_field\n        @property\n        def _private_property(self) -&gt; int:\n            return -self.foo\n\n    m = Model(foo=1)\n    print(repr(m))\n    #&gt; Model(foo=1)\n    ```\n\n    Args:\n        func: the function to wrap.\n        alias: alias to use when serializing this computed field, only used when `by_alias=True`\n        alias_priority: priority of the alias. This affects whether an alias generator is used\n        title: Title to use when including this computed field in JSON Schema\n        field_title_generator: A callable that takes a field name and returns title for it.\n        description: Description to use when including this computed field in JSON Schema, defaults to the function's\n            docstring\n        deprecated: A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport).\n            to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the\n            `deprecated` decorator.\n        examples: Example values to use when including this computed field in JSON Schema\n        json_schema_extra: A dict or callable to provide extra JSON schema properties.\n        repr: whether to include this computed field in model repr.\n            Default is `False` for private properties and `True` for public properties.\n        return_type: optional return for serialization logic to expect when serializing to JSON, if included\n            this must be correct, otherwise a `TypeError` is raised.\n            If you don't include a return type Any is used, which does runtime introspection to handle arbitrary\n            objects.\n\n    Returns:\n        A proxy wrapper for the property.\n    \"\"\"\n\n    def dec(f: Any) -&gt; Any:\n        nonlocal description, deprecated, return_type, alias_priority\n        unwrapped = _decorators.unwrap_wrapped_function(f)\n\n        if description is None and unwrapped.__doc__:\n            description = inspect.cleandoc(unwrapped.__doc__)\n\n        if deprecated is None and hasattr(unwrapped, '__deprecated__'):\n            deprecated = unwrapped.__deprecated__\n\n        # if the function isn't already decorated with `@property` (or another descriptor), then we wrap it now\n        f = _decorators.ensure_property(f)\n        alias_priority = (alias_priority or 2) if alias is not None else None\n\n        if repr is None:\n            repr_: bool = not _wrapped_property_is_private(property_=f)\n        else:\n            repr_ = repr\n\n        dec_info = ComputedFieldInfo(\n            f,\n            return_type,\n            alias,\n            alias_priority,\n            title,\n            field_title_generator,\n            description,\n            deprecated,\n            examples,\n            json_schema_extra,\n            repr_,\n        )\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    if func is None:\n        return dec\n    else:\n        return dec(func)\n</code></pre>"},{"location":"api/fields/#pydantic.fields.ComputedFieldInfo","title":"ComputedFieldInfo  <code>dataclass</code>","text":"<pre><code>ComputedFieldInfo(wrapped_property: property, return_type: Any, alias: str | None, alias_priority: int | None, title: str | None, field_title_generator: Callable[[str, ComputedFieldInfo], str] | None, description: str | None, deprecated: Deprecated | str | bool | None, examples: list[Any] | None, json_schema_extra: JsonDict | Callable[[JsonDict], None] | None, repr: bool)\n</code></pre> <p>A container for data from <code>@computed_field</code> so that we can access it while building the pydantic-core schema.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>decorator_repr</code> <code>str</code> <p>A class variable representing the decorator string, '@computed_field'.</p> <code>wrapped_property</code> <code>property</code> <p>The wrapped computed field property.</p> <code>return_type</code> <code>Any</code> <p>The type of the computed field property's return value.</p> <code>alias</code> <code>str | None</code> <p>The alias of the property to be used during serialization.</p> <code>alias_priority</code> <code>int | None</code> <p>The priority of the alias. This affects whether an alias generator is used.</p> <code>title</code> <code>str | None</code> <p>Title of the computed field to include in the serialization JSON schema.</p> <code>field_title_generator</code> <code>Callable[[str, ComputedFieldInfo], str] | None</code> <p>A callable that takes a field name and returns title for it.</p> <code>description</code> <code>str | None</code> <p>Description of the computed field to include in the serialization JSON schema.</p> <code>deprecated</code> <code>Deprecated | str | bool | None</code> <p>A deprecation message, an instance of <code>warnings.deprecated</code> or the <code>typing_extensions.deprecated</code> backport, or a boolean. If <code>True</code>, a default deprecation message will be emitted when accessing the field.</p> <code>examples</code> <code>list[Any] | None</code> <p>Example values of the computed field to include in the serialization JSON schema.</p> <code>json_schema_extra</code> <code>JsonDict | Callable[[JsonDict], None] | None</code> <p>A dict or callable to provide extra JSON schema properties.</p> <code>repr</code> <code>bool</code> <p>A boolean indicating whether to include the field in the repr output.</p>"},{"location":"api/fields/#pydantic.fields.ComputedFieldInfo.deprecation_message","title":"deprecation_message  <code>property</code>","text":"<pre><code>deprecation_message: str | None\n</code></pre> <p>The deprecation message to be emitted, or <code>None</code> if not set.</p>"},{"location":"api/functional_serializers/","title":"Functional Serializers","text":"<p>This module contains related classes and functions for serialization.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.FieldPlainSerializer","title":"FieldPlainSerializer  <code>module-attribute</code>","text":"<pre><code>FieldPlainSerializer: TypeAlias = 'core_schema.SerializerFunction | _Partial'\n</code></pre> <p>A field serializer method or function in <code>plain</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.FieldWrapSerializer","title":"FieldWrapSerializer  <code>module-attribute</code>","text":"<pre><code>FieldWrapSerializer: TypeAlias = 'core_schema.WrapSerializerFunction | _Partial'\n</code></pre> <p>A field serializer method or function in <code>wrap</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.FieldSerializer","title":"FieldSerializer  <code>module-attribute</code>","text":"<pre><code>FieldSerializer: TypeAlias = 'FieldPlainSerializer | FieldWrapSerializer'\n</code></pre> <p>A field serializer method or function.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.ModelPlainSerializerWithInfo","title":"ModelPlainSerializerWithInfo  <code>module-attribute</code>","text":"<pre><code>ModelPlainSerializerWithInfo: TypeAlias = Callable[[Any, SerializationInfo[Any]], Any]\n</code></pre> <p>A model serializer method with the <code>info</code> argument, in <code>plain</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.ModelPlainSerializerWithoutInfo","title":"ModelPlainSerializerWithoutInfo  <code>module-attribute</code>","text":"<pre><code>ModelPlainSerializerWithoutInfo: TypeAlias = Callable[[Any], Any]\n</code></pre> <p>A model serializer method without the <code>info</code> argument, in <code>plain</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.ModelPlainSerializer","title":"ModelPlainSerializer  <code>module-attribute</code>","text":"<pre><code>ModelPlainSerializer: TypeAlias = 'ModelPlainSerializerWithInfo | ModelPlainSerializerWithoutInfo'\n</code></pre> <p>A model serializer method in <code>plain</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.ModelWrapSerializerWithInfo","title":"ModelWrapSerializerWithInfo  <code>module-attribute</code>","text":"<pre><code>ModelWrapSerializerWithInfo: TypeAlias = Callable[[Any, SerializerFunctionWrapHandler, SerializationInfo[Any]], Any]\n</code></pre> <p>A model serializer method with the <code>info</code> argument, in <code>wrap</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.ModelWrapSerializerWithoutInfo","title":"ModelWrapSerializerWithoutInfo  <code>module-attribute</code>","text":"<pre><code>ModelWrapSerializerWithoutInfo: TypeAlias = Callable[[Any, SerializerFunctionWrapHandler], Any]\n</code></pre> <p>A model serializer method without the <code>info</code> argument, in <code>wrap</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.ModelWrapSerializer","title":"ModelWrapSerializer  <code>module-attribute</code>","text":"<pre><code>ModelWrapSerializer: TypeAlias = 'ModelWrapSerializerWithInfo | ModelWrapSerializerWithoutInfo'\n</code></pre> <p>A model serializer method in <code>wrap</code> mode.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.PlainSerializer","title":"PlainSerializer  <code>dataclass</code>","text":"<pre><code>PlainSerializer(func: SerializerFunction, return_type: Any = PydanticUndefined, when_used: WhenUsed = 'always')\n</code></pre> <p>Plain serializers use a function to modify the output of serialization.</p> <p>This is particularly helpful when you want to customize the serialization for annotated types. Consider an input of <code>list</code>, which will be serialized into a space-delimited string.</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\nCustomStr = Annotated[\n    list, PlainSerializer(lambda x: ' '.join(x), return_type=str)\n]\n\nclass StudentModel(BaseModel):\n    courses: CustomStr\n\nstudent = StudentModel(courses=['Math', 'Chemistry', 'English'])\nprint(student.model_dump())\n#&gt; {'courses': 'Math Chemistry English'}\n</code></pre> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>func</code> <code>SerializerFunction</code> <p>The serializer function.</p> <code>return_type</code> <code>Any</code> <p>The return type for the function. If omitted it will be inferred from the type annotation.</p> <code>when_used</code> <code>WhenUsed</code> <p>Determines when this serializer should be used. Accepts a string with values <code>'always'</code>, <code>'unless-none'</code>, <code>'json'</code>, and <code>'json-unless-none'</code>. Defaults to 'always'.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.WrapSerializer","title":"WrapSerializer  <code>dataclass</code>","text":"<pre><code>WrapSerializer(func: WrapSerializerFunction, return_type: Any = PydanticUndefined, when_used: WhenUsed = 'always')\n</code></pre> <p>Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization logic, and can modify the resulting value before returning it as the final output of serialization.</p> <p>For example, here's a scenario in which a wrap serializer transforms timezones to UTC and utilizes the existing <code>datetime</code> serialization logic.</p> <pre><code>from datetime import datetime, timezone\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, WrapSerializer\n\nclass EventDatetime(BaseModel):\n    start: datetime\n    end: datetime\n\ndef convert_to_utc(value: Any, handler, info) -&gt; dict[str, datetime]:\n    # Note that `handler` can actually help serialize the `value` for\n    # further custom serialization in case it's a subclass.\n    partial_result = handler(value, info)\n    if info.mode == 'json':\n        return {\n            k: datetime.fromisoformat(v).astimezone(timezone.utc)\n            for k, v in partial_result.items()\n        }\n    return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()}\n\nUTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)]\n\nclass EventModel(BaseModel):\n    event_datetime: UTCEventDatetime\n\ndt = EventDatetime(\n    start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00'\n)\nevent = EventModel(event_datetime=dt)\nprint(event.model_dump())\n'''\n{\n    'event_datetime': {\n        'start': datetime.datetime(\n            2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc\n        ),\n        'end': datetime.datetime(\n            2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc\n        ),\n    }\n}\n'''\n\nprint(event.model_dump_json())\n'''\n{\"event_datetime\":{\"start\":\"2024-01-01T15:00:00Z\",\"end\":\"2024-01-03T14:00:00Z\"}}\n'''\n</code></pre> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>func</code> <code>WrapSerializerFunction</code> <p>The serializer function to be wrapped.</p> <code>return_type</code> <code>Any</code> <p>The return type for the function. If omitted it will be inferred from the type annotation.</p> <code>when_used</code> <code>WhenUsed</code> <p>Determines when this serializer should be used. Accepts a string with values <code>'always'</code>, <code>'unless-none'</code>, <code>'json'</code>, and <code>'json-unless-none'</code>. Defaults to 'always'.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.SerializeAsAny","title":"SerializeAsAny  <code>dataclass</code>","text":"<pre><code>SerializeAsAny()\n</code></pre> <p>Annotation used to mark a type as having duck-typing serialization behavior.</p> <p>See usage documentation for more details.</p>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.field_serializer","title":"field_serializer","text":"<pre><code>field_serializer(field: str, /, *fields: str, mode: Literal['wrap'], return_type: Any = ..., when_used: WhenUsed = ..., check_fields: bool | None = ...) -&gt; Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT]\n</code></pre><pre><code>field_serializer(field: str, /, *fields: str, mode: Literal['plain'] = ..., return_type: Any = ..., when_used: WhenUsed = ..., check_fields: bool | None = ...) -&gt; Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]\n</code></pre> <pre><code>field_serializer(*fields: str, mode: Literal['plain', 'wrap'] = 'plain', return_type: Any = PydanticUndefined, when_used: WhenUsed = 'always', check_fields: bool | None = None) -&gt; Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT] | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]\n</code></pre> <p>Decorator that enables custom field serialization.</p> <p>In the below example, a field of type <code>set</code> is used to mitigate duplication. A <code>field_serializer</code> is used to serialize the data as a sorted list.</p> <pre><code>from pydantic import BaseModel, field_serializer\n\nclass StudentModel(BaseModel):\n    name: str = 'Jane'\n    courses: set[str]\n\n    @field_serializer('courses', when_used='json')\n    def serialize_courses_in_order(self, courses: set[str]):\n        return sorted(courses)\n\nstudent = StudentModel(courses={'Math', 'Chemistry', 'English'})\nprint(student.model_dump_json())\n#&gt; {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}\n</code></pre> <p>See the usage documentation for more information.</p> <p>Four signatures are supported:</p> <ul> <li><code>(self, value: Any, info: FieldSerializationInfo)</code></li> <li><code>(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)</code></li> <li><code>(value: Any, info: SerializationInfo)</code></li> <li><code>(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)</code></li> </ul> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>fields</code> <code>str</code> <p>Which field(s) the method should be called on.</p> <code>()</code> <code>mode</code> <code>Literal['plain', 'wrap']</code> <p>The serialization mode.</p> <ul> <li><code>plain</code> means the function will be called instead of the default serialization logic,</li> <li><code>wrap</code> means the function will be called with an argument to optionally call the    default serialization logic.</li> </ul> <code>'plain'</code> <code>return_type</code> <code>Any</code> <p>Optional return type for the function, if omitted it will be inferred from the type annotation.</p> <code>PydanticUndefined</code> <code>when_used</code> <code>WhenUsed</code> <p>Determines the serializer will be used for serialization.</p> <code>'always'</code> <code>check_fields</code> <code>bool | None</code> <p>Whether to check that the fields actually exist on the model.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT] | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]</code> <p>The decorator function.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/functional_serializers.py</code> <pre><code>def field_serializer(\n    *fields: str,\n    mode: Literal['plain', 'wrap'] = 'plain',\n    # TODO PEP 747 (grep for 'return_type' on the whole code base):\n    return_type: Any = PydanticUndefined,\n    when_used: WhenUsed = 'always',\n    check_fields: bool | None = None,\n) -&gt; (\n    Callable[[_FieldWrapSerializerT], _FieldWrapSerializerT]\n    | Callable[[_FieldPlainSerializerT], _FieldPlainSerializerT]\n):\n    \"\"\"Decorator that enables custom field serialization.\n\n    In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.\n\n    ```python\n    from pydantic import BaseModel, field_serializer\n\n    class StudentModel(BaseModel):\n        name: str = 'Jane'\n        courses: set[str]\n\n        @field_serializer('courses', when_used='json')\n        def serialize_courses_in_order(self, courses: set[str]):\n            return sorted(courses)\n\n    student = StudentModel(courses={'Math', 'Chemistry', 'English'})\n    print(student.model_dump_json())\n    #&gt; {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}\n    ```\n\n    See [the usage documentation](../concepts/serialization.md#serializers) for more information.\n\n    Four signatures are supported:\n\n    - `(self, value: Any, info: FieldSerializationInfo)`\n    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n    - `(value: Any, info: SerializationInfo)`\n    - `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\n    Args:\n        fields: Which field(s) the method should be called on.\n        mode: The serialization mode.\n\n            - `plain` means the function will be called instead of the default serialization logic,\n            - `wrap` means the function will be called with an argument to optionally call the\n               default serialization logic.\n        return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.\n        when_used: Determines the serializer will be used for serialization.\n        check_fields: Whether to check that the fields actually exist on the model.\n\n    Returns:\n        The decorator function.\n    \"\"\"\n\n    def dec(f: FieldSerializer) -&gt; _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.FieldSerializerDecoratorInfo(\n            fields=fields,\n            mode=mode,\n            return_type=return_type,\n            when_used=when_used,\n            check_fields=check_fields,\n        )\n        return _decorators.PydanticDescriptorProxy(f, dec_info)  # pyright: ignore[reportArgumentType]\n\n    return dec  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/functional_serializers/#pydantic.functional_serializers.model_serializer","title":"model_serializer","text":"<pre><code>model_serializer(f: _ModelPlainSerializerT) -&gt; _ModelPlainSerializerT\n</code></pre><pre><code>model_serializer(*, mode: Literal['wrap'], when_used: WhenUsed = 'always', return_type: Any = ...) -&gt; Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT]\n</code></pre><pre><code>model_serializer(*, mode: Literal['plain'] = ..., when_used: WhenUsed = 'always', return_type: Any = ...) -&gt; Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]\n</code></pre> <pre><code>model_serializer(f: _ModelPlainSerializerT | _ModelWrapSerializerT | None = None, /, *, mode: Literal['plain', 'wrap'] = 'plain', when_used: WhenUsed = 'always', return_type: Any = PydanticUndefined) -&gt; _ModelPlainSerializerT | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT] | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]\n</code></pre> <p>Decorator that enables custom model serialization.</p> <p>This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.</p> <p>An example would be to serialize temperature to the same temperature scale, such as degrees Celsius.</p> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, model_serializer\n\nclass TemperatureModel(BaseModel):\n    unit: Literal['C', 'F']\n    value: int\n\n    @model_serializer()\n    def serialize_model(self):\n        if self.unit == 'F':\n            return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}\n        return {'unit': self.unit, 'value': self.value}\n\ntemperature = TemperatureModel(unit='F', value=212)\nprint(temperature.model_dump())\n#&gt; {'unit': 'C', 'value': 100}\n</code></pre> <p>Two signatures are supported for <code>mode='plain'</code>, which is the default:</p> <ul> <li><code>(self)</code></li> <li><code>(self, info: SerializationInfo)</code></li> </ul> <p>And two other signatures for <code>mode='wrap'</code>:</p> <ul> <li><code>(self, nxt: SerializerFunctionWrapHandler)</code></li> <li> <p><code>(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)</code></p> <p>See the usage documentation for more information.</p> </li> </ul> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>f</code> <code>_ModelPlainSerializerT | _ModelWrapSerializerT | None</code> <p>The function to be decorated.</p> <code>None</code> <code>mode</code> <code>Literal['plain', 'wrap']</code> <p>The serialization mode.</p> <ul> <li><code>'plain'</code> means the function will be called instead of the default serialization logic</li> <li><code>'wrap'</code> means the function will be called with an argument to optionally call the default     serialization logic.</li> </ul> <code>'plain'</code> <code>when_used</code> <code>WhenUsed</code> <p>Determines when this serializer should be used.</p> <code>'always'</code> <code>return_type</code> <code>Any</code> <p>The return type for the function. If omitted it will be inferred from the type annotation.</p> <code>PydanticUndefined</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>_ModelPlainSerializerT | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT] | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]</code> <p>The decorator function.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/functional_serializers.py</code> <pre><code>def model_serializer(\n    f: _ModelPlainSerializerT | _ModelWrapSerializerT | None = None,\n    /,\n    *,\n    mode: Literal['plain', 'wrap'] = 'plain',\n    when_used: WhenUsed = 'always',\n    return_type: Any = PydanticUndefined,\n) -&gt; (\n    _ModelPlainSerializerT\n    | Callable[[_ModelWrapSerializerT], _ModelWrapSerializerT]\n    | Callable[[_ModelPlainSerializerT], _ModelPlainSerializerT]\n):\n    \"\"\"Decorator that enables custom model serialization.\n\n    This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.\n\n    An example would be to serialize temperature to the same temperature scale, such as degrees Celsius.\n\n    ```python\n    from typing import Literal\n\n    from pydantic import BaseModel, model_serializer\n\n    class TemperatureModel(BaseModel):\n        unit: Literal['C', 'F']\n        value: int\n\n        @model_serializer()\n        def serialize_model(self):\n            if self.unit == 'F':\n                return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}\n            return {'unit': self.unit, 'value': self.value}\n\n    temperature = TemperatureModel(unit='F', value=212)\n    print(temperature.model_dump())\n    #&gt; {'unit': 'C', 'value': 100}\n    ```\n\n    Two signatures are supported for `mode='plain'`, which is the default:\n\n    - `(self)`\n    - `(self, info: SerializationInfo)`\n\n    And two other signatures for `mode='wrap'`:\n\n    - `(self, nxt: SerializerFunctionWrapHandler)`\n    - `(self, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\n        See [the usage documentation](../concepts/serialization.md#serializers) for more information.\n\n    Args:\n        f: The function to be decorated.\n        mode: The serialization mode.\n\n            - `'plain'` means the function will be called instead of the default serialization logic\n            - `'wrap'` means the function will be called with an argument to optionally call the default\n                serialization logic.\n        when_used: Determines when this serializer should be used.\n        return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n\n    Returns:\n        The decorator function.\n    \"\"\"\n\n    def dec(f: ModelSerializer) -&gt; _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used)\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    if f is None:\n        return dec  # pyright: ignore[reportReturnType]\n    else:\n        return dec(f)  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/functional_validators/","title":"Functional Validators","text":"<p>This module contains related classes and functions for validation.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelAfterValidatorWithoutInfo","title":"ModelAfterValidatorWithoutInfo  <code>module-attribute</code>","text":"<pre><code>ModelAfterValidatorWithoutInfo = Callable[[_ModelType], _ModelType]\n</code></pre> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='after'</code> and the function does not have info argument.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelAfterValidator","title":"ModelAfterValidator  <code>module-attribute</code>","text":"<pre><code>ModelAfterValidator = Callable[[_ModelType, ValidationInfo[Any]], _ModelType]\n</code></pre> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='after'</code>.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.AfterValidator","title":"AfterValidator  <code>dataclass</code>","text":"<pre><code>AfterValidator(func: NoInfoValidatorFunction | WithInfoValidatorFunction)\n</code></pre> <p>Usage Documentation</p> <p>field after validators</p> <p>A metadata class that indicates that a validation should be applied after the inner validation logic.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>func</code> <code>NoInfoValidatorFunction | WithInfoValidatorFunction</code> <p>The validator function.</p> Example <pre><code>from typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationError\n\nMyInt = Annotated[int, AfterValidator(lambda v: v + 1)]\n\nclass Model(BaseModel):\n    a: MyInt\n\nprint(Model(a=1).a)\n#&gt; 2\n\ntry:\n    Model(a='a')\nexcept ValidationError as e:\n    print(e.json(indent=2))\n    '''\n    [\n      {\n        \"type\": \"int_parsing\",\n        \"loc\": [\n          \"a\"\n        ],\n        \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n        \"input\": \"a\",\n        \"url\": \"https://errors.pydantic.dev/2/v/int_parsing\"\n      }\n    ]\n    '''\n</code></pre>"},{"location":"api/functional_validators/#pydantic.functional_validators.BeforeValidator","title":"BeforeValidator  <code>dataclass</code>","text":"<pre><code>BeforeValidator(func: NoInfoValidatorFunction | WithInfoValidatorFunction, json_schema_input_type: Any = PydanticUndefined)\n</code></pre> <p>Usage Documentation</p> <p>field before validators</p> <p>A metadata class that indicates that a validation should be applied before the inner validation logic.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>func</code> <code>NoInfoValidatorFunction | WithInfoValidatorFunction</code> <p>The validator function.</p> <code>json_schema_input_type</code> <code>Any</code> <p>The input type used to generate the appropriate JSON Schema (in validation mode). The actual input type is <code>Any</code>.</p> Example <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, BeforeValidator\n\nMyInt = Annotated[int, BeforeValidator(lambda v: v + 1)]\n\nclass Model(BaseModel):\n    a: MyInt\n\nprint(Model(a=1).a)\n#&gt; 2\n\ntry:\n    Model(a='a')\nexcept TypeError as e:\n    print(e)\n    #&gt; can only concatenate str (not \"int\") to str\n</code></pre>"},{"location":"api/functional_validators/#pydantic.functional_validators.PlainValidator","title":"PlainValidator  <code>dataclass</code>","text":"<pre><code>PlainValidator(func: NoInfoValidatorFunction | WithInfoValidatorFunction, json_schema_input_type: Any = Any)\n</code></pre> <p>Usage Documentation</p> <p>field plain validators</p> <p>A metadata class that indicates that a validation should be applied instead of the inner validation logic.</p> <p>Note</p> <p>Before v2.9, <code>PlainValidator</code> wasn't always compatible with JSON Schema generation for <code>mode='validation'</code>. You can now use the <code>json_schema_input_type</code> argument to specify the input type of the function to be used in the JSON schema when <code>mode='validation'</code> (the default). See the example below for more details.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>func</code> <code>NoInfoValidatorFunction | WithInfoValidatorFunction</code> <p>The validator function.</p> <code>json_schema_input_type</code> <code>Any</code> <p>The input type used to generate the appropriate JSON Schema (in validation mode). The actual input type is <code>Any</code>.</p> Example <pre><code>from typing import Annotated, Union\n\nfrom pydantic import BaseModel, PlainValidator\n\ndef validate(v: object) -&gt; int:\n    if not isinstance(v, (int, str)):\n        raise ValueError(f'Expected int or str, go {type(v)}')\n\n    return int(v) + 1\n\nMyInt = Annotated[\n    int,\n    PlainValidator(validate, json_schema_input_type=Union[str, int]),  # (1)!\n]\n\nclass Model(BaseModel):\n    a: MyInt\n\nprint(Model(a='1').a)\n#&gt; 2\n\nprint(Model(a=1).a)\n#&gt; 2\n</code></pre> <ol> <li>In this example, we've specified the <code>json_schema_input_type</code> as <code>Union[str, int]</code> which indicates to the JSON schema generator that in validation mode, the input type for the <code>a</code> field can be either a <code>str</code> or an <code>int</code>.</li> </ol>"},{"location":"api/functional_validators/#pydantic.functional_validators.WrapValidator","title":"WrapValidator  <code>dataclass</code>","text":"<pre><code>WrapValidator(func: NoInfoWrapValidatorFunction | WithInfoWrapValidatorFunction, json_schema_input_type: Any = PydanticUndefined)\n</code></pre> <p>Usage Documentation</p> <p>field wrap validators</p> <p>A metadata class that indicates that a validation should be applied around the inner validation logic.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>func</code> <code>NoInfoWrapValidatorFunction | WithInfoWrapValidatorFunction</code> <p>The validator function.</p> <code>json_schema_input_type</code> <code>Any</code> <p>The input type used to generate the appropriate JSON Schema (in validation mode). The actual input type is <code>Any</code>.</p> <pre><code>from datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\ndef validate_timestamp(v, handler):\n    if v == 'now':\n        # we don't want to bother with further validation, just return the new value\n        return datetime.now()\n    try:\n        return handler(v)\n    except ValidationError:\n        # validation failed, in this case we want to return a default value\n        return datetime(2000, 1, 1)\n\nMyTimestamp = Annotated[datetime, WrapValidator(validate_timestamp)]\n\nclass Model(BaseModel):\n    a: MyTimestamp\n\nprint(Model(a='now').a)\n#&gt; 2032-01-02 03:04:05.000006\nprint(Model(a='invalid').a)\n#&gt; 2000-01-01 00:00:00\n</code></pre>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelWrapValidatorHandler","title":"ModelWrapValidatorHandler","text":"<p>               Bases: <code>ValidatorFunctionWrapHandler</code>, <code>Protocol[_ModelTypeCo]</code></p> <p><code>@model_validator</code> decorated function handler argument type. This is used when <code>mode='wrap'</code>.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelWrapValidatorWithoutInfo","title":"ModelWrapValidatorWithoutInfo","text":"<p>               Bases: <code>Protocol[_ModelType]</code></p> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='wrap'</code> and the function does not have info argument.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelWrapValidator","title":"ModelWrapValidator","text":"<p>               Bases: <code>Protocol[_ModelType]</code></p> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='wrap'</code>.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.FreeModelBeforeValidatorWithoutInfo","title":"FreeModelBeforeValidatorWithoutInfo","text":"<p>               Bases: <code>Protocol</code></p> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='before'</code> and the function does not have info argument.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelBeforeValidatorWithoutInfo","title":"ModelBeforeValidatorWithoutInfo","text":"<p>               Bases: <code>Protocol</code></p> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='before'</code> and the function does not have info argument.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.FreeModelBeforeValidator","title":"FreeModelBeforeValidator","text":"<p>               Bases: <code>Protocol</code></p> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='before'</code>.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ModelBeforeValidator","title":"ModelBeforeValidator","text":"<p>               Bases: <code>Protocol</code></p> <p>A <code>@model_validator</code> decorated function signature. This is used when <code>mode='before'</code>.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.InstanceOf","title":"InstanceOf  <code>dataclass</code>","text":"<pre><code>InstanceOf()\n</code></pre> <p>Generic type for annotating a type that is an instance of a given class.</p> Example <pre><code>from pydantic import BaseModel, InstanceOf\n\nclass Foo:\n    ...\n\nclass Bar(BaseModel):\n    foo: InstanceOf[Foo]\n\nBar(foo=Foo())\ntry:\n    Bar(foo=42)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    [\n    \u2502   {\n    \u2502   \u2502   'type': 'is_instance_of',\n    \u2502   \u2502   'loc': ('foo',),\n    \u2502   \u2502   'msg': 'Input should be an instance of Foo',\n    \u2502   \u2502   'input': 42,\n    \u2502   \u2502   'ctx': {'class': 'Foo'},\n    \u2502   \u2502   'url': 'https://errors.pydantic.dev/0.38.0/v/is_instance_of'\n    \u2502   }\n    ]\n    \"\"\"\n</code></pre>"},{"location":"api/functional_validators/#pydantic.functional_validators.SkipValidation","title":"SkipValidation  <code>dataclass</code>","text":"<pre><code>SkipValidation()\n</code></pre> <p>If this is applied as an annotation (e.g., via <code>x: Annotated[int, SkipValidation]</code>), validation will be     skipped. You can also use <code>SkipValidation[int]</code> as a shorthand for <code>Annotated[int, SkipValidation]</code>.</p> <p>This can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes, and know that it is safe to skip validation for one or more of the fields.</p> <p>Because this converts the validation schema to <code>any_schema</code>, subsequent annotation-applied transformations may not have the expected effects. Therefore, when used, this annotation should generally be the final annotation applied to a type.</p>"},{"location":"api/functional_validators/#pydantic.functional_validators.ValidateAs","title":"ValidateAs","text":"<pre><code>ValidateAs(from_type: type[_FromTypeT], /, instantiation_hook: Callable[[_FromTypeT], Any])\n</code></pre> <p>A helper class to validate a custom type from a type that is natively supported by Pydantic.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>from_type</code> <code>type[_FromTypeT]</code> <p>The type natively supported by Pydantic to use to perform validation.</p> \u5fc5\u9700 <code>instantiation_hook</code> <code>Callable[[_FromTypeT], Any]</code> <p>A callable taking the validated type as an argument, and returning the populated custom type.</p> \u5fc5\u9700 Example <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, TypeAdapter, ValidateAs\n\nclass MyCls:\n    def __init__(self, a: int) -&gt; None:\n        self.a = a\n\n    def __repr__(self) -&gt; str:\n        return f\"MyCls(a={self.a})\"\n\nclass Model(BaseModel):\n    a: int\n\n\nta = TypeAdapter(\n    Annotated[MyCls, ValidateAs(Model, lambda v: MyCls(a=v.a))]\n)\n\nprint(ta.validate_python({'a': 1}))\n#&gt; MyCls(a=1)\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/functional_validators.py</code> <pre><code>def __init__(self, from_type: type[_FromTypeT], /, instantiation_hook: Callable[[_FromTypeT], Any]) -&gt; None:\n    self.from_type = from_type\n    self.instantiation_hook = instantiation_hook\n</code></pre>"},{"location":"api/functional_validators/#pydantic.functional_validators.field_validator","title":"field_validator","text":"<pre><code>field_validator(field: str, /, *fields: str, mode: Literal['wrap'], check_fields: bool | None = ..., json_schema_input_type: Any = ...) -&gt; Callable[[_V2WrapValidatorType], _V2WrapValidatorType]\n</code></pre><pre><code>field_validator(field: str, /, *fields: str, mode: Literal['before', 'plain'], check_fields: bool | None = ..., json_schema_input_type: Any = ...) -&gt; Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]\n</code></pre><pre><code>field_validator(field: str, /, *fields: str, mode: Literal['after'] = ..., check_fields: bool | None = ...) -&gt; Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]\n</code></pre> <pre><code>field_validator(field: str, /, *fields: str, mode: FieldValidatorModes = 'after', check_fields: bool | None = None, json_schema_input_type: Any = PydanticUndefined) -&gt; Callable[[Any], Any]\n</code></pre> <p>Usage Documentation</p> <p>field validators</p> <p>Decorate methods on the class indicating that they should be used to validate fields.</p> <p>Example usage: <pre><code>from typing import Any\n\nfrom pydantic import (\n    BaseModel,\n    ValidationError,\n    field_validator,\n)\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    @classmethod\n    def ensure_foobar(cls, v: Any):\n        if 'foobar' not in v:\n            raise ValueError('\"foobar\" not found in a')\n        return v\n\nprint(repr(Model(a='this is foobar good')))\n#&gt; Model(a='this is foobar good')\n\ntry:\n    Model(a='snap')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    '''\n    1 validation error for Model\n    a\n      Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]\n    '''\n</code></pre></p> <p>For more in depth examples, see Field Validators.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>str</code> <p>The first field the <code>field_validator</code> should be called on; this is separate from <code>fields</code> to ensure an error is raised if you don't pass at least one.</p> \u5fc5\u9700 <code>*fields</code> <code>str</code> <p>Additional field(s) the <code>field_validator</code> should be called on.</p> <code>()</code> <code>mode</code> <code>FieldValidatorModes</code> <p>Specifies whether to validate the fields before or after validation.</p> <code>'after'</code> <code>check_fields</code> <code>bool | None</code> <p>Whether to check that the fields actually exist on the model.</p> <code>None</code> <code>json_schema_input_type</code> <code>Any</code> <p>The input type of the function. This is only used to generate the appropriate JSON Schema (in validation mode) and can only specified when <code>mode</code> is either <code>'before'</code>, <code>'plain'</code> or <code>'wrap'</code>.</p> <code>PydanticUndefined</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Callable[[Any], Any]</code> <p>A decorator that can be used to decorate a function to be used as a field_validator.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticUserError</code> <ul> <li>If <code>@field_validator</code> is used bare (with no fields).</li> <li>If the args passed to <code>@field_validator</code> as fields are not strings.</li> <li>If <code>@field_validator</code> applied to instance methods.</li> </ul> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/functional_validators.py</code> <pre><code>def field_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: FieldValidatorModes = 'after',\n    check_fields: bool | None = None,\n    json_schema_input_type: Any = PydanticUndefined,\n) -&gt; Callable[[Any], Any]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [field validators](../concepts/validators.md#field-validators)\n\n    Decorate methods on the class indicating that they should be used to validate fields.\n\n    Example usage:\n    ```python\n    from typing import Any\n\n    from pydantic import (\n        BaseModel,\n        ValidationError,\n        field_validator,\n    )\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def ensure_foobar(cls, v: Any):\n            if 'foobar' not in v:\n                raise ValueError('\"foobar\" not found in a')\n            return v\n\n    print(repr(Model(a='this is foobar good')))\n    #&gt; Model(a='this is foobar good')\n\n    try:\n        Model(a='snap')\n    except ValidationError as exc_info:\n        print(exc_info)\n        '''\n        1 validation error for Model\n        a\n          Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]\n        '''\n    ```\n\n    For more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).\n\n    Args:\n        field: The first field the `field_validator` should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one.\n        *fields: Additional field(s) the `field_validator` should be called on.\n        mode: Specifies whether to validate the fields before or after validation.\n        check_fields: Whether to check that the fields actually exist on the model.\n        json_schema_input_type: The input type of the function. This is only used to generate\n            the appropriate JSON Schema (in validation mode) and can only specified\n            when `mode` is either `'before'`, `'plain'` or `'wrap'`.\n\n    Returns:\n        A decorator that can be used to decorate a function to be used as a field_validator.\n\n    Raises:\n        PydanticUserError:\n            - If `@field_validator` is used bare (with no fields).\n            - If the args passed to `@field_validator` as fields are not strings.\n            - If `@field_validator` applied to instance methods.\n    \"\"\"\n    if isinstance(field, FunctionType):\n        raise PydanticUserError(\n            '`@field_validator` should be used with fields and keyword arguments, not bare. '\n            \"E.g. usage should be `@validator('&lt;field_name&gt;', ...)`\",\n            code='validator-no-fields',\n        )\n\n    if mode not in ('before', 'plain', 'wrap') and json_schema_input_type is not PydanticUndefined:\n        raise PydanticUserError(\n            f\"`json_schema_input_type` can't be used when mode is set to {mode!r}\",\n            code='validator-input-type',\n        )\n\n    if json_schema_input_type is PydanticUndefined and mode == 'plain':\n        json_schema_input_type = Any\n\n    fields = field, *fields\n    if not all(isinstance(field, str) for field in fields):\n        raise PydanticUserError(\n            '`@field_validator` fields should be passed as separate string args. '\n            \"E.g. usage should be `@validator('&lt;field_name_1&gt;', '&lt;field_name_2&gt;', ...)`\",\n            code='validator-invalid-fields',\n        )\n\n    def dec(\n        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],\n    ) -&gt; _decorators.PydanticDescriptorProxy[Any]:\n        if _decorators.is_instance_method_from_sig(f):\n            raise PydanticUserError(\n                '`@field_validator` cannot be applied to instance methods', code='validator-instance-method'\n            )\n\n        # auto apply the @classmethod decorator\n        f = _decorators.ensure_classmethod_based_on_signature(f)\n\n        dec_info = _decorators.FieldValidatorDecoratorInfo(\n            fields=fields, mode=mode, check_fields=check_fields, json_schema_input_type=json_schema_input_type\n        )\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    return dec\n</code></pre>"},{"location":"api/functional_validators/#pydantic.functional_validators.model_validator","title":"model_validator","text":"<pre><code>model_validator(*, mode: Literal['wrap']) -&gt; Callable[[_AnyModelWrapValidator[_ModelType]], PydanticDescriptorProxy[ModelValidatorDecoratorInfo]]\n</code></pre><pre><code>model_validator(*, mode: Literal['before']) -&gt; Callable[[_AnyModelBeforeValidator], PydanticDescriptorProxy[ModelValidatorDecoratorInfo]]\n</code></pre><pre><code>model_validator(*, mode: Literal['after']) -&gt; Callable[[_AnyModelAfterValidator[_ModelType]], PydanticDescriptorProxy[ModelValidatorDecoratorInfo]]\n</code></pre> <pre><code>model_validator(*, mode: Literal['wrap', 'before', 'after']) -&gt; Any\n</code></pre> <p>Usage Documentation</p> <p>Model Validators</p> <p>Decorate model methods for validation purposes.</p> <p>Example usage: <pre><code>from typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\nclass Square(BaseModel):\n    width: float\n    height: float\n\n    @model_validator(mode='after')\n    def verify_square(self) -&gt; Self:\n        if self.width != self.height:\n            raise ValueError('width and height do not match')\n        return self\n\ns = Square(width=1, height=1)\nprint(repr(s))\n#&gt; Square(width=1.0, height=1.0)\n\ntry:\n    Square(width=1, height=2)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Square\n      Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]\n    '''\n</code></pre></p> <p>For more in depth examples, see Model Validators.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>mode</code> <code>Literal['wrap', 'before', 'after']</code> <p>A required string literal that specifies the validation mode. It can be one of the following: 'wrap', 'before', or 'after'.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>A decorator that can be used to decorate a function to be used as a model validator.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/functional_validators.py</code> <pre><code>def model_validator(\n    *,\n    mode: Literal['wrap', 'before', 'after'],\n) -&gt; Any:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Model Validators](../concepts/validators.md#model-validators)\n\n    Decorate model methods for validation purposes.\n\n    Example usage:\n    ```python\n    from typing_extensions import Self\n\n    from pydantic import BaseModel, ValidationError, model_validator\n\n    class Square(BaseModel):\n        width: float\n        height: float\n\n        @model_validator(mode='after')\n        def verify_square(self) -&gt; Self:\n            if self.width != self.height:\n                raise ValueError('width and height do not match')\n            return self\n\n    s = Square(width=1, height=1)\n    print(repr(s))\n    #&gt; Square(width=1.0, height=1.0)\n\n    try:\n        Square(width=1, height=2)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Square\n          Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]\n        '''\n    ```\n\n    For more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).\n\n    Args:\n        mode: A required string literal that specifies the validation mode.\n            It can be one of the following: 'wrap', 'before', or 'after'.\n\n    Returns:\n        A decorator that can be used to decorate a function to be used as a model validator.\n    \"\"\"\n\n    def dec(f: Any) -&gt; _decorators.PydanticDescriptorProxy[Any]:\n        # auto apply the @classmethod decorator (except for *after* validators, which should be instance methods):\n        if mode != 'after':\n            f = _decorators.ensure_classmethod_based_on_signature(f)\n        dec_info = _decorators.ModelValidatorDecoratorInfo(mode=mode)\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    return dec\n</code></pre>"},{"location":"api/json_schema/","title":"JSON Schema","text":"<p>Usage Documentation</p> <p>JSON Schema</p> <p>The <code>json_schema</code> module contains classes and functions to allow the way JSON Schema is generated to be customized.</p> <p>In general you shouldn't need to use this module directly; instead, you can use <code>BaseModel.model_json_schema</code> and <code>TypeAdapter.json_schema</code>.</p>"},{"location":"api/json_schema/#pydantic.json_schema.CoreSchemaOrFieldType","title":"CoreSchemaOrFieldType  <code>module-attribute</code>","text":"<pre><code>CoreSchemaOrFieldType = Literal[CoreSchemaType, CoreSchemaFieldType]\n</code></pre> <p>A type alias for defined schema types that represents a union of <code>core_schema.CoreSchemaType</code> and <code>core_schema.CoreSchemaFieldType</code>.</p>"},{"location":"api/json_schema/#pydantic.json_schema.JsonSchemaValue","title":"JsonSchemaValue  <code>module-attribute</code>","text":"<pre><code>JsonSchemaValue = dict[str, Any]\n</code></pre> <p>A type alias for a JSON schema value. This is a dictionary of string keys to arbitrary JSON values.</p>"},{"location":"api/json_schema/#pydantic.json_schema.JsonSchemaMode","title":"JsonSchemaMode  <code>module-attribute</code>","text":"<pre><code>JsonSchemaMode = Literal['validation', 'serialization']\n</code></pre> <p>A type alias that represents the mode of a JSON schema; either 'validation' or 'serialization'.</p> <p>For some types, the inputs to validation differ from the outputs of serialization. For example, computed fields will only be present when serializing, and should not be provided when validating. This flag provides a way to indicate whether you want the JSON schema required for validation inputs, or that will be matched by serialization outputs.</p>"},{"location":"api/json_schema/#pydantic.json_schema.JsonSchemaWarningKind","title":"JsonSchemaWarningKind  <code>module-attribute</code>","text":"<pre><code>JsonSchemaWarningKind = Literal['skipped-choice', 'non-serializable-default', 'skipped-discriminator']\n</code></pre> <p>A type alias representing the kinds of warnings that can be emitted during JSON schema generation.</p> <p>See <code>GenerateJsonSchema.render_warning_message</code> for more details.</p>"},{"location":"api/json_schema/#pydantic.json_schema.NoDefault","title":"NoDefault  <code>module-attribute</code>","text":"<pre><code>NoDefault = object()\n</code></pre> <p>A sentinel value used to indicate that no default value should be used when generating a JSON Schema for a core schema with a default value.</p>"},{"location":"api/json_schema/#pydantic.json_schema.DEFAULT_REF_TEMPLATE","title":"DEFAULT_REF_TEMPLATE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_REF_TEMPLATE = '#/$defs/{model}'\n</code></pre> <p>The default format string used to generate reference names.</p>"},{"location":"api/json_schema/#pydantic.json_schema.PydanticJsonSchemaWarning","title":"PydanticJsonSchemaWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>This class is used to emit warnings produced during JSON schema generation. See the <code>GenerateJsonSchema.emit_warning</code> and <code>GenerateJsonSchema.render_warning_message</code> methods for more details; these can be overridden to control warning behavior.</p>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema","title":"GenerateJsonSchema","text":"<pre><code>GenerateJsonSchema(by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of')\n</code></pre> <p>Usage Documentation</p> <p>Customizing the JSON Schema Generation Process</p> <p>A class for generating JSON schemas.</p> <p>This class generates JSON schemas based on configured parameters. The default schema dialect is https://json-schema.org/draft/2020-12/schema. The class uses <code>by_alias</code> to configure how fields with multiple names are handled and <code>ref_template</code> to format reference names.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>schema_dialect</code> <p>The JSON schema dialect used to generate the schema. See Declaring a Dialect in the JSON Schema documentation for more information about dialects.</p> <code>ignored_warning_kinds</code> <code>set[JsonSchemaWarningKind]</code> <p>Warnings to ignore when generating the schema. <code>self.render_warning_message</code> will do nothing if its argument <code>kind</code> is in <code>ignored_warning_kinds</code>; this value can be modified on subclasses to easily control which warnings are emitted.</p> <code>by_alias</code> <p>Whether to use field aliases when generating the schema.</p> <code>ref_template</code> <p>The format string used when generating reference names.</p> <code>core_to_json_refs</code> <code>dict[CoreModeRef, JsonRef]</code> <p>A mapping of core refs to JSON refs.</p> <code>core_to_defs_refs</code> <code>dict[CoreModeRef, DefsRef]</code> <p>A mapping of core refs to definition refs.</p> <code>defs_to_core_refs</code> <code>dict[DefsRef, CoreModeRef]</code> <p>A mapping of definition refs to core refs.</p> <code>json_to_defs_refs</code> <code>dict[JsonRef, DefsRef]</code> <p>A mapping of JSON refs to definition refs.</p> <code>definitions</code> <code>dict[DefsRef, JsonSchemaValue]</code> <p>Definitions in the schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>by_alias</code> <code>bool</code> <p>Whether to use field aliases in the generated schemas.</p> <code>True</code> <code>ref_template</code> <code>str</code> <p>The format string to use when generating reference names.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>union_format</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code>   keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code>   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to   <code>any_of</code>.</li> </ul> <code>'any_of'</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaError</code> <p>If the instance of the class is inadvertently reused after generating a schema.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def __init__(\n    self,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n) -&gt; None:\n    self.by_alias = by_alias\n    self.ref_template = ref_template\n    self.union_format: Literal['any_of', 'primitive_type_array'] = union_format\n\n    self.core_to_json_refs: dict[CoreModeRef, JsonRef] = {}\n    self.core_to_defs_refs: dict[CoreModeRef, DefsRef] = {}\n    self.defs_to_core_refs: dict[DefsRef, CoreModeRef] = {}\n    self.json_to_defs_refs: dict[JsonRef, DefsRef] = {}\n\n    self.definitions: dict[DefsRef, JsonSchemaValue] = {}\n    self._config_wrapper_stack = _config.ConfigWrapperStack(_config.ConfigWrapper({}))\n\n    self._mode: JsonSchemaMode = 'validation'\n\n    # The following includes a mapping of a fully-unique defs ref choice to a list of preferred\n    # alternatives, which are generally simpler, such as only including the class name.\n    # At the end of schema generation, we use these to produce a JSON schema with more human-readable\n    # definitions, which would also work better in a generated OpenAPI client, etc.\n    self._prioritized_defsref_choices: dict[DefsRef, list[DefsRef]] = {}\n    self._collision_counter: dict[str, int] = defaultdict(int)\n    self._collision_index: dict[str, int] = {}\n\n    self._schema_type_to_method = self.build_schema_type_to_method()\n\n    # When we encounter definitions we need to try to build them immediately\n    # so that they are available schemas that reference them\n    # But it's possible that CoreSchema was never going to be used\n    # (e.g. because the CoreSchema that references short circuits is JSON schema generation without needing\n    #  the reference) so instead of failing altogether if we can't build a definition we\n    # store the error raised and re-throw it if we end up needing that def\n    self._core_defs_invalid_for_json_schema: dict[DefsRef, PydanticInvalidForJsonSchema] = {}\n\n    # This changes to True after generating a schema, to prevent issues caused by accidental reuse\n    # of a single instance of a schema generator\n    self._used = False\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.ValidationsMapping","title":"ValidationsMapping","text":"<p>This class just contains mappings from core_schema attribute names to the corresponding JSON schema attribute names. While I suspect it is unlikely to be necessary, you can in principle override this class in a subclass of GenerateJsonSchema (by inheriting from GenerateJsonSchema.ValidationsMapping) to change these mappings.</p>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.build_schema_type_to_method","title":"build_schema_type_to_method","text":"<pre><code>build_schema_type_to_method() -&gt; dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]\n</code></pre> <p>Builds a dictionary mapping fields to methods for generating JSON schemas.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]</code> <p>A dictionary containing the mapping of <code>CoreSchemaOrFieldType</code> to a handler method.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>TypeError</code> <p>If no method has been defined for generating a JSON schema for a given pydantic core schema type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def build_schema_type_to_method(\n    self,\n) -&gt; dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]:\n    \"\"\"Builds a dictionary mapping fields to methods for generating JSON schemas.\n\n    Returns:\n        A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method.\n\n    Raises:\n        TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.\n    \"\"\"\n    mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}\n    core_schema_types: list[CoreSchemaOrFieldType] = list(get_literal_values(CoreSchemaOrFieldType))\n    for key in core_schema_types:\n        method_name = f'{key.replace(\"-\", \"_\")}_schema'\n        try:\n            mapping[key] = getattr(self, method_name)\n        except AttributeError as e:  # pragma: no cover\n            if os.getenv('PYDANTIC_PRIVATE_ALLOW_UNHANDLED_SCHEMA_TYPES'):\n                continue\n            raise TypeError(\n                f'No method for generating JsonSchema for core_schema.type={key!r} '\n                f'(expected: {type(self).__name__}.{method_name})'\n            ) from e\n    return mapping\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.generate_definitions","title":"generate_definitions","text":"<pre><code>generate_definitions(inputs: Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, CoreSchema]]) -&gt; tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]\n</code></pre> <p>Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a mapping that links the input keys to the definition references.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>inputs</code> <code>Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, CoreSchema]]</code> <p>A sequence of tuples, where:</p> <ul> <li>The first element is a JSON schema key type.</li> <li>The second element is the JSON mode: either 'validation' or 'serialization'.</li> <li>The third element is a core schema.</li> </ul> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]</code> <p>A tuple where:</p> <ul> <li>The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and     whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have     JsonRef references to definitions that are defined in the second returned element.)</li> <li>The second element is a dictionary whose keys are definition references for the JSON schemas     from the first returned element, and whose values are the actual JSON schema definitions.</li> </ul> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticUserError</code> <p>Raised if the JSON schema generator has already been used to generate a JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def generate_definitions(\n    self, inputs: Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, core_schema.CoreSchema]]\n) -&gt; tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]:\n    \"\"\"Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a\n    mapping that links the input keys to the definition references.\n\n    Args:\n        inputs: A sequence of tuples, where:\n\n            - The first element is a JSON schema key type.\n            - The second element is the JSON mode: either 'validation' or 'serialization'.\n            - The third element is a core schema.\n\n    Returns:\n        A tuple where:\n\n            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a dictionary whose keys are definition references for the JSON schemas\n                from the first returned element, and whose values are the actual JSON schema definitions.\n\n    Raises:\n        PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema.\n    \"\"\"\n    if self._used:\n        raise PydanticUserError(\n            'This JSON schema generator has already been used to generate a JSON schema. '\n            f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',\n            code='json-schema-already-used',\n        )\n\n    for _, mode, schema in inputs:\n        self._mode = mode\n        self.generate_inner(schema)\n\n    definitions_remapping = self._build_definitions_remapping()\n\n    json_schemas_map: dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef] = {}\n    for key, mode, schema in inputs:\n        self._mode = mode\n        json_schema = self.generate_inner(schema)\n        json_schemas_map[(key, mode)] = definitions_remapping.remap_json_schema(json_schema)\n\n    json_schema = {'$defs': self.definitions}\n    json_schema = definitions_remapping.remap_json_schema(json_schema)\n    self._used = True\n    return json_schemas_map, self.sort(json_schema['$defs'])  # type: ignore\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.generate","title":"generate","text":"<pre><code>generate(schema: CoreSchema, mode: JsonSchemaMode = 'validation') -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema for a specified schema in a specified mode.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>A Pydantic model.</p> \u5fc5\u9700 <code>mode</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema. Defaults to 'validation'.</p> <code>'validation'</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>A JSON schema representing the specified schema.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticUserError</code> <p>If the JSON schema generator has already been used to generate a JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def generate(self, schema: CoreSchema, mode: JsonSchemaMode = 'validation') -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema for a specified schema in a specified mode.\n\n    Args:\n        schema: A Pydantic model.\n        mode: The mode in which to generate the schema. Defaults to 'validation'.\n\n    Returns:\n        A JSON schema representing the specified schema.\n\n    Raises:\n        PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema.\n    \"\"\"\n    self._mode = mode\n    if self._used:\n        raise PydanticUserError(\n            'This JSON schema generator has already been used to generate a JSON schema. '\n            f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',\n            code='json-schema-already-used',\n        )\n\n    json_schema: JsonSchemaValue = self.generate_inner(schema)\n    json_ref_counts = self.get_json_ref_counts(json_schema)\n\n    ref = cast(JsonRef, json_schema.get('$ref'))\n    while ref is not None:  # may need to unpack multiple levels\n        ref_json_schema = self.get_schema_from_definitions(ref)\n        if json_ref_counts[ref] == 1 and ref_json_schema is not None and len(json_schema) == 1:\n            # \"Unpack\" the ref since this is the only reference and there are no sibling keys\n            json_schema = ref_json_schema.copy()  # copy to prevent recursive dict reference\n            json_ref_counts[ref] -= 1\n            ref = cast(JsonRef, json_schema.get('$ref'))\n        ref = None\n\n    self._garbage_collect_definitions(json_schema)\n    definitions_remapping = self._build_definitions_remapping()\n\n    if self.definitions:\n        json_schema['$defs'] = self.definitions\n\n    json_schema = definitions_remapping.remap_json_schema(json_schema)\n\n    # For now, we will not set the $schema key. However, if desired, this can be easily added by overriding\n    # this method and adding the following line after a call to super().generate(schema):\n    # json_schema['$schema'] = self.schema_dialect\n\n    self._used = True\n    return self.sort(json_schema)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.generate_inner","title":"generate_inner","text":"<pre><code>generate_inner(schema: CoreSchemaOrField) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema for a given core schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchemaOrField</code> <p>The given core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> <p>TODO: the nested function definitions here seem like bad practice, I'd like to unpack these in a future PR. It'd be great if we could shorten the call stack a bit for JSON schema generation, and I think there's potential for that here.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def generate_inner(self, schema: CoreSchemaOrField) -&gt; JsonSchemaValue:  # noqa: C901\n    \"\"\"Generates a JSON schema for a given core schema.\n\n    Args:\n        schema: The given core schema.\n\n    Returns:\n        The generated JSON schema.\n\n    TODO: the nested function definitions here seem like bad practice, I'd like to unpack these\n    in a future PR. It'd be great if we could shorten the call stack a bit for JSON schema generation,\n    and I think there's potential for that here.\n    \"\"\"\n    # If a schema with the same CoreRef has been handled, just return a reference to it\n    # Note that this assumes that it will _never_ be the case that the same CoreRef is used\n    # on types that should have different JSON schemas\n    if 'ref' in schema:\n        core_ref = CoreRef(schema['ref'])  # type: ignore[typeddict-item]\n        core_mode_ref = (core_ref, self.mode)\n        if core_mode_ref in self.core_to_defs_refs and self.core_to_defs_refs[core_mode_ref] in self.definitions:\n            return {'$ref': self.core_to_json_refs[core_mode_ref]}\n\n    def populate_defs(core_schema: CoreSchema, json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:\n        if 'ref' in core_schema:\n            core_ref = CoreRef(core_schema['ref'])  # type: ignore[typeddict-item]\n            defs_ref, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)\n            json_ref = JsonRef(ref_json_schema['$ref'])\n            # Replace the schema if it's not a reference to itself\n            # What we want to avoid is having the def be just a ref to itself\n            # which is what would happen if we blindly assigned any\n            if json_schema.get('$ref', None) != json_ref:\n                self.definitions[defs_ref] = json_schema\n                self._core_defs_invalid_for_json_schema.pop(defs_ref, None)\n            json_schema = ref_json_schema\n        return json_schema\n\n    def handler_func(schema_or_field: CoreSchemaOrField) -&gt; JsonSchemaValue:\n        \"\"\"Generate a JSON schema based on the input schema.\n\n        Args:\n            schema_or_field: The core schema to generate a JSON schema from.\n\n        Returns:\n            The generated JSON schema.\n\n        Raises:\n            TypeError: If an unexpected schema type is encountered.\n        \"\"\"\n        # Generate the core-schema-type-specific bits of the schema generation:\n        json_schema: JsonSchemaValue | None = None\n        if self.mode == 'serialization' and 'serialization' in schema_or_field:\n            # In this case, we skip the JSON Schema generation of the schema\n            # and use the `'serialization'` schema instead (canonical example:\n            # `Annotated[int, PlainSerializer(str)]`).\n            ser_schema = schema_or_field['serialization']  # type: ignore\n            json_schema = self.ser_schema(ser_schema)\n\n            # It might be that the 'serialization'` is skipped depending on `when_used`.\n            # This is only relevant for `nullable` schemas though, so we special case here.\n            if (\n                json_schema is not None\n                and ser_schema.get('when_used') in ('unless-none', 'json-unless-none')\n                and schema_or_field['type'] == 'nullable'\n            ):\n                json_schema = self.get_union_of_schemas([{'type': 'null'}, json_schema])\n        if json_schema is None:\n            if _core_utils.is_core_schema(schema_or_field) or _core_utils.is_core_schema_field(schema_or_field):\n                generate_for_schema_type = self._schema_type_to_method[schema_or_field['type']]\n                json_schema = generate_for_schema_type(schema_or_field)\n            else:\n                raise TypeError(f'Unexpected schema type: schema={schema_or_field}')\n        return json_schema\n\n    current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, handler_func)\n\n    metadata = cast(_core_metadata.CoreMetadata, schema.get('metadata', {}))\n\n    # TODO: I dislike that we have to wrap these basic dict updates in callables, is there any way around this?\n\n    if js_updates := metadata.get('pydantic_js_updates'):\n\n        def js_updates_handler_func(\n            schema_or_field: CoreSchemaOrField,\n            current_handler: GetJsonSchemaHandler = current_handler,\n        ) -&gt; JsonSchemaValue:\n            json_schema = {**current_handler(schema_or_field), **js_updates}\n            return json_schema\n\n        current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, js_updates_handler_func)\n\n    if js_extra := metadata.get('pydantic_js_extra'):\n\n        def js_extra_handler_func(\n            schema_or_field: CoreSchemaOrField,\n            current_handler: GetJsonSchemaHandler = current_handler,\n        ) -&gt; JsonSchemaValue:\n            json_schema = current_handler(schema_or_field)\n            if isinstance(js_extra, dict):\n                json_schema.update(to_jsonable_python(js_extra))\n            elif callable(js_extra):\n                # similar to typing issue in _update_class_schema when we're working with callable js extra\n                js_extra(json_schema)  # type: ignore\n            return json_schema\n\n        current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, js_extra_handler_func)\n\n    for js_modify_function in metadata.get('pydantic_js_functions', ()):\n\n        def new_handler_func(\n            schema_or_field: CoreSchemaOrField,\n            current_handler: GetJsonSchemaHandler = current_handler,\n            js_modify_function: GetJsonSchemaFunction = js_modify_function,\n        ) -&gt; JsonSchemaValue:\n            json_schema = js_modify_function(schema_or_field, current_handler)\n            if _core_utils.is_core_schema(schema_or_field):\n                json_schema = populate_defs(schema_or_field, json_schema)\n            original_schema = current_handler.resolve_ref_schema(json_schema)\n            ref = json_schema.pop('$ref', None)\n            if ref and json_schema:\n                original_schema.update(json_schema)\n            return original_schema\n\n        current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)\n\n    for js_modify_function in metadata.get('pydantic_js_annotation_functions', ()):\n\n        def new_handler_func(\n            schema_or_field: CoreSchemaOrField,\n            current_handler: GetJsonSchemaHandler = current_handler,\n            js_modify_function: GetJsonSchemaFunction = js_modify_function,\n        ) -&gt; JsonSchemaValue:\n            return js_modify_function(schema_or_field, current_handler)\n\n        current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)\n\n    json_schema = current_handler(schema)\n    if _core_utils.is_core_schema(schema):\n        json_schema = populate_defs(schema, json_schema)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.sort","title":"sort","text":"<pre><code>sort(value: JsonSchemaValue, parent_key: str | None = None) -&gt; JsonSchemaValue\n</code></pre> <p>Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)</p> <p>By default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order. This sort is recursive, so it will sort all nested dictionaries as well.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def sort(self, value: JsonSchemaValue, parent_key: str | None = None) -&gt; JsonSchemaValue:\n    \"\"\"Override this method to customize the sorting of the JSON schema (e.g., don't sort at all, sort all keys unconditionally, etc.)\n\n    By default, alphabetically sort the keys in the JSON schema, skipping the 'properties' and 'default' keys to preserve field definition order.\n    This sort is recursive, so it will sort all nested dictionaries as well.\n    \"\"\"\n    sorted_dict: dict[str, JsonSchemaValue] = {}\n    keys = value.keys()\n    if parent_key not in ('properties', 'default'):\n        keys = sorted(keys)\n    for key in keys:\n        sorted_dict[key] = self._sort_recursive(value[key], parent_key=key)\n    return sorted_dict\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.invalid_schema","title":"invalid_schema","text":"<pre><code>invalid_schema(schema: InvalidSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Placeholder - should never be called.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def invalid_schema(self, schema: core_schema.InvalidSchema) -&gt; JsonSchemaValue:\n    \"\"\"Placeholder - should never be called.\"\"\"\n\n    raise RuntimeError('Cannot generate schema for invalid_schema. This is a bug! Please report it.')\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.any_schema","title":"any_schema","text":"<pre><code>any_schema(schema: AnySchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches any value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>AnySchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def any_schema(self, schema: core_schema.AnySchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches any value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.none_schema","title":"none_schema","text":"<pre><code>none_schema(schema: NoneSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches <code>None</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>NoneSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def none_schema(self, schema: core_schema.NoneSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches `None`.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'null'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.bool_schema","title":"bool_schema","text":"<pre><code>bool_schema(schema: BoolSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a bool value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>BoolSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def bool_schema(self, schema: core_schema.BoolSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a bool value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'boolean'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.int_schema","title":"int_schema","text":"<pre><code>int_schema(schema: IntSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches an int value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>IntSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def int_schema(self, schema: core_schema.IntSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches an int value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema: dict[str, Any] = {'type': 'integer'}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n    json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.float_schema","title":"float_schema","text":"<pre><code>float_schema(schema: FloatSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a float value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>FloatSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def float_schema(self, schema: core_schema.FloatSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a float value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema: dict[str, Any] = {'type': 'number'}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n    json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.decimal_schema","title":"decimal_schema","text":"<pre><code>decimal_schema(schema: DecimalSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a decimal value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DecimalSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def decimal_schema(self, schema: core_schema.DecimalSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a decimal value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n\n    def get_decimal_pattern(schema: core_schema.DecimalSchema) -&gt; str:\n        max_digits = schema.get('max_digits')\n        decimal_places = schema.get('decimal_places')\n\n        pattern = (\n            r'^(?!^[-+.]*$)[+-]?0*'  # check it is not empty string and not one or sequence of \".+-\" characters.\n        )\n\n        # Case 1: Both max_digits and decimal_places are set\n        if max_digits is not None and decimal_places is not None:\n            integer_places = max(0, max_digits - decimal_places)\n            pattern += (\n                rf'(?:'\n                rf'\\d{{0,{integer_places}}}'\n                rf'|'\n                rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n                rf'\\d{{0,{integer_places}}}\\.\\d{{0,{decimal_places}}}0*$'\n                rf')'\n            )\n\n        # Case 2: Only max_digits is set\n        elif max_digits is not None and decimal_places is None:\n            pattern += (\n                rf'(?:'\n                rf'\\d{{0,{max_digits}}}'\n                rf'|'\n                rf'(?=[\\d.]{{1,{max_digits + 1}}}0*$)'\n                rf'\\d*\\.\\d*0*$'\n                rf')'\n            )\n\n        # Case 3: Only decimal_places is set\n        elif max_digits is None and decimal_places is not None:\n            pattern += rf'\\d*\\.?\\d{{0,{decimal_places}}}0*$'\n\n        # Case 4: Both are None (no restrictions)\n        else:\n            pattern += r'\\d*\\.?\\d*$'  # look for arbitrary integer or decimal\n\n        return pattern\n\n    json_schema = self.str_schema(core_schema.str_schema(pattern=get_decimal_pattern(schema)))\n    if self.mode == 'validation':\n        multiple_of = schema.get('multiple_of')\n        le = schema.get('le')\n        ge = schema.get('ge')\n        lt = schema.get('lt')\n        gt = schema.get('gt')\n        json_schema = {\n            'anyOf': [\n                self.float_schema(\n                    core_schema.float_schema(\n                        allow_inf_nan=schema.get('allow_inf_nan'),\n                        multiple_of=None if multiple_of is None else float(multiple_of),\n                        le=None if le is None else float(le),\n                        ge=None if ge is None else float(ge),\n                        lt=None if lt is None else float(lt),\n                        gt=None if gt is None else float(gt),\n                    )\n                ),\n                json_schema,\n            ],\n        }\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.str_schema","title":"str_schema","text":"<pre><code>str_schema(schema: StringSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a string value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>StringSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def str_schema(self, schema: core_schema.StringSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a string value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema = {'type': 'string'}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n    if isinstance(json_schema.get('pattern'), Pattern):\n        # TODO: should we add regex flags to the pattern?\n        json_schema['pattern'] = json_schema.get('pattern').pattern  # type: ignore\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.bytes_schema","title":"bytes_schema","text":"<pre><code>bytes_schema(schema: BytesSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a bytes value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>BytesSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def bytes_schema(self, schema: core_schema.BytesSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a bytes value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.bytes)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.date_schema","title":"date_schema","text":"<pre><code>date_schema(schema: DateSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a date value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DateSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def date_schema(self, schema: core_schema.DateSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a date value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'string', 'format': 'date'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.time_schema","title":"time_schema","text":"<pre><code>time_schema(schema: TimeSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a time value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>TimeSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def time_schema(self, schema: core_schema.TimeSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a time value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'string', 'format': 'time'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.datetime_schema","title":"datetime_schema","text":"<pre><code>datetime_schema(schema: DatetimeSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a datetime value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DatetimeSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def datetime_schema(self, schema: core_schema.DatetimeSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a datetime value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'string', 'format': 'date-time'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.timedelta_schema","title":"timedelta_schema","text":"<pre><code>timedelta_schema(schema: TimedeltaSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a timedelta value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>TimedeltaSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def timedelta_schema(self, schema: core_schema.TimedeltaSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a timedelta value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    if self._config.ser_json_timedelta == 'float':\n        return {'type': 'number'}\n    return {'type': 'string', 'format': 'duration'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.literal_schema","title":"literal_schema","text":"<pre><code>literal_schema(schema: LiteralSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a literal value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>LiteralSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def literal_schema(self, schema: core_schema.LiteralSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a literal value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    expected = [to_jsonable_python(v.value if isinstance(v, Enum) else v) for v in schema['expected']]\n\n    result: dict[str, Any] = {}\n    if len(expected) == 1:\n        result['const'] = expected[0]\n    else:\n        result['enum'] = expected\n\n    types = {type(e) for e in expected}\n    if types == {str}:\n        result['type'] = 'string'\n    elif types == {int}:\n        result['type'] = 'integer'\n    elif types == {float}:\n        result['type'] = 'number'\n    elif types == {bool}:\n        result['type'] = 'boolean'\n    elif types == {list}:\n        result['type'] = 'array'\n    elif types == {type(None)}:\n        result['type'] = 'null'\n    return result\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.missing_sentinel_schema","title":"missing_sentinel_schema","text":"<pre><code>missing_sentinel_schema(schema: MissingSentinelSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches the <code>MISSING</code> sentinel value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>MissingSentinelSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def missing_sentinel_schema(self, schema: core_schema.MissingSentinelSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches the `MISSING` sentinel value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    raise PydanticOmit\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.enum_schema","title":"enum_schema","text":"<pre><code>enum_schema(schema: EnumSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches an Enum value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>EnumSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def enum_schema(self, schema: core_schema.EnumSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches an Enum value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    enum_type = schema['cls']\n    description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)\n    if (\n        description == 'An enumeration.'\n    ):  # This is the default value provided by enum.EnumMeta.__new__; don't use it\n        description = None\n    result: dict[str, Any] = {'title': enum_type.__name__, 'description': description}\n    result = {k: v for k, v in result.items() if v is not None}\n\n    expected = [to_jsonable_python(v.value) for v in schema['members']]\n\n    result['enum'] = expected\n\n    types = {type(e) for e in expected}\n    if isinstance(enum_type, str) or types == {str}:\n        result['type'] = 'string'\n    elif isinstance(enum_type, int) or types == {int}:\n        result['type'] = 'integer'\n    elif isinstance(enum_type, float) or types == {float}:\n        result['type'] = 'number'\n    elif types == {bool}:\n        result['type'] = 'boolean'\n    elif types == {list}:\n        result['type'] = 'array'\n\n    return result\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.is_instance_schema","title":"is_instance_schema","text":"<pre><code>is_instance_schema(schema: IsInstanceSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Handles JSON schema generation for a core schema that checks if a value is an instance of a class.</p> <p>Unless overridden in a subclass, this raises an error.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>IsInstanceSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def is_instance_schema(self, schema: core_schema.IsInstanceSchema) -&gt; JsonSchemaValue:\n    \"\"\"Handles JSON schema generation for a core schema that checks if a value is an instance of a class.\n\n    Unless overridden in a subclass, this raises an error.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.handle_invalid_for_json_schema(schema, f'core_schema.IsInstanceSchema ({schema[\"cls\"]})')\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.is_subclass_schema","title":"is_subclass_schema","text":"<pre><code>is_subclass_schema(schema: IsSubclassSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.</p> <p>For backwards compatibility with v1, this does not raise an error, but can be overridden to change this.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>IsSubclassSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def is_subclass_schema(self, schema: core_schema.IsSubclassSchema) -&gt; JsonSchemaValue:\n    \"\"\"Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.\n\n    For backwards compatibility with v1, this does not raise an error, but can be overridden to change this.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    # Note: This is for compatibility with V1; you can override if you want different behavior.\n    return {}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.callable_schema","title":"callable_schema","text":"<pre><code>callable_schema(schema: CallableSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a callable value.</p> <p>Unless overridden in a subclass, this raises an error.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CallableSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def callable_schema(self, schema: core_schema.CallableSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a callable value.\n\n    Unless overridden in a subclass, this raises an error.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.handle_invalid_for_json_schema(schema, 'core_schema.CallableSchema')\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.list_schema","title":"list_schema","text":"<pre><code>list_schema(schema: ListSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Returns a schema that matches a list schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ListSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def list_schema(self, schema: core_schema.ListSchema) -&gt; JsonSchemaValue:\n    \"\"\"Returns a schema that matches a list schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n    json_schema = {'type': 'array', 'items': items_schema}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.tuple_positional_schema","title":"tuple_positional_schema","text":"<pre><code>tuple_positional_schema(schema: TupleSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Replaced by <code>tuple_schema</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>@deprecated('`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.', category=None)\n@final\ndef tuple_positional_schema(self, schema: core_schema.TupleSchema) -&gt; JsonSchemaValue:\n    \"\"\"Replaced by `tuple_schema`.\"\"\"\n    warnings.warn(\n        '`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.',\n        PydanticDeprecatedSince26,\n        stacklevel=2,\n    )\n    return self.tuple_schema(schema)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.tuple_variable_schema","title":"tuple_variable_schema","text":"<pre><code>tuple_variable_schema(schema: TupleSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Replaced by <code>tuple_schema</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>@deprecated('`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.', category=None)\n@final\ndef tuple_variable_schema(self, schema: core_schema.TupleSchema) -&gt; JsonSchemaValue:\n    \"\"\"Replaced by `tuple_schema`.\"\"\"\n    warnings.warn(\n        '`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.',\n        PydanticDeprecatedSince26,\n        stacklevel=2,\n    )\n    return self.tuple_schema(schema)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.tuple_schema","title":"tuple_schema","text":"<pre><code>tuple_schema(schema: TupleSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a tuple schema e.g. <code>tuple[int, str, bool]</code> or <code>tuple[int, ...]</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>TupleSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def tuple_schema(self, schema: core_schema.TupleSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a tuple schema e.g. `tuple[int,\n    str, bool]` or `tuple[int, ...]`.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema: JsonSchemaValue = {'type': 'array'}\n    if 'variadic_item_index' in schema:\n        variadic_item_index = schema['variadic_item_index']\n        if variadic_item_index &gt; 0:\n            json_schema['minItems'] = variadic_item_index\n            json_schema['prefixItems'] = [\n                self.generate_inner(item) for item in schema['items_schema'][:variadic_item_index]\n            ]\n        if variadic_item_index + 1 == len(schema['items_schema']):\n            # if the variadic item is the last item, then represent it faithfully\n            json_schema['items'] = self.generate_inner(schema['items_schema'][variadic_item_index])\n        else:\n            # otherwise, 'items' represents the schema for the variadic\n            # item plus the suffix, so just allow anything for simplicity\n            # for now\n            json_schema['items'] = True\n    else:\n        prefixItems = [self.generate_inner(item) for item in schema['items_schema']]\n        if prefixItems:\n            json_schema['prefixItems'] = prefixItems\n        json_schema['minItems'] = len(prefixItems)\n        json_schema['maxItems'] = len(prefixItems)\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.set_schema","title":"set_schema","text":"<pre><code>set_schema(schema: SetSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a set schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>SetSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def set_schema(self, schema: core_schema.SetSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a set schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self._common_set_schema(schema)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.frozenset_schema","title":"frozenset_schema","text":"<pre><code>frozenset_schema(schema: FrozenSetSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a frozenset schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>FrozenSetSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def frozenset_schema(self, schema: core_schema.FrozenSetSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a frozenset schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self._common_set_schema(schema)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.generator_schema","title":"generator_schema","text":"<pre><code>generator_schema(schema: GeneratorSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Returns a JSON schema that represents the provided GeneratorSchema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>GeneratorSchema</code> <p>The schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def generator_schema(self, schema: core_schema.GeneratorSchema) -&gt; JsonSchemaValue:\n    \"\"\"Returns a JSON schema that represents the provided GeneratorSchema.\n\n    Args:\n        schema: The schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n    json_schema = {'type': 'array', 'items': items_schema}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.dict_schema","title":"dict_schema","text":"<pre><code>dict_schema(schema: DictSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a dict schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DictSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def dict_schema(self, schema: core_schema.DictSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a dict schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema: JsonSchemaValue = {'type': 'object'}\n\n    keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n    if '$ref' not in keys_schema:\n        keys_pattern = keys_schema.pop('pattern', None)\n        # Don't give a title to patternProperties/propertyNames:\n        keys_schema.pop('title', None)\n    else:\n        # Here, we assume that if the keys schema is a definition reference,\n        # it can't be a simple string core schema (and thus no pattern can exist).\n        # However, this is only in practice (in theory, a definition reference core\n        # schema could be generated for a simple string schema).\n        # Note that we avoid calling `self.resolve_ref_schema`, as it might not exist yet.\n        keys_pattern = None\n\n    values_schema = self.generate_inner(schema['values_schema']).copy() if 'values_schema' in schema else {}\n    # don't give a title to additionalProperties:\n    values_schema.pop('title', None)\n\n    if values_schema or keys_pattern is not None:\n        if keys_pattern is None:\n            json_schema['additionalProperties'] = values_schema\n        else:\n            json_schema['patternProperties'] = {keys_pattern: values_schema}\n    else:  # for `dict[str, Any]`, we allow any key and any value, since `str` is the default key type\n        json_schema['additionalProperties'] = True\n\n    if (\n        # The len check indicates that constraints are probably present:\n        (keys_schema.get('type') == 'string' and len(keys_schema) &gt; 1)\n        # If this is a definition reference schema, it most likely has constraints:\n        or '$ref' in keys_schema\n    ):\n        keys_schema.pop('type', None)\n        json_schema['propertyNames'] = keys_schema\n\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.object)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.function_before_schema","title":"function_before_schema","text":"<pre><code>function_before_schema(schema: BeforeValidatorFunctionSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a function-before schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>BeforeValidatorFunctionSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def function_before_schema(self, schema: core_schema.BeforeValidatorFunctionSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a function-before schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    if self.mode == 'validation' and (input_schema := schema.get('json_schema_input_schema')):\n        return self.generate_inner(input_schema)\n\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.function_after_schema","title":"function_after_schema","text":"<pre><code>function_after_schema(schema: AfterValidatorFunctionSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a function-after schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>AfterValidatorFunctionSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def function_after_schema(self, schema: core_schema.AfterValidatorFunctionSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a function-after schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.function_plain_schema","title":"function_plain_schema","text":"<pre><code>function_plain_schema(schema: PlainValidatorFunctionSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a function-plain schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>PlainValidatorFunctionSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def function_plain_schema(self, schema: core_schema.PlainValidatorFunctionSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a function-plain schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    if self.mode == 'validation' and (input_schema := schema.get('json_schema_input_schema')):\n        return self.generate_inner(input_schema)\n\n    return self.handle_invalid_for_json_schema(\n        schema, f'core_schema.PlainValidatorFunctionSchema ({schema[\"function\"]})'\n    )\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.function_wrap_schema","title":"function_wrap_schema","text":"<pre><code>function_wrap_schema(schema: WrapValidatorFunctionSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a function-wrap schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>WrapValidatorFunctionSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def function_wrap_schema(self, schema: core_schema.WrapValidatorFunctionSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a function-wrap schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    if self.mode == 'validation' and (input_schema := schema.get('json_schema_input_schema')):\n        return self.generate_inner(input_schema)\n\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.default_schema","title":"default_schema","text":"<pre><code>default_schema(schema: WithDefaultSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema with a default value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>WithDefaultSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def default_schema(self, schema: core_schema.WithDefaultSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema with a default value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema = self.generate_inner(schema['schema'])\n\n    default = self.get_default_value(schema)\n    if default is NoDefault or default is MISSING:\n        return json_schema\n\n    # we reflect the application of custom plain, no-info serializers to defaults for\n    # JSON Schemas viewed in serialization mode:\n    # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n    if self.mode == 'serialization':\n        # `_get_ser_schema_for_default_value()` is used to unpack potentially nested validator schemas:\n        ser_schema = _get_ser_schema_for_default_value(schema['schema'])\n        if (\n            ser_schema is not None\n            and (ser_func := ser_schema.get('function'))\n            and not (default is None and ser_schema.get('when_used') in ('unless-none', 'json-unless-none'))\n        ):\n            try:\n                default = ser_func(default)  # type: ignore\n            except Exception:\n                # It might be that the provided default needs to be validated (read: parsed) first\n                # (assuming `validate_default` is enabled). However, we can't perform\n                # such validation during JSON Schema generation so we don't support\n                # this pattern for now.\n                # (One example is when using `foo: ByteSize = '1MB'`, which validates and\n                # serializes as an int. In this case, `ser_func` is `int` and `int('1MB')` fails).\n                self.emit_warning(\n                    'non-serializable-default',\n                    f'Unable to serialize value {default!r} with the plain serializer; excluding default from JSON schema',\n                )\n                return json_schema\n\n    try:\n        encoded_default = self.encode_default(default)\n    except pydantic_core.PydanticSerializationError:\n        self.emit_warning(\n            'non-serializable-default',\n            f'Default value {default} is not JSON serializable; excluding default from JSON schema',\n        )\n        # Return the inner schema, as though there was no default\n        return json_schema\n\n    json_schema['default'] = encoded_default\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_default_value","title":"get_default_value","text":"<pre><code>get_default_value(schema: WithDefaultSchema) -&gt; Any\n</code></pre> <p>Get the default value to be used when generating a JSON Schema for a core schema with a default.</p> <p>The default implementation is to use the statically defined default value. This method can be overridden if you want to make use of the default factory.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>WithDefaultSchema</code> <p>The <code>'with-default'</code> core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The default value to use, or <code>NoDefault</code> if no default value is available.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_default_value(self, schema: core_schema.WithDefaultSchema) -&gt; Any:\n    \"\"\"Get the default value to be used when generating a JSON Schema for a core schema with a default.\n\n    The default implementation is to use the statically defined default value. This method can be overridden\n    if you want to make use of the default factory.\n\n    Args:\n        schema: The `'with-default'` core schema.\n\n    Returns:\n        The default value to use, or [`NoDefault`][pydantic.json_schema.NoDefault] if no default\n            value is available.\n    \"\"\"\n    return schema.get('default', NoDefault)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.nullable_schema","title":"nullable_schema","text":"<pre><code>nullable_schema(schema: NullableSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that allows null values.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>NullableSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def nullable_schema(self, schema: core_schema.NullableSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that allows null values.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    null_schema = {'type': 'null'}\n    inner_json_schema = self.generate_inner(schema['schema'])\n\n    if inner_json_schema == null_schema:\n        return null_schema\n    else:\n        return self.get_union_of_schemas([inner_json_schema, null_schema])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.union_schema","title":"union_schema","text":"<pre><code>union_schema(schema: UnionSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that allows values matching any of the given schemas.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>UnionSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def union_schema(self, schema: core_schema.UnionSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that allows values matching any of the given schemas.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    generated: list[JsonSchemaValue] = []\n\n    choices = schema['choices']\n    for choice in choices:\n        # choice will be a tuple if an explicit label was provided\n        choice_schema = choice[0] if isinstance(choice, tuple) else choice\n        try:\n            generated.append(self.generate_inner(choice_schema))\n        except PydanticOmit:\n            continue\n        except PydanticInvalidForJsonSchema as exc:\n            self.emit_warning('skipped-choice', exc.message)\n    if len(generated) == 1:\n        return generated[0]\n    return self.get_union_of_schemas(generated)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_union_of_schemas","title":"get_union_of_schemas","text":"<pre><code>get_union_of_schemas(schemas: list[JsonSchemaValue]) -&gt; JsonSchemaValue\n</code></pre> <p>Returns the JSON Schema representation for the union of the provided JSON Schemas.</p> <p>The result depends on the configured <code>'union_format'</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schemas</code> <code>list[JsonSchemaValue]</code> <p>The list of JSON Schemas to be included in the union.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The JSON Schema representing the union of schemas.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_union_of_schemas(self, schemas: list[JsonSchemaValue]) -&gt; JsonSchemaValue:\n    \"\"\"Returns the JSON Schema representation for the union of the provided JSON Schemas.\n\n    The result depends on the configured `'union_format'`.\n\n    Args:\n        schemas: The list of JSON Schemas to be included in the union.\n\n    Returns:\n        The JSON Schema representing the union of schemas.\n    \"\"\"\n    if self.union_format == 'primitive_type_array':\n        types: list[str] = []\n        for schema in schemas:\n            schema_types: list[str] | str | None = schema.get('type')\n            if schema_types is None:\n                # No type, meaning it can be a ref or an empty schema.\n                break\n            if not isinstance(schema_types, list):\n                schema_types = [schema_types]\n            if not all(t in _PRIMITIVE_JSON_SCHEMA_TYPES for t in schema_types):\n                break\n            if len(schema) != 1:\n                # We only want to include types that don't have any constraints. For instance,\n                # if `schemas = [{'type': 'string', 'maxLength': 3}, {'type': 'string', 'minLength': 5}]`,\n                # we don't want to produce `{'type': 'string', 'maxLength': 3, 'minLength': 5}`.\n                # Same if we have some metadata (e.g. `title`) on a specific union member, we want to preserve it.\n                break\n\n            types.extend(schema_types)\n        else:\n            # If we got there, all the schemas where valid to be used with the `'primitive_type_array` format\n            return {'type': list(dict.fromkeys(types))}\n\n    return self.get_flattened_anyof(schemas)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.tagged_union_schema","title":"tagged_union_schema","text":"<pre><code>tagged_union_schema(schema: TaggedUnionSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where the schemas are tagged with a discriminator field that indicates which schema should be used to validate the value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>TaggedUnionSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def tagged_union_schema(self, schema: core_schema.TaggedUnionSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where\n    the schemas are tagged with a discriminator field that indicates which schema should be used to validate\n    the value.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    generated: dict[str, JsonSchemaValue] = {}\n    for k, v in schema['choices'].items():\n        if isinstance(k, Enum):\n            k = k.value\n        try:\n            # Use str(k) since keys must be strings for json; while not technically correct,\n            # it's the closest that can be represented in valid JSON\n            generated[str(k)] = self.generate_inner(v).copy()\n        except PydanticOmit:\n            continue\n        except PydanticInvalidForJsonSchema as exc:\n            self.emit_warning('skipped-choice', exc.message)\n\n    one_of_choices = _deduplicate_schemas(generated.values())\n    json_schema: JsonSchemaValue = {'oneOf': one_of_choices}\n\n    # This reflects the v1 behavior; TODO: we should make it possible to exclude OpenAPI stuff from the JSON schema\n    openapi_discriminator = self._extract_discriminator(schema, one_of_choices)\n    if openapi_discriminator is not None:\n        json_schema['discriminator'] = {\n            'propertyName': openapi_discriminator,\n            'mapping': {k: v.get('$ref', v) for k, v in generated.items()},\n        }\n\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.chain_schema","title":"chain_schema","text":"<pre><code>chain_schema(schema: ChainSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a core_schema.ChainSchema.</p> <p>When generating a schema for validation, we return the validation JSON schema for the first step in the chain. For serialization, we return the serialization JSON schema for the last step in the chain.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ChainSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def chain_schema(self, schema: core_schema.ChainSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a core_schema.ChainSchema.\n\n    When generating a schema for validation, we return the validation JSON schema for the first step in the chain.\n    For serialization, we return the serialization JSON schema for the last step in the chain.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    step_index = 0 if self.mode == 'validation' else -1  # use first step for validation, last for serialization\n    return self.generate_inner(schema['steps'][step_index])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.lax_or_strict_schema","title":"lax_or_strict_schema","text":"<pre><code>lax_or_strict_schema(schema: LaxOrStrictSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that allows values matching either the lax schema or the strict schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>LaxOrStrictSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that allows values matching either the lax schema or the\n    strict schema.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    # TODO: Need to read the default value off of model config or whatever\n    use_strict = schema.get('strict', False)  # TODO: replace this default False\n    # If your JSON schema fails to generate it is probably\n    # because one of the following two branches failed.\n    if use_strict:\n        return self.generate_inner(schema['strict_schema'])\n    else:\n        return self.generate_inner(schema['lax_schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.json_or_python_schema","title":"json_or_python_schema","text":"<pre><code>json_or_python_schema(schema: JsonOrPythonSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the Python schema.</p> <p>The JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override this method.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>JsonOrPythonSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the\n    Python schema.\n\n    The JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override\n    this method.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['json_schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.typed_dict_schema","title":"typed_dict_schema","text":"<pre><code>typed_dict_schema(schema: TypedDictSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a typed dict.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>TypedDictSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def typed_dict_schema(self, schema: core_schema.TypedDictSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a typed dict.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    total = schema.get('total', True)\n    named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [\n        (name, self.field_is_required(field, total), field)\n        for name, field in schema['fields'].items()\n        if self.field_is_present(field)\n    ]\n    if self.mode == 'serialization':\n        named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))\n    cls = schema.get('cls')\n    config = _get_typed_dict_config(cls)\n    with self._config_wrapper_stack.push(config):\n        json_schema = self._named_required_fields_schema(named_required_fields)\n\n    # There's some duplication between `extra_behavior` and\n    # the config's `extra`/core config's `extra_fields_behavior`.\n    # However, it is common to manually create TypedDictSchemas,\n    # where you don't necessarily have a class.\n    # At runtime, `extra_behavior` takes priority over the config\n    # for validation, so follow the same for the JSON Schema:\n    if schema.get('extra_behavior') == 'forbid':\n        json_schema['additionalProperties'] = False\n    elif schema.get('extra_behavior') == 'allow':\n        if 'extras_schema' in schema and schema['extras_schema'] != {'type': 'any'}:\n            json_schema['additionalProperties'] = self.generate_inner(schema['extras_schema'])\n        else:\n            json_schema['additionalProperties'] = True\n\n    if cls is not None:\n        # `_update_class_schema()` will not override\n        # `additionalProperties` if already present:\n        self._update_class_schema(json_schema, cls, config)\n    elif 'additionalProperties' not in json_schema:\n        extra = schema.get('config', {}).get('extra_fields_behavior')\n        if extra == 'forbid':\n            json_schema['additionalProperties'] = False\n        elif extra == 'allow':\n            json_schema['additionalProperties'] = True\n\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.typed_dict_field_schema","title":"typed_dict_field_schema","text":"<pre><code>typed_dict_field_schema(schema: TypedDictField) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a typed dict field.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>TypedDictField</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def typed_dict_field_schema(self, schema: core_schema.TypedDictField) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a typed dict field.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.dataclass_field_schema","title":"dataclass_field_schema","text":"<pre><code>dataclass_field_schema(schema: DataclassField) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a dataclass field.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DataclassField</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def dataclass_field_schema(self, schema: core_schema.DataclassField) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a dataclass field.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.model_field_schema","title":"model_field_schema","text":"<pre><code>model_field_schema(schema: ModelField) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a model field.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ModelField</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def model_field_schema(self, schema: core_schema.ModelField) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a model field.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.computed_field_schema","title":"computed_field_schema","text":"<pre><code>computed_field_schema(schema: ComputedField) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a computed field.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ComputedField</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def computed_field_schema(self, schema: core_schema.ComputedField) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a computed field.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['return_schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.model_schema","title":"model_schema","text":"<pre><code>model_schema(schema: ModelSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ModelSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def model_schema(self, schema: core_schema.ModelSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a model.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    # We do not use schema['model'].model_json_schema() here\n    # because it could lead to inconsistent refs handling, etc.\n    cls = cast('type[BaseModel]', schema['cls'])\n    config = cls.model_config\n\n    with self._config_wrapper_stack.push(config):\n        json_schema = self.generate_inner(schema['schema'])\n\n    self._update_class_schema(json_schema, cls, config)\n\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.resolve_ref_schema","title":"resolve_ref_schema","text":"<pre><code>resolve_ref_schema(json_schema: JsonSchemaValue) -&gt; JsonSchemaValue\n</code></pre> <p>Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>json_schema</code> <code>JsonSchemaValue</code> <p>The schema to resolve.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The resolved schema.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>RuntimeError</code> <p>If the schema reference can't be found in definitions.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def resolve_ref_schema(self, json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:\n    \"\"\"Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.\n\n    Args:\n        json_schema: The schema to resolve.\n\n    Returns:\n        The resolved schema.\n\n    Raises:\n        RuntimeError: If the schema reference can't be found in definitions.\n    \"\"\"\n    while '$ref' in json_schema:\n        ref = json_schema['$ref']\n        schema_to_update = self.get_schema_from_definitions(JsonRef(ref))\n        if schema_to_update is None:\n            raise RuntimeError(f'Cannot update undefined schema for $ref={ref}')\n        json_schema = schema_to_update\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.model_fields_schema","title":"model_fields_schema","text":"<pre><code>model_fields_schema(schema: ModelFieldsSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a model's fields.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ModelFieldsSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def model_fields_schema(self, schema: core_schema.ModelFieldsSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a model's fields.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [\n        (name, self.field_is_required(field, total=True), field)\n        for name, field in schema['fields'].items()\n        if self.field_is_present(field)\n    ]\n    if self.mode == 'serialization':\n        named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))\n    json_schema = self._named_required_fields_schema(named_required_fields)\n    extras_schema = schema.get('extras_schema', None)\n    if extras_schema is not None:\n        schema_to_update = self.resolve_ref_schema(json_schema)\n        schema_to_update['additionalProperties'] = self.generate_inner(extras_schema)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.field_is_present","title":"field_is_present","text":"<pre><code>field_is_present(field: CoreSchemaField) -&gt; bool\n</code></pre> <p>Whether the field should be included in the generated JSON schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>CoreSchemaField</code> <p>The schema for the field itself.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool</code> <p><code>True</code> if the field should be included in the generated JSON schema, <code>False</code> otherwise.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def field_is_present(self, field: CoreSchemaField) -&gt; bool:\n    \"\"\"Whether the field should be included in the generated JSON schema.\n\n    Args:\n        field: The schema for the field itself.\n\n    Returns:\n        `True` if the field should be included in the generated JSON schema, `False` otherwise.\n    \"\"\"\n    if self.mode == 'serialization':\n        # If you still want to include the field in the generated JSON schema,\n        # override this method and return True\n        return not field.get('serialization_exclude')\n    elif self.mode == 'validation':\n        return True\n    else:\n        assert_never(self.mode)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.field_is_required","title":"field_is_required","text":"<pre><code>field_is_required(field: ModelField | DataclassField | TypedDictField, total: bool) -&gt; bool\n</code></pre> <p>Whether the field should be marked as required in the generated JSON schema. (Note that this is irrelevant if the field is not present in the JSON schema.).</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>ModelField | DataclassField | TypedDictField</code> <p>The schema for the field itself.</p> \u5fc5\u9700 <code>total</code> <code>bool</code> <p>Only applies to <code>TypedDictField</code>s. Indicates if the <code>TypedDict</code> this field belongs to is total, in which case any fields that don't explicitly specify <code>required=False</code> are required.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool</code> <p><code>True</code> if the field should be marked as required in the generated JSON schema, <code>False</code> otherwise.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def field_is_required(\n    self,\n    field: core_schema.ModelField | core_schema.DataclassField | core_schema.TypedDictField,\n    total: bool,\n) -&gt; bool:\n    \"\"\"Whether the field should be marked as required in the generated JSON schema.\n    (Note that this is irrelevant if the field is not present in the JSON schema.).\n\n    Args:\n        field: The schema for the field itself.\n        total: Only applies to `TypedDictField`s.\n            Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't\n            explicitly specify `required=False` are required.\n\n    Returns:\n        `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.\n    \"\"\"\n    if self.mode == 'serialization' and self._config.json_schema_serialization_defaults_required:\n        return not field.get('serialization_exclude')\n    else:\n        if field['type'] == 'typed-dict-field':\n            return field.get('required', total)\n        else:\n            return field['schema']['type'] != 'default'\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.dataclass_args_schema","title":"dataclass_args_schema","text":"<pre><code>dataclass_args_schema(schema: DataclassArgsSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DataclassArgsSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [\n        (field['name'], self.field_is_required(field, total=True), field)\n        for field in schema['fields']\n        if self.field_is_present(field)\n    ]\n    if self.mode == 'serialization':\n        named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))\n    return self._named_required_fields_schema(named_required_fields)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.dataclass_schema","title":"dataclass_schema","text":"<pre><code>dataclass_schema(schema: DataclassSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a dataclass.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DataclassSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def dataclass_schema(self, schema: core_schema.DataclassSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a dataclass.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    from ._internal._dataclasses import is_stdlib_dataclass\n\n    cls = schema['cls']\n    config: ConfigDict = getattr(cls, '__pydantic_config__', cast('ConfigDict', {}))\n\n    with self._config_wrapper_stack.push(config):\n        json_schema = self.generate_inner(schema['schema']).copy()\n\n    self._update_class_schema(json_schema, cls, config)\n\n    # Dataclass-specific handling of description\n    if is_stdlib_dataclass(cls):\n        # vanilla dataclass; don't use cls.__doc__ as it will contain the class signature by default\n        description = None\n    else:\n        description = None if cls.__doc__ is None else inspect.cleandoc(cls.__doc__)\n    if description:\n        json_schema['description'] = description\n\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.arguments_schema","title":"arguments_schema","text":"<pre><code>arguments_schema(schema: ArgumentsSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a function's arguments.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ArgumentsSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def arguments_schema(self, schema: core_schema.ArgumentsSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a function's arguments.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    prefer_positional = schema.get('metadata', {}).get('pydantic_js_prefer_positional_arguments')\n\n    arguments = schema['arguments_schema']\n    kw_only_arguments = [a for a in arguments if a.get('mode') == 'keyword_only']\n    kw_or_p_arguments = [a for a in arguments if a.get('mode') in {'positional_or_keyword', None}]\n    p_only_arguments = [a for a in arguments if a.get('mode') == 'positional_only']\n    var_args_schema = schema.get('var_args_schema')\n    var_kwargs_schema = schema.get('var_kwargs_schema')\n\n    if prefer_positional:\n        positional_possible = not kw_only_arguments and not var_kwargs_schema\n        if positional_possible:\n            return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)\n\n    keyword_possible = not p_only_arguments and not var_args_schema\n    if keyword_possible:\n        return self.kw_arguments_schema(kw_or_p_arguments + kw_only_arguments, var_kwargs_schema)\n\n    if not prefer_positional:\n        positional_possible = not kw_only_arguments and not var_kwargs_schema\n        if positional_possible:\n            return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)\n\n    raise PydanticInvalidForJsonSchema(\n        'Unable to generate JSON schema for arguments validator with positional-only and keyword-only arguments'\n    )\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.kw_arguments_schema","title":"kw_arguments_schema","text":"<pre><code>kw_arguments_schema(arguments: list[ArgumentsParameter], var_kwargs_schema: CoreSchema | None) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a function's keyword arguments.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>arguments</code> <code>list[ArgumentsParameter]</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def kw_arguments_schema(\n    self, arguments: list[core_schema.ArgumentsParameter], var_kwargs_schema: CoreSchema | None\n) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a function's keyword arguments.\n\n    Args:\n        arguments: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    properties: dict[str, JsonSchemaValue] = {}\n    required: list[str] = []\n    for argument in arguments:\n        name = self.get_argument_name(argument)\n        argument_schema = self.generate_inner(argument['schema']).copy()\n        if 'title' not in argument_schema and self.field_title_should_be_set(argument['schema']):\n            argument_schema['title'] = self.get_title_from_name(name)\n        properties[name] = argument_schema\n\n        if argument['schema']['type'] != 'default':\n            # This assumes that if the argument has a default value,\n            # the inner schema must be of type WithDefaultSchema.\n            # I believe this is true, but I am not 100% sure\n            required.append(name)\n\n    json_schema: JsonSchemaValue = {'type': 'object', 'properties': properties}\n    if required:\n        json_schema['required'] = required\n\n    if var_kwargs_schema:\n        additional_properties_schema = self.generate_inner(var_kwargs_schema)\n        if additional_properties_schema:\n            json_schema['additionalProperties'] = additional_properties_schema\n    else:\n        json_schema['additionalProperties'] = False\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.p_arguments_schema","title":"p_arguments_schema","text":"<pre><code>p_arguments_schema(arguments: list[ArgumentsParameter], var_args_schema: CoreSchema | None) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a function's positional arguments.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>arguments</code> <code>list[ArgumentsParameter]</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def p_arguments_schema(\n    self, arguments: list[core_schema.ArgumentsParameter], var_args_schema: CoreSchema | None\n) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a function's positional arguments.\n\n    Args:\n        arguments: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    prefix_items: list[JsonSchemaValue] = []\n    min_items = 0\n\n    for argument in arguments:\n        name = self.get_argument_name(argument)\n\n        argument_schema = self.generate_inner(argument['schema']).copy()\n        if 'title' not in argument_schema and self.field_title_should_be_set(argument['schema']):\n            argument_schema['title'] = self.get_title_from_name(name)\n        prefix_items.append(argument_schema)\n\n        if argument['schema']['type'] != 'default':\n            # This assumes that if the argument has a default value,\n            # the inner schema must be of type WithDefaultSchema.\n            # I believe this is true, but I am not 100% sure\n            min_items += 1\n\n    json_schema: JsonSchemaValue = {'type': 'array'}\n    if prefix_items:\n        json_schema['prefixItems'] = prefix_items\n    if min_items:\n        json_schema['minItems'] = min_items\n\n    if var_args_schema:\n        items_schema = self.generate_inner(var_args_schema)\n        if items_schema:\n            json_schema['items'] = items_schema\n    else:\n        json_schema['maxItems'] = len(prefix_items)\n\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_argument_name","title":"get_argument_name","text":"<pre><code>get_argument_name(argument: ArgumentsParameter | ArgumentsV3Parameter) -&gt; str\n</code></pre> <p>Retrieves the name of an argument.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>argument</code> <code>ArgumentsParameter | ArgumentsV3Parameter</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The name of the argument.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_argument_name(self, argument: core_schema.ArgumentsParameter | core_schema.ArgumentsV3Parameter) -&gt; str:\n    \"\"\"Retrieves the name of an argument.\n\n    Args:\n        argument: The core schema.\n\n    Returns:\n        The name of the argument.\n    \"\"\"\n    name = argument['name']\n    if self.by_alias:\n        alias = argument.get('alias')\n        if isinstance(alias, str):\n            name = alias\n        else:\n            pass  # might want to do something else?\n    return name\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.arguments_v3_schema","title":"arguments_v3_schema","text":"<pre><code>arguments_v3_schema(schema: ArgumentsV3Schema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a function's arguments.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ArgumentsV3Schema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def arguments_v3_schema(self, schema: core_schema.ArgumentsV3Schema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a function's arguments.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    arguments = schema['arguments_schema']\n    properties: dict[str, JsonSchemaValue] = {}\n    required: list[str] = []\n    for argument in arguments:\n        mode = argument.get('mode', 'positional_or_keyword')\n        name = self.get_argument_name(argument)\n        argument_schema = self.generate_inner(argument['schema']).copy()\n        if mode == 'var_args':\n            argument_schema = {'type': 'array', 'items': argument_schema}\n        elif mode == 'var_kwargs_uniform':\n            argument_schema = {'type': 'object', 'additionalProperties': argument_schema}\n\n        argument_schema.setdefault('title', self.get_title_from_name(name))\n        properties[name] = argument_schema\n\n        if (\n            (mode == 'var_kwargs_unpacked_typed_dict' and 'required' in argument_schema)\n            or mode not in {'var_args', 'var_kwargs_uniform', 'var_kwargs_unpacked_typed_dict'}\n            and argument['schema']['type'] != 'default'\n        ):\n            # This assumes that if the argument has a default value,\n            # the inner schema must be of type WithDefaultSchema.\n            # I believe this is true, but I am not 100% sure\n            required.append(name)\n\n    json_schema: JsonSchemaValue = {'type': 'object', 'properties': properties}\n    if required:\n        json_schema['required'] = required\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.call_schema","title":"call_schema","text":"<pre><code>call_schema(schema: CallSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a function call.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CallSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def call_schema(self, schema: core_schema.CallSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a function call.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['arguments_schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.custom_error_schema","title":"custom_error_schema","text":"<pre><code>custom_error_schema(schema: CustomErrorSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a custom error.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CustomErrorSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def custom_error_schema(self, schema: core_schema.CustomErrorSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a custom error.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.json_schema","title":"json_schema","text":"<pre><code>json_schema(schema: JsonSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a JSON object.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>JsonSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def json_schema(self, schema: core_schema.JsonSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a JSON object.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    content_core_schema = schema.get('schema') or core_schema.any_schema()\n    content_json_schema = self.generate_inner(content_core_schema)\n    if self.mode == 'validation':\n        return {'type': 'string', 'contentMediaType': 'application/json', 'contentSchema': content_json_schema}\n    else:\n        # self.mode == 'serialization'\n        return content_json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.url_schema","title":"url_schema","text":"<pre><code>url_schema(schema: UrlSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a URL.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>UrlSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def url_schema(self, schema: core_schema.UrlSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a URL.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    json_schema = {'type': 'string', 'format': 'uri', 'minLength': 1}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.multi_host_url_schema","title":"multi_host_url_schema","text":"<pre><code>multi_host_url_schema(schema: MultiHostUrlSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>MultiHostUrlSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def multi_host_url_schema(self, schema: core_schema.MultiHostUrlSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    # Note: 'multi-host-uri' is a custom/pydantic-specific format, not part of the JSON Schema spec\n    json_schema = {'type': 'string', 'format': 'multi-host-uri', 'minLength': 1}\n    self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.uuid_schema","title":"uuid_schema","text":"<pre><code>uuid_schema(schema: UuidSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a UUID.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>UuidSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def uuid_schema(self, schema: core_schema.UuidSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a UUID.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'string', 'format': 'uuid'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.definitions_schema","title":"definitions_schema","text":"<pre><code>definitions_schema(schema: DefinitionsSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a JSON object with definitions.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DefinitionsSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def definitions_schema(self, schema: core_schema.DefinitionsSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that defines a JSON object with definitions.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    for definition in schema['definitions']:\n        try:\n            self.generate_inner(definition)\n        except PydanticInvalidForJsonSchema as e:  # noqa: PERF203\n            core_ref: CoreRef = CoreRef(definition['ref'])  # type: ignore\n            self._core_defs_invalid_for_json_schema[self.get_defs_ref((core_ref, self.mode))] = e\n            continue\n    return self.generate_inner(schema['schema'])\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.definition_ref_schema","title":"definition_ref_schema","text":"<pre><code>definition_ref_schema(schema: DefinitionReferenceSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a schema that references a definition.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>DefinitionReferenceSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def definition_ref_schema(self, schema: core_schema.DefinitionReferenceSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a schema that references a definition.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    core_ref = CoreRef(schema['schema_ref'])\n    _, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)\n    return ref_json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.ser_schema","title":"ser_schema","text":"<pre><code>ser_schema(schema: SerSchema | IncExSeqSerSchema | IncExDictSerSchema) -&gt; JsonSchemaValue | None\n</code></pre> <p>Generates a JSON schema that matches a schema that defines a serialized object.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>SerSchema | IncExSeqSerSchema | IncExDictSerSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue | None</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def ser_schema(\n    self, schema: core_schema.SerSchema | core_schema.IncExSeqSerSchema | core_schema.IncExDictSerSchema\n) -&gt; JsonSchemaValue | None:\n    \"\"\"Generates a JSON schema that matches a schema that defines a serialized object.\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    schema_type = schema['type']\n    if schema_type == 'function-plain' or schema_type == 'function-wrap':\n        # PlainSerializerFunctionSerSchema or WrapSerializerFunctionSerSchema\n        return_schema = schema.get('return_schema')\n        if return_schema is not None:\n            return self.generate_inner(return_schema)\n    elif schema_type == 'format' or schema_type == 'to-string':\n        # FormatSerSchema or ToStringSerSchema\n        return self.str_schema(core_schema.str_schema())\n    elif schema['type'] == 'model':\n        # ModelSerSchema\n        return self.generate_inner(schema['schema'])\n    return None\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.complex_schema","title":"complex_schema","text":"<pre><code>complex_schema(schema: ComplexSchema) -&gt; JsonSchemaValue\n</code></pre> <p>Generates a JSON schema that matches a complex number.</p> <p>JSON has no standard way to represent complex numbers. Complex number is not a numeric type. Here we represent complex number as strings following the rule defined by Python. For instance, '1+2j' is an accepted complex string. Details can be found in Python's <code>complex</code> documentation.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>ComplexSchema</code> <p>The core schema.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The generated JSON schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def complex_schema(self, schema: core_schema.ComplexSchema) -&gt; JsonSchemaValue:\n    \"\"\"Generates a JSON schema that matches a complex number.\n\n    JSON has no standard way to represent complex numbers. Complex number is not a numeric\n    type. Here we represent complex number as strings following the rule defined by Python.\n    For instance, '1+2j' is an accepted complex string. Details can be found in\n    [Python's `complex` documentation][complex].\n\n    Args:\n        schema: The core schema.\n\n    Returns:\n        The generated JSON schema.\n    \"\"\"\n    return {'type': 'string'}\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_title_from_name","title":"get_title_from_name","text":"<pre><code>get_title_from_name(name: str) -&gt; str\n</code></pre> <p>Retrieves a title from a name.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>name</code> <code>str</code> <p>The name to retrieve a title from.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The title.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_title_from_name(self, name: str) -&gt; str:\n    \"\"\"Retrieves a title from a name.\n\n    Args:\n        name: The name to retrieve a title from.\n\n    Returns:\n        The title.\n    \"\"\"\n    return name.title().replace('_', ' ').strip()\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.field_title_should_be_set","title":"field_title_should_be_set","text":"<pre><code>field_title_should_be_set(schema: CoreSchemaOrField) -&gt; bool\n</code></pre> <p>Returns true if a field with the given schema should have a title set based on the field name.</p> <p>Intuitively, we want this to return true for schemas that wouldn't otherwise provide their own title (e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchemaOrField</code> <p>The schema to check.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool</code> <p><code>True</code> if the field should have a title set, <code>False</code> otherwise.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def field_title_should_be_set(self, schema: CoreSchemaOrField) -&gt; bool:\n    \"\"\"Returns true if a field with the given schema should have a title set based on the field name.\n\n    Intuitively, we want this to return true for schemas that wouldn't otherwise provide their own title\n    (e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).\n\n    Args:\n        schema: The schema to check.\n\n    Returns:\n        `True` if the field should have a title set, `False` otherwise.\n    \"\"\"\n    if _core_utils.is_core_schema_field(schema):\n        if schema['type'] == 'computed-field':\n            field_schema = schema['return_schema']\n        else:\n            field_schema = schema['schema']\n        return self.field_title_should_be_set(field_schema)\n\n    elif _core_utils.is_core_schema(schema):\n        if schema.get('ref'):  # things with refs, such as models and enums, should not have titles set\n            return False\n        if schema['type'] in {'default', 'nullable', 'definitions'}:\n            return self.field_title_should_be_set(schema['schema'])  # type: ignore[typeddict-item]\n        if _core_utils.is_function_with_inner_schema(schema):\n            return self.field_title_should_be_set(schema['schema'])\n        if schema['type'] == 'definition-ref':\n            # Referenced schemas should not have titles set for the same reason\n            # schemas with refs should not\n            return False\n        return True  # anything else should have title set\n\n    else:\n        raise PydanticInvalidForJsonSchema(f'Unexpected schema type: schema={schema}')  # pragma: no cover\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.normalize_name","title":"normalize_name","text":"<pre><code>normalize_name(name: str) -&gt; str\n</code></pre> <p>Normalizes a name to be used as a key in a dictionary.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>name</code> <code>str</code> <p>The name to normalize.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The normalized name.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def normalize_name(self, name: str) -&gt; str:\n    \"\"\"Normalizes a name to be used as a key in a dictionary.\n\n    Args:\n        name: The name to normalize.\n\n    Returns:\n        The normalized name.\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9.\\-_]', '_', name).replace('.', '__')\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_defs_ref","title":"get_defs_ref","text":"<pre><code>get_defs_ref(core_mode_ref: CoreModeRef) -&gt; DefsRef\n</code></pre> <p>Override this method to change the way that definitions keys are generated from a core reference.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>core_mode_ref</code> <code>CoreModeRef</code> <p>The core reference.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>DefsRef</code> <p>The definitions key.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_defs_ref(self, core_mode_ref: CoreModeRef) -&gt; DefsRef:\n    \"\"\"Override this method to change the way that definitions keys are generated from a core reference.\n\n    Args:\n        core_mode_ref: The core reference.\n\n    Returns:\n        The definitions key.\n    \"\"\"\n    # Split the core ref into \"components\"; generic origins and arguments are each separate components\n    core_ref, mode = core_mode_ref\n    components = re.split(r'([\\][,])', core_ref)\n    # Remove IDs from each component\n    components = [x.rsplit(':', 1)[0] for x in components]\n    core_ref_no_id = ''.join(components)\n    # Remove everything before the last period from each \"component\"\n    components = [re.sub(r'(?:[^.[\\]]+\\.)+((?:[^.[\\]]+))', r'\\1', x) for x in components]\n    short_ref = ''.join(components)\n\n    mode_title = _MODE_TITLE_MAPPING[mode]\n\n    # It is important that the generated defs_ref values be such that at least one choice will not\n    # be generated for any other core_ref. Currently, this should be the case because we include\n    # the id of the source type in the core_ref\n    name = DefsRef(self.normalize_name(short_ref))\n    name_mode = DefsRef(self.normalize_name(short_ref) + f'-{mode_title}')\n    module_qualname = DefsRef(self.normalize_name(core_ref_no_id))\n    module_qualname_mode = DefsRef(f'{module_qualname}-{mode_title}')\n    module_qualname_id = DefsRef(self.normalize_name(core_ref))\n    occurrence_index = self._collision_index.get(module_qualname_id)\n    if occurrence_index is None:\n        self._collision_counter[module_qualname] += 1\n        occurrence_index = self._collision_index[module_qualname_id] = self._collision_counter[module_qualname]\n\n    module_qualname_occurrence = DefsRef(f'{module_qualname}__{occurrence_index}')\n    module_qualname_occurrence_mode = DefsRef(f'{module_qualname_mode}__{occurrence_index}')\n\n    self._prioritized_defsref_choices[module_qualname_occurrence_mode] = [\n        name,\n        name_mode,\n        module_qualname,\n        module_qualname_mode,\n        module_qualname_occurrence,\n        module_qualname_occurrence_mode,\n    ]\n\n    return module_qualname_occurrence_mode\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_cache_defs_ref_schema","title":"get_cache_defs_ref_schema","text":"<pre><code>get_cache_defs_ref_schema(core_ref: CoreRef) -&gt; tuple[DefsRef, JsonSchemaValue]\n</code></pre> <p>This method wraps the get_defs_ref method with some cache-lookup/population logic, and returns both the produced defs_ref and the JSON schema that will refer to the right definition.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>core_ref</code> <code>CoreRef</code> <p>The core reference to get the definitions reference for.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[DefsRef, JsonSchemaValue]</code> <p>A tuple of the definitions reference and the JSON schema that will refer to it.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_cache_defs_ref_schema(self, core_ref: CoreRef) -&gt; tuple[DefsRef, JsonSchemaValue]:\n    \"\"\"This method wraps the get_defs_ref method with some cache-lookup/population logic,\n    and returns both the produced defs_ref and the JSON schema that will refer to the right definition.\n\n    Args:\n        core_ref: The core reference to get the definitions reference for.\n\n    Returns:\n        A tuple of the definitions reference and the JSON schema that will refer to it.\n    \"\"\"\n    core_mode_ref = (core_ref, self.mode)\n    maybe_defs_ref = self.core_to_defs_refs.get(core_mode_ref)\n    if maybe_defs_ref is not None:\n        json_ref = self.core_to_json_refs[core_mode_ref]\n        return maybe_defs_ref, {'$ref': json_ref}\n\n    defs_ref = self.get_defs_ref(core_mode_ref)\n\n    # populate the ref translation mappings\n    self.core_to_defs_refs[core_mode_ref] = defs_ref\n    self.defs_to_core_refs[defs_ref] = core_mode_ref\n\n    json_ref = JsonRef(self.ref_template.format(model=defs_ref))\n    self.core_to_json_refs[core_mode_ref] = json_ref\n    self.json_to_defs_refs[json_ref] = defs_ref\n    ref_json_schema = {'$ref': json_ref}\n    return defs_ref, ref_json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.handle_ref_overrides","title":"handle_ref_overrides","text":"<pre><code>handle_ref_overrides(json_schema: JsonSchemaValue) -&gt; JsonSchemaValue\n</code></pre> <p>Remove any sibling keys that are redundant with the referenced schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>json_schema</code> <code>JsonSchemaValue</code> <p>The schema to remove redundant sibling keys from.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>JsonSchemaValue</code> <p>The schema with redundant sibling keys removed.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def handle_ref_overrides(self, json_schema: JsonSchemaValue) -&gt; JsonSchemaValue:\n    \"\"\"Remove any sibling keys that are redundant with the referenced schema.\n\n    Args:\n        json_schema: The schema to remove redundant sibling keys from.\n\n    Returns:\n        The schema with redundant sibling keys removed.\n    \"\"\"\n    if '$ref' in json_schema:\n        # prevent modifications to the input; this copy may be safe to drop if there is significant overhead\n        json_schema = json_schema.copy()\n\n        referenced_json_schema = self.get_schema_from_definitions(JsonRef(json_schema['$ref']))\n        if referenced_json_schema is None:\n            # This can happen when building schemas for models with not-yet-defined references.\n            # It may be a good idea to do a recursive pass at the end of the generation to remove\n            # any redundant override keys.\n            return json_schema\n        for k, v in list(json_schema.items()):\n            if k == '$ref':\n                continue\n            if k in referenced_json_schema and referenced_json_schema[k] == v:\n                del json_schema[k]  # redundant key\n\n    return json_schema\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.encode_default","title":"encode_default","text":"<pre><code>encode_default(dft: Any) -&gt; Any\n</code></pre> <p>Encode a default value to a JSON-serializable value.</p> <p>This is used to encode default values for fields in the generated JSON schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>dft</code> <code>Any</code> <p>The default value to encode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The encoded default value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def encode_default(self, dft: Any) -&gt; Any:\n    \"\"\"Encode a default value to a JSON-serializable value.\n\n    This is used to encode default values for fields in the generated JSON schema.\n\n    Args:\n        dft: The default value to encode.\n\n    Returns:\n        The encoded default value.\n    \"\"\"\n    from .type_adapter import TypeAdapter, _type_has_config\n\n    config = self._config\n    try:\n        default = (\n            dft\n            if _type_has_config(type(dft))\n            else TypeAdapter(type(dft), config=config.config_dict).dump_python(\n                dft, by_alias=self.by_alias, mode='json'\n            )\n        )\n    except PydanticSchemaGenerationError:\n        raise pydantic_core.PydanticSerializationError(f'Unable to encode default value {dft}')\n\n    return pydantic_core.to_jsonable_python(\n        default, timedelta_mode=config.ser_json_timedelta, bytes_mode=config.ser_json_bytes, by_alias=self.by_alias\n    )\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.update_with_validations","title":"update_with_validations","text":"<pre><code>update_with_validations(json_schema: JsonSchemaValue, core_schema: CoreSchema, mapping: dict[str, str]) -&gt; None\n</code></pre> <p>Update the json_schema with the corresponding validations specified in the core_schema, using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>json_schema</code> <code>JsonSchemaValue</code> <p>The JSON schema to update.</p> \u5fc5\u9700 <code>core_schema</code> <code>CoreSchema</code> <p>The core schema to get the validations from.</p> \u5fc5\u9700 <code>mapping</code> <code>dict[str, str]</code> <p>A mapping from core_schema attribute names to the corresponding JSON schema attribute names.</p> \u5fc5\u9700 \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def update_with_validations(\n    self, json_schema: JsonSchemaValue, core_schema: CoreSchema, mapping: dict[str, str]\n) -&gt; None:\n    \"\"\"Update the json_schema with the corresponding validations specified in the core_schema,\n    using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.\n\n    Args:\n        json_schema: The JSON schema to update.\n        core_schema: The core schema to get the validations from.\n        mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.\n    \"\"\"\n    for core_key, json_schema_key in mapping.items():\n        if core_key in core_schema:\n            json_schema[json_schema_key] = core_schema[core_key]\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.get_json_ref_counts","title":"get_json_ref_counts","text":"<pre><code>get_json_ref_counts(json_schema: JsonSchemaValue) -&gt; dict[JsonRef, int]\n</code></pre> <p>Get all values corresponding to the key '$ref' anywhere in the json_schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def get_json_ref_counts(self, json_schema: JsonSchemaValue) -&gt; dict[JsonRef, int]:\n    \"\"\"Get all values corresponding to the key '$ref' anywhere in the json_schema.\"\"\"\n    json_refs: dict[JsonRef, int] = Counter()\n\n    def _add_json_refs(schema: Any) -&gt; None:\n        if isinstance(schema, dict):\n            if '$ref' in schema:\n                json_ref = JsonRef(schema['$ref'])\n                if not isinstance(json_ref, str):\n                    return  # in this case, '$ref' might have been the name of a property\n                already_visited = json_ref in json_refs\n                json_refs[json_ref] += 1\n                if already_visited:\n                    return  # prevent recursion on a definition that was already visited\n                try:\n                    defs_ref = self.json_to_defs_refs[json_ref]\n                    if defs_ref in self._core_defs_invalid_for_json_schema:\n                        raise self._core_defs_invalid_for_json_schema[defs_ref]\n                    _add_json_refs(self.definitions[defs_ref])\n                except KeyError:\n                    if not json_ref.startswith(('http://', 'https://')):\n                        raise\n\n            for k, v in schema.items():\n                if k == 'examples' and isinstance(v, list):\n                    # Skip examples that may contain arbitrary values and references\n                    # (see the comment in `_get_all_json_refs` for more details).\n                    continue\n                _add_json_refs(v)\n        elif isinstance(schema, list):\n            for v in schema:\n                _add_json_refs(v)\n\n    _add_json_refs(json_schema)\n    return json_refs\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.emit_warning","title":"emit_warning","text":"<pre><code>emit_warning(kind: JsonSchemaWarningKind, detail: str) -&gt; None\n</code></pre> <p>This method simply emits PydanticJsonSchemaWarnings based on handling in the <code>warning_message</code> method.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -&gt; None:\n    \"\"\"This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.\"\"\"\n    message = self.render_warning_message(kind, detail)\n    if message is not None:\n        warnings.warn(message, PydanticJsonSchemaWarning)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.GenerateJsonSchema.render_warning_message","title":"render_warning_message","text":"<pre><code>render_warning_message(kind: JsonSchemaWarningKind, detail: str) -&gt; str | None\n</code></pre> <p>This method is responsible for ignoring warnings as desired, and for formatting the warning messages.</p> <p>You can override the value of <code>ignored_warning_kinds</code> in a subclass of GenerateJsonSchema to modify what warnings are generated. If you want more control, you can override this method; just return None in situations where you don't want warnings to be emitted.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>kind</code> <code>JsonSchemaWarningKind</code> <p>The kind of warning to render. It can be one of the following:</p> <ul> <li>'skipped-choice': A choice field was skipped because it had no valid choices.</li> <li>'non-serializable-default': A default value was skipped because it was not JSON-serializable.</li> </ul> \u5fc5\u9700 <code>detail</code> <code>str</code> <p>A string with additional details about the warning.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str | None</code> <p>The formatted warning message, or <code>None</code> if no warning should be emitted.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def render_warning_message(self, kind: JsonSchemaWarningKind, detail: str) -&gt; str | None:\n    \"\"\"This method is responsible for ignoring warnings as desired, and for formatting the warning messages.\n\n    You can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema\n    to modify what warnings are generated. If you want more control, you can override this method;\n    just return None in situations where you don't want warnings to be emitted.\n\n    Args:\n        kind: The kind of warning to render. It can be one of the following:\n\n            - 'skipped-choice': A choice field was skipped because it had no valid choices.\n            - 'non-serializable-default': A default value was skipped because it was not JSON-serializable.\n        detail: A string with additional details about the warning.\n\n    Returns:\n        The formatted warning message, or `None` if no warning should be emitted.\n    \"\"\"\n    if kind in self.ignored_warning_kinds:\n        return None\n    return f'{detail} [{kind}]'\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.WithJsonSchema","title":"WithJsonSchema  <code>dataclass</code>","text":"<pre><code>WithJsonSchema(json_schema: JsonSchemaValue | None, mode: Literal['validation', 'serialization'] | None = None)\n</code></pre> <p>Usage Documentation</p> <p><code>WithJsonSchema</code> Annotation</p> <p>Add this as an annotation on a field to override the (base) JSON schema that would be generated for that field. This provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema, such as Callable, or types that have an is-instance core schema, without needing to go so far as creating a custom subclass of pydantic.json_schema.GenerateJsonSchema. Note that any modifications to the schema that would normally be made (such as setting the title for model fields) will still be performed.</p> <p>If <code>mode</code> is set this will only apply to that schema generation mode, allowing you to set different json schemas for validation and serialization.</p>"},{"location":"api/json_schema/#pydantic.json_schema.Examples","title":"Examples","text":"<pre><code>Examples(examples: dict[str, Any], mode: Literal['validation', 'serialization'] | None = None)\n</code></pre><pre><code>Examples(examples: list[Any], mode: Literal['validation', 'serialization'] | None = None)\n</code></pre> <pre><code>Examples(examples: dict[str, Any] | list[Any], mode: Literal['validation', 'serialization'] | None = None)\n</code></pre> <p>Add examples to a JSON schema.</p> <p>If the JSON Schema already contains examples, the provided examples will be appended.</p> <p>If <code>mode</code> is set this will only apply to that schema generation mode, allowing you to add different examples for validation and serialization.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def __init__(\n    self, examples: dict[str, Any] | list[Any], mode: Literal['validation', 'serialization'] | None = None\n) -&gt; None:\n    if isinstance(examples, dict):\n        warnings.warn(\n            'Using a dict for `examples` is deprecated, use a list instead.',\n            PydanticDeprecatedSince29,\n            stacklevel=2,\n        )\n    self.examples = examples\n    self.mode = mode\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.SkipJsonSchema","title":"SkipJsonSchema  <code>dataclass</code>","text":"<pre><code>SkipJsonSchema()\n</code></pre> <p>Usage Documentation</p> <p><code>SkipJsonSchema</code> Annotation</p> <p>Add this as an annotation on a field to skip generating a JSON schema for that field.</p> Example <pre><code>from pprint import pprint\nfrom typing import Union\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import SkipJsonSchema\n\nclass Model(BaseModel):\n    a: Union[int, None] = None  # (1)!\n    b: Union[int, SkipJsonSchema[None]] = None  # (2)!\n    c: SkipJsonSchema[Union[int, None]] = None  # (3)!\n\npprint(Model.model_json_schema())\n'''\n{\n    'properties': {\n        'a': {\n            'anyOf': [\n                {'type': 'integer'},\n                {'type': 'null'}\n            ],\n            'default': None,\n            'title': 'A'\n        },\n        'b': {\n            'default': None,\n            'title': 'B',\n            'type': 'integer'\n        }\n    },\n    'title': 'Model',\n    'type': 'object'\n}\n'''\n</code></pre> <ol> <li>The integer and null types are both included in the schema for <code>a</code>.</li> <li>The integer type is the only type included in the schema for <code>b</code>.</li> <li>The entirety of the <code>c</code> field is omitted from the schema.</li> </ol>"},{"location":"api/json_schema/#pydantic.json_schema.model_json_schema","title":"model_json_schema","text":"<pre><code>model_json_schema(cls: type[BaseModel] | type[PydanticDataclass], by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of', schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation') -&gt; dict[str, Any]\n</code></pre> <p>Utility function to generate a JSON Schema for a model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>type[BaseModel] | type[PydanticDataclass]</code> <p>The model class to generate a JSON Schema for.</p> \u5fc5\u9700 <code>by_alias</code> <code>bool</code> <p>If <code>True</code> (the default), fields will be serialized according to their alias. If <code>False</code>, fields will be serialized according to their attribute name.</p> <code>True</code> <code>ref_template</code> <code>str</code> <p>The template to use for generating JSON Schema references.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>union_format</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code>   keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code>   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to   <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>schema_generator</code> <code>type[GenerateJsonSchema]</code> <p>The class to use for generating the JSON Schema.</p> <code>GenerateJsonSchema</code> <code>mode</code> <code>JsonSchemaMode</code> <p>The mode to use for generating the JSON Schema. It can be one of the following:</p> <ul> <li>'validation': Generate a JSON Schema for validating data.</li> <li>'serialization': Generate a JSON Schema for serializing data.</li> </ul> <code>'validation'</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any]</code> <p>The generated JSON Schema.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def model_json_schema(\n    cls: type[BaseModel] | type[PydanticDataclass],\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n) -&gt; dict[str, Any]:\n    \"\"\"Utility function to generate a JSON Schema for a model.\n\n    Args:\n        cls: The model class to generate a JSON Schema for.\n        by_alias: If `True` (the default), fields will be serialized according to their alias.\n            If `False`, fields will be serialized according to their attribute name.\n        ref_template: The template to use for generating JSON Schema references.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n              keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n              keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n              type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n              `any_of`.\n        schema_generator: The class to use for generating the JSON Schema.\n        mode: The mode to use for generating the JSON Schema. It can be one of the following:\n\n            - 'validation': Generate a JSON Schema for validating data.\n            - 'serialization': Generate a JSON Schema for serializing data.\n\n    Returns:\n        The generated JSON Schema.\n    \"\"\"\n    from .main import BaseModel\n\n    schema_generator_instance = schema_generator(\n        by_alias=by_alias, ref_template=ref_template, union_format=union_format\n    )\n\n    if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):\n        cls.__pydantic_core_schema__.rebuild()\n\n    if cls is BaseModel:\n        raise AttributeError('model_json_schema() must be called on a subclass of BaseModel, not BaseModel itself.')\n\n    assert not isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema), 'this is a bug! please report it'\n    return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode)\n</code></pre>"},{"location":"api/json_schema/#pydantic.json_schema.models_json_schema","title":"models_json_schema","text":"<pre><code>models_json_schema(models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]], *, by_alias: bool = True, title: str | None = None, description: str | None = None, ref_template: str = DEFAULT_REF_TEMPLATE, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of', schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema) -&gt; tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]\n</code></pre> <p>Utility function to generate a JSON Schema for multiple models.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>models</code> <code>Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]]</code> <p>A sequence of tuples of the form (model, mode).</p> \u5fc5\u9700 <code>by_alias</code> <code>bool</code> <p>Whether field aliases should be used as keys in the generated JSON Schema.</p> <code>True</code> <code>title</code> <code>str | None</code> <p>The title of the generated JSON Schema.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The description of the generated JSON Schema.</p> <code>None</code> <code>ref_template</code> <code>str</code> <p>The reference template to use for generating JSON Schema references.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>union_format</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code>   keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code>   keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive   type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to   <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>schema_generator</code> <code>type[GenerateJsonSchema]</code> <p>The schema generator to use for generating the JSON Schema.</p> <code>GenerateJsonSchema</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]</code> <p>A tuple where: - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and     whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have     JsonRef references to definitions that are defined in the second returned element.) - The second element is a JSON schema containing all definitions referenced in the first returned         element, along with the optional title and description keys.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/json_schema.py</code> <pre><code>def models_json_schema(\n    models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]],\n    *,\n    by_alias: bool = True,\n    title: str | None = None,\n    description: str | None = None,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n) -&gt; tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:\n    \"\"\"Utility function to generate a JSON Schema for multiple models.\n\n    Args:\n        models: A sequence of tuples of the form (model, mode).\n        by_alias: Whether field aliases should be used as keys in the generated JSON Schema.\n        title: The title of the generated JSON Schema.\n        description: The description of the generated JSON Schema.\n        ref_template: The reference template to use for generating JSON Schema references.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n              keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n              keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n              type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n              `any_of`.\n        schema_generator: The schema generator to use for generating the JSON Schema.\n\n    Returns:\n        A tuple where:\n            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions referenced in the first returned\n                    element, along with the optional title and description keys.\n    \"\"\"\n    for cls, _ in models:\n        if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):\n            cls.__pydantic_core_schema__.rebuild()\n\n    instance = schema_generator(by_alias=by_alias, ref_template=ref_template, union_format=union_format)\n    inputs: list[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode, CoreSchema]] = [\n        (m, mode, m.__pydantic_core_schema__) for m, mode in models\n    ]\n    json_schemas_map, definitions = instance.generate_definitions(inputs)\n\n    json_schema: dict[str, Any] = {}\n    if definitions:\n        json_schema['$defs'] = definitions\n    if title:\n        json_schema['title'] = title\n    if description:\n        json_schema['description'] = description\n\n    return json_schemas_map, json_schema\n</code></pre>"},{"location":"api/networks/","title":"Network Types","text":"<p>The networks module contains types for common network-related fields.</p>"},{"location":"api/networks/#pydantic.networks.MAX_EMAIL_LENGTH","title":"MAX_EMAIL_LENGTH  <code>module-attribute</code>","text":"<pre><code>MAX_EMAIL_LENGTH = 2048\n</code></pre> <p>Maximum length for an email. A somewhat arbitrary but very generous number compared to what is allowed by most implementations.</p>"},{"location":"api/networks/#pydantic.networks.UrlConstraints","title":"UrlConstraints  <code>dataclass</code>","text":"<pre><code>UrlConstraints(max_length: int | None = None, allowed_schemes: list[str] | None = None, host_required: bool | None = None, default_host: str | None = None, default_port: int | None = None, default_path: str | None = None, preserve_empty_path: bool | None = None)\n</code></pre> <p>Url constraints.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>max_length</code> <code>int | None</code> <p>The maximum length of the url. Defaults to <code>None</code>.</p> <code>allowed_schemes</code> <code>list[str] | None</code> <p>The allowed schemes. Defaults to <code>None</code>.</p> <code>host_required</code> <code>bool | None</code> <p>Whether the host is required. Defaults to <code>None</code>.</p> <code>default_host</code> <code>str | None</code> <p>The default host. Defaults to <code>None</code>.</p> <code>default_port</code> <code>int | None</code> <p>The default port. Defaults to <code>None</code>.</p> <code>default_path</code> <code>str | None</code> <p>The default path. Defaults to <code>None</code>.</p> <code>preserve_empty_path</code> <code>bool | None</code> <p>Whether to preserve empty URL paths. Defaults to <code>None</code>.</p>"},{"location":"api/networks/#pydantic.networks.UrlConstraints.defined_constraints","title":"defined_constraints  <code>property</code>","text":"<pre><code>defined_constraints: dict[str, Any]\n</code></pre> <p>Fetch a key / value mapping of constraints to values that are not None. Used for core schema updates.</p>"},{"location":"api/networks/#pydantic.networks.AnyUrl","title":"AnyUrl","text":"<pre><code>AnyUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>_BaseUrl</code></p> <p>Base type for all URLs.</p> <ul> <li>Any scheme allowed</li> <li>Top-level domain (TLD) not required</li> <li>Host not required</li> </ul> <p>Assuming an input URL of <code>http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit</code>, the types export the following properties:</p> <ul> <li><code>scheme</code>: the URL scheme (<code>http</code>), always set.</li> <li><code>host</code>: the URL host (<code>example.com</code>).</li> <li><code>username</code>: optional username if included (<code>samuel</code>).</li> <li><code>password</code>: optional password if included (<code>pass</code>).</li> <li><code>port</code>: optional port (<code>8000</code>).</li> <li><code>path</code>: optional path (<code>/the/path/</code>).</li> <li><code>query</code>: optional URL query (for example, <code>GET</code> arguments or \"search string\", such as <code>query=here</code>).</li> <li><code>fragment</code>: optional fragment (<code>fragment=is;this=bit</code>).</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.AnyHttpUrl","title":"AnyHttpUrl","text":"<pre><code>AnyHttpUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any http or https URL.</p> <ul> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.HttpUrl","title":"HttpUrl","text":"<pre><code>HttpUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any http or https URL.</p> <ul> <li>TLD not required</li> <li>Host not required</li> <li>Max length 2083</li> </ul> <pre><code>from pydantic import BaseModel, HttpUrl, ValidationError\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')  # (1)!\nprint(m.url)\n#&gt; http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n    '''\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n    '''\n</code></pre> <ol> <li>Note: mypy would prefer <code>m = MyModel(url=HttpUrl('http://www.example.com'))</code>, but Pydantic will convert the string to an HttpUrl instance anyway.</li> </ol> <p>\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via punycode (see this article for a good description of why this is important):</p> <pre><code>from pydantic import BaseModel, HttpUrl\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm1 = MyModel(url='http://puny\u00a3code.com')\nprint(m1.url)\n#&gt; http://xn--punycode-eja.com/\nm2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\nprint(m2.url)\n#&gt; https://www.xn--80ak6aa92e.com/\nm3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\nprint(m3.url)\n#&gt; https://www.example.xn--pbt977c/\n</code></pre> <p>Underscores in Hostnames</p> <p>In Pydantic, underscores are allowed in all parts of a domain except the TLD. Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.</p> <p>To explain this; consider the following two cases:</p> <ul> <li><code>exam_ple.co.uk</code>: the hostname is <code>exam_ple</code>, which should not be allowed since it contains an underscore.</li> <li><code>foo_bar.example.com</code> the hostname is <code>example</code>, which should be allowed since the underscore is in the subdomain.</li> </ul> <p>Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore underscores are allowed, but you can always do further validation in a validator if desired.</p> <p>Also, Chrome, Firefox, and Safari all currently accept <code>http://exam_ple.com</code> as a URL, so we're in good (or at least big) company.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.AnyWebsocketUrl","title":"AnyWebsocketUrl","text":"<pre><code>AnyWebsocketUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any ws or wss URL.</p> <ul> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.WebsocketUrl","title":"WebsocketUrl","text":"<pre><code>WebsocketUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any ws or wss URL.</p> <ul> <li>TLD not required</li> <li>Host not required</li> <li>Max length 2083</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.FileUrl","title":"FileUrl","text":"<pre><code>FileUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any file URL.</p> <ul> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.FtpUrl","title":"FtpUrl","text":"<pre><code>FtpUrl(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept ftp URL.</p> <ul> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.PostgresDsn","title":"PostgresDsn","text":"<pre><code>PostgresDsn(url: str | MultiHostUrl | _BaseMultiHostUrl)\n</code></pre> <p>               Bases: <code>_BaseMultiHostUrl</code></p> <p>A type that will accept any Postgres DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host required</li> <li>Supports multiple hosts</li> </ul> <p>If further validation is required, these properties can be used by validators to enforce specific behaviour:</p> <pre><code>from pydantic import (\n    BaseModel,\n    HttpUrl,\n    PostgresDsn,\n    ValidationError,\n    field_validator,\n)\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\n#&gt; HttpUrl('http://www.example.com/')\nprint(m.url.scheme)\n#&gt; http\nprint(m.url.host)\n#&gt; www.example.com\nprint(m.url.port)\n#&gt; 80\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @field_validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) &gt; 1, 'database must be provided'\n        return v\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n#&gt; postgres://user:pass@localhost:5432/foobar\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyDatabaseModel\n    db\n      Assertion failed, database must be provided\n    assert (None)\n     +  where None = PostgresDsn('postgres://user:pass@localhost:5432').path [type=assertion_error, input_value='postgres://user:pass@localhost:5432', input_type=str]\n    '''\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreMultiHostUrl | _BaseMultiHostUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.PostgresDsn.host","title":"host  <code>property</code>","text":"<pre><code>host: str\n</code></pre> <p>The required URL host.</p>"},{"location":"api/networks/#pydantic.networks.CockroachDsn","title":"CockroachDsn","text":"<pre><code>CockroachDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any Cockroach DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.CockroachDsn.host","title":"host  <code>property</code>","text":"<pre><code>host: str\n</code></pre> <p>The required URL host.</p>"},{"location":"api/networks/#pydantic.networks.AmqpDsn","title":"AmqpDsn","text":"<pre><code>AmqpDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any AMQP DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.RedisDsn","title":"RedisDsn","text":"<pre><code>RedisDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any Redis DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host required (e.g., <code>rediss://:pass@localhost</code>)</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.RedisDsn.host","title":"host  <code>property</code>","text":"<pre><code>host: str\n</code></pre> <p>The required URL host.</p>"},{"location":"api/networks/#pydantic.networks.MongoDsn","title":"MongoDsn","text":"<pre><code>MongoDsn(url: str | MultiHostUrl | _BaseMultiHostUrl)\n</code></pre> <p>               Bases: <code>_BaseMultiHostUrl</code></p> <p>A type that will accept any MongoDB DSN.</p> <ul> <li>User info not required</li> <li>Database name not required</li> <li>Port not required</li> <li>User info may be passed without user part (e.g., <code>mongodb://mongodb0.example.com:27017</code>).</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreMultiHostUrl | _BaseMultiHostUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.KafkaDsn","title":"KafkaDsn","text":"<pre><code>KafkaDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any Kafka DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.NatsDsn","title":"NatsDsn","text":"<pre><code>NatsDsn(url: str | MultiHostUrl | _BaseMultiHostUrl)\n</code></pre> <p>               Bases: <code>_BaseMultiHostUrl</code></p> <p>A type that will accept any NATS DSN.</p> <p>NATS is a connective technology built for the ever increasingly hyper-connected world. It is a single technology that enables applications to securely communicate across any combination of cloud vendors, on-premise, edge, web and mobile, and devices. More: https://nats.io</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreMultiHostUrl | _BaseMultiHostUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.MySQLDsn","title":"MySQLDsn","text":"<pre><code>MySQLDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any MySQL DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.MariaDBDsn","title":"MariaDBDsn","text":"<pre><code>MariaDBDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any MariaDB DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.ClickHouseDsn","title":"ClickHouseDsn","text":"<pre><code>ClickHouseDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any ClickHouse DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host not required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.SnowflakeDsn","title":"SnowflakeDsn","text":"<pre><code>SnowflakeDsn(url: str | Url | _BaseUrl)\n</code></pre> <p>               Bases: <code>AnyUrl</code></p> <p>A type that will accept any Snowflake DSN.</p> <ul> <li>User info required</li> <li>TLD not required</li> <li>Host required</li> </ul> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, url: str | _CoreUrl | _BaseUrl) -&gt; None:\n    self._url = _build_type_adapter(self.__class__).validate_python(url)._url\n</code></pre>"},{"location":"api/networks/#pydantic.networks.SnowflakeDsn.host","title":"host  <code>property</code>","text":"<pre><code>host: str\n</code></pre> <p>The required URL host.</p>"},{"location":"api/networks/#pydantic.networks.EmailStr","title":"EmailStr","text":"Info <p>To use this type, you need to install the optional <code>email-validator</code> package:</p> <pre><code>pip install email-validator\n</code></pre> <p>Validate email addresses.</p> <pre><code>from pydantic import BaseModel, EmailStr\n\nclass Model(BaseModel):\n    email: EmailStr\n\nprint(Model(email='contact@mail.com'))\n#&gt; email='contact@mail.com'\n</code></pre>"},{"location":"api/networks/#pydantic.networks.NameEmail","title":"NameEmail","text":"<pre><code>NameEmail(name: str, email: str)\n</code></pre> <p>               Bases: <code>Representation</code></p> Info <p>To use this type, you need to install the optional <code>email-validator</code> package:</p> <pre><code>pip install email-validator\n</code></pre> <p>Validate a name and email address combination, as specified by RFC 5322.</p> <p>The <code>NameEmail</code> has two properties: <code>name</code> and <code>email</code>. In case the <code>name</code> is not provided, it's inferred from the email address.</p> <pre><code>from pydantic import BaseModel, NameEmail\n\nclass User(BaseModel):\n    email: NameEmail\n\nuser = User(email='Fred Bloggs &lt;fred.bloggs@example.com&gt;')\nprint(user.email)\n#&gt; Fred Bloggs &lt;fred.bloggs@example.com&gt;\nprint(user.email.name)\n#&gt; Fred Bloggs\n\nuser = User(email='fred.bloggs@example.com')\nprint(user.email)\n#&gt; fred.bloggs &lt;fred.bloggs@example.com&gt;\nprint(user.email.name)\n#&gt; fred.bloggs\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def __init__(self, name: str, email: str):\n    self.name = name\n    self.email = email\n</code></pre>"},{"location":"api/networks/#pydantic.networks.IPvAnyAddress","title":"IPvAnyAddress","text":"<p>Validate an IPv4 or IPv6 address.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic.networks import IPvAnyAddress\n\nclass IpModel(BaseModel):\n    ip: IPvAnyAddress\n\nprint(IpModel(ip='127.0.0.1'))\n#&gt; ip=IPv4Address('127.0.0.1')\n\ntry:\n    IpModel(ip='http://www.example.com')\nexcept ValueError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'ip_any_address',\n            'loc': ('ip',),\n            'msg': 'value is not a valid IPv4 or IPv6 address',\n            'input': 'http://www.example.com',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/networks/#pydantic.networks.IPvAnyInterface","title":"IPvAnyInterface","text":"<p>Validate an IPv4 or IPv6 interface.</p>"},{"location":"api/networks/#pydantic.networks.IPvAnyNetwork","title":"IPvAnyNetwork","text":"<p>Validate an IPv4 or IPv6 network.</p>"},{"location":"api/networks/#pydantic.networks.validate_email","title":"validate_email","text":"<pre><code>validate_email(value: str) -&gt; tuple[str, str]\n</code></pre> <p>Email address validation using email-validator.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[str, str]</code> <p>A tuple containing the local part of the email (or the name for \"pretty\" email addresses) and the normalized email.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the email is invalid.</p> Note <p>Note that:</p> <ul> <li>Raw IP address (literal) domain parts are not allowed.</li> <li><code>\"John Doe &lt;local_part@domain.com&gt;\"</code> style \"pretty\" email addresses are processed.</li> <li>Spaces are striped from the beginning and end of addresses, but no error is raised.</li> </ul> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/networks.py</code> <pre><code>def validate_email(value: str) -&gt; tuple[str, str]:\n    \"\"\"Email address validation using [email-validator](https://pypi.org/project/email-validator/).\n\n    Returns:\n        A tuple containing the local part of the email (or the name for \"pretty\" email addresses)\n            and the normalized email.\n\n    Raises:\n        PydanticCustomError: If the email is invalid.\n\n    Note:\n        Note that:\n\n        * Raw IP address (literal) domain parts are not allowed.\n        * `\"John Doe &lt;local_part@domain.com&gt;\"` style \"pretty\" email addresses are processed.\n        * Spaces are striped from the beginning and end of addresses, but no error is raised.\n    \"\"\"\n    if email_validator is None:\n        import_email_validator()\n\n    if len(value) &gt; MAX_EMAIL_LENGTH:\n        raise PydanticCustomError(\n            'value_error',\n            'value is not a valid email address: {reason}',\n            {'reason': f'Length must not exceed {MAX_EMAIL_LENGTH} characters'},\n        )\n\n    m = pretty_email_regex.fullmatch(value)\n    name: str | None = None\n    if m:\n        unquoted_name, quoted_name, value = m.groups()\n        name = unquoted_name or quoted_name\n\n    email = value.strip()\n\n    try:\n        parts = email_validator.validate_email(email, check_deliverability=False)\n    except email_validator.EmailNotValidError as e:\n        raise PydanticCustomError(\n            'value_error', 'value is not a valid email address: {reason}', {'reason': str(e.args[0])}\n        ) from e\n\n    email = parts.normalized\n    assert email is not None\n    name = name or parts.local_part\n    return name, email\n</code></pre>"},{"location":"api/pydantic_core/","title":"pydantic_core","text":""},{"location":"api/pydantic_core/#pydantic_core.__version__","title":"__version__  <code>module-attribute</code>","text":"<pre><code>__version__: str\n</code></pre>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator","title":"SchemaValidator","text":"<pre><code>SchemaValidator(schema: CoreSchema, config: CoreConfig | None = None)\n</code></pre> <p><code>SchemaValidator</code> is the Python wrapper for <code>pydantic-core</code>'s Rust validation logic, internally it owns one <code>CombinedValidator</code> which may in turn own more <code>CombinedValidator</code>s which make up the full schema validator.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The <code>CoreSchema</code> to use for validation.</p> \u5fc5\u9700 <code>config</code> <code>CoreConfig | None</code> <p>Optionally a <code>CoreConfig</code> to configure validation.</p> <code>None</code>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.title","title":"title  <code>property</code>","text":"<pre><code>title: str\n</code></pre> <p>The title of the schema, as used in the heading of <code>ValidationError.__str__()</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.validate_python","title":"validate_python","text":"<pre><code>validate_python(input: Any, *, strict: bool | None = None, extra: ExtraBehavior | None = None, from_attributes: bool | None = None, context: Any | None = None, self_instance: Any | None = None, allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Any\n</code></pre> <p>Validate a Python object against the schema and return the validated object.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>input</code> <code>Any</code> <p>The Python object to validate.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to validate the object in strict mode. If <code>None</code>, the value of <code>CoreConfig.strict</code> is used.</p> <code>None</code> <code>extra</code> <code>ExtraBehavior | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. If <code>None</code>, the value of <code>CoreConfig.extra_fields_behavior</code> is used.</p> <code>None</code> <code>from_attributes</code> <code>bool | None</code> <p>Whether to validate objects as inputs to models by extracting attributes. If <code>None</code>, the value of <code>CoreConfig.from_attributes</code> is used.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>The context to use for validation, this is passed to functional validators as <code>info.context</code>.</p> <code>None</code> <code>self_instance</code> <code>Any | None</code> <p>An instance of a model set attributes on from validation, this is used when running validation from the <code>__init__</code> method of a model.</p> <code>None</code> <code>allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Whether to allow partial validation; if <code>True</code> errors in the last element of sequences and mappings are ignored. <code>'trailing-strings'</code> means any final unfinished JSON string is included in the result.</p> <code>False</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If validation fails.</p> <code>Exception</code> <p>Other error types maybe raised if internal errors occur.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The validated object.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.isinstance_python","title":"isinstance_python","text":"<pre><code>isinstance_python(input: Any, *, strict: bool | None = None, extra: ExtraBehavior | None = None, from_attributes: bool | None = None, context: Any | None = None, self_instance: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; bool\n</code></pre> <p>Similar to <code>validate_python()</code> but returns a boolean.</p> <p>Arguments match <code>validate_python()</code>. This method will not raise <code>ValidationError</code>s but will raise internal errors.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool</code> <p><code>True</code> if validation succeeds, <code>False</code> if validation fails.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.validate_json","title":"validate_json","text":"<pre><code>validate_json(input: str | bytes | bytearray, *, strict: bool | None = None, extra: ExtraBehavior | None = None, context: Any | None = None, self_instance: Any | None = None, allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Any\n</code></pre> <p>Validate JSON data directly against the schema and return the validated Python object.</p> <p>This method should be significantly faster than <code>validate_python(json.loads(json_data))</code> as it avoids the need to create intermediate Python objects</p> <p>It also handles constructing the correct Python type even in strict mode, where <code>validate_python(json.loads(json_data))</code> would fail validation.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>input</code> <code>str | bytes | bytearray</code> <p>The JSON data to validate.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to validate the object in strict mode. If <code>None</code>, the value of <code>CoreConfig.strict</code> is used.</p> <code>None</code> <code>extra</code> <code>ExtraBehavior | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. If <code>None</code>, the value of <code>CoreConfig.extra_fields_behavior</code> is used.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>The context to use for validation, this is passed to functional validators as <code>info.context</code>.</p> <code>None</code> <code>self_instance</code> <code>Any | None</code> <p>An instance of a model set attributes on from validation.</p> <code>None</code> <code>allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Whether to allow partial validation; if <code>True</code> incomplete JSON will be parsed successfully and errors in the last element of sequences and mappings are ignored. <code>'trailing-strings'</code> means any final unfinished JSON string is included in the result.</p> <code>False</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If validation fails or if the JSON data is invalid.</p> <code>Exception</code> <p>Other error types maybe raised if internal errors occur.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The validated Python object.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.validate_strings","title":"validate_strings","text":"<pre><code>validate_strings(input: _StringInput, *, strict: bool | None = None, extra: ExtraBehavior | None = None, context: Any | None = None, allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False, by_alias: bool | None = None, by_name: bool | None = None) -&gt; Any\n</code></pre> <p>Validate a string against the schema and return the validated Python object.</p> <p>This is similar to <code>validate_json</code> but applies to scenarios where the input will be a string but not JSON data, e.g. URL fragments, query parameters, etc.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>input</code> <code>_StringInput</code> <p>The input as a string, or bytes/bytearray if <code>strict=False</code>.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to validate the object in strict mode. If <code>None</code>, the value of <code>CoreConfig.strict</code> is used.</p> <code>None</code> <code>extra</code> <code>ExtraBehavior | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. If <code>None</code>, the value of <code>CoreConfig.extra_fields_behavior</code> is used.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>The context to use for validation, this is passed to functional validators as <code>info.context</code>.</p> <code>None</code> <code>allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Whether to allow partial validation; if <code>True</code> errors in the last element of sequences and mappings are ignored. <code>'trailing-strings'</code> means any final unfinished JSON string is included in the result.</p> <code>False</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If validation fails or if the JSON data is invalid.</p> <code>Exception</code> <p>Other error types maybe raised if internal errors occur.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The validated Python object.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.validate_assignment","title":"validate_assignment","text":"<pre><code>validate_assignment(obj: Any, field_name: str, field_value: Any, *, strict: bool | None = None, extra: ExtraBehavior | None = None, from_attributes: bool | None = None, context: Any | None = None, by_alias: bool | None = None, by_name: bool | None = None) -&gt; dict[str, Any] | tuple[dict[str, Any], dict[str, Any] | None, set[str]]\n</code></pre> <p>Validate an assignment to a field on a model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>obj</code> <code>Any</code> <p>The model instance being assigned to.</p> \u5fc5\u9700 <code>field_name</code> <code>str</code> <p>The name of the field to validate assignment for.</p> \u5fc5\u9700 <code>field_value</code> <code>Any</code> <p>The value to assign to the field.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to validate the object in strict mode. If <code>None</code>, the value of <code>CoreConfig.strict</code> is used.</p> <code>None</code> <code>extra</code> <code>ExtraBehavior | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. If <code>None</code>, the value of <code>CoreConfig.extra_fields_behavior</code> is used.</p> <code>None</code> <code>from_attributes</code> <code>bool | None</code> <p>Whether to validate objects as inputs to models by extracting attributes. If <code>None</code>, the value of <code>CoreConfig.from_attributes</code> is used.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>The context to use for validation, this is passed to functional validators as <code>info.context</code>.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If validation fails.</p> <code>Exception</code> <p>Other error types maybe raised if internal errors occur.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any] | tuple[dict[str, Any], dict[str, Any] | None, set[str]]</code> <p>Either the model dict or a tuple of <code>(model_data, model_extra, fields_set)</code></p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaValidator.get_default_value","title":"get_default_value","text":"<pre><code>get_default_value(*, strict: bool | None = None, context: Any = None) -&gt; Some | None\n</code></pre> <p>Get the default value for the schema, including running default value validation.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether to validate the default value in strict mode. If <code>None</code>, the value of <code>CoreConfig.strict</code> is used.</p> <code>None</code> <code>context</code> <code>Any</code> <p>The context to use for validation, this is passed to functional validators as <code>info.context</code>.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValidationError</code> <p>If validation fails.</p> <code>Exception</code> <p>Other error types maybe raised if internal errors occur.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Some | None</code> <p><code>None</code> if the schema has no default value, otherwise a <code>Some</code> containing the default.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaSerializer","title":"SchemaSerializer","text":"<pre><code>SchemaSerializer(schema: CoreSchema, config: CoreConfig | None = None)\n</code></pre> <p><code>SchemaSerializer</code> is the Python wrapper for <code>pydantic-core</code>'s Rust serialization logic, internally it owns one <code>CombinedSerializer</code> which may in turn own more <code>CombinedSerializer</code>s which make up the full schema serializer.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The <code>CoreSchema</code> to use for serialization.</p> \u5fc5\u9700 <code>config</code> <code>CoreConfig | None</code> <p>Optionally a <code>CoreConfig</code> to to configure serialization.</p> <code>None</code>"},{"location":"api/pydantic_core/#pydantic_core.SchemaSerializer.to_python","title":"to_python","text":"<pre><code>to_python(value: Any, *, mode: str | None = None, include: _IncEx | None = None, exclude: _IncEx | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False, context: Any | None = None) -&gt; Any\n</code></pre> <p>Serialize/marshal a Python object to a Python object including transforming and filtering data.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>Any</code> <p>The Python object to serialize.</p> \u5fc5\u9700 <code>mode</code> <code>str | None</code> <p>The serialization mode to use, either <code>'python'</code> or <code>'json'</code>, defaults to <code>'python'</code>. In JSON mode, all values are converted to JSON compatible types, e.g. <code>None</code>, <code>int</code>, <code>float</code>, <code>str</code>, <code>list</code>, <code>dict</code>.</p> <code>None</code> <code>include</code> <code>_IncEx | None</code> <p>A set of fields to include, if <code>None</code> all fields are included.</p> <code>None</code> <code>exclude</code> <code>_IncEx | None</code> <p>A set of fields to exclude, if <code>None</code> no fields are excluded.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the alias names of fields.</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude fields that are not set, e.g. are not included in <code>__pydantic_fields_set__</code>.</p> <code>False</code> <code>exclude_defaults</code> <code>bool</code> <p>Whether to exclude fields that are equal to their default value.</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>exclude_computed_fields</code> <code>bool</code> <p>Whether to exclude computed fields.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>Whether to enable serialization and validation round-trip support.</p> <code>False</code> <code>warnings</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle invalid fields. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered, if <code>None</code> a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <code>context</code> <code>Any | None</code> <p>The context to use for serialization, this is passed to functional serializers as <code>info.context</code>.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticSerializationError</code> <p>If serialization fails and no <code>fallback</code> function is provided.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The serialized Python object.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaSerializer.to_json","title":"to_json","text":"<pre><code>to_json(value: Any, *, indent: int | None = None, ensure_ascii: bool = False, include: _IncEx | None = None, exclude: _IncEx | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False, context: Any | None = None) -&gt; bytes\n</code></pre> <p>Serialize a Python object to JSON including transforming and filtering data.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>Any</code> <p>The Python object to serialize.</p> \u5fc5\u9700 <code>indent</code> <code>int | None</code> <p>If <code>None</code>, the JSON will be compact, otherwise it will be pretty-printed with the indent provided.</p> <code>None</code> <code>ensure_ascii</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>include</code> <code>_IncEx | None</code> <p>A set of fields to include, if <code>None</code> all fields are included.</p> <code>None</code> <code>exclude</code> <code>_IncEx | None</code> <p>A set of fields to exclude, if <code>None</code> no fields are excluded.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the alias names of fields.</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude fields that are not set, e.g. are not included in <code>__pydantic_fields_set__</code>.</p> <code>False</code> <code>exclude_defaults</code> <code>bool</code> <p>Whether to exclude fields that are equal to their default value.</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>exclude_computed_fields</code> <code>bool</code> <p>Whether to exclude computed fields.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>Whether to enable serialization and validation round-trip support.</p> <code>False</code> <code>warnings</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle invalid fields. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered, if <code>None</code> a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <code>context</code> <code>Any | None</code> <p>The context to use for serialization, this is passed to functional serializers as <code>info.context</code>.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticSerializationError</code> <p>If serialization fails and no <code>fallback</code> function is provided.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>JSON bytes.</p>"},{"location":"api/pydantic_core/#pydantic_core.ValidationError","title":"ValidationError","text":"<p>               Bases: <code>ValueError</code></p> <p><code>ValidationError</code> is the exception raised by <code>pydantic-core</code> when validation fails, it contains a list of errors which detail why validation failed.</p>"},{"location":"api/pydantic_core/#pydantic_core.ValidationError.title","title":"title  <code>property</code>","text":"<pre><code>title: str\n</code></pre> <p>The title of the error, as used in the heading of <code>str(validation_error)</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.ValidationError.from_exception_data","title":"from_exception_data  <code>classmethod</code>","text":"<pre><code>from_exception_data(title: str, line_errors: list[InitErrorDetails], input_type: Literal['python', 'json'] = 'python', hide_input: bool = False) -&gt; Self\n</code></pre> <p>Python constructor for a Validation Error.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>title</code> <code>str</code> <p>The title of the error, as used in the heading of <code>str(validation_error)</code></p> \u5fc5\u9700 <code>line_errors</code> <code>list[InitErrorDetails]</code> <p>A list of <code>InitErrorDetails</code> which contain information about errors that occurred during validation.</p> \u5fc5\u9700 <code>input_type</code> <code>Literal['python', 'json']</code> <p>Whether the error is for a Python object or JSON.</p> <code>'python'</code> <code>hide_input</code> <code>bool</code> <p>Whether to hide the input value in the error message.</p> <code>False</code>"},{"location":"api/pydantic_core/#pydantic_core.ValidationError.error_count","title":"error_count","text":"<pre><code>error_count() -&gt; int\n</code></pre> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>int</code> <p>The number of errors in the validation error.</p>"},{"location":"api/pydantic_core/#pydantic_core.ValidationError.errors","title":"errors","text":"<pre><code>errors(*, include_url: bool = True, include_context: bool = True, include_input: bool = True) -&gt; list[ErrorDetails]\n</code></pre> <p>Details about each error in the validation error.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>include_url</code> <code>bool</code> <p>Whether to include a URL to documentation on the error each error.</p> <code>True</code> <code>include_context</code> <code>bool</code> <p>Whether to include the context of each error.</p> <code>True</code> <code>include_input</code> <code>bool</code> <p>Whether to include the input value of each error.</p> <code>True</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>list[ErrorDetails]</code> <p>A list of <code>ErrorDetails</code> for each error in the validation error.</p>"},{"location":"api/pydantic_core/#pydantic_core.ValidationError.json","title":"json","text":"<pre><code>json(*, indent: int | None = None, include_url: bool = True, include_context: bool = True, include_input: bool = True) -&gt; str\n</code></pre> <p>Same as <code>errors()</code> but returns a JSON string.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>indent</code> <code>int | None</code> <p>The number of spaces to indent the JSON by, or <code>None</code> for no indentation - compact JSON.</p> <code>None</code> <code>include_url</code> <code>bool</code> <p>Whether to include a URL to documentation on the error each error.</p> <code>True</code> <code>include_context</code> <code>bool</code> <p>Whether to include the context of each error.</p> <code>True</code> <code>include_input</code> <code>bool</code> <p>Whether to include the input value of each error.</p> <code>True</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>a JSON string.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails","title":"ErrorDetails","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str\n</code></pre> <p>The type of error that occurred, this is an identifier designed for programmatic use that will change rarely or never.</p> <p><code>type</code> is unique for each error message, and can hence be used as an identifier to build custom error messages.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails.loc","title":"loc  <code>instance-attribute</code>","text":"<pre><code>loc: tuple[int | str, ...]\n</code></pre> <p>Tuple of strings and ints identifying where in the schema the error occurred.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails.msg","title":"msg  <code>instance-attribute</code>","text":"<pre><code>msg: str\n</code></pre> <p>A human readable error message.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: Any\n</code></pre> <p>The input data at this <code>loc</code> that caused the error.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails.ctx","title":"ctx  <code>instance-attribute</code>","text":"<pre><code>ctx: NotRequired[dict[str, Any]]\n</code></pre> <p>Values which are required to render the error message, and could hence be useful in rendering custom error messages. Also useful for passing custom error data forward.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorDetails.url","title":"url  <code>instance-attribute</code>","text":"<pre><code>url: NotRequired[str]\n</code></pre> <p>The documentation URL giving information about the error. No URL is available if a <code>PydanticCustomError</code> is used.</p>"},{"location":"api/pydantic_core/#pydantic_core.InitErrorDetails","title":"InitErrorDetails","text":"<p>               Bases: <code>TypedDict</code></p>"},{"location":"api/pydantic_core/#pydantic_core.InitErrorDetails.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: str | PydanticCustomError\n</code></pre> <p>The type of error that occurred, this should be a \"slug\" identifier that changes rarely or never.</p>"},{"location":"api/pydantic_core/#pydantic_core.InitErrorDetails.loc","title":"loc  <code>instance-attribute</code>","text":"<pre><code>loc: NotRequired[tuple[int | str, ...]]\n</code></pre> <p>Tuple of strings and ints identifying where in the schema the error occurred.</p>"},{"location":"api/pydantic_core/#pydantic_core.InitErrorDetails.input","title":"input  <code>instance-attribute</code>","text":"<pre><code>input: Any\n</code></pre> <p>The input data at this <code>loc</code> that caused the error.</p>"},{"location":"api/pydantic_core/#pydantic_core.InitErrorDetails.ctx","title":"ctx  <code>instance-attribute</code>","text":"<pre><code>ctx: NotRequired[dict[str, Any]]\n</code></pre> <p>Values which are required to render the error message, and could hence be useful in rendering custom error messages. Also useful for passing custom error data forward.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaError","title":"SchemaError","text":"<p>               Bases: <code>Exception</code></p> <p>Information about errors that occur while building a <code>SchemaValidator</code> or <code>SchemaSerializer</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaError.error_count","title":"error_count","text":"<pre><code>error_count() -&gt; int\n</code></pre> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>int</code> <p>The number of errors in the schema.</p>"},{"location":"api/pydantic_core/#pydantic_core.SchemaError.errors","title":"errors","text":"<pre><code>errors() -&gt; list[ErrorDetails]\n</code></pre> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>list[ErrorDetails]</code> <p>A list of <code>ErrorDetails</code> for each error in the schema.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticCustomError","title":"PydanticCustomError","text":"<pre><code>PydanticCustomError(error_type: LiteralString, message_template: LiteralString, context: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>A custom exception providing flexible error handling for Pydantic validators.</p> <p>You can raise this error in custom validators when you'd like flexibility in regards to the error type, message, and context.</p> Example <pre><code>from pydantic_core import PydanticCustomError\n\ndef custom_validator(v) -&gt; None:\n    if v &lt;= 10:\n        raise PydanticCustomError('custom_value_error', 'Value must be greater than {value}', {'value': 10, 'extra_context': 'extra_data'})\n    return v\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>error_type</code> <code>LiteralString</code> <p>The error type.</p> \u5fc5\u9700 <code>message_template</code> <code>LiteralString</code> <p>The message template.</p> \u5fc5\u9700 <code>context</code> <code>dict[str, Any] | None</code> <p>The data to inject into the message template.</p> <code>None</code>"},{"location":"api/pydantic_core/#pydantic_core.PydanticCustomError.context","title":"context  <code>property</code>","text":"<pre><code>context: dict[str, Any] | None\n</code></pre> <p>Values which are required to render the error message, and could hence be useful in passing error data forward.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticCustomError.type","title":"type  <code>property</code>","text":"<pre><code>type: str\n</code></pre> <p>The error type associated with the error. For consistency with Pydantic, this is typically a snake_case string.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticCustomError.message_template","title":"message_template  <code>property</code>","text":"<pre><code>message_template: str\n</code></pre> <p>The message template associated with the error. This is a string that can be formatted with context variables in <code>{curly_braces}</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticCustomError.message","title":"message","text":"<pre><code>message() -&gt; str\n</code></pre> <p>The formatted message associated with the error. This presents as the message template with context variables appropriately injected.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticKnownError","title":"PydanticKnownError","text":"<pre><code>PydanticKnownError(error_type: ErrorType, context: dict[str, Any] | None = None)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>A helper class for raising exceptions that mimic Pydantic's built-in exceptions, with more flexibility in regards to context.</p> <p>Unlike <code>PydanticCustomError</code>, the <code>error_type</code> argument must be a known <code>ErrorType</code>.</p> Example <pre><code>from pydantic_core import PydanticKnownError\n\ndef custom_validator(v) -&gt; None:\n    if v &lt;= 10:\n        raise PydanticKnownError('greater_than', {'gt': 10})\n    return v\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>error_type</code> <code>ErrorType</code> <p>The error type.</p> \u5fc5\u9700 <code>context</code> <code>dict[str, Any] | None</code> <p>The data to inject into the message template.</p> <code>None</code>"},{"location":"api/pydantic_core/#pydantic_core.PydanticKnownError.context","title":"context  <code>property</code>","text":"<pre><code>context: dict[str, Any] | None\n</code></pre> <p>Values which are required to render the error message, and could hence be useful in passing error data forward.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticKnownError.type","title":"type  <code>property</code>","text":"<pre><code>type: ErrorType\n</code></pre> <p>The type of the error.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticKnownError.message_template","title":"message_template  <code>property</code>","text":"<pre><code>message_template: str\n</code></pre> <p>The message template associated with the provided error type. This is a string that can be formatted with context variables in <code>{curly_braces}</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticKnownError.message","title":"message","text":"<pre><code>message() -&gt; str\n</code></pre> <p>The formatted message associated with the error. This presents as the message template with context variables appropriately injected.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticOmit","title":"PydanticOmit","text":"<p>               Bases: <code>Exception</code></p> <p>An exception to signal that a field should be omitted from a generated result.</p> <p>This could span from omitting a field from a JSON Schema to omitting a field from a serialized result. Upcoming: more robust support for using PydanticOmit in custom serializers is still in development. Right now, this is primarily used in the JSON Schema generation process.</p> Example <pre><code>from typing import Callable\n\nfrom pydantic_core import PydanticOmit\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(self, schema, error_info) -&gt; JsonSchemaValue:\n        raise PydanticOmit\n\n\nclass Predicate(BaseModel):\n    name: str = 'no-op'\n    func: Callable = lambda x: x\n\n\ninstance_example = Predicate()\n\nvalidation_schema = instance_example.model_json_schema(schema_generator=MyGenerateJsonSchema, mode='validation')\nprint(validation_schema)\n'''\n{'properties': {'name': {'default': 'no-op', 'title': 'Name', 'type': 'string'}}, 'title': 'Predicate', 'type': 'object'}\n'''\n</code></pre> <p>For a more in depth example / explanation, see the customizing JSON schema docs.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticUseDefault","title":"PydanticUseDefault","text":"<p>               Bases: <code>Exception</code></p> <p>An exception to signal that standard validation either failed or should be skipped, and the default value should be used instead.</p> <p>This warning can be raised in custom valiation functions to redirect the flow of validation.</p> Example <pre><code>from pydantic_core import PydanticUseDefault\nfrom datetime import datetime\nfrom pydantic import BaseModel, field_validator\n\n\nclass Event(BaseModel):\n    name: str = 'meeting'\n    time: datetime\n\n    @field_validator('name', mode='plain')\n    def name_must_be_present(cls, v) -&gt; str:\n        if not v or not isinstance(v, str):\n            raise PydanticUseDefault()\n        return v\n\n\nevent1 = Event(name='party', time=datetime(2024, 1, 1, 12, 0, 0))\nprint(repr(event1))\n# &gt; Event(name='party', time=datetime.datetime(2024, 1, 1, 12, 0))\nevent2 = Event(time=datetime(2024, 1, 1, 12, 0, 0))\nprint(repr(event2))\n# &gt; Event(name='meeting', time=datetime.datetime(2024, 1, 1, 12, 0))\n</code></pre> <p>For an additional example, see the validating partial json data section of the Pydantic documentation.</p>"},{"location":"api/pydantic_core/#pydantic_core.PydanticSerializationError","title":"PydanticSerializationError","text":"<pre><code>PydanticSerializationError(message: str)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>An error raised when an issue occurs during serialization.</p> <p>In custom serializers, this error can be used to indicate that serialization has failed.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>message</code> <code>str</code> <p>The message associated with the error.</p> \u5fc5\u9700"},{"location":"api/pydantic_core/#pydantic_core.PydanticSerializationUnexpectedValue","title":"PydanticSerializationUnexpectedValue","text":"<pre><code>PydanticSerializationUnexpectedValue(message: str)\n</code></pre> <p>               Bases: <code>ValueError</code></p> <p>An error raised when an unexpected value is encountered during serialization.</p> <p>This error is often caught and coerced into a warning, as <code>pydantic-core</code> generally makes a best attempt at serializing values, in contrast with validation where errors are eagerly raised.</p> Example <pre><code>from pydantic import BaseModel, field_serializer\nfrom pydantic_core import PydanticSerializationUnexpectedValue\n\nclass BasicPoint(BaseModel):\n    x: int\n    y: int\n\n    @field_serializer('*')\n    def serialize(self, v):\n        if not isinstance(v, int):\n            raise PydanticSerializationUnexpectedValue(f'Expected type `int`, got {type(v)} with value {v}')\n        return v\n\npoint = BasicPoint(x=1, y=2)\n# some sort of mutation\npoint.x = 'a'\n\nprint(point.model_dump())\n'''\nUserWarning: Pydantic serializer warnings:\nPydanticSerializationUnexpectedValue(Expected type `int`, got &lt;class 'str'&gt; with value a)\nreturn self.__pydantic_serializer__.to_python(\n{'x': 'a', 'y': 2}\n'''\n</code></pre> <p>This is often used internally in <code>pydantic-core</code> when unexpected types are encountered during serialization, but it can also be used by users in custom serializers, as seen above.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>message</code> <code>str</code> <p>The message associated with the unexpected value.</p> \u5fc5\u9700"},{"location":"api/pydantic_core/#pydantic_core.Url","title":"Url","text":"<pre><code>Url(url: str)\n</code></pre> <p>               Bases: <code>SupportsAllComparisons</code></p> <p>A URL type, internal logic uses the url rust crate originally developed by Mozilla.</p>"},{"location":"api/pydantic_core/#pydantic_core.MultiHostUrl","title":"MultiHostUrl","text":"<pre><code>MultiHostUrl(url: str)\n</code></pre> <p>               Bases: <code>SupportsAllComparisons</code></p> <p>A URL type with support for multiple hosts, as used by some databases for DSNs, e.g. <code>https://foo.com,bar.com/path</code>.</p> <p>Internal URL logic uses the url rust crate originally developed by Mozilla.</p>"},{"location":"api/pydantic_core/#pydantic_core.MultiHostHost","title":"MultiHostHost","text":"<p>               Bases: <code>TypedDict</code></p> <p>A host part of a multi-host URL.</p>"},{"location":"api/pydantic_core/#pydantic_core.MultiHostHost.username","title":"username  <code>instance-attribute</code>","text":"<pre><code>username: str | None\n</code></pre> <p>The username part of this host, or <code>None</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.MultiHostHost.password","title":"password  <code>instance-attribute</code>","text":"<pre><code>password: str | None\n</code></pre> <p>The password part of this host, or <code>None</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.MultiHostHost.host","title":"host  <code>instance-attribute</code>","text":"<pre><code>host: str | None\n</code></pre> <p>The host part of this host, or <code>None</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.MultiHostHost.port","title":"port  <code>instance-attribute</code>","text":"<pre><code>port: int | None\n</code></pre> <p>The port part of this host, or <code>None</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.ArgsKwargs","title":"ArgsKwargs","text":"<pre><code>ArgsKwargs(args: tuple[Any, ...], kwargs: dict[str, Any] | None = None)\n</code></pre> <p>A construct used to store arguments and keyword arguments for a function call.</p> <p>This data structure is generally used to store information for core schemas associated with functions (like in an arguments schema). This data structure is also currently used for some validation against dataclasses.</p> Example <pre><code>from pydantic.dataclasses import dataclass\nfrom pydantic import model_validator\n\n\n@dataclass\nclass Model:\n    a: int\n    b: int\n\n    @model_validator(mode=\"before\")\n    @classmethod\n    def no_op_validator(cls, values):\n        print(values)\n        return values\n\nModel(1, b=2)\n#&gt; ArgsKwargs((1,), {\"b\": 2})\n\nModel(1, 2)\n#&gt; ArgsKwargs((1, 2), {})\n\nModel(a=1, b=2)\n#&gt; ArgsKwargs((), {\"a\": 1, \"b\": 2})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>args</code> <code>tuple[Any, ...]</code> <p>The arguments (inherently ordered) for a function call.</p> \u5fc5\u9700 <code>kwargs</code> <code>dict[str, Any] | None</code> <p>The keyword arguments for a function call</p> <code>None</code>"},{"location":"api/pydantic_core/#pydantic_core.ArgsKwargs.args","title":"args  <code>property</code>","text":"<pre><code>args: tuple[Any, ...]\n</code></pre> <p>The arguments (inherently ordered) for a function call.</p>"},{"location":"api/pydantic_core/#pydantic_core.ArgsKwargs.kwargs","title":"kwargs  <code>property</code>","text":"<pre><code>kwargs: dict[str, Any] | None\n</code></pre> <p>The keyword arguments for a function call.</p>"},{"location":"api/pydantic_core/#pydantic_core.Some","title":"Some","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Similar to Rust's <code>Option::Some</code> type, this identifies a value as being present, and provides a way to access it.</p> <p>Generally used in a union with <code>None</code> to different between \"some value which could be None\" and no value.</p>"},{"location":"api/pydantic_core/#pydantic_core.Some.value","title":"value  <code>property</code>","text":"<pre><code>value: _T\n</code></pre> <p>Returns the value wrapped by <code>Some</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.TzInfo","title":"TzInfo","text":"<pre><code>TzInfo(seconds: float = 0.0)\n</code></pre> <p>               Bases: <code>tzinfo</code></p> <p>An <code>pydantic-core</code> implementation of the abstract <code>datetime.tzinfo</code> class.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>seconds</code> <code>float</code> <p>The offset from UTC in seconds. Defaults to 0.0 (UTC).</p> <code>0.0</code>"},{"location":"api/pydantic_core/#pydantic_core.TzInfo.tzname","title":"tzname","text":"<pre><code>tzname(dt: datetime | None) -&gt; str | None\n</code></pre> <p>Return the time zone name corresponding to the <code>datetime</code> object dt, as a string.</p> <p>For more info, see <code>tzinfo.tzname</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.TzInfo.utcoffset","title":"utcoffset","text":"<pre><code>utcoffset(dt: datetime | None) -&gt; timedelta | None\n</code></pre> <p>Return offset of local time from UTC, as a <code>timedelta</code> object that is positive east of UTC. If local time is west of UTC, this should be negative.</p> <p>More info can be found at <code>tzinfo.utcoffset</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.TzInfo.dst","title":"dst","text":"<pre><code>dst(dt: datetime | None) -&gt; timedelta | None\n</code></pre> <p>Return the daylight saving time (DST) adjustment, as a <code>timedelta</code> object or <code>None</code> if DST information isn\u2019t known.</p> <p>More info can be found at<code>tzinfo.dst</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.TzInfo.fromutc","title":"fromutc","text":"<pre><code>fromutc(dt: datetime) -&gt; datetime\n</code></pre> <p>Adjust the date and time data associated datetime object dt, returning an equivalent datetime in self\u2019s local time.</p> <p>More info can be found at <code>tzinfo.fromutc</code>.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo","title":"ErrorTypeInfo","text":"<p>               Bases: <code>TypedDict</code></p> <p>Gives information about errors.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: ErrorType\n</code></pre> <p>The type of error that occurred, this should be a \"slug\" identifier that changes rarely or never.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo.message_template_python","title":"message_template_python  <code>instance-attribute</code>","text":"<pre><code>message_template_python: str\n</code></pre> <p>String template to render a human readable error message from using context, when the input is Python.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo.example_message_python","title":"example_message_python  <code>instance-attribute</code>","text":"<pre><code>example_message_python: str\n</code></pre> <p>Example of a human readable error message, when the input is Python.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo.message_template_json","title":"message_template_json  <code>instance-attribute</code>","text":"<pre><code>message_template_json: NotRequired[str]\n</code></pre> <p>String template to render a human readable error message from using context, when the input is JSON data.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo.example_message_json","title":"example_message_json  <code>instance-attribute</code>","text":"<pre><code>example_message_json: NotRequired[str]\n</code></pre> <p>Example of a human readable error message, when the input is JSON data.</p>"},{"location":"api/pydantic_core/#pydantic_core.ErrorTypeInfo.example_context","title":"example_context  <code>instance-attribute</code>","text":"<pre><code>example_context: dict[str, Any] | None\n</code></pre> <p>Example of context values.</p>"},{"location":"api/pydantic_core/#pydantic_core.to_json","title":"to_json","text":"<pre><code>to_json(value: Any, *, indent: int | None = None, ensure_ascii: bool = False, include: _IncEx | None = None, exclude: _IncEx | None = None, by_alias: bool = True, exclude_none: bool = False, round_trip: bool = False, timedelta_mode: Literal['iso8601', 'float'] = 'iso8601', temporal_mode: Literal['iso8601', 'seconds', 'milliseconds'] = 'iso8601', bytes_mode: Literal['utf8', 'base64', 'hex'] = 'utf8', inf_nan_mode: Literal['null', 'constants', 'strings'] = 'constants', serialize_unknown: bool = False, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False, context: Any | None = None) -&gt; bytes\n</code></pre> <p>Serialize a Python object to JSON including transforming and filtering data.</p> <p>This is effectively a standalone version of <code>SchemaSerializer.to_json</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>Any</code> <p>The Python object to serialize.</p> \u5fc5\u9700 <code>indent</code> <code>int | None</code> <p>If <code>None</code>, the JSON will be compact, otherwise it will be pretty-printed with the indent provided.</p> <code>None</code> <code>ensure_ascii</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>include</code> <code>_IncEx | None</code> <p>A set of fields to include, if <code>None</code> all fields are included.</p> <code>None</code> <code>exclude</code> <code>_IncEx | None</code> <p>A set of fields to exclude, if <code>None</code> no fields are excluded.</p> <code>None</code> <code>by_alias</code> <code>bool</code> <p>Whether to use the alias names of fields.</p> <code>True</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>Whether to enable serialization and validation round-trip support.</p> <code>False</code> <code>timedelta_mode</code> <code>Literal['iso8601', 'float']</code> <p>How to serialize <code>timedelta</code> objects, either <code>'iso8601'</code> or <code>'float'</code>.</p> <code>'iso8601'</code> <code>temporal_mode</code> <code>Literal['iso8601', 'seconds', 'milliseconds']</code> <p>How to serialize datetime-like objects (<code>datetime</code>, <code>date</code>, <code>time</code>), either <code>'iso8601'</code>, <code>'seconds'</code>, or <code>'milliseconds'</code>. <code>iso8601</code> returns an ISO 8601 string; <code>seconds</code> returns the Unix timestamp in seconds as a float; <code>milliseconds</code> returns the Unix timestamp in milliseconds as a float.</p> <code>'iso8601'</code> <code>bytes_mode</code> <code>Literal['utf8', 'base64', 'hex']</code> <p>How to serialize <code>bytes</code> objects, either <code>'utf8'</code>, <code>'base64'</code>, or <code>'hex'</code>.</p> <code>'utf8'</code> <code>inf_nan_mode</code> <code>Literal['null', 'constants', 'strings']</code> <p>How to serialize <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code> values, either <code>'null'</code>, <code>'constants'</code>, or <code>'strings'</code>.</p> <code>'constants'</code> <code>serialize_unknown</code> <code>bool</code> <p>Attempt to serialize unknown types, <code>str(value)</code> will be used, if that fails <code>\"&lt;Unserializable {value_type} object&gt;\"</code> will be used.</p> <code>False</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered, if <code>None</code> a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <code>context</code> <code>Any | None</code> <p>The context to use for serialization, this is passed to functional serializers as <code>info.context</code>.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticSerializationError</code> <p>If serialization fails and no <code>fallback</code> function is provided.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>JSON bytes.</p>"},{"location":"api/pydantic_core/#pydantic_core.from_json","title":"from_json","text":"<pre><code>from_json(data: str | bytes | bytearray, *, allow_inf_nan: bool = True, cache_strings: bool | Literal['all', 'keys', 'none'] = True, allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False) -&gt; Any\n</code></pre> <p>Deserialize JSON data to a Python object.</p> <p>This is effectively a faster version of <code>json.loads()</code>, with some extra functionality.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>str | bytes | bytearray</code> <p>The JSON data to deserialize.</p> \u5fc5\u9700 <code>allow_inf_nan</code> <code>bool</code> <p>Whether to allow <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code> values as <code>json.loads()</code> does by default.</p> <code>True</code> <code>cache_strings</code> <code>bool | Literal['all', 'keys', 'none']</code> <p>Whether to cache strings to avoid constructing new Python objects, this should have a significant impact on performance while increasing memory usage slightly, <code>all/True</code> means cache all strings, <code>keys</code> means cache only dict keys, <code>none/False</code> means no caching.</p> <code>True</code> <code>allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Whether to allow partial deserialization, if <code>True</code> JSON data is returned if the end of the input is reached before the full object is deserialized, e.g. <code>[\"aa\", \"bb\", \"c</code> would return <code>['aa', 'bb']</code>. <code>'trailing-strings'</code> means any final unfinished JSON string is included in the result.</p> <code>False</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValueError</code> <p>If deserialization fails.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The deserialized Python object.</p>"},{"location":"api/pydantic_core/#pydantic_core.to_jsonable_python","title":"to_jsonable_python","text":"<pre><code>to_jsonable_python(value: Any, *, include: _IncEx | None = None, exclude: _IncEx | None = None, by_alias: bool = True, exclude_none: bool = False, round_trip: bool = False, timedelta_mode: Literal['iso8601', 'float'] = 'iso8601', temporal_mode: Literal['iso8601', 'seconds', 'milliseconds'] = 'iso8601', bytes_mode: Literal['utf8', 'base64', 'hex'] = 'utf8', inf_nan_mode: Literal['null', 'constants', 'strings'] = 'constants', serialize_unknown: bool = False, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False, context: Any | None = None) -&gt; Any\n</code></pre> <p>Serialize/marshal a Python object to a JSON-serializable Python object including transforming and filtering data.</p> <p>This is effectively a standalone version of <code>SchemaSerializer.to_python(mode='json')</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>Any</code> <p>The Python object to serialize.</p> \u5fc5\u9700 <code>include</code> <code>_IncEx | None</code> <p>A set of fields to include, if <code>None</code> all fields are included.</p> <code>None</code> <code>exclude</code> <code>_IncEx | None</code> <p>A set of fields to exclude, if <code>None</code> no fields are excluded.</p> <code>None</code> <code>by_alias</code> <code>bool</code> <p>Whether to use the alias names of fields.</p> <code>True</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields that have a value of <code>None</code>.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>Whether to enable serialization and validation round-trip support.</p> <code>False</code> <code>timedelta_mode</code> <code>Literal['iso8601', 'float']</code> <p>How to serialize <code>timedelta</code> objects, either <code>'iso8601'</code> or <code>'float'</code>.</p> <code>'iso8601'</code> <code>temporal_mode</code> <code>Literal['iso8601', 'seconds', 'milliseconds']</code> <p>How to serialize datetime-like objects (<code>datetime</code>, <code>date</code>, <code>time</code>), either <code>'iso8601'</code>, <code>'seconds'</code>, or <code>'milliseconds'</code>. <code>iso8601</code> returns an ISO 8601 string; <code>seconds</code> returns the Unix timestamp in seconds as a float; <code>milliseconds</code> returns the Unix timestamp in milliseconds as a float.</p> <code>'iso8601'</code> <code>bytes_mode</code> <code>Literal['utf8', 'base64', 'hex']</code> <p>How to serialize <code>bytes</code> objects, either <code>'utf8'</code>, <code>'base64'</code>, or <code>'hex'</code>.</p> <code>'utf8'</code> <code>inf_nan_mode</code> <code>Literal['null', 'constants', 'strings']</code> <p>How to serialize <code>Infinity</code>, <code>-Infinity</code> and <code>NaN</code> values, either <code>'null'</code>, <code>'constants'</code>, or <code>'strings'</code>.</p> <code>'constants'</code> <code>serialize_unknown</code> <code>bool</code> <p>Attempt to serialize unknown types, <code>str(value)</code> will be used, if that fails <code>\"&lt;Unserializable {value_type} object&gt;\"</code> will be used.</p> <code>False</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered, if <code>None</code> a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <code>context</code> <code>Any | None</code> <p>The context to use for serialization, this is passed to functional serializers as <code>info.context</code>.</p> <code>None</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticSerializationError</code> <p>If serialization fails and no <code>fallback</code> function is provided.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The serialized Python object.</p>"},{"location":"api/pydantic_core_schema/","title":"pydantic_core.core_schema","text":"<p>This module contains definitions to build schemas which <code>pydantic_core</code> can validate and serialize.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.WhenUsed","title":"WhenUsed  <code>module-attribute</code>","text":"<pre><code>WhenUsed = Literal['always', 'unless-none', 'json', 'json-unless-none']\n</code></pre> <p>Values have the following meanings:</p> <ul> <li><code>'always'</code> means always use</li> <li><code>'unless-none'</code> means use unless the value is <code>None</code></li> <li><code>'json'</code> means use when serializing to JSON</li> <li><code>'json-unless-none'</code> means use when serializing to JSON and the value is not <code>None</code></li> </ul>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.CoreConfig","title":"CoreConfig","text":"<p>               Bases: <code>TypedDict</code></p> <p>Base class for schema configuration options.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>title</code> <code>str</code> <p>The name of the configuration.</p> <code>strict</code> <code>bool</code> <p>Whether the configuration should strictly adhere to specified rules.</p> <code>extra_fields_behavior</code> <code>ExtraBehavior</code> <p>The behavior for handling extra fields.</p> <code>typed_dict_total</code> <code>bool</code> <p>Whether the TypedDict should be considered total. Default is <code>True</code>.</p> <code>from_attributes</code> <code>bool</code> <p>Whether to use attributes for models, dataclasses, and tagged union keys.</p> <code>loc_by_alias</code> <code>bool</code> <p>Whether to use the used alias (or first alias for \"field required\" errors) instead of <code>field_names</code> to construct error <code>loc</code>s. Default is <code>True</code>.</p> <code>revalidate_instances</code> <code>Literal['always', 'never', 'subclass-instances']</code> <p>Whether instances of models and dataclasses should re-validate. Default is 'never'.</p> <code>validate_default</code> <code>bool</code> <p>Whether to validate default values during validation. Default is <code>False</code>.</p> <code>str_max_length</code> <code>int</code> <p>The maximum length for string fields.</p> <code>str_min_length</code> <code>int</code> <p>The minimum length for string fields.</p> <code>str_strip_whitespace</code> <code>bool</code> <p>Whether to strip whitespace from string fields.</p> <code>str_to_lower</code> <code>bool</code> <p>Whether to convert string fields to lowercase.</p> <code>str_to_upper</code> <code>bool</code> <p>Whether to convert string fields to uppercase.</p> <code>allow_inf_nan</code> <code>bool</code> <p>Whether to allow infinity and NaN values for float fields. Default is <code>True</code>.</p> <code>ser_json_timedelta</code> <code>Literal['iso8601', 'float']</code> <p>The serialization option for <code>timedelta</code> values. Default is 'iso8601'. Note that if ser_json_temporal is set, then this param will be ignored.</p> <code>ser_json_temporal</code> <code>Literal['iso8601', 'seconds', 'milliseconds']</code> <p>The serialization option for datetime like values. Default is 'iso8601'. The types this covers are datetime, date, time and timedelta. If this is set, it will take precedence over ser_json_timedelta</p> <code>ser_json_bytes</code> <code>Literal['utf8', 'base64', 'hex']</code> <p>The serialization option for <code>bytes</code> values. Default is 'utf8'.</p> <code>ser_json_inf_nan</code> <code>Literal['null', 'constants', 'strings']</code> <p>The serialization option for infinity and NaN values in float fields. Default is 'null'.</p> <code>val_json_bytes</code> <code>Literal['utf8', 'base64', 'hex']</code> <p>The validation option for <code>bytes</code> values, complementing ser_json_bytes. Default is 'utf8'.</p> <code>hide_input_in_errors</code> <code>bool</code> <p>Whether to hide input data from <code>ValidationError</code> representation.</p> <code>validation_error_cause</code> <code>bool</code> <p>Whether to add user-python excs to the cause of a ValidationError. Requires exceptiongroup backport pre Python 3.11.</p> <code>coerce_numbers_to_str</code> <code>bool</code> <p>Whether to enable coercion of any <code>Number</code> type to <code>str</code> (not applicable in <code>strict</code> mode).</p> <code>regex_engine</code> <code>Literal['rust-regex', 'python-re']</code> <p>The regex engine to use for regex pattern validation. Default is 'rust-regex'. See <code>StringSchema</code>.</p> <code>cache_strings</code> <code>Union[bool, Literal['all', 'keys', 'none']]</code> <p>Whether to cache strings. Default is <code>True</code>, <code>True</code> or <code>'all'</code> is required to cache strings during general validation since validators don't know if they're in a key or a value.</p> <code>validate_by_alias</code> <code>bool</code> <p>Whether to use the field's alias when validating against the provided input data. Default is <code>True</code>.</p> <code>validate_by_name</code> <code>bool</code> <p>Whether to use the field's name when validating against the provided input data. Default is <code>False</code>. Replacement for <code>populate_by_name</code>.</p> <code>serialize_by_alias</code> <code>bool</code> <p>Whether to serialize by alias. Default is <code>False</code>, expected to change to <code>True</code> in V3.</p> <code>url_preserve_empty_path</code> <code>bool</code> <p>Whether to preserve empty URL paths when validating values for a URL type. Defaults to <code>False</code>.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo","title":"SerializationInfo","text":"<p>               Bases: <code>Protocol[ContextT]</code></p> <p>Extra data used during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.include","title":"include  <code>property</code>","text":"<pre><code>include: IncExCall\n</code></pre> <p>The <code>include</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.exclude","title":"exclude  <code>property</code>","text":"<pre><code>exclude: IncExCall\n</code></pre> <p>The <code>exclude</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.context","title":"context  <code>property</code>","text":"<pre><code>context: ContextT\n</code></pre> <p>The current serialization context.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.mode","title":"mode  <code>property</code>","text":"<pre><code>mode: Literal['python', 'json'] | str\n</code></pre> <p>The serialization mode set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.by_alias","title":"by_alias  <code>property</code>","text":"<pre><code>by_alias: bool\n</code></pre> <p>The <code>by_alias</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.exclude_unset","title":"exclude_unset  <code>property</code>","text":"<pre><code>exclude_unset: bool\n</code></pre> <p>The <code>exclude_unset</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.exclude_defaults","title":"exclude_defaults  <code>property</code>","text":"<pre><code>exclude_defaults: bool\n</code></pre> <p>The <code>exclude_defaults</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.exclude_none","title":"exclude_none  <code>property</code>","text":"<pre><code>exclude_none: bool\n</code></pre> <p>The <code>exclude_none</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.exclude_computed_fields","title":"exclude_computed_fields  <code>property</code>","text":"<pre><code>exclude_computed_fields: bool\n</code></pre> <p>The <code>exclude_computed_fields</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.serialize_as_any","title":"serialize_as_any  <code>property</code>","text":"<pre><code>serialize_as_any: bool\n</code></pre> <p>The <code>serialize_as_any</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.SerializationInfo.round_trip","title":"round_trip  <code>property</code>","text":"<pre><code>round_trip: bool\n</code></pre> <p>The <code>round_trip</code> argument set during serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.FieldSerializationInfo","title":"FieldSerializationInfo","text":"<p>               Bases: <code>SerializationInfo[ContextT]</code>, <code>Protocol</code></p> <p>Extra data used during field serialization.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.FieldSerializationInfo.field_name","title":"field_name  <code>property</code>","text":"<pre><code>field_name: str\n</code></pre> <p>The name of the current field being serialized.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.ValidationInfo","title":"ValidationInfo","text":"<p>               Bases: <code>Protocol[ContextT]</code></p> <p>Extra data used during validation.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.ValidationInfo.context","title":"context  <code>property</code>","text":"<pre><code>context: ContextT\n</code></pre> <p>The current validation context.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.ValidationInfo.config","title":"config  <code>property</code>","text":"<pre><code>config: CoreConfig | None\n</code></pre> <p>The CoreConfig that applies to this validation.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.ValidationInfo.mode","title":"mode  <code>property</code>","text":"<pre><code>mode: Literal['python', 'json']\n</code></pre> <p>The type of input data we are currently validating.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.ValidationInfo.data","title":"data  <code>property</code>","text":"<pre><code>data: dict[str, Any]\n</code></pre> <p>The data being validated for this model.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.ValidationInfo.field_name","title":"field_name  <code>property</code>","text":"<pre><code>field_name: str | None\n</code></pre> <p>The name of the current field being validated if this validator is attached to a model field.</p>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.simple_ser_schema","title":"simple_ser_schema","text":"<pre><code>simple_ser_schema(type: ExpectedSerializationTypes) -&gt; SimpleSerSchema\n</code></pre> <p>Returns a schema for serialization with a custom type.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>type</code> <code>ExpectedSerializationTypes</code> <p>The type to use for serialization</p> \u5fc5\u9700 \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def simple_ser_schema(type: ExpectedSerializationTypes) -&gt; SimpleSerSchema:\n    \"\"\"\n    Returns a schema for serialization with a custom type.\n\n    Args:\n        type: The type to use for serialization\n    \"\"\"\n    return SimpleSerSchema(type=type)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.plain_serializer_function_ser_schema","title":"plain_serializer_function_ser_schema","text":"<pre><code>plain_serializer_function_ser_schema(function: SerializerFunction, *, is_field_serializer: bool | None = None, info_arg: bool | None = None, return_schema: CoreSchema | None = None, when_used: WhenUsed = 'always') -&gt; PlainSerializerFunctionSerSchema\n</code></pre> <p>Returns a schema for serialization with a function, can be either a \"general\" or \"field\" function.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>SerializerFunction</code> <p>The function to use for serialization</p> \u5fc5\u9700 <code>is_field_serializer</code> <code>bool | None</code> <p>Whether the serializer is for a field, e.g. takes <code>model</code> as the first argument, and <code>info</code> includes <code>field_name</code></p> <code>None</code> <code>info_arg</code> <code>bool | None</code> <p>Whether the function takes an <code>info</code> argument</p> <code>None</code> <code>return_schema</code> <code>CoreSchema | None</code> <p>Schema to use for serializing return value</p> <code>None</code> <code>when_used</code> <code>WhenUsed</code> <p>When the function should be called</p> <code>'always'</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def plain_serializer_function_ser_schema(\n    function: SerializerFunction,\n    *,\n    is_field_serializer: bool | None = None,\n    info_arg: bool | None = None,\n    return_schema: CoreSchema | None = None,\n    when_used: WhenUsed = 'always',\n) -&gt; PlainSerializerFunctionSerSchema:\n    \"\"\"\n    Returns a schema for serialization with a function, can be either a \"general\" or \"field\" function.\n\n    Args:\n        function: The function to use for serialization\n        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,\n            and `info` includes `field_name`\n        info_arg: Whether the function takes an `info` argument\n        return_schema: Schema to use for serializing return value\n        when_used: When the function should be called\n    \"\"\"\n    if when_used == 'always':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        when_used = None  # type: ignore\n    return _dict_not_none(\n        type='function-plain',\n        function=function,\n        is_field_serializer=is_field_serializer,\n        info_arg=info_arg,\n        return_schema=return_schema,\n        when_used=when_used,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.wrap_serializer_function_ser_schema","title":"wrap_serializer_function_ser_schema","text":"<pre><code>wrap_serializer_function_ser_schema(function: WrapSerializerFunction, *, is_field_serializer: bool | None = None, info_arg: bool | None = None, schema: CoreSchema | None = None, return_schema: CoreSchema | None = None, when_used: WhenUsed = 'always') -&gt; WrapSerializerFunctionSerSchema\n</code></pre> <p>Returns a schema for serialization with a wrap function, can be either a \"general\" or \"field\" function.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>WrapSerializerFunction</code> <p>The function to use for serialization</p> \u5fc5\u9700 <code>is_field_serializer</code> <code>bool | None</code> <p>Whether the serializer is for a field, e.g. takes <code>model</code> as the first argument, and <code>info</code> includes <code>field_name</code></p> <code>None</code> <code>info_arg</code> <code>bool | None</code> <p>Whether the function takes an <code>info</code> argument</p> <code>None</code> <code>schema</code> <code>CoreSchema | None</code> <p>The schema to use for the inner serialization</p> <code>None</code> <code>return_schema</code> <code>CoreSchema | None</code> <p>Schema to use for serializing return value</p> <code>None</code> <code>when_used</code> <code>WhenUsed</code> <p>When the function should be called</p> <code>'always'</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def wrap_serializer_function_ser_schema(\n    function: WrapSerializerFunction,\n    *,\n    is_field_serializer: bool | None = None,\n    info_arg: bool | None = None,\n    schema: CoreSchema | None = None,\n    return_schema: CoreSchema | None = None,\n    when_used: WhenUsed = 'always',\n) -&gt; WrapSerializerFunctionSerSchema:\n    \"\"\"\n    Returns a schema for serialization with a wrap function, can be either a \"general\" or \"field\" function.\n\n    Args:\n        function: The function to use for serialization\n        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,\n            and `info` includes `field_name`\n        info_arg: Whether the function takes an `info` argument\n        schema: The schema to use for the inner serialization\n        return_schema: Schema to use for serializing return value\n        when_used: When the function should be called\n    \"\"\"\n    if when_used == 'always':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        when_used = None  # type: ignore\n    return _dict_not_none(\n        type='function-wrap',\n        function=function,\n        is_field_serializer=is_field_serializer,\n        info_arg=info_arg,\n        schema=schema,\n        return_schema=return_schema,\n        when_used=when_used,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.format_ser_schema","title":"format_ser_schema","text":"<pre><code>format_ser_schema(formatting_string: str, *, when_used: WhenUsed = 'json-unless-none') -&gt; FormatSerSchema\n</code></pre> <p>Returns a schema for serialization using python's <code>format</code> method.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>formatting_string</code> <code>str</code> <p>String defining the format to use</p> \u5fc5\u9700 <code>when_used</code> <code>WhenUsed</code> <p>Same meaning as for [general_function_plain_ser_schema], but with a different default</p> <code>'json-unless-none'</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def format_ser_schema(formatting_string: str, *, when_used: WhenUsed = 'json-unless-none') -&gt; FormatSerSchema:\n    \"\"\"\n    Returns a schema for serialization using python's `format` method.\n\n    Args:\n        formatting_string: String defining the format to use\n        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default\n    \"\"\"\n    if when_used == 'json-unless-none':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        when_used = None  # type: ignore\n    return _dict_not_none(type='format', formatting_string=formatting_string, when_used=when_used)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.to_string_ser_schema","title":"to_string_ser_schema","text":"<pre><code>to_string_ser_schema(*, when_used: WhenUsed = 'json-unless-none') -&gt; ToStringSerSchema\n</code></pre> <p>Returns a schema for serialization using python's <code>str()</code> / <code>__str__</code> method.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>when_used</code> <code>WhenUsed</code> <p>Same meaning as for [general_function_plain_ser_schema], but with a different default</p> <code>'json-unless-none'</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def to_string_ser_schema(*, when_used: WhenUsed = 'json-unless-none') -&gt; ToStringSerSchema:\n    \"\"\"\n    Returns a schema for serialization using python's `str()` / `__str__` method.\n\n    Args:\n        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default\n    \"\"\"\n    s = dict(type='to-string')\n    if when_used != 'json-unless-none':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        s['when_used'] = when_used\n    return s  # type: ignore\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.model_ser_schema","title":"model_ser_schema","text":"<pre><code>model_ser_schema(cls: type[Any], schema: CoreSchema) -&gt; ModelSerSchema\n</code></pre> <p>Returns a schema for serialization using a model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>type[Any]</code> <p>The expected class type, used to generate warnings if the wrong type is passed</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>Internal schema to use to serialize the model dict</p> \u5fc5\u9700 \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def model_ser_schema(cls: type[Any], schema: CoreSchema) -&gt; ModelSerSchema:\n    \"\"\"\n    Returns a schema for serialization using a model.\n\n    Args:\n        cls: The expected class type, used to generate warnings if the wrong type is passed\n        schema: Internal schema to use to serialize the model dict\n    \"\"\"\n    return ModelSerSchema(type='model', cls=cls, schema=schema)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.invalid_schema","title":"invalid_schema","text":"<pre><code>invalid_schema(ref: str | None = None, metadata: dict[str, Any] | None = None) -&gt; InvalidSchema\n</code></pre> <p>Returns an invalid schema, used to indicate that a schema is invalid.</p> <pre><code>Returns a schema that matches any value, e.g.:\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def invalid_schema(ref: str | None = None, metadata: dict[str, Any] | None = None) -&gt; InvalidSchema:\n    \"\"\"\n    Returns an invalid schema, used to indicate that a schema is invalid.\n\n        Returns a schema that matches any value, e.g.:\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n\n    return _dict_not_none(type='invalid', ref=ref, metadata=metadata)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.computed_field","title":"computed_field","text":"<pre><code>computed_field(property_name: str, return_schema: CoreSchema, *, alias: str | None = None, metadata: dict[str, Any] | None = None) -&gt; ComputedField\n</code></pre> <p>ComputedFields are properties of a model or dataclass that are included in serialization.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>property_name</code> <code>str</code> <p>The name of the property on the model or dataclass</p> \u5fc5\u9700 <code>return_schema</code> <code>CoreSchema</code> <p>The schema used for the type returned by the computed field</p> \u5fc5\u9700 <code>alias</code> <code>str | None</code> <p>The name to use in the serialized output</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def computed_field(\n    property_name: str, return_schema: CoreSchema, *, alias: str | None = None, metadata: dict[str, Any] | None = None\n) -&gt; ComputedField:\n    \"\"\"\n    ComputedFields are properties of a model or dataclass that are included in serialization.\n\n    Args:\n        property_name: The name of the property on the model or dataclass\n        return_schema: The schema used for the type returned by the computed field\n        alias: The name to use in the serialized output\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n    return _dict_not_none(\n        type='computed-field', property_name=property_name, return_schema=return_schema, alias=alias, metadata=metadata\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.any_schema","title":"any_schema","text":"<pre><code>any_schema(*, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; AnySchema\n</code></pre> <p>Returns a schema that matches any value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.any_schema()\nv = SchemaValidator(schema)\nassert v.validate_python(1) == 1\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def any_schema(\n    *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None\n) -&gt; AnySchema:\n    \"\"\"\n    Returns a schema that matches any value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.any_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python(1) == 1\n    ```\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='any', ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.none_schema","title":"none_schema","text":"<pre><code>none_schema(*, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; NoneSchema\n</code></pre> <p>Returns a schema that matches a None value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.none_schema()\nv = SchemaValidator(schema)\nassert v.validate_python(None) is None\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def none_schema(\n    *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None\n) -&gt; NoneSchema:\n    \"\"\"\n    Returns a schema that matches a None value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.none_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python(None) is None\n    ```\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='none', ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.bool_schema","title":"bool_schema","text":"<pre><code>bool_schema(strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; BoolSchema\n</code></pre> <p>Returns a schema that matches a bool value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.bool_schema()\nv = SchemaValidator(schema)\nassert v.validate_python('True') is True\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether the value should be a bool or a value that can be converted to a bool</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def bool_schema(\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; BoolSchema:\n    \"\"\"\n    Returns a schema that matches a bool value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.bool_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python('True') is True\n    ```\n\n    Args:\n        strict: Whether the value should be a bool or a value that can be converted to a bool\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='bool', strict=strict, ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.int_schema","title":"int_schema","text":"<pre><code>int_schema(*, multiple_of: int | None = None, le: int | None = None, ge: int | None = None, lt: int | None = None, gt: int | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; IntSchema\n</code></pre> <p>Returns a schema that matches a int value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.int_schema(multiple_of=2, le=6, ge=2)\nv = SchemaValidator(schema)\nassert v.validate_python('4') == 4\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>multiple_of</code> <code>int | None</code> <p>The value must be a multiple of this number</p> <code>None</code> <code>le</code> <code>int | None</code> <p>The value must be less than or equal to this number</p> <code>None</code> <code>ge</code> <code>int | None</code> <p>The value must be greater than or equal to this number</p> <code>None</code> <code>lt</code> <code>int | None</code> <p>The value must be strictly less than this number</p> <code>None</code> <code>gt</code> <code>int | None</code> <p>The value must be strictly greater than this number</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the value should be a int or a value that can be converted to a int</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def int_schema(\n    *,\n    multiple_of: int | None = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; IntSchema:\n    \"\"\"\n    Returns a schema that matches a int value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.int_schema(multiple_of=2, le=6, ge=2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('4') == 4\n    ```\n\n    Args:\n        multiple_of: The value must be a multiple of this number\n        le: The value must be less than or equal to this number\n        ge: The value must be greater than or equal to this number\n        lt: The value must be strictly less than this number\n        gt: The value must be strictly greater than this number\n        strict: Whether the value should be a int or a value that can be converted to a int\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='int',\n        multiple_of=multiple_of,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.float_schema","title":"float_schema","text":"<pre><code>float_schema(*, allow_inf_nan: bool | None = None, multiple_of: float | None = None, le: float | None = None, ge: float | None = None, lt: float | None = None, gt: float | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; FloatSchema\n</code></pre> <p>Returns a schema that matches a float value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.float_schema(le=0.8, ge=0.2)\nv = SchemaValidator(schema)\nassert v.validate_python('0.5') == 0.5\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>allow_inf_nan</code> <code>bool | None</code> <p>Whether to allow inf and nan values</p> <code>None</code> <code>multiple_of</code> <code>float | None</code> <p>The value must be a multiple of this number</p> <code>None</code> <code>le</code> <code>float | None</code> <p>The value must be less than or equal to this number</p> <code>None</code> <code>ge</code> <code>float | None</code> <p>The value must be greater than or equal to this number</p> <code>None</code> <code>lt</code> <code>float | None</code> <p>The value must be strictly less than this number</p> <code>None</code> <code>gt</code> <code>float | None</code> <p>The value must be strictly greater than this number</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the value should be a float or a value that can be converted to a float</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def float_schema(\n    *,\n    allow_inf_nan: bool | None = None,\n    multiple_of: float | None = None,\n    le: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    gt: float | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; FloatSchema:\n    \"\"\"\n    Returns a schema that matches a float value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.float_schema(le=0.8, ge=0.2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('0.5') == 0.5\n    ```\n\n    Args:\n        allow_inf_nan: Whether to allow inf and nan values\n        multiple_of: The value must be a multiple of this number\n        le: The value must be less than or equal to this number\n        ge: The value must be greater than or equal to this number\n        lt: The value must be strictly less than this number\n        gt: The value must be strictly greater than this number\n        strict: Whether the value should be a float or a value that can be converted to a float\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='float',\n        allow_inf_nan=allow_inf_nan,\n        multiple_of=multiple_of,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.decimal_schema","title":"decimal_schema","text":"<pre><code>decimal_schema(*, allow_inf_nan: bool | None = None, multiple_of: Decimal | None = None, le: Decimal | None = None, ge: Decimal | None = None, lt: Decimal | None = None, gt: Decimal | None = None, max_digits: int | None = None, decimal_places: int | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; DecimalSchema\n</code></pre> <p>Returns a schema that matches a decimal value, e.g.:</p> <pre><code>from decimal import Decimal\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.decimal_schema(le=0.8, ge=0.2)\nv = SchemaValidator(schema)\nassert v.validate_python('0.5') == Decimal('0.5')\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>allow_inf_nan</code> <code>bool | None</code> <p>Whether to allow inf and nan values</p> <code>None</code> <code>multiple_of</code> <code>Decimal | None</code> <p>The value must be a multiple of this number</p> <code>None</code> <code>le</code> <code>Decimal | None</code> <p>The value must be less than or equal to this number</p> <code>None</code> <code>ge</code> <code>Decimal | None</code> <p>The value must be greater than or equal to this number</p> <code>None</code> <code>lt</code> <code>Decimal | None</code> <p>The value must be strictly less than this number</p> <code>None</code> <code>gt</code> <code>Decimal | None</code> <p>The value must be strictly greater than this number</p> <code>None</code> <code>max_digits</code> <code>int | None</code> <p>The maximum number of decimal digits allowed</p> <code>None</code> <code>decimal_places</code> <code>int | None</code> <p>The maximum number of decimal places allowed</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the value should be a float or a value that can be converted to a float</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def decimal_schema(\n    *,\n    allow_inf_nan: bool | None = None,\n    multiple_of: Decimal | None = None,\n    le: Decimal | None = None,\n    ge: Decimal | None = None,\n    lt: Decimal | None = None,\n    gt: Decimal | None = None,\n    max_digits: int | None = None,\n    decimal_places: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; DecimalSchema:\n    \"\"\"\n    Returns a schema that matches a decimal value, e.g.:\n\n    ```py\n    from decimal import Decimal\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.decimal_schema(le=0.8, ge=0.2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('0.5') == Decimal('0.5')\n    ```\n\n    Args:\n        allow_inf_nan: Whether to allow inf and nan values\n        multiple_of: The value must be a multiple of this number\n        le: The value must be less than or equal to this number\n        ge: The value must be greater than or equal to this number\n        lt: The value must be strictly less than this number\n        gt: The value must be strictly greater than this number\n        max_digits: The maximum number of decimal digits allowed\n        decimal_places: The maximum number of decimal places allowed\n        strict: Whether the value should be a float or a value that can be converted to a float\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='decimal',\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.complex_schema","title":"complex_schema","text":"<pre><code>complex_schema(*, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; ComplexSchema\n</code></pre> <p>Returns a schema that matches a complex value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.complex_schema()\nv = SchemaValidator(schema)\nassert v.validate_python('1+2j') == complex(1, 2)\nassert v.validate_python(complex(1, 2)) == complex(1, 2)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether the value should be a complex object instance or a value that can be converted to a complex object</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def complex_schema(\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; ComplexSchema:\n    \"\"\"\n    Returns a schema that matches a complex value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.complex_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python('1+2j') == complex(1, 2)\n    assert v.validate_python(complex(1, 2)) == complex(1, 2)\n    ```\n\n    Args:\n        strict: Whether the value should be a complex object instance or a value that can be converted to a complex object\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='complex',\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.str_schema","title":"str_schema","text":"<pre><code>str_schema(*, pattern: str | Pattern[str] | None = None, max_length: int | None = None, min_length: int | None = None, strip_whitespace: bool | None = None, to_lower: bool | None = None, to_upper: bool | None = None, regex_engine: Literal['rust-regex', 'python-re'] | None = None, strict: bool | None = None, coerce_numbers_to_str: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; StringSchema\n</code></pre> <p>Returns a schema that matches a string value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.str_schema(max_length=10, min_length=2)\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>pattern</code> <code>str | Pattern[str] | None</code> <p>A regex pattern that the value must match</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be at most this length</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be at least this length</p> <code>None</code> <code>strip_whitespace</code> <code>bool | None</code> <p>Whether to strip whitespace from the value</p> <code>None</code> <code>to_lower</code> <code>bool | None</code> <p>Whether to convert the value to lowercase</p> <code>None</code> <code>to_upper</code> <code>bool | None</code> <p>Whether to convert the value to uppercase</p> <code>None</code> <code>regex_engine</code> <code>Literal['rust-regex', 'python-re'] | None</code> <p>The regex engine to use for pattern validation. Default is 'rust-regex'. - <code>rust-regex</code> uses the <code>regex</code> Rust   crate, which is non-backtracking and therefore more DDoS   resistant, but does not support all regex features. - <code>python-re</code> use the <code>re</code> module,   which supports all regex features, but may be slower.</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the value should be a string or a value that can be converted to a string</p> <code>None</code> <code>coerce_numbers_to_str</code> <code>bool | None</code> <p>Whether to enable coercion of any <code>Number</code> type to <code>str</code> (not applicable in <code>strict</code> mode).</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def str_schema(\n    *,\n    pattern: str | Pattern[str] | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    strip_whitespace: bool | None = None,\n    to_lower: bool | None = None,\n    to_upper: bool | None = None,\n    regex_engine: Literal['rust-regex', 'python-re'] | None = None,\n    strict: bool | None = None,\n    coerce_numbers_to_str: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; StringSchema:\n    \"\"\"\n    Returns a schema that matches a string value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.str_schema(max_length=10, min_length=2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello'\n    ```\n\n    Args:\n        pattern: A regex pattern that the value must match\n        max_length: The value must be at most this length\n        min_length: The value must be at least this length\n        strip_whitespace: Whether to strip whitespace from the value\n        to_lower: Whether to convert the value to lowercase\n        to_upper: Whether to convert the value to uppercase\n        regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'.\n            - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust\n              crate, which is non-backtracking and therefore more DDoS\n              resistant, but does not support all regex features.\n            - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,\n              which supports all regex features, but may be slower.\n        strict: Whether the value should be a string or a value that can be converted to a string\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='str',\n        pattern=pattern,\n        max_length=max_length,\n        min_length=min_length,\n        strip_whitespace=strip_whitespace,\n        to_lower=to_lower,\n        to_upper=to_upper,\n        regex_engine=regex_engine,\n        strict=strict,\n        coerce_numbers_to_str=coerce_numbers_to_str,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.bytes_schema","title":"bytes_schema","text":"<pre><code>bytes_schema(*, max_length: int | None = None, min_length: int | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; BytesSchema\n</code></pre> <p>Returns a schema that matches a bytes value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.bytes_schema(max_length=10, min_length=2)\nv = SchemaValidator(schema)\nassert v.validate_python(b'hello') == b'hello'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>max_length</code> <code>int | None</code> <p>The value must be at most this length</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be at least this length</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the value should be a bytes or a value that can be converted to a bytes</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def bytes_schema(\n    *,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; BytesSchema:\n    \"\"\"\n    Returns a schema that matches a bytes value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.bytes_schema(max_length=10, min_length=2)\n    v = SchemaValidator(schema)\n    assert v.validate_python(b'hello') == b'hello'\n    ```\n\n    Args:\n        max_length: The value must be at most this length\n        min_length: The value must be at least this length\n        strict: Whether the value should be a bytes or a value that can be converted to a bytes\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='bytes',\n        max_length=max_length,\n        min_length=min_length,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.date_schema","title":"date_schema","text":"<pre><code>date_schema(*, strict: bool | None = None, le: date | None = None, ge: date | None = None, lt: date | None = None, gt: date | None = None, now_op: Literal['past', 'future'] | None = None, now_utc_offset: int | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; DateSchema\n</code></pre> <p>Returns a schema that matches a date value, e.g.:</p> <pre><code>from datetime import date\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))\nv = SchemaValidator(schema)\nassert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether the value should be a date or a value that can be converted to a date</p> <code>None</code> <code>le</code> <code>date | None</code> <p>The value must be less than or equal to this date</p> <code>None</code> <code>ge</code> <code>date | None</code> <p>The value must be greater than or equal to this date</p> <code>None</code> <code>lt</code> <code>date | None</code> <p>The value must be strictly less than this date</p> <code>None</code> <code>gt</code> <code>date | None</code> <p>The value must be strictly greater than this date</p> <code>None</code> <code>now_op</code> <code>Literal['past', 'future'] | None</code> <p>The value must be in the past or future relative to the current date</p> <code>None</code> <code>now_utc_offset</code> <code>int | None</code> <p>The value must be in the past or future relative to the current date with this utc offset</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def date_schema(\n    *,\n    strict: bool | None = None,\n    le: date | None = None,\n    ge: date | None = None,\n    lt: date | None = None,\n    gt: date | None = None,\n    now_op: Literal['past', 'future'] | None = None,\n    now_utc_offset: int | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; DateSchema:\n    \"\"\"\n    Returns a schema that matches a date value, e.g.:\n\n    ```py\n    from datetime import date\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))\n    v = SchemaValidator(schema)\n    assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)\n    ```\n\n    Args:\n        strict: Whether the value should be a date or a value that can be converted to a date\n        le: The value must be less than or equal to this date\n        ge: The value must be greater than or equal to this date\n        lt: The value must be strictly less than this date\n        gt: The value must be strictly greater than this date\n        now_op: The value must be in the past or future relative to the current date\n        now_utc_offset: The value must be in the past or future relative to the current date with this utc offset\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='date',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        now_op=now_op,\n        now_utc_offset=now_utc_offset,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.time_schema","title":"time_schema","text":"<pre><code>time_schema(*, strict: bool | None = None, le: time | None = None, ge: time | None = None, lt: time | None = None, gt: time | None = None, tz_constraint: Literal['aware', 'naive'] | int | None = None, microseconds_precision: Literal['truncate', 'error'] = 'truncate', ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; TimeSchema\n</code></pre> <p>Returns a schema that matches a time value, e.g.:</p> <pre><code>from datetime import time\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))\nv = SchemaValidator(schema)\nassert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether the value should be a time or a value that can be converted to a time</p> <code>None</code> <code>le</code> <code>time | None</code> <p>The value must be less than or equal to this time</p> <code>None</code> <code>ge</code> <code>time | None</code> <p>The value must be greater than or equal to this time</p> <code>None</code> <code>lt</code> <code>time | None</code> <p>The value must be strictly less than this time</p> <code>None</code> <code>gt</code> <code>time | None</code> <p>The value must be strictly greater than this time</p> <code>None</code> <code>tz_constraint</code> <code>Literal['aware', 'naive'] | int | None</code> <p>The value must be timezone aware or naive, or an int to indicate required tz offset</p> <code>None</code> <code>microseconds_precision</code> <code>Literal['truncate', 'error']</code> <p>The behavior when seconds have more than 6 digits or microseconds is too large</p> <code>'truncate'</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def time_schema(\n    *,\n    strict: bool | None = None,\n    le: time | None = None,\n    ge: time | None = None,\n    lt: time | None = None,\n    gt: time | None = None,\n    tz_constraint: Literal['aware', 'naive'] | int | None = None,\n    microseconds_precision: Literal['truncate', 'error'] = 'truncate',\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; TimeSchema:\n    \"\"\"\n    Returns a schema that matches a time value, e.g.:\n\n    ```py\n    from datetime import time\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))\n    v = SchemaValidator(schema)\n    assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)\n    ```\n\n    Args:\n        strict: Whether the value should be a time or a value that can be converted to a time\n        le: The value must be less than or equal to this time\n        ge: The value must be greater than or equal to this time\n        lt: The value must be strictly less than this time\n        gt: The value must be strictly greater than this time\n        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset\n        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='time',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        tz_constraint=tz_constraint,\n        microseconds_precision=microseconds_precision,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.datetime_schema","title":"datetime_schema","text":"<pre><code>datetime_schema(*, strict: bool | None = None, le: datetime | None = None, ge: datetime | None = None, lt: datetime | None = None, gt: datetime | None = None, now_op: Literal['past', 'future'] | None = None, tz_constraint: Literal['aware', 'naive'] | int | None = None, now_utc_offset: int | None = None, microseconds_precision: Literal['truncate', 'error'] = 'truncate', ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; DatetimeSchema\n</code></pre> <p>Returns a schema that matches a datetime value, e.g.:</p> <pre><code>from datetime import datetime\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.datetime_schema()\nv = SchemaValidator(schema)\nnow = datetime.now()\nassert v.validate_python(str(now)) == now\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether the value should be a datetime or a value that can be converted to a datetime</p> <code>None</code> <code>le</code> <code>datetime | None</code> <p>The value must be less than or equal to this datetime</p> <code>None</code> <code>ge</code> <code>datetime | None</code> <p>The value must be greater than or equal to this datetime</p> <code>None</code> <code>lt</code> <code>datetime | None</code> <p>The value must be strictly less than this datetime</p> <code>None</code> <code>gt</code> <code>datetime | None</code> <p>The value must be strictly greater than this datetime</p> <code>None</code> <code>now_op</code> <code>Literal['past', 'future'] | None</code> <p>The value must be in the past or future relative to the current datetime</p> <code>None</code> <code>tz_constraint</code> <code>Literal['aware', 'naive'] | int | None</code> <p>The value must be timezone aware or naive, or an int to indicate required tz offset TODO: use of a tzinfo where offset changes based on the datetime is not yet supported</p> <code>None</code> <code>now_utc_offset</code> <code>int | None</code> <p>The value must be in the past or future relative to the current datetime with this utc offset</p> <code>None</code> <code>microseconds_precision</code> <code>Literal['truncate', 'error']</code> <p>The behavior when seconds have more than 6 digits or microseconds is too large</p> <code>'truncate'</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def datetime_schema(\n    *,\n    strict: bool | None = None,\n    le: datetime | None = None,\n    ge: datetime | None = None,\n    lt: datetime | None = None,\n    gt: datetime | None = None,\n    now_op: Literal['past', 'future'] | None = None,\n    tz_constraint: Literal['aware', 'naive'] | int | None = None,\n    now_utc_offset: int | None = None,\n    microseconds_precision: Literal['truncate', 'error'] = 'truncate',\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; DatetimeSchema:\n    \"\"\"\n    Returns a schema that matches a datetime value, e.g.:\n\n    ```py\n    from datetime import datetime\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.datetime_schema()\n    v = SchemaValidator(schema)\n    now = datetime.now()\n    assert v.validate_python(str(now)) == now\n    ```\n\n    Args:\n        strict: Whether the value should be a datetime or a value that can be converted to a datetime\n        le: The value must be less than or equal to this datetime\n        ge: The value must be greater than or equal to this datetime\n        lt: The value must be strictly less than this datetime\n        gt: The value must be strictly greater than this datetime\n        now_op: The value must be in the past or future relative to the current datetime\n        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset\n            TODO: use of a tzinfo where offset changes based on the datetime is not yet supported\n        now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset\n        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='datetime',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        now_op=now_op,\n        tz_constraint=tz_constraint,\n        now_utc_offset=now_utc_offset,\n        microseconds_precision=microseconds_precision,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.timedelta_schema","title":"timedelta_schema","text":"<pre><code>timedelta_schema(*, strict: bool | None = None, le: timedelta | None = None, ge: timedelta | None = None, lt: timedelta | None = None, gt: timedelta | None = None, microseconds_precision: Literal['truncate', 'error'] = 'truncate', ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; TimedeltaSchema\n</code></pre> <p>Returns a schema that matches a timedelta value, e.g.:</p> <pre><code>from datetime import timedelta\nfrom pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))\nv = SchemaValidator(schema)\nassert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether the value should be a timedelta or a value that can be converted to a timedelta</p> <code>None</code> <code>le</code> <code>timedelta | None</code> <p>The value must be less than or equal to this timedelta</p> <code>None</code> <code>ge</code> <code>timedelta | None</code> <p>The value must be greater than or equal to this timedelta</p> <code>None</code> <code>lt</code> <code>timedelta | None</code> <p>The value must be strictly less than this timedelta</p> <code>None</code> <code>gt</code> <code>timedelta | None</code> <p>The value must be strictly greater than this timedelta</p> <code>None</code> <code>microseconds_precision</code> <code>Literal['truncate', 'error']</code> <p>The behavior when seconds have more than 6 digits or microseconds is too large</p> <code>'truncate'</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def timedelta_schema(\n    *,\n    strict: bool | None = None,\n    le: timedelta | None = None,\n    ge: timedelta | None = None,\n    lt: timedelta | None = None,\n    gt: timedelta | None = None,\n    microseconds_precision: Literal['truncate', 'error'] = 'truncate',\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; TimedeltaSchema:\n    \"\"\"\n    Returns a schema that matches a timedelta value, e.g.:\n\n    ```py\n    from datetime import timedelta\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))\n    v = SchemaValidator(schema)\n    assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)\n    ```\n\n    Args:\n        strict: Whether the value should be a timedelta or a value that can be converted to a timedelta\n        le: The value must be less than or equal to this timedelta\n        ge: The value must be greater than or equal to this timedelta\n        lt: The value must be strictly less than this timedelta\n        gt: The value must be strictly greater than this timedelta\n        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='timedelta',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        microseconds_precision=microseconds_precision,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.literal_schema","title":"literal_schema","text":"<pre><code>literal_schema(expected: list[Any], *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; LiteralSchema\n</code></pre> <p>Returns a schema that matches a literal value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.literal_schema(['hello', 'world'])\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>expected</code> <code>list[Any]</code> <p>The value must be one of these values</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def literal_schema(\n    expected: list[Any],\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; LiteralSchema:\n    \"\"\"\n    Returns a schema that matches a literal value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.literal_schema(['hello', 'world'])\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello'\n    ```\n\n    Args:\n        expected: The value must be one of these values\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='literal', expected=expected, ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.enum_schema","title":"enum_schema","text":"<pre><code>enum_schema(cls: Any, members: list[Any], *, sub_type: Literal['str', 'int', 'float'] | None = None, missing: Callable[[Any], Any] | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; EnumSchema\n</code></pre> <p>Returns a schema that matches an enum value, e.g.:</p> <pre><code>from enum import Enum\nfrom pydantic_core import SchemaValidator, core_schema\n\nclass Color(Enum):\n    RED = 1\n    GREEN = 2\n    BLUE = 3\n\nschema = core_schema.enum_schema(Color, list(Color.__members__.values()))\nv = SchemaValidator(schema)\nassert v.validate_python(2) is Color.GREEN\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>Any</code> <p>The enum class</p> \u5fc5\u9700 <code>members</code> <code>list[Any]</code> <p>The members of the enum, generally <code>list(MyEnum.__members__.values())</code></p> \u5fc5\u9700 <code>sub_type</code> <code>Literal['str', 'int', 'float'] | None</code> <p>The type of the enum, either 'str' or 'int' or None for plain enums</p> <code>None</code> <code>missing</code> <code>Callable[[Any], Any] | None</code> <p>A function to use when the value is not found in the enum, from <code>_missing_</code></p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether to use strict mode, defaults to False</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def enum_schema(\n    cls: Any,\n    members: list[Any],\n    *,\n    sub_type: Literal['str', 'int', 'float'] | None = None,\n    missing: Callable[[Any], Any] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; EnumSchema:\n    \"\"\"\n    Returns a schema that matches an enum value, e.g.:\n\n    ```py\n    from enum import Enum\n    from pydantic_core import SchemaValidator, core_schema\n\n    class Color(Enum):\n        RED = 1\n        GREEN = 2\n        BLUE = 3\n\n    schema = core_schema.enum_schema(Color, list(Color.__members__.values()))\n    v = SchemaValidator(schema)\n    assert v.validate_python(2) is Color.GREEN\n    ```\n\n    Args:\n        cls: The enum class\n        members: The members of the enum, generally `list(MyEnum.__members__.values())`\n        sub_type: The type of the enum, either 'str' or 'int' or None for plain enums\n        missing: A function to use when the value is not found in the enum, from `_missing_`\n        strict: Whether to use strict mode, defaults to False\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='enum',\n        cls=cls,\n        members=members,\n        sub_type=sub_type,\n        missing=missing,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.missing_sentinel_schema","title":"missing_sentinel_schema","text":"<pre><code>missing_sentinel_schema(metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; MissingSentinelSchema\n</code></pre> <p>Returns a schema for the <code>MISSING</code> sentinel.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def missing_sentinel_schema(\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; MissingSentinelSchema:\n    \"\"\"Returns a schema for the `MISSING` sentinel.\"\"\"\n\n    return _dict_not_none(\n        type='missing-sentinel',\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.is_instance_schema","title":"is_instance_schema","text":"<pre><code>is_instance_schema(cls: Any, *, cls_repr: str | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; IsInstanceSchema\n</code></pre> <p>Returns a schema that checks if a value is an instance of a class, equivalent to python's <code>isinstance</code> method, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nclass A:\n    pass\n\nschema = core_schema.is_instance_schema(cls=A)\nv = SchemaValidator(schema)\nv.validate_python(A())\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>Any</code> <p>The value must be an instance of this class</p> \u5fc5\u9700 <code>cls_repr</code> <code>str | None</code> <p>If provided this string is used in the validator name instead of <code>repr(cls)</code></p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def is_instance_schema(\n    cls: Any,\n    *,\n    cls_repr: str | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; IsInstanceSchema:\n    \"\"\"\n    Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    class A:\n        pass\n\n    schema = core_schema.is_instance_schema(cls=A)\n    v = SchemaValidator(schema)\n    v.validate_python(A())\n    ```\n\n    Args:\n        cls: The value must be an instance of this class\n        cls_repr: If provided this string is used in the validator name instead of `repr(cls)`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='is-instance', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.is_subclass_schema","title":"is_subclass_schema","text":"<pre><code>is_subclass_schema(cls: type[Any], *, cls_repr: str | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; IsInstanceSchema\n</code></pre> <p>Returns a schema that checks if a value is a subtype of a class, equivalent to python's <code>issubclass</code> method, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nclass A:\n    pass\n\nclass B(A):\n    pass\n\nschema = core_schema.is_subclass_schema(cls=A)\nv = SchemaValidator(schema)\nv.validate_python(B)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>type[Any]</code> <p>The value must be a subclass of this class</p> \u5fc5\u9700 <code>cls_repr</code> <code>str | None</code> <p>If provided this string is used in the validator name instead of <code>repr(cls)</code></p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def is_subclass_schema(\n    cls: type[Any],\n    *,\n    cls_repr: str | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; IsInstanceSchema:\n    \"\"\"\n    Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    class A:\n        pass\n\n    class B(A):\n        pass\n\n    schema = core_schema.is_subclass_schema(cls=A)\n    v = SchemaValidator(schema)\n    v.validate_python(B)\n    ```\n\n    Args:\n        cls: The value must be a subclass of this class\n        cls_repr: If provided this string is used in the validator name instead of `repr(cls)`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='is-subclass', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.callable_schema","title":"callable_schema","text":"<pre><code>callable_schema(*, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; CallableSchema\n</code></pre> <p>Returns a schema that checks if a value is callable, equivalent to python's <code>callable</code> method, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.callable_schema()\nv = SchemaValidator(schema)\nv.validate_python(min)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def callable_schema(\n    *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None\n) -&gt; CallableSchema:\n    \"\"\"\n    Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.callable_schema()\n    v = SchemaValidator(schema)\n    v.validate_python(min)\n    ```\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='callable', ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.list_schema","title":"list_schema","text":"<pre><code>list_schema(items_schema: CoreSchema | None = None, *, min_length: int | None = None, max_length: int | None = None, fail_fast: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: IncExSeqOrElseSerSchema | None = None) -&gt; ListSchema\n</code></pre> <p>Returns a schema that matches a list value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)\nv = SchemaValidator(schema)\nassert v.validate_python(['4']) == [4]\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>CoreSchema | None</code> <p>The value must be a list of items that match this schema</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a list with at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a list with at most this many items</p> <code>None</code> <code>fail_fast</code> <code>bool | None</code> <p>Stop validation on the first error</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>The value must be a list with exactly this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>IncExSeqOrElseSerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def list_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -&gt; ListSchema:\n    \"\"\"\n    Returns a schema that matches a list value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)\n    v = SchemaValidator(schema)\n    assert v.validate_python(['4']) == [4]\n    ```\n\n    Args:\n        items_schema: The value must be a list of items that match this schema\n        min_length: The value must be a list with at least this many items\n        max_length: The value must be a list with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a list with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='list',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.tuple_positional_schema","title":"tuple_positional_schema","text":"<pre><code>tuple_positional_schema(items_schema: list[CoreSchema], *, extras_schema: CoreSchema | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: IncExSeqOrElseSerSchema | None = None) -&gt; TupleSchema\n</code></pre> <p>Returns a schema that matches a tuple of schemas, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.tuple_positional_schema(\n    [core_schema.int_schema(), core_schema.str_schema()]\n)\nv = SchemaValidator(schema)\nassert v.validate_python((1, 'hello')) == (1, 'hello')\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>list[CoreSchema]</code> <p>The value must be a tuple with items that match these schemas</p> \u5fc5\u9700 <code>extras_schema</code> <code>CoreSchema | None</code> <p>The value must be a tuple with items that match this schema This was inspired by JSON schema's <code>prefixItems</code> and <code>items</code> fields. In python's <code>typing.Tuple</code>, you can't specify a type for \"extra\" items -- they must all be the same type if the length is variable. So this field won't be set from a <code>typing.Tuple</code> annotation on a pydantic model.</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>The value must be a tuple with exactly this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>IncExSeqOrElseSerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def tuple_positional_schema(\n    items_schema: list[CoreSchema],\n    *,\n    extras_schema: CoreSchema | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -&gt; TupleSchema:\n    \"\"\"\n    Returns a schema that matches a tuple of schemas, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.tuple_positional_schema(\n        [core_schema.int_schema(), core_schema.str_schema()]\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python((1, 'hello')) == (1, 'hello')\n    ```\n\n    Args:\n        items_schema: The value must be a tuple with items that match these schemas\n        extras_schema: The value must be a tuple with items that match this schema\n            This was inspired by JSON schema's `prefixItems` and `items` fields.\n            In python's `typing.Tuple`, you can't specify a type for \"extra\" items -- they must all be the same type\n            if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model.\n        strict: The value must be a tuple with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    if extras_schema is not None:\n        variadic_item_index = len(items_schema)\n        items_schema = items_schema + [extras_schema]\n    else:\n        variadic_item_index = None\n    return tuple_schema(\n        items_schema=items_schema,\n        variadic_item_index=variadic_item_index,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.tuple_variable_schema","title":"tuple_variable_schema","text":"<pre><code>tuple_variable_schema(items_schema: CoreSchema | None = None, *, min_length: int | None = None, max_length: int | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: IncExSeqOrElseSerSchema | None = None) -&gt; TupleSchema\n</code></pre> <p>Returns a schema that matches a tuple of a given schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.tuple_variable_schema(\n    items_schema=core_schema.int_schema(), min_length=0, max_length=10\n)\nv = SchemaValidator(schema)\nassert v.validate_python(('1', 2, 3)) == (1, 2, 3)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>CoreSchema | None</code> <p>The value must be a tuple with items that match this schema</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a tuple with at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a tuple with at most this many items</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>The value must be a tuple with exactly this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>Optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>IncExSeqOrElseSerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def tuple_variable_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -&gt; TupleSchema:\n    \"\"\"\n    Returns a schema that matches a tuple of a given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.tuple_variable_schema(\n        items_schema=core_schema.int_schema(), min_length=0, max_length=10\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python(('1', 2, 3)) == (1, 2, 3)\n    ```\n\n    Args:\n        items_schema: The value must be a tuple with items that match this schema\n        min_length: The value must be a tuple with at least this many items\n        max_length: The value must be a tuple with at most this many items\n        strict: The value must be a tuple with exactly this many items\n        ref: Optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return tuple_schema(\n        items_schema=[items_schema or any_schema()],\n        variadic_item_index=0,\n        min_length=min_length,\n        max_length=max_length,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.tuple_schema","title":"tuple_schema","text":"<pre><code>tuple_schema(items_schema: list[CoreSchema], *, variadic_item_index: int | None = None, min_length: int | None = None, max_length: int | None = None, fail_fast: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: IncExSeqOrElseSerSchema | None = None) -&gt; TupleSchema\n</code></pre> <p>Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.tuple_schema(\n    [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],\n    variadic_item_index=1,\n)\nv = SchemaValidator(schema)\nassert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>list[CoreSchema]</code> <p>The value must be a tuple with items that match these schemas</p> \u5fc5\u9700 <code>variadic_item_index</code> <code>int | None</code> <p>The index of the schema in <code>items_schema</code> to be treated as variadic (following PEP 646)</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a tuple with at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a tuple with at most this many items</p> <code>None</code> <code>fail_fast</code> <code>bool | None</code> <p>Stop validation on the first error</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>The value must be a tuple with exactly this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>Optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>IncExSeqOrElseSerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def tuple_schema(\n    items_schema: list[CoreSchema],\n    *,\n    variadic_item_index: int | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -&gt; TupleSchema:\n    \"\"\"\n    Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.tuple_schema(\n        [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],\n        variadic_item_index=1,\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)\n    ```\n\n    Args:\n        items_schema: The value must be a tuple with items that match these schemas\n        variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646)\n        min_length: The value must be a tuple with at least this many items\n        max_length: The value must be a tuple with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a tuple with exactly this many items\n        ref: Optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='tuple',\n        items_schema=items_schema,\n        variadic_item_index=variadic_item_index,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.set_schema","title":"set_schema","text":"<pre><code>set_schema(items_schema: CoreSchema | None = None, *, min_length: int | None = None, max_length: int | None = None, fail_fast: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; SetSchema\n</code></pre> <p>Returns a schema that matches a set of a given schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.set_schema(\n    items_schema=core_schema.int_schema(), min_length=0, max_length=10\n)\nv = SchemaValidator(schema)\nassert v.validate_python({1, '2', 3}) == {1, 2, 3}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>CoreSchema | None</code> <p>The value must be a set with items that match this schema</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a set with at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a set with at most this many items</p> <code>None</code> <code>fail_fast</code> <code>bool | None</code> <p>Stop validation on the first error</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>The value must be a set with exactly this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def set_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; SetSchema:\n    \"\"\"\n    Returns a schema that matches a set of a given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.set_schema(\n        items_schema=core_schema.int_schema(), min_length=0, max_length=10\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python({1, '2', 3}) == {1, 2, 3}\n    ```\n\n    Args:\n        items_schema: The value must be a set with items that match this schema\n        min_length: The value must be a set with at least this many items\n        max_length: The value must be a set with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a set with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='set',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.frozenset_schema","title":"frozenset_schema","text":"<pre><code>frozenset_schema(items_schema: CoreSchema | None = None, *, min_length: int | None = None, max_length: int | None = None, fail_fast: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; FrozenSetSchema\n</code></pre> <p>Returns a schema that matches a frozenset of a given schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.frozenset_schema(\n    items_schema=core_schema.int_schema(), min_length=0, max_length=10\n)\nv = SchemaValidator(schema)\nassert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>CoreSchema | None</code> <p>The value must be a frozenset with items that match this schema</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a frozenset with at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a frozenset with at most this many items</p> <code>None</code> <code>fail_fast</code> <code>bool | None</code> <p>Stop validation on the first error</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>The value must be a frozenset with exactly this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def frozenset_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; FrozenSetSchema:\n    \"\"\"\n    Returns a schema that matches a frozenset of a given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.frozenset_schema(\n        items_schema=core_schema.int_schema(), min_length=0, max_length=10\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})\n    ```\n\n    Args:\n        items_schema: The value must be a frozenset with items that match this schema\n        min_length: The value must be a frozenset with at least this many items\n        max_length: The value must be a frozenset with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a frozenset with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='frozenset',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.generator_schema","title":"generator_schema","text":"<pre><code>generator_schema(items_schema: CoreSchema | None = None, *, min_length: int | None = None, max_length: int | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: IncExSeqOrElseSerSchema | None = None) -&gt; GeneratorSchema\n</code></pre> <p>Returns a schema that matches a generator value, e.g.:</p> <pre><code>from typing import Iterator\nfrom pydantic_core import SchemaValidator, core_schema\n\ndef gen() -&gt; Iterator[int]:\n    yield 1\n\nschema = core_schema.generator_schema(items_schema=core_schema.int_schema())\nv = SchemaValidator(schema)\nv.validate_python(gen())\n</code></pre> <p>Unlike other types, validated generators do not raise ValidationErrors eagerly, but instead will raise a ValidationError when a violating value is actually read from the generator. This is to ensure that \"validated\" generators retain the benefit of lazy evaluation.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>items_schema</code> <code>CoreSchema | None</code> <p>The value must be a generator with items that match this schema</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a generator that yields at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a generator that yields at most this many items</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>IncExSeqOrElseSerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def generator_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -&gt; GeneratorSchema:\n    \"\"\"\n    Returns a schema that matches a generator value, e.g.:\n\n    ```py\n    from typing import Iterator\n    from pydantic_core import SchemaValidator, core_schema\n\n    def gen() -&gt; Iterator[int]:\n        yield 1\n\n    schema = core_schema.generator_schema(items_schema=core_schema.int_schema())\n    v = SchemaValidator(schema)\n    v.validate_python(gen())\n    ```\n\n    Unlike other types, validated generators do not raise ValidationErrors eagerly,\n    but instead will raise a ValidationError when a violating value is actually read from the generator.\n    This is to ensure that \"validated\" generators retain the benefit of lazy evaluation.\n\n    Args:\n        items_schema: The value must be a generator with items that match this schema\n        min_length: The value must be a generator that yields at least this many items\n        max_length: The value must be a generator that yields at most this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='generator',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.dict_schema","title":"dict_schema","text":"<pre><code>dict_schema(keys_schema: CoreSchema | None = None, values_schema: CoreSchema | None = None, *, min_length: int | None = None, max_length: int | None = None, fail_fast: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; DictSchema\n</code></pre> <p>Returns a schema that matches a dict value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.dict_schema(\n    keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()\n)\nv = SchemaValidator(schema)\nassert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>keys_schema</code> <code>CoreSchema | None</code> <p>The value must be a dict with keys that match this schema</p> <code>None</code> <code>values_schema</code> <code>CoreSchema | None</code> <p>The value must be a dict with values that match this schema</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The value must be a dict with at least this many items</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The value must be a dict with at most this many items</p> <code>None</code> <code>fail_fast</code> <code>bool | None</code> <p>Stop validation on the first error</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the keys and values should be validated with strict mode</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def dict_schema(\n    keys_schema: CoreSchema | None = None,\n    values_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; DictSchema:\n    \"\"\"\n    Returns a schema that matches a dict value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.dict_schema(\n        keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}\n    ```\n\n    Args:\n        keys_schema: The value must be a dict with keys that match this schema\n        values_schema: The value must be a dict with values that match this schema\n        min_length: The value must be a dict with at least this many items\n        max_length: The value must be a dict with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: Whether the keys and values should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='dict',\n        keys_schema=keys_schema,\n        values_schema=values_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.no_info_before_validator_function","title":"no_info_before_validator_function","text":"<pre><code>no_info_before_validator_function(function: NoInfoValidatorFunction, schema: CoreSchema, *, ref: str | None = None, json_schema_input_schema: CoreSchema | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; BeforeValidatorFunctionSchema\n</code></pre> <p>Returns a schema that calls a validator function before validating, no <code>info</code> argument is provided, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: bytes) -&gt; str:\n    return v.decode() + 'world'\n\nfunc_schema = core_schema.no_info_before_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>NoInfoValidatorFunction</code> <p>The validator function to call</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to validate the output of the validator function</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def no_info_before_validator_function(\n    function: NoInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; BeforeValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: bytes) -&gt; str:\n        return v.decode() + 'world'\n\n    func_schema = core_schema.no_info_before_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call\n        schema: The schema to validate the output of the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-before',\n        function={'type': 'no-info', 'function': function},\n        schema=schema,\n        ref=ref,\n        json_schema_input_schema=json_schema_input_schema,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.with_info_before_validator_function","title":"with_info_before_validator_function","text":"<pre><code>with_info_before_validator_function(function: WithInfoValidatorFunction, schema: CoreSchema, *, field_name: str | None = None, ref: str | None = None, json_schema_input_schema: CoreSchema | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; BeforeValidatorFunctionSchema\n</code></pre> <p>Returns a schema that calls a validator function before validation, the function is called with an <code>info</code> argument, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: bytes, info: core_schema.ValidationInfo) -&gt; str:\n    assert info.data is not None\n    assert info.field_name is not None\n    return v.decode() + 'world'\n\nfunc_schema = core_schema.with_info_before_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>WithInfoValidatorFunction</code> <p>The validator function to call</p> \u5fc5\u9700 <code>field_name</code> <code>str | None</code> <p>The name of the field this validator is applied to, if any (deprecated)</p> <code>None</code> <code>schema</code> <code>CoreSchema</code> <p>The schema to validate the output of the validator function</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def with_info_before_validator_function(\n    function: WithInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; BeforeValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function before validation, the function is called with\n    an `info` argument, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: bytes, info: core_schema.ValidationInfo) -&gt; str:\n        assert info.data is not None\n        assert info.field_name is not None\n        return v.decode() + 'world'\n\n    func_schema = core_schema.with_info_before_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call\n        field_name: The name of the field this validator is applied to, if any (deprecated)\n        schema: The schema to validate the output of the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    if field_name is not None:\n        warnings.warn(\n            'The `field_name` argument on `with_info_before_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    return _dict_not_none(\n        type='function-before',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        schema=schema,\n        ref=ref,\n        json_schema_input_schema=json_schema_input_schema,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.no_info_after_validator_function","title":"no_info_after_validator_function","text":"<pre><code>no_info_after_validator_function(function: NoInfoValidatorFunction, schema: CoreSchema, *, ref: str | None = None, json_schema_input_schema: CoreSchema | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; AfterValidatorFunctionSchema\n</code></pre> <p>Returns a schema that calls a validator function after validating, no <code>info</code> argument is provided, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str) -&gt; str:\n    return v + 'world'\n\nfunc_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>NoInfoValidatorFunction</code> <p>The validator function to call after the schema is validated</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to validate before the validator function</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def no_info_after_validator_function(\n    function: NoInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; AfterValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str) -&gt; str:\n        return v + 'world'\n\n    func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call after the schema is validated\n        schema: The schema to validate before the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-after',\n        function={'type': 'no-info', 'function': function},\n        schema=schema,\n        ref=ref,\n        json_schema_input_schema=json_schema_input_schema,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.with_info_after_validator_function","title":"with_info_after_validator_function","text":"<pre><code>with_info_after_validator_function(function: WithInfoValidatorFunction, schema: CoreSchema, *, field_name: str | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; AfterValidatorFunctionSchema\n</code></pre> <p>Returns a schema that calls a validator function after validation, the function is called with an <code>info</code> argument, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n    assert info.data is not None\n    assert info.field_name is not None\n    return v + 'world'\n\nfunc_schema = core_schema.with_info_after_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nschema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\nv = SchemaValidator(schema)\nassert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>WithInfoValidatorFunction</code> <p>The validator function to call after the schema is validated</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to validate before the validator function</p> \u5fc5\u9700 <code>field_name</code> <code>str | None</code> <p>The name of the field this validator is applied to, if any (deprecated)</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def with_info_after_validator_function(\n    function: WithInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; AfterValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function after validation, the function is called with\n    an `info` argument, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n        assert info.data is not None\n        assert info.field_name is not None\n        return v + 'world'\n\n    func_schema = core_schema.with_info_after_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call after the schema is validated\n        schema: The schema to validate before the validator function\n        field_name: The name of the field this validator is applied to, if any (deprecated)\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    if field_name is not None:\n        warnings.warn(\n            'The `field_name` argument on `with_info_after_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    return _dict_not_none(\n        type='function-after',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.no_info_wrap_validator_function","title":"no_info_wrap_validator_function","text":"<pre><code>no_info_wrap_validator_function(function: NoInfoWrapValidatorFunction, schema: CoreSchema, *, ref: str | None = None, json_schema_input_schema: CoreSchema | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; WrapValidatorFunctionSchema\n</code></pre> <p>Returns a schema which calls a function with a <code>validator</code> callable argument which can optionally be used to call inner validation with the function logic, this is much like the \"onion\" implementation of middleware in many popular web frameworks, no <code>info</code> argument is passed, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(\n    v: str,\n    validator: core_schema.ValidatorFunctionWrapHandler,\n) -&gt; str:\n    return validator(input_value=v) + 'world'\n\nschema = core_schema.no_info_wrap_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>NoInfoWrapValidatorFunction</code> <p>The validator function to call</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to validate the output of the validator function</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def no_info_wrap_validator_function(\n    function: NoInfoWrapValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; WrapValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema which calls a function with a `validator` callable argument which can\n    optionally be used to call inner validation with the function logic, this is much like the\n    \"onion\" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(\n        v: str,\n        validator: core_schema.ValidatorFunctionWrapHandler,\n    ) -&gt; str:\n        return validator(input_value=v) + 'world'\n\n    schema = core_schema.no_info_wrap_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        schema: The schema to validate the output of the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-wrap',\n        function={'type': 'no-info', 'function': function},\n        schema=schema,\n        json_schema_input_schema=json_schema_input_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.with_info_wrap_validator_function","title":"with_info_wrap_validator_function","text":"<pre><code>with_info_wrap_validator_function(function: WithInfoWrapValidatorFunction, schema: CoreSchema, *, field_name: str | None = None, json_schema_input_schema: CoreSchema | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; WrapValidatorFunctionSchema\n</code></pre> <p>Returns a schema which calls a function with a <code>validator</code> callable argument which can optionally be used to call inner validation with the function logic, this is much like the \"onion\" implementation of middleware in many popular web frameworks, an <code>info</code> argument is also passed, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(\n    v: str,\n    validator: core_schema.ValidatorFunctionWrapHandler,\n    info: core_schema.ValidationInfo,\n) -&gt; str:\n    return validator(input_value=v) + 'world'\n\nschema = core_schema.with_info_wrap_validator_function(\n    function=fn, schema=core_schema.str_schema()\n)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>WithInfoWrapValidatorFunction</code> <p>The validator function to call</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to validate the output of the validator function</p> \u5fc5\u9700 <code>field_name</code> <code>str | None</code> <p>The name of the field this validator is applied to, if any (deprecated)</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def with_info_wrap_validator_function(\n    function: WithInfoWrapValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; WrapValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema which calls a function with a `validator` callable argument which can\n    optionally be used to call inner validation with the function logic, this is much like the\n    \"onion\" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(\n        v: str,\n        validator: core_schema.ValidatorFunctionWrapHandler,\n        info: core_schema.ValidationInfo,\n    ) -&gt; str:\n        return validator(input_value=v) + 'world'\n\n    schema = core_schema.with_info_wrap_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        schema: The schema to validate the output of the validator function\n        field_name: The name of the field this validator is applied to, if any (deprecated)\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    if field_name is not None:\n        warnings.warn(\n            'The `field_name` argument on `with_info_wrap_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    return _dict_not_none(\n        type='function-wrap',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        schema=schema,\n        json_schema_input_schema=json_schema_input_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.no_info_plain_validator_function","title":"no_info_plain_validator_function","text":"<pre><code>no_info_plain_validator_function(function: NoInfoValidatorFunction, *, ref: str | None = None, json_schema_input_schema: CoreSchema | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; PlainValidatorFunctionSchema\n</code></pre> <p>Returns a schema that uses the provided function for validation, no <code>info</code> argument is passed, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str) -&gt; str:\n    assert 'hello' in v\n    return v + 'world'\n\nschema = core_schema.no_info_plain_validator_function(function=fn)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>NoInfoValidatorFunction</code> <p>The validator function to call</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def no_info_plain_validator_function(\n    function: NoInfoValidatorFunction,\n    *,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str) -&gt; str:\n        assert 'hello' in v\n        return v + 'world'\n\n    schema = core_schema.no_info_plain_validator_function(function=fn)\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-plain',\n        function={'type': 'no-info', 'function': function},\n        ref=ref,\n        json_schema_input_schema=json_schema_input_schema,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.with_info_plain_validator_function","title":"with_info_plain_validator_function","text":"<pre><code>with_info_plain_validator_function(function: WithInfoValidatorFunction, *, field_name: str | None = None, ref: str | None = None, json_schema_input_schema: CoreSchema | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; PlainValidatorFunctionSchema\n</code></pre> <p>Returns a schema that uses the provided function for validation, an <code>info</code> argument is passed, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n    assert 'hello' in v\n    return v + 'world'\n\nschema = core_schema.with_info_plain_validator_function(function=fn)\nv = SchemaValidator(schema)\nassert v.validate_python('hello ') == 'hello world'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>function</code> <code>WithInfoValidatorFunction</code> <p>The validator function to call</p> \u5fc5\u9700 <code>field_name</code> <code>str | None</code> <p>The name of the field this validator is applied to, if any (deprecated)</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>json_schema_input_schema</code> <code>CoreSchema | None</code> <p>The core schema to be used to generate the corresponding JSON Schema input type</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def with_info_plain_validator_function(\n    function: WithInfoValidatorFunction,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    json_schema_input_schema: CoreSchema | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; PlainValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n        assert 'hello' in v\n        return v + 'world'\n\n    schema = core_schema.with_info_plain_validator_function(function=fn)\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        field_name: The name of the field this validator is applied to, if any (deprecated)\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        json_schema_input_schema: The core schema to be used to generate the corresponding JSON Schema input type\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    if field_name is not None:\n        warnings.warn(\n            'The `field_name` argument on `with_info_plain_validator_function` is deprecated, it will be passed to the function through `ValidationState` instead.',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n\n    return _dict_not_none(\n        type='function-plain',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        ref=ref,\n        json_schema_input_schema=json_schema_input_schema,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.with_default_schema","title":"with_default_schema","text":"<pre><code>with_default_schema(schema: CoreSchema, *, default: Any = PydanticUndefined, default_factory: Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None] = None, default_factory_takes_data: bool | None = None, on_error: Literal['raise', 'omit', 'default'] | None = None, validate_default: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; WithDefaultSchema\n</code></pre> <p>Returns a schema that adds a default value to the given schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')\nwrapper_schema = core_schema.typed_dict_schema(\n    {'a': core_schema.typed_dict_field(schema)}\n)\nv = SchemaValidator(wrapper_schema)\nassert v.validate_python({}) == v.validate_python({'a': 'hello'})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The schema to add a default value to</p> \u5fc5\u9700 <code>default</code> <code>Any</code> <p>The default value to use</p> <code>PydanticUndefined</code> <code>default_factory</code> <code>Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None]</code> <p>A callable that returns the default value to use</p> <code>None</code> <code>default_factory_takes_data</code> <code>bool | None</code> <p>Whether the default factory takes a validated data argument</p> <code>None</code> <code>on_error</code> <code>Literal['raise', 'omit', 'default'] | None</code> <p>What to do if the schema validation fails. One of 'raise', 'omit', 'default'</p> <code>None</code> <code>validate_default</code> <code>bool | None</code> <p>Whether the default value should be validated</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the underlying schema should be validated with strict mode</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def with_default_schema(\n    schema: CoreSchema,\n    *,\n    default: Any = PydanticUndefined,\n    default_factory: Union[Callable[[], Any], Callable[[dict[str, Any]], Any], None] = None,\n    default_factory_takes_data: bool | None = None,\n    on_error: Literal['raise', 'omit', 'default'] | None = None,\n    validate_default: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; WithDefaultSchema:\n    \"\"\"\n    Returns a schema that adds a default value to the given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')\n    wrapper_schema = core_schema.typed_dict_schema(\n        {'a': core_schema.typed_dict_field(schema)}\n    )\n    v = SchemaValidator(wrapper_schema)\n    assert v.validate_python({}) == v.validate_python({'a': 'hello'})\n    ```\n\n    Args:\n        schema: The schema to add a default value to\n        default: The default value to use\n        default_factory: A callable that returns the default value to use\n        default_factory_takes_data: Whether the default factory takes a validated data argument\n        on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default'\n        validate_default: Whether the default value should be validated\n        strict: Whether the underlying schema should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    s = _dict_not_none(\n        type='default',\n        schema=schema,\n        default_factory=default_factory,\n        default_factory_takes_data=default_factory_takes_data,\n        on_error=on_error,\n        validate_default=validate_default,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n    if default is not PydanticUndefined:\n        s['default'] = default\n    return s\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.nullable_schema","title":"nullable_schema","text":"<pre><code>nullable_schema(schema: CoreSchema, *, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; NullableSchema\n</code></pre> <p>Returns a schema that matches a nullable value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.nullable_schema(core_schema.str_schema())\nv = SchemaValidator(schema)\nassert v.validate_python(None) is None\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The schema to wrap</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether the underlying schema should be validated with strict mode</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def nullable_schema(\n    schema: CoreSchema,\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; NullableSchema:\n    \"\"\"\n    Returns a schema that matches a nullable value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.nullable_schema(core_schema.str_schema())\n    v = SchemaValidator(schema)\n    assert v.validate_python(None) is None\n    ```\n\n    Args:\n        schema: The schema to wrap\n        strict: Whether the underlying schema should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='nullable', schema=schema, strict=strict, ref=ref, metadata=metadata, serialization=serialization\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.union_schema","title":"union_schema","text":"<pre><code>union_schema(choices: list[CoreSchema | tuple[CoreSchema, str]], *, auto_collapse: bool | None = None, custom_error_type: str | None = None, custom_error_message: str | None = None, custom_error_context: dict[str, str | int] | None = None, mode: Literal['smart', 'left_to_right'] | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; UnionSchema\n</code></pre> <p>Returns a schema that matches a union value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello'\nassert v.validate_python(1) == 1\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>choices</code> <code>list[CoreSchema | tuple[CoreSchema, str]]</code> <p>The schemas to match. If a tuple, the second item is used as the label for the case.</p> \u5fc5\u9700 <code>auto_collapse</code> <code>bool | None</code> <p>whether to automatically collapse unions with one element to the inner validator, default true</p> <code>None</code> <code>custom_error_type</code> <code>str | None</code> <p>The custom error type to use if the validation fails</p> <code>None</code> <code>custom_error_message</code> <code>str | None</code> <p>The custom error message to use if the validation fails</p> <code>None</code> <code>custom_error_context</code> <code>dict[str, str | int] | None</code> <p>The custom error context to use if the validation fails</p> <code>None</code> <code>mode</code> <code>Literal['smart', 'left_to_right'] | None</code> <p>How to select which choice to return * <code>smart</code> (default) will try to return the choice which is the closest match to the input value * <code>left_to_right</code> will return the first choice in <code>choices</code> which succeeds validation</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def union_schema(\n    choices: list[CoreSchema | tuple[CoreSchema, str]],\n    *,\n    auto_collapse: bool | None = None,\n    custom_error_type: str | None = None,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, str | int] | None = None,\n    mode: Literal['smart', 'left_to_right'] | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; UnionSchema:\n    \"\"\"\n    Returns a schema that matches a union value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello'\n    assert v.validate_python(1) == 1\n    ```\n\n    Args:\n        choices: The schemas to match. If a tuple, the second item is used as the label for the case.\n        auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true\n        custom_error_type: The custom error type to use if the validation fails\n        custom_error_message: The custom error message to use if the validation fails\n        custom_error_context: The custom error context to use if the validation fails\n        mode: How to select which choice to return\n            * `smart` (default) will try to return the choice which is the closest match to the input value\n            * `left_to_right` will return the first choice in `choices` which succeeds validation\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='union',\n        choices=choices,\n        auto_collapse=auto_collapse,\n        custom_error_type=custom_error_type,\n        custom_error_message=custom_error_message,\n        custom_error_context=custom_error_context,\n        mode=mode,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.tagged_union_schema","title":"tagged_union_schema","text":"<pre><code>tagged_union_schema(choices: dict[Any, CoreSchema], discriminator: str | list[str | int] | list[list[str | int]] | Callable[[Any], Any], *, custom_error_type: str | None = None, custom_error_message: str | None = None, custom_error_context: dict[str, int | str | float] | None = None, strict: bool | None = None, from_attributes: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; TaggedUnionSchema\n</code></pre> <p>Returns a schema that matches a tagged union value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\napple_schema = core_schema.typed_dict_schema(\n    {\n        'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n        'bar': core_schema.typed_dict_field(core_schema.int_schema()),\n    }\n)\nbanana_schema = core_schema.typed_dict_schema(\n    {\n        'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n        'spam': core_schema.typed_dict_field(\n            core_schema.list_schema(items_schema=core_schema.int_schema())\n        ),\n    }\n)\nschema = core_schema.tagged_union_schema(\n    choices={\n        'apple': apple_schema,\n        'banana': banana_schema,\n    },\n    discriminator='foo',\n)\nv = SchemaValidator(schema)\nassert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}\nassert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {\n    'foo': 'banana',\n    'spam': [1, 2, 3],\n}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>choices</code> <code>dict[Any, CoreSchema]</code> <p>The schemas to match When retrieving a schema from <code>choices</code> using the discriminator value, if the value is a str, it should be fed back into the <code>choices</code> map until a schema is obtained (This approach is to prevent multiple ownership of a single schema in Rust)</p> \u5fc5\u9700 <code>discriminator</code> <code>str | list[str | int] | list[list[str | int]] | Callable[[Any], Any]</code> <p>The discriminator to use to determine the schema to use * If <code>discriminator</code> is a str, it is the name of the attribute to use as the discriminator * If <code>discriminator</code> is a list of int/str, it should be used as a \"path\" to access the discriminator * If <code>discriminator</code> is a list of lists, each inner list is a path, and the first path that exists is used * If <code>discriminator</code> is a callable, it should return the discriminator when called on the value to validate;   the callable can return <code>None</code> to indicate that there is no matching discriminator present on the input</p> \u5fc5\u9700 <code>custom_error_type</code> <code>str | None</code> <p>The custom error type to use if the validation fails</p> <code>None</code> <code>custom_error_message</code> <code>str | None</code> <p>The custom error message to use if the validation fails</p> <code>None</code> <code>custom_error_context</code> <code>dict[str, int | str | float] | None</code> <p>The custom error context to use if the validation fails</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the underlying schemas should be validated with strict mode</p> <code>None</code> <code>from_attributes</code> <code>bool | None</code> <p>Whether to use the attributes of the object to retrieve the discriminator value</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def tagged_union_schema(\n    choices: dict[Any, CoreSchema],\n    discriminator: str | list[str | int] | list[list[str | int]] | Callable[[Any], Any],\n    *,\n    custom_error_type: str | None = None,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, int | str | float] | None = None,\n    strict: bool | None = None,\n    from_attributes: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; TaggedUnionSchema:\n    \"\"\"\n    Returns a schema that matches a tagged union value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    apple_schema = core_schema.typed_dict_schema(\n        {\n            'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n            'bar': core_schema.typed_dict_field(core_schema.int_schema()),\n        }\n    )\n    banana_schema = core_schema.typed_dict_schema(\n        {\n            'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n            'spam': core_schema.typed_dict_field(\n                core_schema.list_schema(items_schema=core_schema.int_schema())\n            ),\n        }\n    )\n    schema = core_schema.tagged_union_schema(\n        choices={\n            'apple': apple_schema,\n            'banana': banana_schema,\n        },\n        discriminator='foo',\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}\n    assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {\n        'foo': 'banana',\n        'spam': [1, 2, 3],\n    }\n    ```\n\n    Args:\n        choices: The schemas to match\n            When retrieving a schema from `choices` using the discriminator value, if the value is a str,\n            it should be fed back into the `choices` map until a schema is obtained\n            (This approach is to prevent multiple ownership of a single schema in Rust)\n        discriminator: The discriminator to use to determine the schema to use\n            * If `discriminator` is a str, it is the name of the attribute to use as the discriminator\n            * If `discriminator` is a list of int/str, it should be used as a \"path\" to access the discriminator\n            * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used\n            * If `discriminator` is a callable, it should return the discriminator when called on the value to validate;\n              the callable can return `None` to indicate that there is no matching discriminator present on the input\n        custom_error_type: The custom error type to use if the validation fails\n        custom_error_message: The custom error message to use if the validation fails\n        custom_error_context: The custom error context to use if the validation fails\n        strict: Whether the underlying schemas should be validated with strict mode\n        from_attributes: Whether to use the attributes of the object to retrieve the discriminator value\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='tagged-union',\n        choices=choices,\n        discriminator=discriminator,\n        custom_error_type=custom_error_type,\n        custom_error_message=custom_error_message,\n        custom_error_context=custom_error_context,\n        strict=strict,\n        from_attributes=from_attributes,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.chain_schema","title":"chain_schema","text":"<pre><code>chain_schema(steps: list[CoreSchema], *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; ChainSchema\n</code></pre> <p>Returns a schema that chains the provided validation schemas, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n    assert 'hello' in v\n    return v + ' world'\n\nfn_schema = core_schema.with_info_plain_validator_function(function=fn)\nschema = core_schema.chain_schema(\n    [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]\n)\nv = SchemaValidator(schema)\nassert v.validate_python('hello') == 'hello world world world'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>steps</code> <code>list[CoreSchema]</code> <p>The schemas to chain</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def chain_schema(\n    steps: list[CoreSchema],\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; ChainSchema:\n    \"\"\"\n    Returns a schema that chains the provided validation schemas, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n        assert 'hello' in v\n        return v + ' world'\n\n    fn_schema = core_schema.with_info_plain_validator_function(function=fn)\n    schema = core_schema.chain_schema(\n        [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello world world world'\n    ```\n\n    Args:\n        steps: The schemas to chain\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='chain', steps=steps, ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.lax_or_strict_schema","title":"lax_or_strict_schema","text":"<pre><code>lax_or_strict_schema(lax_schema: CoreSchema, strict_schema: CoreSchema, *, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; LaxOrStrictSchema\n</code></pre> <p>Returns a schema that uses the lax or strict schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndef fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n    assert 'hello' in v\n    return v + ' world'\n\nlax_schema = core_schema.int_schema(strict=False)\nstrict_schema = core_schema.int_schema(strict=True)\n\nschema = core_schema.lax_or_strict_schema(\n    lax_schema=lax_schema, strict_schema=strict_schema, strict=True\n)\nv = SchemaValidator(schema)\nassert v.validate_python(123) == 123\n\nschema = core_schema.lax_or_strict_schema(\n    lax_schema=lax_schema, strict_schema=strict_schema, strict=False\n)\nv = SchemaValidator(schema)\nassert v.validate_python('123') == 123\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>lax_schema</code> <code>CoreSchema</code> <p>The lax schema to use</p> \u5fc5\u9700 <code>strict_schema</code> <code>CoreSchema</code> <p>The strict schema to use</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether the strict schema should be used</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def lax_or_strict_schema(\n    lax_schema: CoreSchema,\n    strict_schema: CoreSchema,\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; LaxOrStrictSchema:\n    \"\"\"\n    Returns a schema that uses the lax or strict schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -&gt; str:\n        assert 'hello' in v\n        return v + ' world'\n\n    lax_schema = core_schema.int_schema(strict=False)\n    strict_schema = core_schema.int_schema(strict=True)\n\n    schema = core_schema.lax_or_strict_schema(\n        lax_schema=lax_schema, strict_schema=strict_schema, strict=True\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python(123) == 123\n\n    schema = core_schema.lax_or_strict_schema(\n        lax_schema=lax_schema, strict_schema=strict_schema, strict=False\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('123') == 123\n    ```\n\n    Args:\n        lax_schema: The lax schema to use\n        strict_schema: The strict schema to use\n        strict: Whether the strict schema should be used\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='lax-or-strict',\n        lax_schema=lax_schema,\n        strict_schema=strict_schema,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.json_or_python_schema","title":"json_or_python_schema","text":"<pre><code>json_or_python_schema(json_schema: CoreSchema, python_schema: CoreSchema, *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; JsonOrPythonSchema\n</code></pre> <p>Returns a schema that uses the Json or Python schema depending on the input:</p> <pre><code>from pydantic_core import SchemaValidator, ValidationError, core_schema\n\nv = SchemaValidator(\n    core_schema.json_or_python_schema(\n        json_schema=core_schema.int_schema(),\n        python_schema=core_schema.int_schema(strict=True),\n    )\n)\n\nassert v.validate_json('\"123\"') == 123\n\ntry:\n    v.validate_python('123')\nexcept ValidationError:\n    pass\nelse:\n    raise AssertionError('Validation should have failed')\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>json_schema</code> <code>CoreSchema</code> <p>The schema to use for Json inputs</p> \u5fc5\u9700 <code>python_schema</code> <code>CoreSchema</code> <p>The schema to use for Python inputs</p> \u5fc5\u9700 <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def json_or_python_schema(\n    json_schema: CoreSchema,\n    python_schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; JsonOrPythonSchema:\n    \"\"\"\n    Returns a schema that uses the Json or Python schema depending on the input:\n\n    ```py\n    from pydantic_core import SchemaValidator, ValidationError, core_schema\n\n    v = SchemaValidator(\n        core_schema.json_or_python_schema(\n            json_schema=core_schema.int_schema(),\n            python_schema=core_schema.int_schema(strict=True),\n        )\n    )\n\n    assert v.validate_json('\"123\"') == 123\n\n    try:\n        v.validate_python('123')\n    except ValidationError:\n        pass\n    else:\n        raise AssertionError('Validation should have failed')\n    ```\n\n    Args:\n        json_schema: The schema to use for Json inputs\n        python_schema: The schema to use for Python inputs\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='json-or-python',\n        json_schema=json_schema,\n        python_schema=python_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.typed_dict_field","title":"typed_dict_field","text":"<pre><code>typed_dict_field(schema: CoreSchema, *, required: bool | None = None, validation_alias: str | list[str | int] | list[list[str | int]] | None = None, serialization_alias: str | None = None, serialization_exclude: bool | None = None, metadata: dict[str, Any] | None = None, serialization_exclude_if: Callable[[Any], bool] | None = None) -&gt; TypedDictField\n</code></pre> <p>Returns a schema that matches a typed dict field, e.g.:</p> <pre><code>from pydantic_core import core_schema\n\nfield = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the field</p> \u5fc5\u9700 <code>required</code> <code>bool | None</code> <p>Whether the field is required, otherwise uses the value from <code>total</code> on the typed dict</p> <code>None</code> <code>validation_alias</code> <code>str | list[str | int] | list[list[str | int]] | None</code> <p>The alias(es) to use to find the field in the validation data</p> <code>None</code> <code>serialization_alias</code> <code>str | None</code> <p>The alias to use as a key when serializing</p> <code>None</code> <code>serialization_exclude</code> <code>bool | None</code> <p>Whether to exclude the field when serializing</p> <code>None</code> <code>serialization_exclude_if</code> <code>Callable[[Any], bool] | None</code> <p>A callable that determines whether to exclude the field when serializing based on its value.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def typed_dict_field(\n    schema: CoreSchema,\n    *,\n    required: bool | None = None,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization_exclude_if: Callable[[Any], bool] | None = None,\n) -&gt; TypedDictField:\n    \"\"\"\n    Returns a schema that matches a typed dict field, e.g.:\n\n    ```py\n    from pydantic_core import core_schema\n\n    field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)\n    ```\n\n    Args:\n        schema: The schema to use for the field\n        required: Whether the field is required, otherwise uses the value from `total` on the typed dict\n        validation_alias: The alias(es) to use to find the field in the validation data\n        serialization_alias: The alias to use as a key when serializing\n        serialization_exclude: Whether to exclude the field when serializing\n        serialization_exclude_if: A callable that determines whether to exclude the field when serializing based on its value.\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n    return _dict_not_none(\n        type='typed-dict-field',\n        schema=schema,\n        required=required,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        serialization_exclude=serialization_exclude,\n        serialization_exclude_if=serialization_exclude_if,\n        metadata=metadata,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.typed_dict_schema","title":"typed_dict_schema","text":"<pre><code>typed_dict_schema(fields: dict[str, TypedDictField], *, cls: type[Any] | None = None, cls_name: str | None = None, computed_fields: list[ComputedField] | None = None, strict: bool | None = None, extras_schema: CoreSchema | None = None, extra_behavior: ExtraBehavior | None = None, total: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None, config: CoreConfig | None = None) -&gt; TypedDictSchema\n</code></pre> <p>Returns a schema that matches a typed dict, e.g.:</p> <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic_core import SchemaValidator, core_schema\n\nclass MyTypedDict(TypedDict):\n    a: str\n\nwrapper_schema = core_schema.typed_dict_schema(\n    {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict\n)\nv = SchemaValidator(wrapper_schema)\nassert v.validate_python({'a': 'hello'}) == {'a': 'hello'}\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>fields</code> <code>dict[str, TypedDictField]</code> <p>The fields to use for the typed dict</p> \u5fc5\u9700 <code>cls</code> <code>type[Any] | None</code> <p>The class to use for the typed dict</p> <code>None</code> <code>cls_name</code> <code>str | None</code> <p>The name to use in error locations. Falls back to <code>cls.__name__</code>, or the validator name if no class is provided.</p> <code>None</code> <code>computed_fields</code> <code>list[ComputedField] | None</code> <p>Computed fields to use when serializing the model, only applies when directly inside a model</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the typed dict is strict</p> <code>None</code> <code>extras_schema</code> <code>CoreSchema | None</code> <p>The extra validator to use for the typed dict</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>extra_behavior</code> <code>ExtraBehavior | None</code> <p>The extra behavior to use for the typed dict</p> <code>None</code> <code>total</code> <code>bool | None</code> <p>Whether the typed dict is total, otherwise uses <code>typed_dict_total</code> from config</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def typed_dict_schema(\n    fields: dict[str, TypedDictField],\n    *,\n    cls: type[Any] | None = None,\n    cls_name: str | None = None,\n    computed_fields: list[ComputedField] | None = None,\n    strict: bool | None = None,\n    extras_schema: CoreSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    total: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n    config: CoreConfig | None = None,\n) -&gt; TypedDictSchema:\n    \"\"\"\n    Returns a schema that matches a typed dict, e.g.:\n\n    ```py\n    from typing_extensions import TypedDict\n\n    from pydantic_core import SchemaValidator, core_schema\n\n    class MyTypedDict(TypedDict):\n        a: str\n\n    wrapper_schema = core_schema.typed_dict_schema(\n        {'a': core_schema.typed_dict_field(core_schema.str_schema())}, cls=MyTypedDict\n    )\n    v = SchemaValidator(wrapper_schema)\n    assert v.validate_python({'a': 'hello'}) == {'a': 'hello'}\n    ```\n\n    Args:\n        fields: The fields to use for the typed dict\n        cls: The class to use for the typed dict\n        cls_name: The name to use in error locations. Falls back to `cls.__name__`, or the validator name if no class\n            is provided.\n        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model\n        strict: Whether the typed dict is strict\n        extras_schema: The extra validator to use for the typed dict\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        extra_behavior: The extra behavior to use for the typed dict\n        total: Whether the typed dict is total, otherwise uses `typed_dict_total` from config\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='typed-dict',\n        fields=fields,\n        cls=cls,\n        cls_name=cls_name,\n        computed_fields=computed_fields,\n        strict=strict,\n        extras_schema=extras_schema,\n        extra_behavior=extra_behavior,\n        total=total,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n        config=config,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.model_field","title":"model_field","text":"<pre><code>model_field(schema: CoreSchema, *, validation_alias: str | list[str | int] | list[list[str | int]] | None = None, serialization_alias: str | None = None, serialization_exclude: bool | None = None, serialization_exclude_if: Callable[[Any], bool] | None = None, frozen: bool | None = None, metadata: dict[str, Any] | None = None) -&gt; ModelField\n</code></pre> <p>Returns a schema for a model field, e.g.:</p> <pre><code>from pydantic_core import core_schema\n\nfield = core_schema.model_field(schema=core_schema.int_schema())\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the field</p> \u5fc5\u9700 <code>validation_alias</code> <code>str | list[str | int] | list[list[str | int]] | None</code> <p>The alias(es) to use to find the field in the validation data</p> <code>None</code> <code>serialization_alias</code> <code>str | None</code> <p>The alias to use as a key when serializing</p> <code>None</code> <code>serialization_exclude</code> <code>bool | None</code> <p>Whether to exclude the field when serializing</p> <code>None</code> <code>serialization_exclude_if</code> <code>Callable[[Any], bool] | None</code> <p>A Callable that determines whether to exclude a field during serialization based on its value.</p> <code>None</code> <code>frozen</code> <code>bool | None</code> <p>Whether the field is frozen</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def model_field(\n    schema: CoreSchema,\n    *,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    serialization_exclude_if: Callable[[Any], bool] | None = None,\n    frozen: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n) -&gt; ModelField:\n    \"\"\"\n    Returns a schema for a model field, e.g.:\n\n    ```py\n    from pydantic_core import core_schema\n\n    field = core_schema.model_field(schema=core_schema.int_schema())\n    ```\n\n    Args:\n        schema: The schema to use for the field\n        validation_alias: The alias(es) to use to find the field in the validation data\n        serialization_alias: The alias to use as a key when serializing\n        serialization_exclude: Whether to exclude the field when serializing\n        serialization_exclude_if: A Callable that determines whether to exclude a field during serialization based on its value.\n        frozen: Whether the field is frozen\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n    return _dict_not_none(\n        type='model-field',\n        schema=schema,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        serialization_exclude=serialization_exclude,\n        serialization_exclude_if=serialization_exclude_if,\n        frozen=frozen,\n        metadata=metadata,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.model_fields_schema","title":"model_fields_schema","text":"<pre><code>model_fields_schema(fields: dict[str, ModelField], *, model_name: str | None = None, computed_fields: list[ComputedField] | None = None, strict: bool | None = None, extras_schema: CoreSchema | None = None, extras_keys_schema: CoreSchema | None = None, extra_behavior: ExtraBehavior | None = None, from_attributes: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; ModelFieldsSchema\n</code></pre> <p>Returns a schema that matches the fields of a Pydantic model, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nwrapper_schema = core_schema.model_fields_schema(\n    {'a': core_schema.model_field(core_schema.str_schema())}\n)\nv = SchemaValidator(wrapper_schema)\nprint(v.validate_python({'a': 'hello'}))\n#&gt; ({'a': 'hello'}, None, {'a'})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>fields</code> <code>dict[str, ModelField]</code> <p>The fields of the model</p> \u5fc5\u9700 <code>model_name</code> <code>str | None</code> <p>The name of the model, used for error messages, defaults to \"Model\"</p> <code>None</code> <code>computed_fields</code> <code>list[ComputedField] | None</code> <p>Computed fields to use when serializing the model, only applies when directly inside a model</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the model is strict</p> <code>None</code> <code>extras_schema</code> <code>CoreSchema | None</code> <p>The schema to use when validating extra input data</p> <code>None</code> <code>extras_keys_schema</code> <code>CoreSchema | None</code> <p>The schema to use when validating the keys of extra input data</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>extra_behavior</code> <code>ExtraBehavior | None</code> <p>The extra behavior to use for the model fields</p> <code>None</code> <code>from_attributes</code> <code>bool | None</code> <p>Whether the model fields should be populated from attributes</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def model_fields_schema(\n    fields: dict[str, ModelField],\n    *,\n    model_name: str | None = None,\n    computed_fields: list[ComputedField] | None = None,\n    strict: bool | None = None,\n    extras_schema: CoreSchema | None = None,\n    extras_keys_schema: CoreSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    from_attributes: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; ModelFieldsSchema:\n    \"\"\"\n    Returns a schema that matches the fields of a Pydantic model, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    wrapper_schema = core_schema.model_fields_schema(\n        {'a': core_schema.model_field(core_schema.str_schema())}\n    )\n    v = SchemaValidator(wrapper_schema)\n    print(v.validate_python({'a': 'hello'}))\n    #&gt; ({'a': 'hello'}, None, {'a'})\n    ```\n\n    Args:\n        fields: The fields of the model\n        model_name: The name of the model, used for error messages, defaults to \"Model\"\n        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model\n        strict: Whether the model is strict\n        extras_schema: The schema to use when validating extra input data\n        extras_keys_schema: The schema to use when validating the keys of extra input data\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        extra_behavior: The extra behavior to use for the model fields\n        from_attributes: Whether the model fields should be populated from attributes\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='model-fields',\n        fields=fields,\n        model_name=model_name,\n        computed_fields=computed_fields,\n        strict=strict,\n        extras_schema=extras_schema,\n        extras_keys_schema=extras_keys_schema,\n        extra_behavior=extra_behavior,\n        from_attributes=from_attributes,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.model_schema","title":"model_schema","text":"<pre><code>model_schema(cls: type[Any], schema: CoreSchema, *, generic_origin: type[Any] | None = None, custom_init: bool | None = None, root_model: bool | None = None, post_init: str | None = None, revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None, strict: bool | None = None, frozen: bool | None = None, extra_behavior: ExtraBehavior | None = None, config: CoreConfig | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; ModelSchema\n</code></pre> <p>A model schema generally contains a typed-dict schema. It will run the typed dict validator, then create a new class and set the dict and fields set returned from the typed dict validator to <code>__dict__</code> and <code>__pydantic_fields_set__</code> respectively.</p> <p>Example:</p> <pre><code>from pydantic_core import CoreConfig, SchemaValidator, core_schema\n\nclass MyModel:\n    __slots__ = (\n        '__dict__',\n        '__pydantic_fields_set__',\n        '__pydantic_extra__',\n        '__pydantic_private__',\n    )\n\nschema = core_schema.model_schema(\n    cls=MyModel,\n    config=CoreConfig(str_max_length=5),\n    schema=core_schema.model_fields_schema(\n        fields={'a': core_schema.model_field(core_schema.str_schema())},\n    ),\n)\nv = SchemaValidator(schema)\nassert v.isinstance_python({'a': 'hello'}) is True\nassert v.isinstance_python({'a': 'too long'}) is False\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>type[Any]</code> <p>The class to use for the model</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the model</p> \u5fc5\u9700 <code>generic_origin</code> <code>type[Any] | None</code> <p>The origin type used for this model, if it's a parametrized generic. Ex, if this model schema represents <code>SomeModel[int]</code>, generic_origin is <code>SomeModel</code></p> <code>None</code> <code>custom_init</code> <code>bool | None</code> <p>Whether the model has a custom init method</p> <code>None</code> <code>root_model</code> <code>bool | None</code> <p>Whether the model is a <code>RootModel</code></p> <code>None</code> <code>post_init</code> <code>str | None</code> <p>The call after init to use for the model</p> <code>None</code> <code>revalidate_instances</code> <code>Literal['always', 'never', 'subclass-instances'] | None</code> <p>whether instances of models and dataclasses (including subclass instances) should re-validate defaults to config.revalidate_instances, else 'never'</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether the model is strict</p> <code>None</code> <code>frozen</code> <code>bool | None</code> <p>Whether the model is frozen</p> <code>None</code> <code>extra_behavior</code> <code>ExtraBehavior | None</code> <p>The extra behavior to use for the model, used in serialization</p> <code>None</code> <code>config</code> <code>CoreConfig | None</code> <p>The config to use for the model</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def model_schema(\n    cls: type[Any],\n    schema: CoreSchema,\n    *,\n    generic_origin: type[Any] | None = None,\n    custom_init: bool | None = None,\n    root_model: bool | None = None,\n    post_init: str | None = None,\n    revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,\n    strict: bool | None = None,\n    frozen: bool | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    config: CoreConfig | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; ModelSchema:\n    \"\"\"\n    A model schema generally contains a typed-dict schema.\n    It will run the typed dict validator, then create a new class\n    and set the dict and fields set returned from the typed dict validator\n    to `__dict__` and `__pydantic_fields_set__` respectively.\n\n    Example:\n\n    ```py\n    from pydantic_core import CoreConfig, SchemaValidator, core_schema\n\n    class MyModel:\n        __slots__ = (\n            '__dict__',\n            '__pydantic_fields_set__',\n            '__pydantic_extra__',\n            '__pydantic_private__',\n        )\n\n    schema = core_schema.model_schema(\n        cls=MyModel,\n        config=CoreConfig(str_max_length=5),\n        schema=core_schema.model_fields_schema(\n            fields={'a': core_schema.model_field(core_schema.str_schema())},\n        ),\n    )\n    v = SchemaValidator(schema)\n    assert v.isinstance_python({'a': 'hello'}) is True\n    assert v.isinstance_python({'a': 'too long'}) is False\n    ```\n\n    Args:\n        cls: The class to use for the model\n        schema: The schema to use for the model\n        generic_origin: The origin type used for this model, if it's a parametrized generic. Ex,\n            if this model schema represents `SomeModel[int]`, generic_origin is `SomeModel`\n        custom_init: Whether the model has a custom init method\n        root_model: Whether the model is a `RootModel`\n        post_init: The call after init to use for the model\n        revalidate_instances: whether instances of models and dataclasses (including subclass instances)\n            should re-validate defaults to config.revalidate_instances, else 'never'\n        strict: Whether the model is strict\n        frozen: Whether the model is frozen\n        extra_behavior: The extra behavior to use for the model, used in serialization\n        config: The config to use for the model\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='model',\n        cls=cls,\n        generic_origin=generic_origin,\n        schema=schema,\n        custom_init=custom_init,\n        root_model=root_model,\n        post_init=post_init,\n        revalidate_instances=revalidate_instances,\n        strict=strict,\n        frozen=frozen,\n        extra_behavior=extra_behavior,\n        config=config,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.dataclass_field","title":"dataclass_field","text":"<pre><code>dataclass_field(name: str, schema: CoreSchema, *, kw_only: bool | None = None, init: bool | None = None, init_only: bool | None = None, validation_alias: str | list[str | int] | list[list[str | int]] | None = None, serialization_alias: str | None = None, serialization_exclude: bool | None = None, metadata: dict[str, Any] | None = None, serialization_exclude_if: Callable[[Any], bool] | None = None, frozen: bool | None = None) -&gt; DataclassField\n</code></pre> <p>Returns a schema for a dataclass field, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nfield = core_schema.dataclass_field(\n    name='a', schema=core_schema.str_schema(), kw_only=False\n)\nschema = core_schema.dataclass_args_schema('Foobar', [field])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>name</code> <code>str</code> <p>The name to use for the argument parameter</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the argument parameter</p> \u5fc5\u9700 <code>kw_only</code> <code>bool | None</code> <p>Whether the field can be set with a positional argument as well as a keyword argument</p> <code>None</code> <code>init</code> <code>bool | None</code> <p>Whether the field should be validated during initialization</p> <code>None</code> <code>init_only</code> <code>bool | None</code> <p>Whether the field should be omitted  from <code>__dict__</code> and passed to <code>__post_init__</code></p> <code>None</code> <code>validation_alias</code> <code>str | list[str | int] | list[list[str | int]] | None</code> <p>The alias(es) to use to find the field in the validation data</p> <code>None</code> <code>serialization_alias</code> <code>str | None</code> <p>The alias to use as a key when serializing</p> <code>None</code> <code>serialization_exclude</code> <code>bool | None</code> <p>Whether to exclude the field when serializing</p> <code>None</code> <code>serialization_exclude_if</code> <code>Callable[[Any], bool] | None</code> <p>A callable that determines whether to exclude the field when serializing based on its value.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>frozen</code> <code>bool | None</code> <p>Whether the field is frozen</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def dataclass_field(\n    name: str,\n    schema: CoreSchema,\n    *,\n    kw_only: bool | None = None,\n    init: bool | None = None,\n    init_only: bool | None = None,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization_exclude_if: Callable[[Any], bool] | None = None,\n    frozen: bool | None = None,\n) -&gt; DataclassField:\n    \"\"\"\n    Returns a schema for a dataclass field, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    field = core_schema.dataclass_field(\n        name='a', schema=core_schema.str_schema(), kw_only=False\n    )\n    schema = core_schema.dataclass_args_schema('Foobar', [field])\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)\n    ```\n\n    Args:\n        name: The name to use for the argument parameter\n        schema: The schema to use for the argument parameter\n        kw_only: Whether the field can be set with a positional argument as well as a keyword argument\n        init: Whether the field should be validated during initialization\n        init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__`\n        validation_alias: The alias(es) to use to find the field in the validation data\n        serialization_alias: The alias to use as a key when serializing\n        serialization_exclude: Whether to exclude the field when serializing\n        serialization_exclude_if: A callable that determines whether to exclude the field when serializing based on its value.\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        frozen: Whether the field is frozen\n    \"\"\"\n    return _dict_not_none(\n        type='dataclass-field',\n        name=name,\n        schema=schema,\n        kw_only=kw_only,\n        init=init,\n        init_only=init_only,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        serialization_exclude=serialization_exclude,\n        serialization_exclude_if=serialization_exclude_if,\n        metadata=metadata,\n        frozen=frozen,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.dataclass_args_schema","title":"dataclass_args_schema","text":"<pre><code>dataclass_args_schema(dataclass_name: str, fields: list[DataclassField], *, computed_fields: list[ComputedField] | None = None, collect_init_only: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None, extra_behavior: ExtraBehavior | None = None) -&gt; DataclassArgsSchema\n</code></pre> <p>Returns a schema for validating dataclass arguments, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nfield_a = core_schema.dataclass_field(\n    name='a', schema=core_schema.str_schema(), kw_only=False\n)\nfield_b = core_schema.dataclass_field(\n    name='b', schema=core_schema.bool_schema(), kw_only=False\n)\nschema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>dataclass_name</code> <code>str</code> <p>The name of the dataclass being validated</p> \u5fc5\u9700 <code>fields</code> <code>list[DataclassField]</code> <p>The fields to use for the dataclass</p> \u5fc5\u9700 <code>computed_fields</code> <code>list[ComputedField] | None</code> <p>Computed fields to use when serializing the dataclass</p> <code>None</code> <code>collect_init_only</code> <code>bool | None</code> <p>Whether to collect init only fields into a dict to pass to <code>__post_init__</code></p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> <code>extra_behavior</code> <code>ExtraBehavior | None</code> <p>How to handle extra fields</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def dataclass_args_schema(\n    dataclass_name: str,\n    fields: list[DataclassField],\n    *,\n    computed_fields: list[ComputedField] | None = None,\n    collect_init_only: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n) -&gt; DataclassArgsSchema:\n    \"\"\"\n    Returns a schema for validating dataclass arguments, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    field_a = core_schema.dataclass_field(\n        name='a', schema=core_schema.str_schema(), kw_only=False\n    )\n    field_b = core_schema.dataclass_field(\n        name='b', schema=core_schema.bool_schema(), kw_only=False\n    )\n    schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)\n    ```\n\n    Args:\n        dataclass_name: The name of the dataclass being validated\n        fields: The fields to use for the dataclass\n        computed_fields: Computed fields to use when serializing the dataclass\n        collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n        extra_behavior: How to handle extra fields\n    \"\"\"\n    return _dict_not_none(\n        type='dataclass-args',\n        dataclass_name=dataclass_name,\n        fields=fields,\n        computed_fields=computed_fields,\n        collect_init_only=collect_init_only,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n        extra_behavior=extra_behavior,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.dataclass_schema","title":"dataclass_schema","text":"<pre><code>dataclass_schema(cls: type[Any], schema: CoreSchema, fields: list[str], *, generic_origin: type[Any] | None = None, cls_name: str | None = None, post_init: bool | None = None, revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None, frozen: bool | None = None, slots: bool | None = None, config: CoreConfig | None = None) -&gt; DataclassSchema\n</code></pre> <p>Returns a schema for a dataclass. As with <code>ModelSchema</code>, this schema can only be used as a field within another schema, not as the root type.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cls</code> <code>type[Any]</code> <p>The dataclass type, used to perform subclass checks</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the dataclass fields</p> \u5fc5\u9700 <code>fields</code> <code>list[str]</code> <p>Fields of the dataclass, this is used in serialization and in validation during re-validation and while validating assignment</p> \u5fc5\u9700 <code>generic_origin</code> <code>type[Any] | None</code> <p>The origin type used for this dataclass, if it's a parametrized generic. Ex, if this model schema represents <code>SomeDataclass[int]</code>, generic_origin is <code>SomeDataclass</code></p> <code>None</code> <code>cls_name</code> <code>str | None</code> <p>The name to use in error locs, etc; this is useful for generics (default: <code>cls.__name__</code>)</p> <code>None</code> <code>post_init</code> <code>bool | None</code> <p>Whether to call <code>__post_init__</code> after validation</p> <code>None</code> <code>revalidate_instances</code> <code>Literal['always', 'never', 'subclass-instances'] | None</code> <p>whether instances of models and dataclasses (including subclass instances) should re-validate defaults to config.revalidate_instances, else 'never'</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether to require an exact instance of <code>cls</code></p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> <code>frozen</code> <code>bool | None</code> <p>Whether the dataclass is frozen</p> <code>None</code> <code>slots</code> <code>bool | None</code> <p>Whether <code>slots=True</code> on the dataclass, means each field is assigned independently, rather than simply setting <code>__dict__</code>, default false</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def dataclass_schema(\n    cls: type[Any],\n    schema: CoreSchema,\n    fields: list[str],\n    *,\n    generic_origin: type[Any] | None = None,\n    cls_name: str | None = None,\n    post_init: bool | None = None,\n    revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n    frozen: bool | None = None,\n    slots: bool | None = None,\n    config: CoreConfig | None = None,\n) -&gt; DataclassSchema:\n    \"\"\"\n    Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within\n    another schema, not as the root type.\n\n    Args:\n        cls: The dataclass type, used to perform subclass checks\n        schema: The schema to use for the dataclass fields\n        fields: Fields of the dataclass, this is used in serialization and in validation during re-validation\n            and while validating assignment\n        generic_origin: The origin type used for this dataclass, if it's a parametrized generic. Ex,\n            if this model schema represents `SomeDataclass[int]`, generic_origin is `SomeDataclass`\n        cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`)\n        post_init: Whether to call `__post_init__` after validation\n        revalidate_instances: whether instances of models and dataclasses (including subclass instances)\n            should re-validate defaults to config.revalidate_instances, else 'never'\n        strict: Whether to require an exact instance of `cls`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n        frozen: Whether the dataclass is frozen\n        slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than\n            simply setting `__dict__`, default false\n    \"\"\"\n    return _dict_not_none(\n        type='dataclass',\n        cls=cls,\n        generic_origin=generic_origin,\n        fields=fields,\n        cls_name=cls_name,\n        schema=schema,\n        post_init=post_init,\n        revalidate_instances=revalidate_instances,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n        frozen=frozen,\n        slots=slots,\n        config=config,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.arguments_parameter","title":"arguments_parameter","text":"<pre><code>arguments_parameter(name: str, schema: CoreSchema, *, mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None, alias: str | list[str | int] | list[list[str | int]] | None = None) -&gt; ArgumentsParameter\n</code></pre> <p>Returns a schema that matches an argument parameter, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nparam = core_schema.arguments_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nschema = core_schema.arguments_schema([param])\nv = SchemaValidator(schema)\nassert v.validate_python(('hello',)) == (('hello',), {})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>name</code> <code>str</code> <p>The name to use for the argument parameter</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the argument parameter</p> \u5fc5\u9700 <code>mode</code> <code>Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None</code> <p>The mode to use for the argument parameter</p> <code>None</code> <code>alias</code> <code>str | list[str | int] | list[list[str | int]] | None</code> <p>The alias to use for the argument parameter</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def arguments_parameter(\n    name: str,\n    schema: CoreSchema,\n    *,\n    mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None,\n    alias: str | list[str | int] | list[list[str | int]] | None = None,\n) -&gt; ArgumentsParameter:\n    \"\"\"\n    Returns a schema that matches an argument parameter, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param = core_schema.arguments_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    schema = core_schema.arguments_schema([param])\n    v = SchemaValidator(schema)\n    assert v.validate_python(('hello',)) == (('hello',), {})\n    ```\n\n    Args:\n        name: The name to use for the argument parameter\n        schema: The schema to use for the argument parameter\n        mode: The mode to use for the argument parameter\n        alias: The alias to use for the argument parameter\n    \"\"\"\n    return _dict_not_none(name=name, schema=schema, mode=mode, alias=alias)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.arguments_schema","title":"arguments_schema","text":"<pre><code>arguments_schema(arguments: list[ArgumentsParameter], *, validate_by_name: bool | None = None, validate_by_alias: bool | None = None, var_args_schema: CoreSchema | None = None, var_kwargs_mode: VarKwargsMode | None = None, var_kwargs_schema: CoreSchema | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; ArgumentsSchema\n</code></pre> <p>Returns a schema that matches an arguments schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nparam_a = core_schema.arguments_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nparam_b = core_schema.arguments_parameter(\n    name='b', schema=core_schema.bool_schema(), mode='positional_only'\n)\nschema = core_schema.arguments_schema([param_a, param_b])\nv = SchemaValidator(schema)\nassert v.validate_python(('hello', True)) == (('hello', True), {})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>arguments</code> <code>list[ArgumentsParameter]</code> <p>The arguments to use for the arguments schema</p> \u5fc5\u9700 <code>validate_by_name</code> <code>bool | None</code> <p>Whether to populate by the parameter names, defaults to <code>False</code>.</p> <code>None</code> <code>validate_by_alias</code> <code>bool | None</code> <p>Whether to populate by the parameter aliases, defaults to <code>True</code>.</p> <code>None</code> <code>var_args_schema</code> <code>CoreSchema | None</code> <p>The variable args schema to use for the arguments schema</p> <code>None</code> <code>var_kwargs_mode</code> <code>VarKwargsMode | None</code> <p>The validation mode to use for variadic keyword arguments. If <code>'uniform'</code>, every value of the keyword arguments will be validated against the <code>var_kwargs_schema</code> schema. If <code>'unpacked-typed-dict'</code>, the <code>var_kwargs_schema</code> argument must be a <code>typed_dict_schema</code></p> <code>None</code> <code>var_kwargs_schema</code> <code>CoreSchema | None</code> <p>The variable kwargs schema to use for the arguments schema</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def arguments_schema(\n    arguments: list[ArgumentsParameter],\n    *,\n    validate_by_name: bool | None = None,\n    validate_by_alias: bool | None = None,\n    var_args_schema: CoreSchema | None = None,\n    var_kwargs_mode: VarKwargsMode | None = None,\n    var_kwargs_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; ArgumentsSchema:\n    \"\"\"\n    Returns a schema that matches an arguments schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param_a = core_schema.arguments_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    param_b = core_schema.arguments_parameter(\n        name='b', schema=core_schema.bool_schema(), mode='positional_only'\n    )\n    schema = core_schema.arguments_schema([param_a, param_b])\n    v = SchemaValidator(schema)\n    assert v.validate_python(('hello', True)) == (('hello', True), {})\n    ```\n\n    Args:\n        arguments: The arguments to use for the arguments schema\n        validate_by_name: Whether to populate by the parameter names, defaults to `False`.\n        validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`.\n        var_args_schema: The variable args schema to use for the arguments schema\n        var_kwargs_mode: The validation mode to use for variadic keyword arguments. If `'uniform'`, every value of the\n            keyword arguments will be validated against the `var_kwargs_schema` schema. If `'unpacked-typed-dict'`,\n            the `var_kwargs_schema` argument must be a [`typed_dict_schema`][pydantic_core.core_schema.typed_dict_schema]\n        var_kwargs_schema: The variable kwargs schema to use for the arguments schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='arguments',\n        arguments_schema=arguments,\n        validate_by_name=validate_by_name,\n        validate_by_alias=validate_by_alias,\n        var_args_schema=var_args_schema,\n        var_kwargs_mode=var_kwargs_mode,\n        var_kwargs_schema=var_kwargs_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.arguments_v3_parameter","title":"arguments_v3_parameter","text":"<pre><code>arguments_v3_parameter(name: str, schema: CoreSchema, *, mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only', 'var_args', 'var_kwargs_uniform', 'var_kwargs_unpacked_typed_dict'] | None = None, alias: str | list[str | int] | list[list[str | int]] | None = None) -&gt; ArgumentsV3Parameter\n</code></pre> <p>Returns a schema that matches an argument parameter, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nparam = core_schema.arguments_v3_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nschema = core_schema.arguments_v3_schema([param])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hello'}) == (('hello',), {})\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>name</code> <code>str</code> <p>The name to use for the argument parameter</p> \u5fc5\u9700 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the argument parameter</p> \u5fc5\u9700 <code>mode</code> <code>Literal['positional_only', 'positional_or_keyword', 'keyword_only', 'var_args', 'var_kwargs_uniform', 'var_kwargs_unpacked_typed_dict'] | None</code> <p>The mode to use for the argument parameter</p> <code>None</code> <code>alias</code> <code>str | list[str | int] | list[list[str | int]] | None</code> <p>The alias to use for the argument parameter</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def arguments_v3_parameter(\n    name: str,\n    schema: CoreSchema,\n    *,\n    mode: Literal[\n        'positional_only',\n        'positional_or_keyword',\n        'keyword_only',\n        'var_args',\n        'var_kwargs_uniform',\n        'var_kwargs_unpacked_typed_dict',\n    ]\n    | None = None,\n    alias: str | list[str | int] | list[list[str | int]] | None = None,\n) -&gt; ArgumentsV3Parameter:\n    \"\"\"\n    Returns a schema that matches an argument parameter, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param = core_schema.arguments_v3_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    schema = core_schema.arguments_v3_schema([param])\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': 'hello'}) == (('hello',), {})\n    ```\n\n    Args:\n        name: The name to use for the argument parameter\n        schema: The schema to use for the argument parameter\n        mode: The mode to use for the argument parameter\n        alias: The alias to use for the argument parameter\n    \"\"\"\n    return _dict_not_none(name=name, schema=schema, mode=mode, alias=alias)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.arguments_v3_schema","title":"arguments_v3_schema","text":"<pre><code>arguments_v3_schema(arguments: list[ArgumentsV3Parameter], *, validate_by_name: bool | None = None, validate_by_alias: bool | None = None, extra_behavior: Literal['forbid', 'ignore'] | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; ArgumentsV3Schema\n</code></pre> <p>Returns a schema that matches an arguments schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nparam_a = core_schema.arguments_v3_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nparam_b = core_schema.arguments_v3_parameter(\n    name='kwargs', schema=core_schema.bool_schema(), mode='var_kwargs_uniform'\n)\nschema = core_schema.arguments_v3_schema([param_a, param_b])\nv = SchemaValidator(schema)\nassert v.validate_python({'a': 'hi', 'kwargs': {'b': True}}) == (('hi',), {'b': True})\n</code></pre> <p>This schema is currently not used by other Pydantic components. In V3, it will most likely become the default arguments schema for the <code>'call'</code> schema.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>arguments</code> <code>list[ArgumentsV3Parameter]</code> <p>The arguments to use for the arguments schema.</p> \u5fc5\u9700 <code>validate_by_name</code> <code>bool | None</code> <p>Whether to populate by the parameter names, defaults to <code>False</code>.</p> <code>None</code> <code>validate_by_alias</code> <code>bool | None</code> <p>Whether to populate by the parameter aliases, defaults to <code>True</code>.</p> <code>None</code> <code>extra_behavior</code> <code>Literal['forbid', 'ignore'] | None</code> <p>The extra behavior to use.</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places.</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core.</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema.</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def arguments_v3_schema(\n    arguments: list[ArgumentsV3Parameter],\n    *,\n    validate_by_name: bool | None = None,\n    validate_by_alias: bool | None = None,\n    extra_behavior: Literal['forbid', 'ignore'] | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; ArgumentsV3Schema:\n    \"\"\"\n    Returns a schema that matches an arguments schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param_a = core_schema.arguments_v3_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    param_b = core_schema.arguments_v3_parameter(\n        name='kwargs', schema=core_schema.bool_schema(), mode='var_kwargs_uniform'\n    )\n    schema = core_schema.arguments_v3_schema([param_a, param_b])\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': 'hi', 'kwargs': {'b': True}}) == (('hi',), {'b': True})\n    ```\n\n    This schema is currently not used by other Pydantic components. In V3, it will most likely\n    become the default arguments schema for the `'call'` schema.\n\n    Args:\n        arguments: The arguments to use for the arguments schema.\n        validate_by_name: Whether to populate by the parameter names, defaults to `False`.\n        validate_by_alias: Whether to populate by the parameter aliases, defaults to `True`.\n        extra_behavior: The extra behavior to use.\n        ref: optional unique identifier of the schema, used to reference the schema in other places.\n        metadata: Any other information you want to include with the schema, not used by pydantic-core.\n        serialization: Custom serialization schema.\n    \"\"\"\n    return _dict_not_none(\n        type='arguments-v3',\n        arguments_schema=arguments,\n        validate_by_name=validate_by_name,\n        validate_by_alias=validate_by_alias,\n        extra_behavior=extra_behavior,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.call_schema","title":"call_schema","text":"<pre><code>call_schema(arguments: CoreSchema, function: Callable[..., Any], *, function_name: str | None = None, return_schema: CoreSchema | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; CallSchema\n</code></pre> <p>Returns a schema that matches an arguments schema, then calls a function, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nparam_a = core_schema.arguments_parameter(\n    name='a', schema=core_schema.str_schema(), mode='positional_only'\n)\nparam_b = core_schema.arguments_parameter(\n    name='b', schema=core_schema.bool_schema(), mode='positional_only'\n)\nargs_schema = core_schema.arguments_schema([param_a, param_b])\n\nschema = core_schema.call_schema(\n    arguments=args_schema,\n    function=lambda a, b: a + str(not b),\n    return_schema=core_schema.str_schema(),\n)\nv = SchemaValidator(schema)\nassert v.validate_python((('hello', True))) == 'helloFalse'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>arguments</code> <code>CoreSchema</code> <p>The arguments to use for the arguments schema</p> \u5fc5\u9700 <code>function</code> <code>Callable[..., Any]</code> <p>The function to use for the call schema</p> \u5fc5\u9700 <code>function_name</code> <code>str | None</code> <p>The function name to use for the call schema, if not provided <code>function.__name__</code> is used</p> <code>None</code> <code>return_schema</code> <code>CoreSchema | None</code> <p>The return schema to use for the call schema</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def call_schema(\n    arguments: CoreSchema,\n    function: Callable[..., Any],\n    *,\n    function_name: str | None = None,\n    return_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; CallSchema:\n    \"\"\"\n    Returns a schema that matches an arguments schema, then calls a function, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param_a = core_schema.arguments_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    param_b = core_schema.arguments_parameter(\n        name='b', schema=core_schema.bool_schema(), mode='positional_only'\n    )\n    args_schema = core_schema.arguments_schema([param_a, param_b])\n\n    schema = core_schema.call_schema(\n        arguments=args_schema,\n        function=lambda a, b: a + str(not b),\n        return_schema=core_schema.str_schema(),\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python((('hello', True))) == 'helloFalse'\n    ```\n\n    Args:\n        arguments: The arguments to use for the arguments schema\n        function: The function to use for the call schema\n        function_name: The function name to use for the call schema, if not provided `function.__name__` is used\n        return_schema: The return schema to use for the call schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='call',\n        arguments_schema=arguments,\n        function=function,\n        function_name=function_name,\n        return_schema=return_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.custom_error_schema","title":"custom_error_schema","text":"<pre><code>custom_error_schema(schema: CoreSchema, custom_error_type: str, *, custom_error_message: str | None = None, custom_error_context: dict[str, Any] | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; CustomErrorSchema\n</code></pre> <p>Returns a schema that matches a custom error value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.custom_error_schema(\n    schema=core_schema.int_schema(),\n    custom_error_type='MyError',\n    custom_error_message='Error msg',\n)\nv = SchemaValidator(schema)\nv.validate_python(1)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The schema to use for the custom error schema</p> \u5fc5\u9700 <code>custom_error_type</code> <code>str</code> <p>The custom error type to use for the custom error schema</p> \u5fc5\u9700 <code>custom_error_message</code> <code>str | None</code> <p>The custom error message to use for the custom error schema</p> <code>None</code> <code>custom_error_context</code> <code>dict[str, Any] | None</code> <p>The custom error context to use for the custom error schema</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def custom_error_schema(\n    schema: CoreSchema,\n    custom_error_type: str,\n    *,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, Any] | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; CustomErrorSchema:\n    \"\"\"\n    Returns a schema that matches a custom error value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.custom_error_schema(\n        schema=core_schema.int_schema(),\n        custom_error_type='MyError',\n        custom_error_message='Error msg',\n    )\n    v = SchemaValidator(schema)\n    v.validate_python(1)\n    ```\n\n    Args:\n        schema: The schema to use for the custom error schema\n        custom_error_type: The custom error type to use for the custom error schema\n        custom_error_message: The custom error message to use for the custom error schema\n        custom_error_context: The custom error context to use for the custom error schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='custom-error',\n        schema=schema,\n        custom_error_type=custom_error_type,\n        custom_error_message=custom_error_message,\n        custom_error_context=custom_error_context,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.json_schema","title":"json_schema","text":"<pre><code>json_schema(schema: CoreSchema | None = None, *, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; JsonSchema\n</code></pre> <p>Returns a schema that matches a JSON value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\ndict_schema = core_schema.model_fields_schema(\n    {\n        'field_a': core_schema.model_field(core_schema.str_schema()),\n        'field_b': core_schema.model_field(core_schema.bool_schema()),\n    },\n)\n\nclass MyModel:\n    __slots__ = (\n        '__dict__',\n        '__pydantic_fields_set__',\n        '__pydantic_extra__',\n        '__pydantic_private__',\n    )\n    field_a: str\n    field_b: bool\n\njson_schema = core_schema.json_schema(schema=dict_schema)\nschema = core_schema.model_schema(cls=MyModel, schema=json_schema)\nv = SchemaValidator(schema)\nm = v.validate_python('{\"field_a\": \"hello\", \"field_b\": true}')\nassert isinstance(m, MyModel)\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema | None</code> <p>The schema to use for the JSON schema</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def json_schema(\n    schema: CoreSchema | None = None,\n    *,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; JsonSchema:\n    \"\"\"\n    Returns a schema that matches a JSON value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    dict_schema = core_schema.model_fields_schema(\n        {\n            'field_a': core_schema.model_field(core_schema.str_schema()),\n            'field_b': core_schema.model_field(core_schema.bool_schema()),\n        },\n    )\n\n    class MyModel:\n        __slots__ = (\n            '__dict__',\n            '__pydantic_fields_set__',\n            '__pydantic_extra__',\n            '__pydantic_private__',\n        )\n        field_a: str\n        field_b: bool\n\n    json_schema = core_schema.json_schema(schema=dict_schema)\n    schema = core_schema.model_schema(cls=MyModel, schema=json_schema)\n    v = SchemaValidator(schema)\n    m = v.validate_python('{\"field_a\": \"hello\", \"field_b\": true}')\n    assert isinstance(m, MyModel)\n    ```\n\n    Args:\n        schema: The schema to use for the JSON schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='json', schema=schema, ref=ref, metadata=metadata, serialization=serialization)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.url_schema","title":"url_schema","text":"<pre><code>url_schema(*, max_length: int | None = None, allowed_schemes: list[str] | None = None, host_required: bool | None = None, default_host: str | None = None, default_port: int | None = None, default_path: str | None = None, preserve_empty_path: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; UrlSchema\n</code></pre> <p>Returns a schema that matches a URL value, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.url_schema()\nv = SchemaValidator(schema)\nprint(v.validate_python('https://example.com'))\n#&gt; https://example.com/\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>max_length</code> <code>int | None</code> <p>The maximum length of the URL</p> <code>None</code> <code>allowed_schemes</code> <code>list[str] | None</code> <p>The allowed URL schemes</p> <code>None</code> <code>host_required</code> <code>bool | None</code> <p>Whether the URL must have a host</p> <code>None</code> <code>default_host</code> <code>str | None</code> <p>The default host to use if the URL does not have a host</p> <code>None</code> <code>default_port</code> <code>int | None</code> <p>The default port to use if the URL does not have a port</p> <code>None</code> <code>default_path</code> <code>str | None</code> <p>The default path to use if the URL does not have a path</p> <code>None</code> <code>preserve_empty_path</code> <code>bool | None</code> <p>Whether to preserve an empty path or convert it to '/', default False</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether to use strict URL parsing</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def url_schema(\n    *,\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    preserve_empty_path: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; UrlSchema:\n    \"\"\"\n    Returns a schema that matches a URL value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.url_schema()\n    v = SchemaValidator(schema)\n    print(v.validate_python('https://example.com'))\n    #&gt; https://example.com/\n    ```\n\n    Args:\n        max_length: The maximum length of the URL\n        allowed_schemes: The allowed URL schemes\n        host_required: Whether the URL must have a host\n        default_host: The default host to use if the URL does not have a host\n        default_port: The default port to use if the URL does not have a port\n        default_path: The default path to use if the URL does not have a path\n        preserve_empty_path: Whether to preserve an empty path or convert it to '/', default False\n        strict: Whether to use strict URL parsing\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='url',\n        max_length=max_length,\n        allowed_schemes=allowed_schemes,\n        host_required=host_required,\n        default_host=default_host,\n        default_port=default_port,\n        default_path=default_path,\n        preserve_empty_path=preserve_empty_path,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.multi_host_url_schema","title":"multi_host_url_schema","text":"<pre><code>multi_host_url_schema(*, max_length: int | None = None, allowed_schemes: list[str] | None = None, host_required: bool | None = None, default_host: str | None = None, default_port: int | None = None, default_path: str | None = None, preserve_empty_path: bool | None = None, strict: bool | None = None, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; MultiHostUrlSchema\n</code></pre> <p>Returns a schema that matches a URL value with possibly multiple hosts, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.multi_host_url_schema()\nv = SchemaValidator(schema)\nprint(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))\n#&gt; redis://localhost,0.0.0.0,127.0.0.1\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>max_length</code> <code>int | None</code> <p>The maximum length of the URL</p> <code>None</code> <code>allowed_schemes</code> <code>list[str] | None</code> <p>The allowed URL schemes</p> <code>None</code> <code>host_required</code> <code>bool | None</code> <p>Whether the URL must have a host</p> <code>None</code> <code>default_host</code> <code>str | None</code> <p>The default host to use if the URL does not have a host</p> <code>None</code> <code>default_port</code> <code>int | None</code> <p>The default port to use if the URL does not have a port</p> <code>None</code> <code>default_path</code> <code>str | None</code> <p>The default path to use if the URL does not have a path</p> <code>None</code> <code>preserve_empty_path</code> <code>bool | None</code> <p>Whether to preserve an empty path or convert it to '/', default False</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether to use strict URL parsing</p> <code>None</code> <code>ref</code> <code>str | None</code> <p>optional unique identifier of the schema, used to reference the schema in other places</p> <code>None</code> <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def multi_host_url_schema(\n    *,\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    preserve_empty_path: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; MultiHostUrlSchema:\n    \"\"\"\n    Returns a schema that matches a URL value with possibly multiple hosts, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.multi_host_url_schema()\n    v = SchemaValidator(schema)\n    print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))\n    #&gt; redis://localhost,0.0.0.0,127.0.0.1\n    ```\n\n    Args:\n        max_length: The maximum length of the URL\n        allowed_schemes: The allowed URL schemes\n        host_required: Whether the URL must have a host\n        default_host: The default host to use if the URL does not have a host\n        default_port: The default port to use if the URL does not have a port\n        default_path: The default path to use if the URL does not have a path\n        preserve_empty_path: Whether to preserve an empty path or convert it to '/', default False\n        strict: Whether to use strict URL parsing\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='multi-host-url',\n        max_length=max_length,\n        allowed_schemes=allowed_schemes,\n        host_required=host_required,\n        default_host=default_host,\n        default_port=default_port,\n        default_path=default_path,\n        preserve_empty_path=preserve_empty_path,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.definitions_schema","title":"definitions_schema","text":"<pre><code>definitions_schema(schema: CoreSchema, definitions: list[CoreSchema]) -&gt; DefinitionsSchema\n</code></pre> <p>Build a schema that contains both an inner schema and a list of definitions which can be used within the inner schema.</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema = core_schema.definitions_schema(\n    core_schema.list_schema(core_schema.definition_reference_schema('foobar')),\n    [core_schema.int_schema(ref='foobar')],\n)\nv = SchemaValidator(schema)\nassert v.validate_python([1, 2, '3']) == [1, 2, 3]\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema</code> <code>CoreSchema</code> <p>The inner schema</p> \u5fc5\u9700 <code>definitions</code> <code>list[CoreSchema]</code> <p>List of definitions which can be referenced within inner schema</p> \u5fc5\u9700 \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def definitions_schema(schema: CoreSchema, definitions: list[CoreSchema]) -&gt; DefinitionsSchema:\n    \"\"\"\n    Build a schema that contains both an inner schema and a list of definitions which can be used\n    within the inner schema.\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.definitions_schema(\n        core_schema.list_schema(core_schema.definition_reference_schema('foobar')),\n        [core_schema.int_schema(ref='foobar')],\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python([1, 2, '3']) == [1, 2, 3]\n    ```\n\n    Args:\n        schema: The inner schema\n        definitions: List of definitions which can be referenced within inner schema\n    \"\"\"\n    return DefinitionsSchema(type='definitions', schema=schema, definitions=definitions)\n</code></pre>"},{"location":"api/pydantic_core_schema/#pydantic_core.core_schema.definition_reference_schema","title":"definition_reference_schema","text":"<pre><code>definition_reference_schema(schema_ref: str, ref: str | None = None, metadata: dict[str, Any] | None = None, serialization: SerSchema | None = None) -&gt; DefinitionReferenceSchema\n</code></pre> <p>Returns a schema that points to a schema stored in \"definitions\", this is useful for nested recursive models and also when you want to define validators separately from the main schema, e.g.:</p> <pre><code>from pydantic_core import SchemaValidator, core_schema\n\nschema_definition = core_schema.definition_reference_schema('list-schema')\nschema = core_schema.definitions_schema(\n    schema=schema_definition,\n    definitions=[\n        core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),\n    ],\n)\nv = SchemaValidator(schema)\nassert v.validate_python([()]) == [[]]\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>schema_ref</code> <code>str</code> <p>The schema ref to use for the definition reference schema</p> \u5fc5\u9700 <code>metadata</code> <code>dict[str, Any] | None</code> <p>Any other information you want to include with the schema, not used by pydantic-core</p> <code>None</code> <code>serialization</code> <code>SerSchema | None</code> <p>Custom serialization schema</p> <code>None</code> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_core/core_schema.py</code> <pre><code>def definition_reference_schema(\n    schema_ref: str,\n    ref: str | None = None,\n    metadata: dict[str, Any] | None = None,\n    serialization: SerSchema | None = None,\n) -&gt; DefinitionReferenceSchema:\n    \"\"\"\n    Returns a schema that points to a schema stored in \"definitions\", this is useful for nested recursive\n    models and also when you want to define validators separately from the main schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema_definition = core_schema.definition_reference_schema('list-schema')\n    schema = core_schema.definitions_schema(\n        schema=schema_definition,\n        definitions=[\n            core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),\n        ],\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python([()]) == [[]]\n    ```\n\n    Args:\n        schema_ref: The schema ref to use for the definition reference schema\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='definition-ref', schema_ref=schema_ref, ref=ref, metadata=metadata, serialization=serialization\n    )\n</code></pre>"},{"location":"api/pydantic_extra_types_color/","title":"Color","text":"<p>Color definitions are used as per the CSS3 CSS Color Module Level 3 specification.</p> <p>A few colors have multiple names referring to the same colors, e.g. <code>grey</code> and <code>gray</code> or <code>aqua</code> and <code>cyan</code>.</p> <p>In these cases the last color when sorted alphabetically takes precedence. eg. <code>Color((0, 255, 255)).as_named() == 'cyan'</code> because \"cyan\" comes after \"aqua\".</p>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.RGBA","title":"RGBA","text":"<pre><code>RGBA(r: float, g: float, b: float, alpha: float | None)\n</code></pre> <p>Internal use only as a representation of a color.</p> Source code in <code>pydantic_extra_types/color.py</code> <pre><code>def __init__(self, r: float, g: float, b: float, alpha: float | None):\n    self.r = r\n    self.g = g\n    self.b = b\n    self.alpha = alpha\n\n    self._tuple: tuple[float, float, float, float | None] = (r, g, b, alpha)\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color","title":"Color","text":"<pre><code>Color(value: ColorType)\n</code></pre> <p>               Bases: <code>Representation</code></p> <p>Represents a color.</p> Source code in <code>pydantic_extra_types/color.py</code> <pre><code>def __init__(self, value: ColorType) -&gt; None:\n    self._rgba: RGBA\n    self._original: ColorType\n    if isinstance(value, (tuple, list)):\n        self._rgba = parse_tuple(value)\n    elif isinstance(value, str):\n        self._rgba = parse_str(value)\n    elif isinstance(value, Color):\n        self._rgba = value._rgba\n        value = value._original\n    else:\n        raise PydanticCustomError(\n            'color_error',\n            'value is not a valid color: value must be a tuple, list or string',\n        )\n\n    # if we've got here value must be a valid color\n    self._original = value\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.original","title":"original","text":"<pre><code>original() -&gt; ColorType\n</code></pre> <p>Original value passed to <code>Color</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def original(self) -&gt; ColorType:\n    \"\"\"Original value passed to `Color`.\"\"\"\n    return self._original\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.as_named","title":"as_named","text":"<pre><code>as_named(*, fallback: bool = False) -&gt; str\n</code></pre> <p>Returns the name of the color if it can be found in <code>COLORS_BY_VALUE</code> dictionary, otherwise returns the hexadecimal representation of the color or raises <code>ValueError</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>fallback</code> <code>bool</code> <p>If True, falls back to returning the hexadecimal representation of the color instead of raising a ValueError when no named color is found.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The name of the color, or the hexadecimal representation of the color.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValueError</code> <p>When no named color is found and fallback is <code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def as_named(self, *, fallback: bool = False) -&gt; str:\n    \"\"\"Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,\n    otherwise returns the hexadecimal representation of the color or raises `ValueError`.\n\n    Args:\n        fallback: If True, falls back to returning the hexadecimal representation of\n            the color instead of raising a ValueError when no named color is found.\n\n    Returns:\n        The name of the color, or the hexadecimal representation of the color.\n\n    Raises:\n        ValueError: When no named color is found and fallback is `False`.\n    \"\"\"\n    if self._rgba.alpha is not None:\n        return self.as_hex()\n    rgb = cast('tuple[int, int, int]', self.as_rgb_tuple())\n\n    if rgb in COLORS_BY_VALUE:\n        return COLORS_BY_VALUE[rgb]\n    else:\n        if fallback:\n            return self.as_hex()\n        else:\n            raise ValueError('no named color found, use fallback=True, as_hex() or as_rgb()')\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.as_hex","title":"as_hex","text":"<pre><code>as_hex(format: Literal['short', 'long'] = 'short') -&gt; str\n</code></pre> <p>Returns the hexadecimal representation of the color.</p> <p>Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string a \"short\" representation of the color is possible and whether there's an alpha channel.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The hexadecimal representation of the color.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def as_hex(self, format: Literal['short', 'long'] = 'short') -&gt; str:\n    \"\"\"Returns the hexadecimal representation of the color.\n\n    Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string\n    a \"short\" representation of the color is possible and whether there's an alpha channel.\n\n    Returns:\n        The hexadecimal representation of the color.\n    \"\"\"\n    values = [float_to_255(c) for c in self._rgba[:3]]\n    if self._rgba.alpha is not None:\n        values.append(float_to_255(self._rgba.alpha))\n\n    as_hex = ''.join(f'{v:02x}' for v in values)\n    if format == 'short' and all(c in repeat_colors for c in values):\n        as_hex = ''.join(as_hex[c] for c in range(0, len(as_hex), 2))\n    return f'#{as_hex}'\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.as_rgb","title":"as_rgb","text":"<pre><code>as_rgb() -&gt; str\n</code></pre> <p>Color as an <code>rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;)</code> or <code>rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)</code> string.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def as_rgb(self) -&gt; str:\n    \"\"\"Color as an `rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;)` or `rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)` string.\"\"\"\n    if self._rgba.alpha is None:\n        return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n    else:\n        return (\n            f'rgba({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)}, '\n            f'{round(self._alpha_float(), 2)})'\n        )\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.as_rgb_tuple","title":"as_rgb_tuple","text":"<pre><code>as_rgb_tuple(*, alpha: bool | None = None) -&gt; ColorTuple\n</code></pre> <p>Returns the color as an RGB or RGBA tuple.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>alpha</code> <code>bool | None</code> <p>Whether to include the alpha channel. There are three options for this input:</p> <ul> <li><code>None</code> (default): Include alpha only if it's set. (e.g. not <code>None</code>)</li> <li><code>True</code>: Always include alpha.</li> <li><code>False</code>: Always omit alpha.</li> </ul> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ColorTuple</code> <p>A tuple that contains the values of the red, green, and blue channels in the range 0 to 255. If alpha is included, it is in the range 0 to 1.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def as_rgb_tuple(self, *, alpha: bool | None = None) -&gt; ColorTuple:\n    \"\"\"Returns the color as an RGB or RGBA tuple.\n\n    Args:\n        alpha: Whether to include the alpha channel. There are three options for this input:\n\n            - `None` (default): Include alpha only if it's set. (e.g. not `None`)\n            - `True`: Always include alpha.\n            - `False`: Always omit alpha.\n\n    Returns:\n        A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.\n            If alpha is included, it is in the range 0 to 1.\n    \"\"\"\n    r, g, b = (float_to_255(c) for c in self._rgba[:3])\n    if alpha is None and self._rgba.alpha is None or alpha is not None and not alpha:\n        return r, g, b\n    else:\n        return r, g, b, self._alpha_float()\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.as_hsl","title":"as_hsl","text":"<pre><code>as_hsl() -&gt; str\n</code></pre> <p>Color as an <code>hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;)</code> or <code>hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;, &lt;a&gt;)</code> string.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def as_hsl(self) -&gt; str:\n    \"\"\"Color as an `hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;)` or `hsl(&lt;h&gt;, &lt;s&gt;, &lt;l&gt;, &lt;a&gt;)` string.\"\"\"\n    if self._rgba.alpha is None:\n        h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n        return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n    else:\n        h, s, li, a = self.as_hsl_tuple(alpha=True)  # type: ignore\n        return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%}, {round(a, 2)})'\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.Color.as_hsl_tuple","title":"as_hsl_tuple","text":"<pre><code>as_hsl_tuple(*, alpha: bool | None = None) -&gt; HslColorTuple\n</code></pre> <p>Returns the color as an HSL or HSLA tuple.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>alpha</code> <code>bool | None</code> <p>Whether to include the alpha channel.</p> <ul> <li><code>None</code> (default): Include the alpha channel only if it's set (e.g. not <code>None</code>).</li> <li><code>True</code>: Always include alpha.</li> <li><code>False</code>: Always omit alpha.</li> </ul> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>HslColorTuple</code> <p>The color as a tuple of hue, saturation, lightness, and alpha (if included). All elements are in the range 0 to 1.</p> Note <p>This is HSL as used in HTML and most other places, not HLS as used in Python's <code>colorsys</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def as_hsl_tuple(self, *, alpha: bool | None = None) -&gt; HslColorTuple:\n    \"\"\"Returns the color as an HSL or HSLA tuple.\n\n    Args:\n        alpha: Whether to include the alpha channel.\n\n            - `None` (default): Include the alpha channel only if it's set (e.g. not `None`).\n            - `True`: Always include alpha.\n            - `False`: Always omit alpha.\n\n    Returns:\n        The color as a tuple of hue, saturation, lightness, and alpha (if included).\n            All elements are in the range 0 to 1.\n\n    Note:\n        This is HSL as used in HTML and most other places, not HLS as used in Python's `colorsys`.\n    \"\"\"\n    h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)\n    if alpha is None:\n        if self._rgba.alpha is None:\n            return h, s, l\n        else:\n            return h, s, l, self._alpha_float()\n    return (h, s, l, self._alpha_float()) if alpha else (h, s, l)\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.parse_tuple","title":"parse_tuple","text":"<pre><code>parse_tuple(value: tuple[Any, ...]) -&gt; RGBA\n</code></pre> <p>Parse a tuple or list to get RGBA values.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>tuple[Any, ...]</code> <p>A tuple or list.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>RGBA</code> <p>An <code>RGBA</code> tuple parsed from the input tuple.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If tuple is not valid.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def parse_tuple(value: tuple[Any, ...]) -&gt; RGBA:\n    \"\"\"Parse a tuple or list to get RGBA values.\n\n    Args:\n        value: A tuple or list.\n\n    Returns:\n        An `RGBA` tuple parsed from the input tuple.\n\n    Raises:\n        PydanticCustomError: If tuple is not valid.\n    \"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[:3])\n        return RGBA(r, g, b, parse_float_alpha(value[3]))\n    else:\n        raise PydanticCustomError('color_error', 'value is not a valid color: tuples must have length 3 or 4')\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.parse_str","title":"parse_str","text":"<pre><code>parse_str(value: str) -&gt; RGBA\n</code></pre> <p>Parse a string representing a color to an RGBA tuple.</p> <p>Possible formats for the input string include:</p> <ul> <li>named color, see <code>COLORS_BY_NAME</code></li> <li>hex short eg. <code>&lt;prefix&gt;fff</code> (prefix can be <code>#</code>, <code>0x</code> or nothing)</li> <li>hex long eg. <code>&lt;prefix&gt;ffffff</code> (prefix can be <code>#</code>, <code>0x</code> or nothing)</li> <li><code>rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;)</code></li> <li><code>rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)</code></li> <li><code>transparent</code></li> </ul> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>str</code> <p>A string representing a color.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>RGBA</code> <p>An <code>RGBA</code> tuple parsed from the input string.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValueError</code> <p>If the input string cannot be parsed to an RGBA tuple.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def parse_str(value: str) -&gt; RGBA:\n    \"\"\"Parse a string representing a color to an RGBA tuple.\n\n    Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg. `&lt;prefix&gt;fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg. `&lt;prefix&gt;ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;)`\n    * `rgba(&lt;r&gt;, &lt;g&gt;, &lt;b&gt;, &lt;a&gt;)`\n    * `transparent`\n\n    Args:\n        value: A string representing a color.\n\n    Returns:\n        An `RGBA` tuple parsed from the input string.\n\n    Raises:\n        ValueError: If the input string cannot be parsed to an RGBA tuple.\n    \"\"\"\n    value_lower = value.lower()\n    if value_lower in COLORS_BY_NAME:\n        r, g, b = COLORS_BY_NAME[value_lower]\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(r_hex_short, value_lower)\n    if m:\n        *rgb, a = m.groups()\n        r, g, b = (int(v * 2, 16) for v in rgb)\n        alpha = int(a * 2, 16) / 255 if a else None\n        return ints_to_rgba(r, g, b, alpha)\n\n    m = re.fullmatch(r_hex_long, value_lower)\n    if m:\n        *rgb, a = m.groups()\n        r, g, b = (int(v, 16) for v in rgb)\n        alpha = int(a, 16) / 255 if a else None\n        return ints_to_rgba(r, g, b, alpha)\n\n    m = re.fullmatch(r_rgb, value_lower) or re.fullmatch(r_rgb_v4_style, value_lower)\n    if m:\n        return ints_to_rgba(*m.groups())  # type: ignore\n\n    m = re.fullmatch(r_hsl, value_lower) or re.fullmatch(r_hsl_v4_style, value_lower)\n    if m:\n        return parse_hsl(*m.groups())  # type: ignore\n\n    if value_lower == 'transparent':\n        return RGBA(0, 0, 0, 0)\n\n    raise PydanticCustomError(\n        'color_error',\n        'value is not a valid color: string not recognised as a valid color',\n    )\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.ints_to_rgba","title":"ints_to_rgba","text":"<pre><code>ints_to_rgba(r: int | str, g: int | str, b: int | str, alpha: float | None = None) -&gt; RGBA\n</code></pre> <p>Converts integer or string values for RGB color and an optional alpha value to an <code>RGBA</code> object.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>r</code> <code>int | str</code> <p>An integer or string representing the red color value.</p> \u5fc5\u9700 <code>g</code> <code>int | str</code> <p>An integer or string representing the green color value.</p> \u5fc5\u9700 <code>b</code> <code>int | str</code> <p>An integer or string representing the blue color value.</p> \u5fc5\u9700 <code>alpha</code> <code>float | None</code> <p>A float representing the alpha value. Defaults to None.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>RGBA</code> <p>An instance of the <code>RGBA</code> class with the corresponding color and alpha values.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def ints_to_rgba(\n    r: int | str,\n    g: int | str,\n    b: int | str,\n    alpha: float | None = None,\n) -&gt; RGBA:\n    \"\"\"Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object.\n\n    Args:\n        r: An integer or string representing the red color value.\n        g: An integer or string representing the green color value.\n        b: An integer or string representing the blue color value.\n        alpha: A float representing the alpha value. Defaults to None.\n\n    Returns:\n        An instance of the `RGBA` class with the corresponding color and alpha values.\n    \"\"\"\n    return RGBA(\n        parse_color_value(r),\n        parse_color_value(g),\n        parse_color_value(b),\n        parse_float_alpha(alpha),\n    )\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.parse_color_value","title":"parse_color_value","text":"<pre><code>parse_color_value(value: int | str, max_val: int = 255) -&gt; float\n</code></pre> <p>Parse the color value provided and return a number between 0 and 1.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>int | str</code> <p>An integer or string color value.</p> \u5fc5\u9700 <code>max_val</code> <code>int</code> <p>Maximum range value. Defaults to 255.</p> <code>255</code> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the value is not a valid color.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>float</code> <p>A number between 0 and 1.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def parse_color_value(value: int | str, max_val: int = 255) -&gt; float:\n    \"\"\"Parse the color value provided and return a number between 0 and 1.\n\n    Args:\n        value: An integer or string color value.\n        max_val: Maximum range value. Defaults to 255.\n\n    Raises:\n        PydanticCustomError: If the value is not a valid color.\n\n    Returns:\n        A number between 0 and 1.\n    \"\"\"\n    try:\n        color = float(value)\n    except (ValueError, TypeError) as e:\n        raise PydanticCustomError(\n            'color_error',\n            'value is not a valid color: color values must be a valid number',\n        ) from e\n    if 0 &lt;= color &lt;= max_val:\n        return color / max_val\n    else:\n        raise PydanticCustomError(\n            'color_error',\n            'value is not a valid color: color values must be in the range 0 to {max_val}',\n            {'max_val': max_val},\n        )\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.parse_float_alpha","title":"parse_float_alpha","text":"<pre><code>parse_float_alpha(value: None | str | float | int) -&gt; float | None\n</code></pre> <p>Parse an alpha value checking it's a valid float in the range 0 to 1.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>None | str | float | int</code> <p>The input value to parse.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>float | None</code> <p>The parsed value as a float, or <code>None</code> if the value was None or equal 1.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the input value cannot be successfully parsed as a float in the expected range.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def parse_float_alpha(value: None | str | float | int) -&gt; float | None:\n    \"\"\"Parse an alpha value checking it's a valid float in the range 0 to 1.\n\n    Args:\n        value: The input value to parse.\n\n    Returns:\n        The parsed value as a float, or `None` if the value was None or equal 1.\n\n    Raises:\n        PydanticCustomError: If the input value cannot be successfully parsed as a float in the expected range.\n    \"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(value)\n    except ValueError as e:\n        raise PydanticCustomError(\n            'color_error',\n            'value is not a valid color: alpha values must be a valid float',\n        ) from e\n\n    if math.isclose(alpha, 1):\n        return None\n    elif 0 &lt;= alpha &lt;= 1:\n        return alpha\n    else:\n        raise PydanticCustomError(\n            'color_error',\n            'value is not a valid color: alpha values must be in the range 0 to 1',\n        )\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.parse_hsl","title":"parse_hsl","text":"<pre><code>parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: float | None = None) -&gt; RGBA\n</code></pre> <p>Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>h</code> <code>str</code> <p>The hue value.</p> \u5fc5\u9700 <code>h_units</code> <code>str</code> <p>The unit for hue value.</p> \u5fc5\u9700 <code>sat</code> <code>str</code> <p>The saturation value.</p> \u5fc5\u9700 <code>light</code> <code>str</code> <p>The lightness value.</p> \u5fc5\u9700 <code>alpha</code> <code>float | None</code> <p>Alpha value.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>RGBA</code> <p>An instance of <code>RGBA</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: float | None = None) -&gt; RGBA:\n    \"\"\"Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.\n\n    Args:\n        h: The hue value.\n        h_units: The unit for hue value.\n        sat: The saturation value.\n        light: The lightness value.\n        alpha: Alpha value.\n\n    Returns:\n        An instance of `RGBA`.\n    \"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units == 'rad':\n        h_value = h_value % rads / rads\n    else:\n        # turns\n        h_value %= 1\n\n    r, g, b = hls_to_rgb(h_value, l_value, s_value)\n    return RGBA(r, g, b, parse_float_alpha(alpha))\n</code></pre>"},{"location":"api/pydantic_extra_types_color/#pydantic_extra_types.color.float_to_255","title":"float_to_255","text":"<pre><code>float_to_255(c: float) -&gt; int\n</code></pre> <p>Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>c</code> <code>float</code> <p>The float value to be converted. Must be between 0 and 1 (inclusive).</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>int</code> <p>The integer equivalent of the given float value rounded to the nearest whole number.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/color.py</code> <pre><code>def float_to_255(c: float) -&gt; int:\n    \"\"\"Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).\n\n    Args:\n        c: The float value to be converted. Must be between 0 and 1 (inclusive).\n\n    Returns:\n        The integer equivalent of the given float value rounded to the nearest whole number.\n    \"\"\"\n    return round(c * 255)\n</code></pre>"},{"location":"api/pydantic_extra_types_coordinate/","title":"Coordinate","text":"<p>The <code>pydantic_extra_types.coordinate</code> module provides the <code>Latitude</code>, <code>Longitude</code>, and <code>Coordinate</code> data types.</p>"},{"location":"api/pydantic_extra_types_coordinate/#pydantic_extra_types.coordinate.Latitude","title":"Latitude","text":"<p>               Bases: <code>float</code></p> <p>Latitude value should be between -90 and 90, inclusive.</p> <p>Supports both float and Decimal types.</p> <pre><code>from decimal import Decimal\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.coordinate import Latitude\n\n\nclass Location(BaseModel):\n    latitude: Latitude\n\n\n# Using float\nlocation1 = Location(latitude=41.40338)\n# Using Decimal\nlocation2 = Location(latitude=Decimal('41.40338'))\n</code></pre>"},{"location":"api/pydantic_extra_types_coordinate/#pydantic_extra_types.coordinate.Longitude","title":"Longitude","text":"<p>               Bases: <code>float</code></p> <p>Longitude value should be between -180 and 180, inclusive.</p> <p>Supports both float and Decimal types.</p> <pre><code>from decimal import Decimal\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.coordinate import Longitude\n\n\nclass Location(BaseModel):\n    longitude: Longitude\n\n\n# Using float\nlocation1 = Location(longitude=2.17403)\n# Using Decimal\nlocation2 = Location(longitude=Decimal('2.17403'))\n</code></pre>"},{"location":"api/pydantic_extra_types_coordinate/#pydantic_extra_types.coordinate.Coordinate","title":"Coordinate  <code>dataclass</code>","text":"<pre><code>Coordinate(latitude: Latitude, longitude: Longitude)\n</code></pre> <p>               Bases: <code>Representation</code></p> <p>Coordinate parses Latitude and Longitude.</p> <p>You can use the <code>Coordinate</code> data type for storing coordinates. Coordinates can be defined using one of the following formats:</p> <ol> <li>Tuple: <code>(Latitude, Longitude)</code>. For example: <code>(41.40338, 2.17403)</code> or <code>(Decimal('41.40338'), Decimal('2.17403'))</code>.</li> <li><code>Coordinate</code> instance: <code>Coordinate(latitude=Latitude, longitude=Longitude)</code>.</li> </ol> <pre><code>from decimal import Decimal\nfrom pydantic import BaseModel\n\nfrom pydantic_extra_types.coordinate import Coordinate\n\n\nclass Location(BaseModel):\n    coordinate: Coordinate\n\n\n# Using float values\nlocation1 = Location(coordinate=(41.40338, 2.17403))\n# &gt; coordinate=Coordinate(latitude=41.40338, longitude=2.17403)\n\n# Using Decimal values\nlocation2 = Location(coordinate=(Decimal('41.40338'), Decimal('2.17403')))\n# &gt; coordinate=Coordinate(latitude=41.40338, longitude=2.17403)\n</code></pre>"},{"location":"api/pydantic_extra_types_country/","title":"Country","text":"<p>Country definitions that are based on the ISO 3166.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha2","title":"CountryAlpha2","text":"<p>               Bases: <code>str</code></p> <p>CountryAlpha2 parses country codes in the ISO 3166-1 alpha-2 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryAlpha2\n\n\nclass Product(BaseModel):\n    made_in: CountryAlpha2\n\n\nproduct = Product(made_in='ES')\nprint(product)\n# &gt; made_in='ES'\n</code></pre>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha2.alpha3","title":"alpha3  <code>property</code>","text":"<pre><code>alpha3: str\n</code></pre> <p>The country code in the ISO 3166-1 alpha-3 format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha2.numeric_code","title":"numeric_code  <code>property</code>","text":"<pre><code>numeric_code: str\n</code></pre> <p>The country code in the ISO 3166-1 numeric format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha2.short_name","title":"short_name  <code>property</code>","text":"<pre><code>short_name: str\n</code></pre> <p>The country short name.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha3","title":"CountryAlpha3","text":"<p>               Bases: <code>str</code></p> <p>CountryAlpha3 parses country codes in the ISO 3166-1 alpha-3 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryAlpha3\n\n\nclass Product(BaseModel):\n    made_in: CountryAlpha3\n\n\nproduct = Product(made_in='USA')\nprint(product)\n# &gt; made_in='USA'\n</code></pre>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha3.alpha2","title":"alpha2  <code>property</code>","text":"<pre><code>alpha2: str\n</code></pre> <p>The country code in the ISO 3166-1 alpha-2 format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha3.numeric_code","title":"numeric_code  <code>property</code>","text":"<pre><code>numeric_code: str\n</code></pre> <p>The country code in the ISO 3166-1 numeric format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryAlpha3.short_name","title":"short_name  <code>property</code>","text":"<pre><code>short_name: str\n</code></pre> <p>The country short name.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryNumericCode","title":"CountryNumericCode","text":"<p>               Bases: <code>str</code></p> <p>CountryNumericCode parses country codes in the ISO 3166-1 numeric format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryNumericCode\n\n\nclass Product(BaseModel):\n    made_in: CountryNumericCode\n\n\nproduct = Product(made_in='840')\nprint(product)\n# &gt; made_in='840'\n</code></pre>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryNumericCode.alpha2","title":"alpha2  <code>property</code>","text":"<pre><code>alpha2: str\n</code></pre> <p>The country code in the ISO 3166-1 alpha-2 format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryNumericCode.alpha3","title":"alpha3  <code>property</code>","text":"<pre><code>alpha3: str\n</code></pre> <p>The country code in the ISO 3166-1 alpha-3 format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryNumericCode.short_name","title":"short_name  <code>property</code>","text":"<pre><code>short_name: str\n</code></pre> <p>The country short name.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryShortName","title":"CountryShortName","text":"<p>               Bases: <code>str</code></p> <p>CountryShortName parses country codes in the short name format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.country import CountryShortName\n\n\nclass Product(BaseModel):\n    made_in: CountryShortName\n\n\nproduct = Product(made_in='United States')\nprint(product)\n# &gt; made_in='United States'\n</code></pre>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryShortName.alpha2","title":"alpha2  <code>property</code>","text":"<pre><code>alpha2: str\n</code></pre> <p>The country code in the ISO 3166-1 alpha-2 format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryShortName.alpha3","title":"alpha3  <code>property</code>","text":"<pre><code>alpha3: str\n</code></pre> <p>The country code in the ISO 3166-1 alpha-3 format.</p>"},{"location":"api/pydantic_extra_types_country/#pydantic_extra_types.country.CountryShortName.numeric_code","title":"numeric_code  <code>property</code>","text":"<pre><code>numeric_code: str\n</code></pre> <p>The country code in the ISO 3166-1 numeric format.</p>"},{"location":"api/pydantic_extra_types_currency_code/","title":"Currency","text":"<p>Currency definitions that are based on the ISO4217.</p>"},{"location":"api/pydantic_extra_types_currency_code/#pydantic_extra_types.currency_code.ISO4217","title":"ISO4217","text":"<p>               Bases: <code>str</code></p> <p>ISO4217 parses Currency in the ISO 4217 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.currency_code import ISO4217\n\n\nclass Currency(BaseModel):\n    alpha_3: ISO4217\n\n\ncurrency = Currency(alpha_3='AED')\nprint(currency)\n# &gt; alpha_3='AED'\n</code></pre>"},{"location":"api/pydantic_extra_types_currency_code/#pydantic_extra_types.currency_code.Currency","title":"Currency","text":"<p>               Bases: <code>str</code></p> <p>Currency parses currency subset of the ISO 4217 format. It excludes bonds testing codes and precious metals.     <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.currency_code import Currency\n\n\nclass currency(BaseModel):\n    alpha_3: Currency\n\n\ncur = currency(alpha_3='AED')\nprint(cur)\n# &gt; alpha_3='AED'\n</code></pre></p>"},{"location":"api/pydantic_extra_types_isbn/","title":"ISBN","text":"<p>The <code>pydantic_extra_types.isbn</code> module provides functionality to receive and validate ISBN.</p> <p>ISBN (International Standard Book Number) is a numeric commercial book identifier which is intended to be unique. This module provides an ISBN type for Pydantic models.</p>"},{"location":"api/pydantic_extra_types_isbn/#pydantic_extra_types.isbn.ISBN","title":"ISBN","text":"<p>               Bases: <code>str</code></p> <p>Represents a ISBN and provides methods for conversion, validation, and serialization.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.isbn import ISBN\n\n\nclass Book(BaseModel):\n    isbn: ISBN\n\n\nbook = Book(isbn='8537809667')\nprint(book)\n# &gt; isbn='9788537809662'\n</code></pre>"},{"location":"api/pydantic_extra_types_isbn/#pydantic_extra_types.isbn.ISBN.validate_isbn_format","title":"validate_isbn_format  <code>staticmethod</code>","text":"<pre><code>validate_isbn_format(value: str) -&gt; None\n</code></pre> <p>Validate a ISBN format from the provided str value.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>str</code> <p>The str value representing the ISBN in 10 or 13 digits.</p> \u5fc5\u9700 <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the ISBN is not valid.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/isbn.py</code> <pre><code>@staticmethod\ndef validate_isbn_format(value: str) -&gt; None:\n    \"\"\"Validate a ISBN format from the provided str value.\n\n    Args:\n        value: The str value representing the ISBN in 10 or 13 digits.\n\n    Raises:\n        PydanticCustomError: If the ISBN is not valid.\n    \"\"\"\n    isbn_length = len(value)\n\n    if isbn_length not in (10, 13):\n        raise PydanticCustomError('isbn_length', f'Length for ISBN must be 10 or 13 digits, not {isbn_length}')\n\n    if isbn_length == 10:\n        if not value[:-1].isdigit() or ((value[-1] != 'X') and (not value[-1].isdigit())):\n            raise PydanticCustomError('isbn10_invalid_characters', 'First 9 digits of ISBN-10 must be integers')\n        if isbn10_digit_calc(value) != value[-1]:\n            raise PydanticCustomError('isbn_invalid_digit_check_isbn10', 'Provided digit is invalid for given ISBN')\n\n    if isbn_length == 13:\n        if not value.isdigit():\n            raise PydanticCustomError('isbn13_invalid_characters', 'All digits of ISBN-13 must be integers')\n        if value[:3] not in ('978', '979'):\n            raise PydanticCustomError(\n                'isbn_invalid_early_characters', 'The first 3 digits of ISBN-13 must be 978 or 979'\n            )\n        if isbn13_digit_calc(value) != value[-1]:\n            raise PydanticCustomError('isbn_invalid_digit_check_isbn13', 'Provided digit is invalid for given ISBN')\n</code></pre>"},{"location":"api/pydantic_extra_types_isbn/#pydantic_extra_types.isbn.ISBN.convert_isbn10_to_isbn13","title":"convert_isbn10_to_isbn13  <code>staticmethod</code>","text":"<pre><code>convert_isbn10_to_isbn13(value: str) -&gt; str\n</code></pre> <p>Convert an ISBN-10 to ISBN-13.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>str</code> <p>The ISBN-10 value to be converted.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The converted ISBN or the original value if no conversion is necessary.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/isbn.py</code> <pre><code>@staticmethod\ndef convert_isbn10_to_isbn13(value: str) -&gt; str:\n    \"\"\"Convert an ISBN-10 to ISBN-13.\n\n    Args:\n        value: The ISBN-10 value to be converted.\n\n    Returns:\n        The converted ISBN or the original value if no conversion is necessary.\n    \"\"\"\n    if len(value) == 10:\n        base_isbn = f'978{value[:-1]}'\n        isbn13_digit = isbn13_digit_calc(base_isbn)\n        return ISBN(f'{base_isbn}{isbn13_digit}')\n\n    return ISBN(value)\n</code></pre>"},{"location":"api/pydantic_extra_types_isbn/#pydantic_extra_types.isbn.isbn10_digit_calc","title":"isbn10_digit_calc","text":"<pre><code>isbn10_digit_calc(isbn: str) -&gt; str\n</code></pre> <p>Calculate the ISBN-10 check digit from the provided str value. More information on the validation algorithm on Wikipedia</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>isbn</code> <code>str</code> <p>The str value representing the ISBN in 10 digits.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The calculated last digit of the ISBN-10 value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/isbn.py</code> <pre><code>def isbn10_digit_calc(isbn: str) -&gt; str:\n    \"\"\"Calculate the ISBN-10 check digit from the provided str value. More information on the validation algorithm on [Wikipedia](https://en.wikipedia.org/wiki/ISBN#Check_digits)\n\n    Args:\n        isbn: The str value representing the ISBN in 10 digits.\n\n    Returns:\n        The calculated last digit of the ISBN-10 value.\n    \"\"\"\n    total = sum(int(digit) * (10 - idx) for idx, digit in enumerate(isbn[:9]))\n    diff = (11 - total) % 11\n    valid_check_digit = 'X' if diff == 10 else str(diff)\n    return valid_check_digit\n</code></pre>"},{"location":"api/pydantic_extra_types_isbn/#pydantic_extra_types.isbn.isbn13_digit_calc","title":"isbn13_digit_calc","text":"<pre><code>isbn13_digit_calc(isbn: str) -&gt; str\n</code></pre> <p>Calc a ISBN-13 last digit from the provided str value. More information on the validation algorithm on Wikipedia</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>isbn</code> <code>str</code> <p>The str value representing the ISBN in 13 digits.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The calculated last digit of the ISBN-13 value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/isbn.py</code> <pre><code>def isbn13_digit_calc(isbn: str) -&gt; str:\n    \"\"\"Calc a ISBN-13 last digit from the provided str value. More information on the validation algorithm on [Wikipedia](https://en.wikipedia.org/wiki/ISBN#Check_digits)\n\n    Args:\n        isbn: The str value representing the ISBN in 13 digits.\n\n    Returns:\n        The calculated last digit of the ISBN-13 value.\n    \"\"\"\n    total = sum(int(digit) * factor for digit, factor in zip(isbn[:12], it.cycle((1, 3))))\n\n    check_digit = (10 - total) % 10\n\n    return str(check_digit)\n</code></pre>"},{"location":"api/pydantic_extra_types_language_code/","title":"Language","text":"<p>Language definitions that are based on the ISO 639-3 &amp; ISO 639-5.</p>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageInfo","title":"LanguageInfo  <code>dataclass</code>","text":"<pre><code>LanguageInfo(alpha2: Union[str, None], alpha3: str, name: str)\n</code></pre> <p>LanguageInfo is a dataclass that contains the language information.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>alpha2</code> <code>Union[str, None]</code> <p>The language code in the ISO 639-1 alpha-2 format.</p> \u5fc5\u9700 <code>alpha3</code> <code>str</code> <p>The language code in the ISO 639-3 alpha-3 format.</p> \u5fc5\u9700 <code>name</code> <code>str</code> <p>The language name.</p> \u5fc5\u9700"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageAlpha2","title":"LanguageAlpha2","text":"<p>               Bases: <code>str</code></p> <p>LanguageAlpha2 parses languages codes in the ISO 639-1 alpha-2 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import LanguageAlpha2\n\n\nclass Movie(BaseModel):\n    audio_lang: LanguageAlpha2\n    subtitles_lang: LanguageAlpha2\n\n\nmovie = Movie(audio_lang='de', subtitles_lang='fr')\nprint(movie)\n# &gt; audio_lang='de' subtitles_lang='fr'\n</code></pre>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageAlpha2.alpha3","title":"alpha3  <code>property</code>","text":"<pre><code>alpha3: str\n</code></pre> <p>The language code in the ISO 639-3 alpha-3 format.</p>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageAlpha2.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The language name.</p>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageName","title":"LanguageName","text":"<p>               Bases: <code>str</code></p> <p>LanguageName parses languages names listed in the ISO 639-3 standard format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import LanguageName\n\n\nclass Movie(BaseModel):\n    audio_lang: LanguageName\n    subtitles_lang: LanguageName\n\n\nmovie = Movie(audio_lang='Dutch', subtitles_lang='Mandarin Chinese')\nprint(movie)\n# &gt; audio_lang='Dutch' subtitles_lang='Mandarin Chinese'\n</code></pre>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageName.alpha2","title":"alpha2  <code>property</code>","text":"<pre><code>alpha2: Union[str, None]\n</code></pre> <p>The language code in the ISO 639-1 alpha-2 format. Does not exist for all languages.</p>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.LanguageName.alpha3","title":"alpha3  <code>property</code>","text":"<pre><code>alpha3: str\n</code></pre> <p>The language code in the ISO 639-3 alpha-3 format.</p>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.ISO639_3","title":"ISO639_3","text":"<p>               Bases: <code>str</code></p> <p>ISO639_3 parses Language in the ISO 639-3 alpha-3 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import ISO639_3\n\n\nclass Language(BaseModel):\n    alpha_3: ISO639_3\n\n\nlang = Language(alpha_3='ssr')\nprint(lang)\n# &gt; alpha_3='ssr'\n</code></pre>"},{"location":"api/pydantic_extra_types_language_code/#pydantic_extra_types.language_code.ISO639_5","title":"ISO639_5","text":"<p>               Bases: <code>str</code></p> <p>ISO639_5 parses Language in the ISO 639-5 alpha-3 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import ISO639_5\n\n\nclass Language(BaseModel):\n    alpha_3: ISO639_5\n\n\nlang = Language(alpha_3='gem')\nprint(lang)\n# &gt; alpha_3='gem'\n</code></pre>"},{"location":"api/pydantic_extra_types_mac_address/","title":"Mac Address","text":"<p>The MAC address module provides functionality to parse and validate MAC addresses in different formats, such as IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet format.</p>"},{"location":"api/pydantic_extra_types_mac_address/#pydantic_extra_types.mac_address.MacAddress","title":"MacAddress","text":"<p>               Bases: <code>str</code></p> <p>Represents a MAC address and provides methods for conversion, validation, and serialization.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.mac_address import MacAddress\n\n\nclass Network(BaseModel):\n    mac_address: MacAddress\n\n\nnetwork = Network(mac_address='00:00:5e:00:53:01')\nprint(network)\n# &gt; mac_address='00:00:5e:00:53:01'\n</code></pre>"},{"location":"api/pydantic_extra_types_mac_address/#pydantic_extra_types.mac_address.MacAddress.validate_mac_address","title":"validate_mac_address  <code>staticmethod</code>","text":"<pre><code>validate_mac_address(value: bytes) -&gt; str\n</code></pre> <p>Validate a MAC Address from the provided byte value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/mac_address.py</code> <pre><code>@staticmethod\ndef validate_mac_address(value: bytes) -&gt; str:\n    \"\"\"Validate a MAC Address from the provided byte value.\"\"\"\n    raw = value.decode()\n    if len(raw) &lt; MINIMUM_LENGTH:\n        raise PydanticCustomError(\n            'mac_address_len',\n            'Length for a {mac_address} MAC address must be {required_length}',\n            {'mac_address': raw, 'required_length': MINIMUM_LENGTH},\n        )\n\n    for seperator, chunk_len in ((':', 2), ('-', 2), ('.', 4)):\n        if seperator not in raw:\n            continue\n\n        parts = raw.split(seperator)\n        if any(len(p) != chunk_len for p in parts):\n            raise PydanticCustomError(\n                'mac_address_format',\n                f'Must have the format xx{seperator}xx{seperator}xx{seperator}xx{seperator}xx{seperator}xx',\n            )\n\n        total_bytes = (len(parts) * chunk_len) // 2\n        if total_bytes not in ALLOWED_CHUNK_COUNTS:\n            raise PydanticCustomError(\n                'mac_address_format',\n                'Length for a {mac_address} MAC address must be {required_length}',\n                {'mac_address': raw, 'required_length': ALLOWED_CHUNK_COUNTS},\n            )\n\n        try:\n            mac_bytes: list[int] = []\n            for part in parts:\n                for i in range(0, chunk_len, 2):\n                    mac_bytes.append(int(part[i : i + 2], base=16))\n        except ValueError as exc:\n            raise PydanticCustomError('mac_address_format', 'Unrecognized format') from exc\n\n        return ':'.join(f'{b:02x}' for b in mac_bytes)\n\n    raise PydanticCustomError('mac_address_format', 'Unrecognized format')\n</code></pre>"},{"location":"api/pydantic_extra_types_payment/","title":"Payment","text":"<p>The <code>pydantic_extra_types.payment</code> module provides the <code>PaymentCardNumber</code> data type.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardBrand","title":"PaymentCardBrand","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Payment card brands supported by the <code>PaymentCardNumber</code>.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber","title":"PaymentCardNumber","text":"<pre><code>PaymentCardNumber(card_number: str)\n</code></pre> <p>               Bases: <code>str</code></p> <p>A payment card number.</p> Source code in <code>pydantic_extra_types/payment.py</code> <pre><code>def __init__(self, card_number: str):\n    self.validate_digits(card_number)\n\n    card_number = self.validate_luhn_check_digit(card_number)\n\n    self.bin = card_number[:6]\n    self.last4 = card_number[-4:]\n    self.brand = self.validate_brand(card_number)\n</code></pre>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.strip_whitespace","title":"strip_whitespace  <code>class-attribute</code>","text":"<pre><code>strip_whitespace: bool = True\n</code></pre> <p>Whether to strip whitespace from the input value.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.min_length","title":"min_length  <code>class-attribute</code>","text":"<pre><code>min_length: int = 12\n</code></pre> <p>The minimum length of the card number.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.max_length","title":"max_length  <code>class-attribute</code>","text":"<pre><code>max_length: int = 19\n</code></pre> <p>The maximum length of the card number.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.bin","title":"bin  <code>instance-attribute</code>","text":"<pre><code>bin: str = card_number[:6]\n</code></pre> <p>The first 6 digits of the card number.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.last4","title":"last4  <code>instance-attribute</code>","text":"<pre><code>last4: str = card_number[(-4):]\n</code></pre> <p>The last 4 digits of the card number.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.brand","title":"brand  <code>instance-attribute</code>","text":"<pre><code>brand: PaymentCardBrand = validate_brand(card_number)\n</code></pre> <p>The brand of the card.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.masked","title":"masked  <code>property</code>","text":"<pre><code>masked: str\n</code></pre> <p>The masked card number.</p>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(__input_value: str, _: ValidationInfo) -&gt; PaymentCardNumber\n</code></pre> <p>Validate the <code>PaymentCardNumber</code> instance.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>__input_value</code> <code>str</code> <p>The input value to validate.</p> \u5fc5\u9700 <code>_</code> <code>ValidationInfo</code> <p>The validation info.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PaymentCardNumber</code> <p>The validated <code>PaymentCardNumber</code> instance.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/payment.py</code> <pre><code>@classmethod\ndef validate(cls, __input_value: str, _: core_schema.ValidationInfo) -&gt; PaymentCardNumber:\n    \"\"\"Validate the `PaymentCardNumber` instance.\n\n    Args:\n        __input_value: The input value to validate.\n        _: The validation info.\n\n    Returns:\n        The validated `PaymentCardNumber` instance.\n    \"\"\"\n    return cls(__input_value)\n</code></pre>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.validate_digits","title":"validate_digits  <code>classmethod</code>","text":"<pre><code>validate_digits(card_number: str) -&gt; None\n</code></pre> <p>Validate that the card number is all digits.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>card_number</code> <code>str</code> <p>The card number to validate.</p> \u5fc5\u9700 <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the card number is not all digits.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/payment.py</code> <pre><code>@classmethod\ndef validate_digits(cls, card_number: str) -&gt; None:\n    \"\"\"Validate that the card number is all digits.\n\n    Args:\n        card_number: The card number to validate.\n\n    Raises:\n        PydanticCustomError: If the card number is not all digits.\n    \"\"\"\n    if not card_number or not all('0' &lt;= c &lt;= '9' for c in card_number):\n        raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits')\n</code></pre>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.validate_luhn_check_digit","title":"validate_luhn_check_digit  <code>classmethod</code>","text":"<pre><code>validate_luhn_check_digit(card_number: str) -&gt; str\n</code></pre> <p>Validate the payment card number. Based on the Luhn algorithm.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>card_number</code> <code>str</code> <p>The card number to validate.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The validated card number.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the card number is not valid.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/payment.py</code> <pre><code>@classmethod\ndef validate_luhn_check_digit(cls, card_number: str) -&gt; str:\n    \"\"\"Validate the payment card number.\n    Based on the [Luhn algorithm](https://en.wikipedia.org/wiki/Luhn_algorithm).\n\n    Args:\n        card_number: The card number to validate.\n\n    Returns:\n        The validated card number.\n\n    Raises:\n        PydanticCustomError: If the card number is not valid.\n    \"\"\"\n    sum_ = int(card_number[-1])\n    length = len(card_number)\n    parity = length % 2\n    for i in range(length - 1):\n        digit = int(card_number[i])\n        if i % 2 == parity:\n            digit *= 2\n        if digit &gt; 9:\n            digit -= 9\n        sum_ += digit\n    valid = sum_ % 10 == 0\n    if not valid:\n        raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')\n    return card_number\n</code></pre>"},{"location":"api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.validate_brand","title":"validate_brand  <code>staticmethod</code>","text":"<pre><code>validate_brand(card_number: str) -&gt; PaymentCardBrand\n</code></pre> <p>Validate length based on BIN for major brands.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>card_number</code> <code>str</code> <p>The card number to validate.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PaymentCardBrand</code> <p>The validated card brand.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticCustomError</code> <p>If the card number is not valid.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/payment.py</code> <pre><code>@staticmethod\ndef validate_brand(card_number: str) -&gt; PaymentCardBrand:\n    \"\"\"Validate length based on\n    [BIN](https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN))\n    for major brands.\n\n    Args:\n        card_number: The card number to validate.\n\n    Returns:\n        The validated card brand.\n\n    Raises:\n        PydanticCustomError: If the card number is not valid.\n    \"\"\"\n    brand, required_length = PaymentCardNumber._identify_brand(card_number)\n\n    valid = len(card_number) in required_length if brand != PaymentCardBrand.other else True\n\n    if not valid:\n        raise PydanticCustomError(\n            'payment_card_number_brand',\n            f'Length for a {brand} card must be {\" or \".join(map(str, required_length))}',\n            {'brand': brand, 'required_length': required_length},\n        )\n\n    return brand\n</code></pre>"},{"location":"api/pydantic_extra_types_pendulum_dt/","title":"Pendulum","text":"<p>Native Pendulum DateTime object implementation. This is a copy of the Pendulum DateTime object, but with a Pydantic CoreSchema implementation. This allows Pydantic to validate the DateTime object.</p>"},{"location":"api/pydantic_extra_types_pendulum_dt/#pydantic_extra_types.pendulum_dt.DateTime","title":"DateTime","text":"<p>               Bases: <code>DateTime</code></p> <p>A <code>pendulum.DateTime</code> object. At runtime, this type decomposes into pendulum.DateTime automatically. This type exists because Pydantic throws a fit on unknown types.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import DateTime\n\n\nclass test_model(BaseModel):\n    dt: DateTime\n\n\nprint(test_model(dt='2021-01-01T00:00:00+00:00'))\n\n# &gt; test_model(dt=DateTime(2021, 1, 1, 0, 0, 0, tzinfo=FixedTimezone(0, name=\"+00:00\")))\n</code></pre>"},{"location":"api/pydantic_extra_types_pendulum_dt/#pydantic_extra_types.pendulum_dt.Time","title":"Time","text":"<p>               Bases: <code>Time</code></p> <p>A <code>pendulum.Time</code> object. At runtime, this type decomposes into pendulum.Time automatically. This type exists because Pydantic throws a fit on unknown types.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import Time\n\n\nclass test_model(BaseModel):\n    dt: Time\n\n\nprint(test_model(dt='00:00:00'))\n\n# &gt; test_model(dt=Time(0, 0, 0))\n</code></pre>"},{"location":"api/pydantic_extra_types_pendulum_dt/#pydantic_extra_types.pendulum_dt.Date","title":"Date","text":"<p>               Bases: <code>Date</code></p> <p>A <code>pendulum.Date</code> object. At runtime, this type decomposes into pendulum.Date automatically. This type exists because Pydantic throws a fit on unknown types.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import Date\n\n\nclass test_model(BaseModel):\n    dt: Date\n\n\nprint(test_model(dt='2021-01-01'))\n\n# &gt; test_model(dt=Date(2021, 1, 1))\n</code></pre>"},{"location":"api/pydantic_extra_types_pendulum_dt/#pydantic_extra_types.pendulum_dt.Duration","title":"Duration","text":"<p>               Bases: <code>Duration</code></p> <p>A <code>pendulum.Duration</code> object. At runtime, this type decomposes into pendulum.Duration automatically. This type exists because Pydantic throws a fit on unknown types.</p> <pre><code>from pydantic import BaseModel\nfrom pydantic_extra_types.pendulum_dt import Duration\n\n\nclass test_model(BaseModel):\n    delta_t: Duration\n\n\nprint(test_model(delta_t='P1DT25H'))\n\n# &gt; test_model(delta_t=Duration(days=2, hours=1))\n</code></pre>"},{"location":"api/pydantic_extra_types_pendulum_dt/#pydantic_extra_types.pendulum_dt.Duration.to_iso8601_string","title":"to_iso8601_string","text":"<pre><code>to_iso8601_string() -&gt; str\n</code></pre> <p>Convert a Duration object to an ISO 8601 string.</p> <p>In addition to the standard ISO 8601 format, this method also supports the representation of fractions of a second and negative durations.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The ISO 8601 string representation of the duration.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/pendulum_dt.py</code> <pre><code>def to_iso8601_string(self) -&gt; str:\n    \"\"\"\n    Convert a Duration object to an ISO 8601 string.\n\n    In addition to the standard ISO 8601 format, this method also supports the representation of fractions of a second and negative durations.\n\n    Returns:\n        The ISO 8601 string representation of the duration.\n    \"\"\"\n    # Extracting components from the Duration object\n    years = self.years\n    months = self.months\n    days = self._days\n    hours = self.hours\n    minutes = self.minutes\n    seconds = self.remaining_seconds\n    milliseconds = self.microseconds // 1000\n    microseconds = self.microseconds % 1000\n\n    # Constructing the ISO 8601 duration string\n    iso_duration = 'P'\n    if years or months or days:\n        if years:\n            iso_duration += f'{years}Y'\n        if months:\n            iso_duration += f'{months}M'\n        if days:\n            iso_duration += f'{days}D'\n\n    if hours or minutes or seconds or milliseconds or microseconds:\n        iso_duration += 'T'\n        if hours:\n            iso_duration += f'{hours}H'\n        if minutes:\n            iso_duration += f'{minutes}M'\n        if seconds or milliseconds or microseconds:\n            iso_duration += f'{seconds}'\n            if milliseconds or microseconds:\n                iso_duration += f'.{milliseconds:03d}'\n            if microseconds:\n                iso_duration += f'{microseconds:03d}'\n            iso_duration += 'S'\n\n    # Prefix with '-' if the duration is negative\n    if self.total_seconds() &lt; 0:\n        iso_duration = '-' + iso_duration\n\n    if iso_duration == 'P':\n        iso_duration = 'P0D'\n\n    return iso_duration\n</code></pre>"},{"location":"api/pydantic_extra_types_phone_numbers/","title":"Phone Numbers","text":"<p>The <code>pydantic_extra_types.phone_numbers</code> module provides the <code>PhoneNumber</code> data type.</p> <p>This class depends on the phonenumbers package, which is a Python port of Google's libphonenumber.</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber","title":"PhoneNumber","text":"<p>               Bases: <code>str</code></p> <p>A wrapper around the <code>phonenumbers.PhoneNumber</code> object.</p> <p>It provides class-level configuration points you can change by subclassing:</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber--examples","title":"Examples","text":""},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber--normal-usage","title":"Normal usage:","text":"<pre><code>    from pydantic import BaseModel\n    from pydantic_extra_types.phone_numbers import PhoneNumber\n\n    class Contact(BaseModel):\n        name: str\n        phone: PhoneNumber\n\n    c = Contact(name='Alice', phone='+1 650-253-0000')\n    print(c.phone)\n    &gt;&gt; tel:+1-650-253-0000 (formatted using RFC3966 by default)\n</code></pre>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber--changing-defaults-by-subclassing","title":"Changing defaults by subclassing:","text":"<pre><code>    from pydantic_extra_types.phone_numbers import PhoneNumber\n\n    class USPhone(PhoneNumber):\n        default_region_code = 'US'\n        supported_regions = ['US']\n        phone_format = 'NATIONAL'\n\n    # Now parsing will accept national numbers for the US\n    p = USPhone('650-253-0000')\n    print(p)\n    &gt;&gt; 650-253-0000\n</code></pre>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber--changing-defaults-by-using-the-provided-validator-annotation","title":"Changing defaults by using the provided validator annotation:","text":"<pre><code>    from typing import Annotated, Union\n    import phonenumbers\n    from pydantic import BaseModel\n    from pydantic_extra_types.phone_numbers import PhoneNumberValidator\n\n    E164NumberType = Annotated[\n        Union[str, phonenumbers.PhoneNumber], PhoneNumberValidator(number_format=\"E164\")\n    ]\n\n\n    class Model(BaseModel):\n        phone: E164NumberType\n\n\n    m = Model(phone=\"+1 650-253-0000\")\n    print(m.phone)\n    &gt;&gt; +16502530000\n</code></pre>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber.default_region_code","title":"default_region_code  <code>class-attribute</code>","text":"<pre><code>default_region_code: str | None = None\n</code></pre> <p>The default region code to use when parsing phone numbers without an international prefix.</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber.supported_regions","title":"supported_regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_regions: list[str] = []\n</code></pre> <p>The supported regions. If empty, all regions are supported.</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumber.phone_format","title":"phone_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phone_format: str = 'RFC3966'\n</code></pre> <p>The format of the phone number.</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumberValidator","title":"PhoneNumberValidator  <code>dataclass</code>","text":"<pre><code>PhoneNumberValidator(default_region: str | None = None, number_format: str = 'RFC3966', supported_regions: Sequence[str] | None = None)\n</code></pre> <p>An annotation to validate <code>phonenumbers.PhoneNumber</code> objects.</p> Example <pre><code>from typing import Annotated, Union\n\nimport phonenumbers\nfrom pydantic import BaseModel\nfrom pydantic_extra_types.phone_numbers import PhoneNumberValidator\n\nMyNumberType = Annotated[Union[str, phonenumbers.PhoneNumber], PhoneNumberValidator()]\n\nUSNumberType = Annotated[\n    Union[str, phonenumbers.PhoneNumber], PhoneNumberValidator(supported_regions=['US'], default_region='US')\n]\n\n\nclass SomeModel(BaseModel):\n    phone_number: MyNumberType\n    us_number: USNumberType\n</code></pre>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumberValidator.default_region","title":"default_region  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>default_region: str | None = None\n</code></pre> <p>The default region code to use when parsing phone numbers without an international prefix.</p> <p>If <code>None</code> (the default), the region must be supplied in the phone number as an international prefix.</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumberValidator.number_format","title":"number_format  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>number_format: str = 'RFC3966'\n</code></pre> <p>The format of the phone number to return. See <code>phonenumbers.PhoneNumberFormat</code> for valid values.</p>"},{"location":"api/pydantic_extra_types_phone_numbers/#pydantic_extra_types.phone_numbers.PhoneNumberValidator.supported_regions","title":"supported_regions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>supported_regions: Sequence[str] | None = None\n</code></pre> <p>The supported regions. If empty (the default), all regions are supported.</p>"},{"location":"api/pydantic_extra_types_routing_numbers/","title":"Routing Numbers","text":"<p>The <code>pydantic_extra_types.routing_number</code> module provides the <code>ABARoutingNumber</code> data type.</p>"},{"location":"api/pydantic_extra_types_routing_numbers/#pydantic_extra_types.routing_number.ABARoutingNumber","title":"ABARoutingNumber","text":"<pre><code>ABARoutingNumber(routing_number: str)\n</code></pre> <p>               Bases: <code>str</code></p> <p>The <code>ABARoutingNumber</code> data type is a string of 9 digits representing an ABA routing transit number.</p> <p>The algorithm used to validate the routing number is described in the ABA routing transit number Wikipedia article.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.routing_number import ABARoutingNumber\n\n\nclass BankAccount(BaseModel):\n    routing_number: ABARoutingNumber\n\n\naccount = BankAccount(routing_number='122105155')\nprint(account)\n# &gt; routing_number='122105155'\n</code></pre> Source code in <code>pydantic_extra_types/routing_number.py</code> <pre><code>def __init__(self, routing_number: str):\n    self._validate_digits(routing_number)\n    self._routing_number = self._validate_routing_number(routing_number)\n</code></pre>"},{"location":"api/pydantic_extra_types_script_code/","title":"Script Code","text":"<p>script definitions that are based on the ISO 15924</p>"},{"location":"api/pydantic_extra_types_script_code/#pydantic_extra_types.script_code.ISO_15924","title":"ISO_15924","text":"<p>               Bases: <code>str</code></p> <p>ISO_15924 parses script in the ISO 15924 format.</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_extra_types.language_code import ISO_15924\n\n\nclass Script(BaseModel):\n    alpha_4: ISO_15924\n\n\nscript = Script(alpha_4='Java')\nprint(lang)\n# &gt; script='Java'\n</code></pre>"},{"location":"api/pydantic_extra_types_semantic_version/","title":"Semantic Version","text":"<p>SemanticVersion definition that is based on the Semantiv Versioning Specification semver.</p>"},{"location":"api/pydantic_extra_types_semantic_version/#pydantic_extra_types.semantic_version.SemanticVersion","title":"SemanticVersion","text":"<p>               Bases: <code>Version</code></p> <p>Semantic version based on the official semver thread.</p>"},{"location":"api/pydantic_extra_types_timezone_name/","title":"Timezone Name","text":"<p>Time zone name validation and serialization module.</p>"},{"location":"api/pydantic_extra_types_timezone_name/#pydantic_extra_types.timezone_name.TimeZoneName","title":"TimeZoneName","text":"<p>               Bases: <code>str</code></p> <p>TimeZoneName is a custom string subclass for validating and serializing timezone names.</p> <p>The TimeZoneName class uses the IANA Time Zone Database for validation. It supports both strict and non-strict modes for timezone name validation.</p>"},{"location":"api/pydantic_extra_types_timezone_name/#pydantic_extra_types.timezone_name.TimeZoneName--examples","title":"Examples:","text":"<p>Some examples of using the TimeZoneName class:</p>"},{"location":"api/pydantic_extra_types_timezone_name/#pydantic_extra_types.timezone_name.TimeZoneName--normal-usage","title":"Normal usage:","text":"<pre><code>from pydantic_extra_types.timezone_name import TimeZoneName\nfrom pydantic import BaseModel\nclass Location(BaseModel):\n    city: str\n    timezone: TimeZoneName\n\nloc = Location(city=\"New York\", timezone=\"America/New_York\")\nprint(loc.timezone)\n\n&gt;&gt; America/New_York\n</code></pre>"},{"location":"api/pydantic_extra_types_timezone_name/#pydantic_extra_types.timezone_name.TimeZoneName--non-strict-mode","title":"Non-strict mode:","text":"<pre><code>from pydantic_extra_types.timezone_name import TimeZoneName, timezone_name_settings\n\n@timezone_name_settings(strict=False)\nclass TZNonStrict(TimeZoneName):\n    pass\n\ntz = TZNonStrict(\"america/new_york\")\n\nprint(tz)\n\n&gt;&gt; america/new_york\n</code></pre>"},{"location":"api/pydantic_extra_types_timezone_name/#pydantic_extra_types.timezone_name.get_timezones","title":"get_timezones","text":"<pre><code>get_timezones() -&gt; set[str]\n</code></pre> <p>Determine the timezone provider and return available timezones.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_extra_types/timezone_name.py</code> <pre><code>def get_timezones() -&gt; set[str]:\n    \"\"\"Determine the timezone provider and return available timezones.\"\"\"\n    if _is_available('zoneinfo'):  # pragma: no cover\n        timezones = _tz_provider_from_zone_info()\n        if len(timezones) == 0:  # pragma: no cover\n            raise ImportError('No timezone provider found. Please install tzdata with \"pip install tzdata\"')\n        return timezones\n    elif _is_available('pytz'):  # pragma: no cover\n        return _tz_provider_from_pytz()\n    else:  # pragma: no cover\n        if sys.version_info[:2] == (3, 8):\n            raise ImportError('No pytz module found. Please install it with \"pip install pytz\"')\n        raise ImportError('No timezone provider found. Please install tzdata with \"pip install tzdata\"')\n</code></pre>"},{"location":"api/pydantic_settings/","title":"Pydantic Settings","text":""},{"location":"api/pydantic_settings/#pydantic_settings.SettingsError","title":"SettingsError","text":"<p>               Bases: <code>ValueError</code></p> <p>Base exception for settings-related errors.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.BaseSettings","title":"BaseSettings","text":"<pre><code>BaseSettings(__pydantic_self__, _case_sensitive: bool | None = None, _nested_model_default_partial_update: bool | None = None, _env_prefix: str | None = None, _env_file: DotenvType | None = ENV_FILE_SENTINEL, _env_file_encoding: str | None = None, _env_ignore_empty: bool | None = None, _env_nested_delimiter: str | None = None, _env_nested_max_split: int | None = None, _env_parse_none_str: str | None = None, _env_parse_enums: bool | None = None, _cli_prog_name: str | None = None, _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None, _cli_settings_source: CliSettingsSource[Any] | None = None, _cli_parse_none_str: str | None = None, _cli_hide_none_type: bool | None = None, _cli_avoid_json: bool | None = None, _cli_enforce_required: bool | None = None, _cli_use_class_docs_for_groups: bool | None = None, _cli_exit_on_error: bool | None = None, _cli_prefix: str | None = None, _cli_flag_prefix_char: str | None = None, _cli_implicit_flags: bool | None = None, _cli_ignore_unknown_args: bool | None = None, _cli_kebab_case: bool | None = None, _cli_shortcuts: Mapping[str, str | list[str]] | None = None, _secrets_dir: PathType | None = None, **values: Any)\n</code></pre> <p>               Bases: <code>BaseModel</code></p> <p>Base class for settings, allowing values to be overridden by environment variables.</p> <p>This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose), Heroku and any 12 factor app design.</p> <p>All the below attributes can be set via <code>model_config</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>_case_sensitive</code> <code>bool | None</code> <p>Whether environment and CLI variable names should be read with case-sensitivity. Defaults to <code>None</code>.</p> <code>None</code> <code>_nested_model_default_partial_update</code> <code>bool | None</code> <p>Whether to allow partial updates on nested model default object fields. Defaults to <code>False</code>.</p> <code>None</code> <code>_env_prefix</code> <code>str | None</code> <p>Prefix for all environment variables. Defaults to <code>None</code>.</p> <code>None</code> <code>_env_file</code> <code>DotenvType | None</code> <p>The env file(s) to load settings values from. Defaults to <code>Path('')</code>, which means that the value from <code>model_config['env_file']</code> should be used. You can also pass <code>None</code> to indicate that environment variables should not be loaded from an env file.</p> <code>ENV_FILE_SENTINEL</code> <code>_env_file_encoding</code> <code>str | None</code> <p>The env file encoding, e.g. <code>'latin-1'</code>. Defaults to <code>None</code>.</p> <code>None</code> <code>_env_ignore_empty</code> <code>bool | None</code> <p>Ignore environment variables where the value is an empty string. Default to <code>False</code>.</p> <code>None</code> <code>_env_nested_delimiter</code> <code>str | None</code> <p>The nested env values delimiter. Defaults to <code>None</code>.</p> <code>None</code> <code>_env_nested_max_split</code> <code>int | None</code> <p>The nested env values maximum nesting. Defaults to <code>None</code>, which means no limit.</p> <code>None</code> <code>_env_parse_none_str</code> <code>str | None</code> <p>The env string value that should be parsed (e.g. \"null\", \"void\", \"None\", etc.) into <code>None</code> type(None). Defaults to <code>None</code> type(None), which means no parsing should occur.</p> <code>None</code> <code>_env_parse_enums</code> <code>bool | None</code> <p>Parse enum field names to values. Defaults to <code>None.</code>, which means no parsing should occur.</p> <code>None</code> <code>_cli_prog_name</code> <code>str | None</code> <p>The CLI program name to display in help text. Defaults to <code>None</code> if _cli_parse_args is <code>None</code>. Otherwise, defaults to sys.argv[0].</p> <code>None</code> <code>_cli_parse_args</code> <code>bool | list[str] | tuple[str, ...] | None</code> <p>The list of CLI arguments to parse. Defaults to None. If set to <code>True</code>, defaults to sys.argv[1:].</p> <code>None</code> <code>_cli_settings_source</code> <code>CliSettingsSource[Any] | None</code> <p>Override the default CLI settings source with a user defined instance. Defaults to None.</p> <code>None</code> <code>_cli_parse_none_str</code> <code>str | None</code> <p>The CLI string value that should be parsed (e.g. \"null\", \"void\", \"None\", etc.) into <code>None</code> type(None). Defaults to _env_parse_none_str value if set. Otherwise, defaults to \"null\" if _cli_avoid_json is <code>False</code>, and \"None\" if _cli_avoid_json is <code>True</code>.</p> <code>None</code> <code>_cli_hide_none_type</code> <code>bool | None</code> <p>Hide <code>None</code> values in CLI help text. Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_avoid_json</code> <code>bool | None</code> <p>Avoid complex JSON objects in CLI help text. Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_enforce_required</code> <code>bool | None</code> <p>Enforce required fields at the CLI. Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_use_class_docs_for_groups</code> <code>bool | None</code> <p>Use class docstrings in CLI group help text instead of field descriptions. Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_exit_on_error</code> <code>bool | None</code> <p>Determines whether or not the internal parser exits with error info when an error occurs. Defaults to <code>True</code>.</p> <code>None</code> <code>_cli_prefix</code> <code>str | None</code> <p>The root parser command line arguments prefix. Defaults to \"\".</p> <code>None</code> <code>_cli_flag_prefix_char</code> <code>str | None</code> <p>The flag prefix character to use for CLI optional arguments. Defaults to '-'.</p> <code>None</code> <code>_cli_implicit_flags</code> <code>bool | None</code> <p>Whether <code>bool</code> fields should be implicitly converted into CLI boolean flags. (e.g. --flag, --no-flag). Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_ignore_unknown_args</code> <code>bool | None</code> <p>Whether to ignore unknown CLI args and parse only known ones. Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_kebab_case</code> <code>bool | None</code> <p>CLI args use kebab case. Defaults to <code>False</code>.</p> <code>None</code> <code>_cli_shortcuts</code> <code>Mapping[str, str | list[str]] | None</code> <p>Mapping of target field name to alias names. Defaults to <code>None</code>.</p> <code>None</code> <code>_secrets_dir</code> <code>PathType | None</code> <p>The secret files directory or a sequence of directories. Defaults to <code>None</code>.</p> <code>None</code> Source code in <code>pydantic_settings/main.py</code> <pre><code>def __init__(\n    __pydantic_self__,\n    _case_sensitive: bool | None = None,\n    _nested_model_default_partial_update: bool | None = None,\n    _env_prefix: str | None = None,\n    _env_file: DotenvType | None = ENV_FILE_SENTINEL,\n    _env_file_encoding: str | None = None,\n    _env_ignore_empty: bool | None = None,\n    _env_nested_delimiter: str | None = None,\n    _env_nested_max_split: int | None = None,\n    _env_parse_none_str: str | None = None,\n    _env_parse_enums: bool | None = None,\n    _cli_prog_name: str | None = None,\n    _cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,\n    _cli_settings_source: CliSettingsSource[Any] | None = None,\n    _cli_parse_none_str: str | None = None,\n    _cli_hide_none_type: bool | None = None,\n    _cli_avoid_json: bool | None = None,\n    _cli_enforce_required: bool | None = None,\n    _cli_use_class_docs_for_groups: bool | None = None,\n    _cli_exit_on_error: bool | None = None,\n    _cli_prefix: str | None = None,\n    _cli_flag_prefix_char: str | None = None,\n    _cli_implicit_flags: bool | None = None,\n    _cli_ignore_unknown_args: bool | None = None,\n    _cli_kebab_case: bool | None = None,\n    _cli_shortcuts: Mapping[str, str | list[str]] | None = None,\n    _secrets_dir: PathType | None = None,\n    **values: Any,\n) -&gt; None:\n    super().__init__(\n        **__pydantic_self__._settings_build_values(\n            values,\n            _case_sensitive=_case_sensitive,\n            _nested_model_default_partial_update=_nested_model_default_partial_update,\n            _env_prefix=_env_prefix,\n            _env_file=_env_file,\n            _env_file_encoding=_env_file_encoding,\n            _env_ignore_empty=_env_ignore_empty,\n            _env_nested_delimiter=_env_nested_delimiter,\n            _env_nested_max_split=_env_nested_max_split,\n            _env_parse_none_str=_env_parse_none_str,\n            _env_parse_enums=_env_parse_enums,\n            _cli_prog_name=_cli_prog_name,\n            _cli_parse_args=_cli_parse_args,\n            _cli_settings_source=_cli_settings_source,\n            _cli_parse_none_str=_cli_parse_none_str,\n            _cli_hide_none_type=_cli_hide_none_type,\n            _cli_avoid_json=_cli_avoid_json,\n            _cli_enforce_required=_cli_enforce_required,\n            _cli_use_class_docs_for_groups=_cli_use_class_docs_for_groups,\n            _cli_exit_on_error=_cli_exit_on_error,\n            _cli_prefix=_cli_prefix,\n            _cli_flag_prefix_char=_cli_flag_prefix_char,\n            _cli_implicit_flags=_cli_implicit_flags,\n            _cli_ignore_unknown_args=_cli_ignore_unknown_args,\n            _cli_kebab_case=_cli_kebab_case,\n            _cli_shortcuts=_cli_shortcuts,\n            _secrets_dir=_secrets_dir,\n        )\n    )\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.BaseSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(settings_cls: type[BaseSettings], init_settings: PydanticBaseSettingsSource, env_settings: PydanticBaseSettingsSource, dotenv_settings: PydanticBaseSettingsSource, file_secret_settings: PydanticBaseSettingsSource) -&gt; tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Define the sources and their order for loading the settings values.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>settings_cls</code> <code>type[BaseSettings]</code> <p>The Settings class.</p> \u5fc5\u9700 <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>InitSettingsSource</code> instance.</p> \u5fc5\u9700 <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>EnvSettingsSource</code> instance.</p> \u5fc5\u9700 <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>DotEnvSettingsSource</code> instance.</p> \u5fc5\u9700 <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The <code>SecretsSettingsSource</code> instance.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple containing the sources and their order for loading the settings values.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/main.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Define the sources and their order for loading the settings values.\n\n    Args:\n        settings_cls: The Settings class.\n        init_settings: The `InitSettingsSource` instance.\n        env_settings: The `EnvSettingsSource` instance.\n        dotenv_settings: The `DotEnvSettingsSource` instance.\n        file_secret_settings: The `SecretsSettingsSource` instance.\n\n    Returns:\n        A tuple containing the sources and their order for loading the settings values.\n    \"\"\"\n    return init_settings, env_settings, dotenv_settings, file_secret_settings\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.CliApp","title":"CliApp","text":"<p>A utility class for running Pydantic <code>BaseSettings</code>, <code>BaseModel</code>, or <code>pydantic.dataclasses.dataclass</code> as CLI applications.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.CliApp.run","title":"run  <code>staticmethod</code>","text":"<pre><code>run(model_cls: type[T], cli_args: list[str] | Namespace | SimpleNamespace | dict[str, Any] | None = None, cli_settings_source: CliSettingsSource[Any] | None = None, cli_exit_on_error: bool | None = None, cli_cmd_method_name: str = 'cli_cmd', **model_init_data: Any) -&gt; T\n</code></pre> <p>Runs a Pydantic <code>BaseSettings</code>, <code>BaseModel</code>, or <code>pydantic.dataclasses.dataclass</code> as a CLI application. Running a model as a CLI application requires the <code>cli_cmd</code> method to be defined in the model class.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>model_cls</code> <code>type[T]</code> <p>The model class to run as a CLI application.</p> \u5fc5\u9700 <code>cli_args</code> <code>list[str] | Namespace | SimpleNamespace | dict[str, Any] | None</code> <p>The list of CLI arguments to parse. If <code>cli_settings_source</code> is specified, this may also be a namespace or dictionary of pre-parsed CLI arguments. Defaults to <code>sys.argv[1:]</code>.</p> <code>None</code> <code>cli_settings_source</code> <code>CliSettingsSource[Any] | None</code> <p>Override the default CLI settings source with a user defined instance. Defaults to <code>None</code>.</p> <code>None</code> <code>cli_exit_on_error</code> <code>bool | None</code> <p>Determines whether this function exits on error. If model is subclass of <code>BaseSettings</code>, defaults to BaseSettings <code>cli_exit_on_error</code> value. Otherwise, defaults to <code>True</code>.</p> <code>None</code> <code>cli_cmd_method_name</code> <code>str</code> <p>The CLI command method name to run. Defaults to \"cli_cmd\".</p> <code>'cli_cmd'</code> <code>model_init_data</code> <code>Any</code> <p>The model init data.</p> <code>{}</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>T</code> <p>The ran instance of model.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>SettingsError</code> <p>If model_cls is not subclass of <code>BaseModel</code> or <code>pydantic.dataclasses.dataclass</code>.</p> <code>SettingsError</code> <p>If model_cls does not have a <code>cli_cmd</code> entrypoint defined.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/main.py</code> <pre><code>@staticmethod\ndef run(\n    model_cls: type[T],\n    cli_args: list[str] | Namespace | SimpleNamespace | dict[str, Any] | None = None,\n    cli_settings_source: CliSettingsSource[Any] | None = None,\n    cli_exit_on_error: bool | None = None,\n    cli_cmd_method_name: str = 'cli_cmd',\n    **model_init_data: Any,\n) -&gt; T:\n    \"\"\"\n    Runs a Pydantic `BaseSettings`, `BaseModel`, or `pydantic.dataclasses.dataclass` as a CLI application.\n    Running a model as a CLI application requires the `cli_cmd` method to be defined in the model class.\n\n    Args:\n        model_cls: The model class to run as a CLI application.\n        cli_args: The list of CLI arguments to parse. If `cli_settings_source` is specified, this may\n            also be a namespace or dictionary of pre-parsed CLI arguments. Defaults to `sys.argv[1:]`.\n        cli_settings_source: Override the default CLI settings source with a user defined instance.\n            Defaults to `None`.\n        cli_exit_on_error: Determines whether this function exits on error. If model is subclass of\n            `BaseSettings`, defaults to BaseSettings `cli_exit_on_error` value. Otherwise, defaults to\n            `True`.\n        cli_cmd_method_name: The CLI command method name to run. Defaults to \"cli_cmd\".\n        model_init_data: The model init data.\n\n    Returns:\n        The ran instance of model.\n\n    Raises:\n        SettingsError: If model_cls is not subclass of `BaseModel` or `pydantic.dataclasses.dataclass`.\n        SettingsError: If model_cls does not have a `cli_cmd` entrypoint defined.\n    \"\"\"\n\n    if not (is_pydantic_dataclass(model_cls) or is_model_class(model_cls)):\n        raise SettingsError(\n            f'Error: {model_cls.__name__} is not subclass of BaseModel or pydantic.dataclasses.dataclass'\n        )\n\n    cli_settings = None\n    cli_parse_args = True if cli_args is None else cli_args\n    if cli_settings_source is not None:\n        if isinstance(cli_parse_args, (Namespace, SimpleNamespace, dict)):\n            cli_settings = cli_settings_source(parsed_args=cli_parse_args)\n        else:\n            cli_settings = cli_settings_source(args=cli_parse_args)\n    elif isinstance(cli_parse_args, (Namespace, SimpleNamespace, dict)):\n        raise SettingsError('Error: `cli_args` must be list[str] or None when `cli_settings_source` is not used')\n\n    model_init_data['_cli_parse_args'] = cli_parse_args\n    model_init_data['_cli_exit_on_error'] = cli_exit_on_error\n    model_init_data['_cli_settings_source'] = cli_settings\n    if not issubclass(model_cls, BaseSettings):\n        base_settings_cls = CliApp._get_base_settings_cls(model_cls)\n        model = base_settings_cls(**model_init_data)\n        model_init_data = {}\n        for field_name, field_info in base_settings_cls.model_fields.items():\n            model_init_data[_field_name_for_signature(field_name, field_info)] = getattr(model, field_name)\n\n    return CliApp._run_cli_cmd(model_cls(**model_init_data), cli_cmd_method_name, is_required=False)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.CliApp.run_subcommand","title":"run_subcommand  <code>staticmethod</code>","text":"<pre><code>run_subcommand(model: PydanticModel, cli_exit_on_error: bool | None = None, cli_cmd_method_name: str = 'cli_cmd') -&gt; PydanticModel\n</code></pre> <p>Runs the model subcommand. Running a model subcommand requires the <code>cli_cmd</code> method to be defined in the nested model subcommand class.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>model</code> <code>PydanticModel</code> <p>The model to run the subcommand from.</p> \u5fc5\u9700 <code>cli_exit_on_error</code> <code>bool | None</code> <p>Determines whether this function exits with error if no subcommand is found. Defaults to model_config <code>cli_exit_on_error</code> value if set. Otherwise, defaults to <code>True</code>.</p> <code>None</code> <code>cli_cmd_method_name</code> <code>str</code> <p>The CLI command method name to run. Defaults to \"cli_cmd\".</p> <code>'cli_cmd'</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>PydanticModel</code> <p>The ran subcommand model.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>SystemExit</code> <p>When no subcommand is found and cli_exit_on_error=<code>True</code> (the default).</p> <code>SettingsError</code> <p>When no subcommand is found and cli_exit_on_error=<code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/main.py</code> <pre><code>@staticmethod\ndef run_subcommand(\n    model: PydanticModel, cli_exit_on_error: bool | None = None, cli_cmd_method_name: str = 'cli_cmd'\n) -&gt; PydanticModel:\n    \"\"\"\n    Runs the model subcommand. Running a model subcommand requires the `cli_cmd` method to be defined in\n    the nested model subcommand class.\n\n    Args:\n        model: The model to run the subcommand from.\n        cli_exit_on_error: Determines whether this function exits with error if no subcommand is found.\n            Defaults to model_config `cli_exit_on_error` value if set. Otherwise, defaults to `True`.\n        cli_cmd_method_name: The CLI command method name to run. Defaults to \"cli_cmd\".\n\n    Returns:\n        The ran subcommand model.\n\n    Raises:\n        SystemExit: When no subcommand is found and cli_exit_on_error=`True` (the default).\n        SettingsError: When no subcommand is found and cli_exit_on_error=`False`.\n    \"\"\"\n\n    subcommand = get_subcommand(model, is_required=True, cli_exit_on_error=cli_exit_on_error)\n    return CliApp._run_cli_cmd(subcommand, cli_cmd_method_name, is_required=True)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.CliApp.serialize","title":"serialize  <code>staticmethod</code>","text":"<pre><code>serialize(model: PydanticModel) -&gt; list[str]\n</code></pre> <p>Serializes the CLI arguments for a Pydantic data model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>model</code> <code>PydanticModel</code> <p>The data model to serialize.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>list[str]</code> <p>The serialized CLI arguments for the data model.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/main.py</code> <pre><code>@staticmethod\ndef serialize(model: PydanticModel) -&gt; list[str]:\n    \"\"\"\n    Serializes the CLI arguments for a Pydantic data model.\n\n    Args:\n        model: The data model to serialize.\n\n    Returns:\n        The serialized CLI arguments for the data model.\n    \"\"\"\n\n    base_settings_cls = CliApp._get_base_settings_cls(type(model))\n    return CliSettingsSource[Any](base_settings_cls)._serialized_args(model)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.SettingsConfigDict","title":"SettingsConfigDict","text":"<p>               Bases: <code>ConfigDict</code></p>"},{"location":"api/pydantic_settings/#pydantic_settings.SettingsConfigDict.yaml_config_section","title":"yaml_config_section  <code>instance-attribute</code>","text":"<pre><code>yaml_config_section: str | None\n</code></pre> <p>Specifies the top-level key in a YAML file from which to load the settings. If provided, the settings will be loaded from the nested section under this key. This is useful when the YAML file contains multiple configuration sections and you only want to load a specific subset into your settings model.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.SettingsConfigDict.pyproject_toml_depth","title":"pyproject_toml_depth  <code>instance-attribute</code>","text":"<pre><code>pyproject_toml_depth: int\n</code></pre> <p>Number of levels up from the current working directory to attempt to find a pyproject.toml file.</p> <p>This is only used when a pyproject.toml file is not found in the current working directory.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.SettingsConfigDict.pyproject_toml_table_header","title":"pyproject_toml_table_header  <code>instance-attribute</code>","text":"<pre><code>pyproject_toml_table_header: tuple[str, ...]\n</code></pre> <p>Header of the TOML table within a pyproject.toml file to use when filling variables. This is supplied as a <code>tuple[str, ...]</code> instead of a <code>str</code> to accommodate for headers containing a <code>.</code>.</p> <p>For example, <code>toml_table_header = (\"tool\", \"my.tool\", \"foo\")</code> can be used to fill variable values from a table with header <code>[tool.\"my.tool\".foo]</code>.</p> <p>To use the root table, exclude this config setting or provide an empty tuple.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.CliSettingsSource","title":"CliSettingsSource","text":"<pre><code>CliSettingsSource(settings_cls: type[BaseSettings], cli_prog_name: str | None = None, cli_parse_args: bool | list[str] | tuple[str, ...] | None = None, cli_parse_none_str: str | None = None, cli_hide_none_type: bool | None = None, cli_avoid_json: bool | None = None, cli_enforce_required: bool | None = None, cli_use_class_docs_for_groups: bool | None = None, cli_exit_on_error: bool | None = None, cli_prefix: str | None = None, cli_flag_prefix_char: str | None = None, cli_implicit_flags: bool | None = None, cli_ignore_unknown_args: bool | None = None, cli_kebab_case: bool | None = None, cli_shortcuts: Mapping[str, str | list[str]] | None = None, case_sensitive: bool | None = True, root_parser: Any = None, parse_args_method: Callable[..., Any] | None = None, add_argument_method: Callable[..., Any] | None = add_argument, add_argument_group_method: Callable[..., Any] | None = add_argument_group, add_parser_method: Callable[..., Any] | None = add_parser, add_subparsers_method: Callable[..., Any] | None = add_subparsers, formatter_class: Any = RawDescriptionHelpFormatter)\n</code></pre> <p>               Bases: <code>EnvSettingsSource</code>, <code>Generic[T]</code></p> <p>Source class for loading settings values from CLI.</p> Note <p>A <code>CliSettingsSource</code> connects with a <code>root_parser</code> object by using the parser methods to add <code>settings_cls</code> fields as command line arguments. The <code>CliSettingsSource</code> internal parser representation is based upon the <code>argparse</code> parsing library, and therefore, requires the parser methods to support the same attributes as their <code>argparse</code> library counterparts.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>cli_prog_name</code> <code>str | None</code> <p>The CLI program name to display in help text. Defaults to <code>None</code> if cli_parse_args is <code>None</code>. Otherwise, defaults to sys.argv[0].</p> <code>None</code> <code>cli_parse_args</code> <code>bool | list[str] | tuple[str, ...] | None</code> <p>The list of CLI arguments to parse. Defaults to None. If set to <code>True</code>, defaults to sys.argv[1:].</p> <code>None</code> <code>cli_parse_none_str</code> <code>str | None</code> <p>The CLI string value that should be parsed (e.g. \"null\", \"void\", \"None\", etc.) into <code>None</code> type(None). Defaults to \"null\" if cli_avoid_json is <code>False</code>, and \"None\" if cli_avoid_json is <code>True</code>.</p> <code>None</code> <code>cli_hide_none_type</code> <code>bool | None</code> <p>Hide <code>None</code> values in CLI help text. Defaults to <code>False</code>.</p> <code>None</code> <code>cli_avoid_json</code> <code>bool | None</code> <p>Avoid complex JSON objects in CLI help text. Defaults to <code>False</code>.</p> <code>None</code> <code>cli_enforce_required</code> <code>bool | None</code> <p>Enforce required fields at the CLI. Defaults to <code>False</code>.</p> <code>None</code> <code>cli_use_class_docs_for_groups</code> <code>bool | None</code> <p>Use class docstrings in CLI group help text instead of field descriptions. Defaults to <code>False</code>.</p> <code>None</code> <code>cli_exit_on_error</code> <code>bool | None</code> <p>Determines whether or not the internal parser exits with error info when an error occurs. Defaults to <code>True</code>.</p> <code>None</code> <code>cli_prefix</code> <code>str | None</code> <p>Prefix for command line arguments added under the root parser. Defaults to \"\".</p> <code>None</code> <code>cli_flag_prefix_char</code> <code>str | None</code> <p>The flag prefix character to use for CLI optional arguments. Defaults to '-'.</p> <code>None</code> <code>cli_implicit_flags</code> <code>bool | None</code> <p>Whether <code>bool</code> fields should be implicitly converted into CLI boolean flags. (e.g. --flag, --no-flag). Defaults to <code>False</code>.</p> <code>None</code> <code>cli_ignore_unknown_args</code> <code>bool | None</code> <p>Whether to ignore unknown CLI args and parse only known ones. Defaults to <code>False</code>.</p> <code>None</code> <code>cli_kebab_case</code> <code>bool | None</code> <p>CLI args use kebab case. Defaults to <code>False</code>.</p> <code>None</code> <code>cli_shortcuts</code> <code>Mapping[str, str | list[str]] | None</code> <p>Mapping of target field name to alias names. Defaults to <code>None</code>.</p> <code>None</code> <code>case_sensitive</code> <code>bool | None</code> <p>Whether CLI \"--arg\" names should be read with case-sensitivity. Defaults to <code>True</code>. Note: Case-insensitive matching is only supported on the internal root parser and does not apply to CLI subcommands.</p> <code>True</code> <code>root_parser</code> <code>Any</code> <p>The root parser object.</p> <code>None</code> <code>parse_args_method</code> <code>Callable[..., Any] | None</code> <p>The root parser parse args method. Defaults to <code>argparse.ArgumentParser.parse_args</code>.</p> <code>None</code> <code>add_argument_method</code> <code>Callable[..., Any] | None</code> <p>The root parser add argument method. Defaults to <code>argparse.ArgumentParser.add_argument</code>.</p> <code>add_argument</code> <code>add_argument_group_method</code> <code>Callable[..., Any] | None</code> <p>The root parser add argument group method. Defaults to <code>argparse.ArgumentParser.add_argument_group</code>.</p> <code>add_argument_group</code> <code>add_parser_method</code> <code>Callable[..., Any] | None</code> <p>The root parser add new parser (sub-command) method. Defaults to <code>argparse._SubParsersAction.add_parser</code>.</p> <code>add_parser</code> <code>add_subparsers_method</code> <code>Callable[..., Any] | None</code> <p>The root parser add subparsers (sub-commands) method. Defaults to <code>argparse.ArgumentParser.add_subparsers</code>.</p> <code>add_subparsers</code> <code>formatter_class</code> <code>Any</code> <p>A class for customizing the root parser help text. Defaults to <code>argparse.RawDescriptionHelpFormatter</code>.</p> <code>RawDescriptionHelpFormatter</code> Source code in <code>pydantic_settings/sources/providers/cli.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    cli_prog_name: str | None = None,\n    cli_parse_args: bool | list[str] | tuple[str, ...] | None = None,\n    cli_parse_none_str: str | None = None,\n    cli_hide_none_type: bool | None = None,\n    cli_avoid_json: bool | None = None,\n    cli_enforce_required: bool | None = None,\n    cli_use_class_docs_for_groups: bool | None = None,\n    cli_exit_on_error: bool | None = None,\n    cli_prefix: str | None = None,\n    cli_flag_prefix_char: str | None = None,\n    cli_implicit_flags: bool | None = None,\n    cli_ignore_unknown_args: bool | None = None,\n    cli_kebab_case: bool | None = None,\n    cli_shortcuts: Mapping[str, str | list[str]] | None = None,\n    case_sensitive: bool | None = True,\n    root_parser: Any = None,\n    parse_args_method: Callable[..., Any] | None = None,\n    add_argument_method: Callable[..., Any] | None = ArgumentParser.add_argument,\n    add_argument_group_method: Callable[..., Any] | None = ArgumentParser.add_argument_group,\n    add_parser_method: Callable[..., Any] | None = _SubParsersAction.add_parser,\n    add_subparsers_method: Callable[..., Any] | None = ArgumentParser.add_subparsers,\n    formatter_class: Any = RawDescriptionHelpFormatter,\n) -&gt; None:\n    self.cli_prog_name = (\n        cli_prog_name if cli_prog_name is not None else settings_cls.model_config.get('cli_prog_name', sys.argv[0])\n    )\n    self.cli_hide_none_type = (\n        cli_hide_none_type\n        if cli_hide_none_type is not None\n        else settings_cls.model_config.get('cli_hide_none_type', False)\n    )\n    self.cli_avoid_json = (\n        cli_avoid_json if cli_avoid_json is not None else settings_cls.model_config.get('cli_avoid_json', False)\n    )\n    if not cli_parse_none_str:\n        cli_parse_none_str = 'None' if self.cli_avoid_json is True else 'null'\n    self.cli_parse_none_str = cli_parse_none_str\n    self.cli_enforce_required = (\n        cli_enforce_required\n        if cli_enforce_required is not None\n        else settings_cls.model_config.get('cli_enforce_required', False)\n    )\n    self.cli_use_class_docs_for_groups = (\n        cli_use_class_docs_for_groups\n        if cli_use_class_docs_for_groups is not None\n        else settings_cls.model_config.get('cli_use_class_docs_for_groups', False)\n    )\n    self.cli_exit_on_error = (\n        cli_exit_on_error\n        if cli_exit_on_error is not None\n        else settings_cls.model_config.get('cli_exit_on_error', True)\n    )\n    self.cli_prefix = cli_prefix if cli_prefix is not None else settings_cls.model_config.get('cli_prefix', '')\n    self.cli_flag_prefix_char = (\n        cli_flag_prefix_char\n        if cli_flag_prefix_char is not None\n        else settings_cls.model_config.get('cli_flag_prefix_char', '-')\n    )\n    self._cli_flag_prefix = self.cli_flag_prefix_char * 2\n    if self.cli_prefix:\n        if cli_prefix.startswith('.') or cli_prefix.endswith('.') or not cli_prefix.replace('.', '').isidentifier():  # type: ignore\n            raise SettingsError(f'CLI settings source prefix is invalid: {cli_prefix}')\n        self.cli_prefix += '.'\n    self.cli_implicit_flags = (\n        cli_implicit_flags\n        if cli_implicit_flags is not None\n        else settings_cls.model_config.get('cli_implicit_flags', False)\n    )\n    self.cli_ignore_unknown_args = (\n        cli_ignore_unknown_args\n        if cli_ignore_unknown_args is not None\n        else settings_cls.model_config.get('cli_ignore_unknown_args', False)\n    )\n    self.cli_kebab_case = (\n        cli_kebab_case if cli_kebab_case is not None else settings_cls.model_config.get('cli_kebab_case', False)\n    )\n    self.cli_shortcuts = (\n        cli_shortcuts if cli_shortcuts is not None else settings_cls.model_config.get('cli_shortcuts', None)\n    )\n\n    case_sensitive = case_sensitive if case_sensitive is not None else True\n    if not case_sensitive and root_parser is not None:\n        raise SettingsError('Case-insensitive matching is only supported on the internal root parser')\n\n    super().__init__(\n        settings_cls,\n        env_nested_delimiter='.',\n        env_parse_none_str=self.cli_parse_none_str,\n        env_parse_enums=True,\n        env_prefix=self.cli_prefix,\n        case_sensitive=case_sensitive,\n    )\n\n    root_parser = (\n        _CliInternalArgParser(\n            cli_exit_on_error=self.cli_exit_on_error,\n            prog=self.cli_prog_name,\n            description=None if settings_cls.__doc__ is None else dedent(settings_cls.__doc__),\n            formatter_class=formatter_class,\n            prefix_chars=self.cli_flag_prefix_char,\n            allow_abbrev=False,\n        )\n        if root_parser is None\n        else root_parser\n    )\n    self._connect_root_parser(\n        root_parser=root_parser,\n        parse_args_method=parse_args_method,\n        add_argument_method=add_argument_method,\n        add_argument_group_method=add_argument_group_method,\n        add_parser_method=add_parser_method,\n        add_subparsers_method=add_subparsers_method,\n        formatter_class=formatter_class,\n    )\n\n    if cli_parse_args not in (None, False):\n        if cli_parse_args is True:\n            cli_parse_args = sys.argv[1:]\n        elif not isinstance(cli_parse_args, (list, tuple)):\n            raise SettingsError(\n                f'cli_parse_args must be a list or tuple of strings, received {type(cli_parse_args)}'\n            )\n        self._load_env_vars(parsed_args=self._parse_args(self.root_parser, cli_parse_args))\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.CliSettingsSource.root_parser","title":"root_parser  <code>property</code>","text":"<pre><code>root_parser: T\n</code></pre> <p>The connected root parser instance.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.DotEnvSettingsSource","title":"DotEnvSettingsSource","text":"<pre><code>DotEnvSettingsSource(settings_cls: type[BaseSettings], env_file: DotenvType | None = ENV_FILE_SENTINEL, env_file_encoding: str | None = None, case_sensitive: bool | None = None, env_prefix: str | None = None, env_nested_delimiter: str | None = None, env_nested_max_split: int | None = None, env_ignore_empty: bool | None = None, env_parse_none_str: str | None = None, env_parse_enums: bool | None = None)\n</code></pre> <p>               Bases: <code>EnvSettingsSource</code></p> <p>Source class for loading settings values from env files.</p> Source code in <code>pydantic_settings/sources/providers/dotenv.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    env_file: DotenvType | None = ENV_FILE_SENTINEL,\n    env_file_encoding: str | None = None,\n    case_sensitive: bool | None = None,\n    env_prefix: str | None = None,\n    env_nested_delimiter: str | None = None,\n    env_nested_max_split: int | None = None,\n    env_ignore_empty: bool | None = None,\n    env_parse_none_str: str | None = None,\n    env_parse_enums: bool | None = None,\n) -&gt; None:\n    self.env_file = env_file if env_file != ENV_FILE_SENTINEL else settings_cls.model_config.get('env_file')\n    self.env_file_encoding = (\n        env_file_encoding if env_file_encoding is not None else settings_cls.model_config.get('env_file_encoding')\n    )\n    super().__init__(\n        settings_cls,\n        case_sensitive,\n        env_prefix,\n        env_nested_delimiter,\n        env_nested_max_split,\n        env_ignore_empty,\n        env_parse_none_str,\n        env_parse_enums,\n    )\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.EnvSettingsSource","title":"EnvSettingsSource","text":"<pre><code>EnvSettingsSource(settings_cls: type[BaseSettings], case_sensitive: bool | None = None, env_prefix: str | None = None, env_nested_delimiter: str | None = None, env_nested_max_split: int | None = None, env_ignore_empty: bool | None = None, env_parse_none_str: str | None = None, env_parse_enums: bool | None = None)\n</code></pre> <p>               Bases: <code>PydanticBaseEnvSettingsSource</code></p> <p>Source class for loading settings values from environment variables.</p> Source code in <code>pydantic_settings/sources/providers/env.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    case_sensitive: bool | None = None,\n    env_prefix: str | None = None,\n    env_nested_delimiter: str | None = None,\n    env_nested_max_split: int | None = None,\n    env_ignore_empty: bool | None = None,\n    env_parse_none_str: str | None = None,\n    env_parse_enums: bool | None = None,\n) -&gt; None:\n    super().__init__(\n        settings_cls, case_sensitive, env_prefix, env_ignore_empty, env_parse_none_str, env_parse_enums\n    )\n    self.env_nested_delimiter = (\n        env_nested_delimiter if env_nested_delimiter is not None else self.config.get('env_nested_delimiter')\n    )\n    self.env_nested_max_split = (\n        env_nested_max_split if env_nested_max_split is not None else self.config.get('env_nested_max_split')\n    )\n    self.maxsplit = (self.env_nested_max_split or 0) - 1\n    self.env_prefix_len = len(self.env_prefix)\n\n    self.env_vars = self._load_env_vars()\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.EnvSettingsSource.get_field_value","title":"get_field_value","text":"<pre><code>get_field_value(field: FieldInfo, field_name: str) -&gt; tuple[Any, str, bool]\n</code></pre> <p>Gets the value for field from environment variables and a flag to determine whether value is complex.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[Any, str, bool]</code> <p>A tuple that contains the value (<code>None</code> if not found), key, and a flag to determine whether value is complex.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/providers/env.py</code> <pre><code>def get_field_value(self, field: FieldInfo, field_name: str) -&gt; tuple[Any, str, bool]:\n    \"\"\"\n    Gets the value for field from environment variables and a flag to determine whether value is complex.\n\n    Args:\n        field: The field.\n        field_name: The field name.\n\n    Returns:\n        A tuple that contains the value (`None` if not found), key, and\n            a flag to determine whether value is complex.\n    \"\"\"\n\n    env_val: str | None = None\n    for field_key, env_name, value_is_complex in self._extract_field_info(field, field_name):\n        env_val = self.env_vars.get(env_name)\n        if env_val is not None:\n            break\n\n    return env_val, field_key, value_is_complex\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.EnvSettingsSource.prepare_field_value","title":"prepare_field_value","text":"<pre><code>prepare_field_value(field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -&gt; Any\n</code></pre> <p>Prepare value for the field.</p> <ul> <li>Extract value for nested field.</li> <li>Deserialize value to python object for complex field.</li> </ul> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>A tuple contains prepared value for the field.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>ValuesError</code> <p>When There is an error in deserializing value for complex field.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/providers/env.py</code> <pre><code>def prepare_field_value(self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -&gt; Any:\n    \"\"\"\n    Prepare value for the field.\n\n    * Extract value for nested field.\n    * Deserialize value to python object for complex field.\n\n    Args:\n        field: The field.\n        field_name: The field name.\n\n    Returns:\n        A tuple contains prepared value for the field.\n\n    Raises:\n        ValuesError: When There is an error in deserializing value for complex field.\n    \"\"\"\n    is_complex, allow_parse_failure = self._field_is_complex(field)\n    if self.env_parse_enums:\n        enum_val = _annotation_enum_name_to_val(field.annotation, value)\n        value = value if enum_val is None else enum_val\n\n    if is_complex or value_is_complex:\n        if isinstance(value, EnvNoneType):\n            return value\n        elif value is None:\n            # field is complex but no value found so far, try explode_env_vars\n            env_val_built = self.explode_env_vars(field_name, field, self.env_vars)\n            if env_val_built:\n                return env_val_built\n        else:\n            # field is complex and there's a value, decode that as JSON, then add explode_env_vars\n            try:\n                value = self.decode_complex_value(field_name, field, value)\n            except ValueError as e:\n                if not allow_parse_failure:\n                    raise e\n\n            if isinstance(value, dict):\n                return deep_update(value, self.explode_env_vars(field_name, field, self.env_vars))\n            else:\n                return value\n    elif value is not None:\n        # simplest case, field is not complex, we only need to add the value if it was found\n        return value\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.EnvSettingsSource.next_field","title":"next_field","text":"<pre><code>next_field(field: FieldInfo | Any | None, key: str, case_sensitive: bool | None = None) -&gt; FieldInfo | None\n</code></pre> <p>Find the field in a sub model by key(env name)</p> <p>By having the following models:</p> <pre><code>```py\nclass SubSubModel(BaseSettings):\n    dvals: Dict\n\nclass SubModel(BaseSettings):\n    vals: list[str]\n    sub_sub_model: SubSubModel\n\nclass Cfg(BaseSettings):\n    sub_model: SubModel\n```\n</code></pre> Then <p>next_field(sub_model, 'vals') Returns the <code>vals</code> field of <code>SubModel</code> class next_field(sub_model, 'sub_sub_model') Returns <code>sub_sub_model</code> field of <code>SubModel</code> class</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>FieldInfo | Any | None</code> <p>The field.</p> \u5fc5\u9700 <code>key</code> <code>str</code> <p>The key (env name).</p> \u5fc5\u9700 <code>case_sensitive</code> <code>bool | None</code> <p>Whether to search for key case sensitively.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>FieldInfo | None</code> <p>Field if it finds the next field otherwise <code>None</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/providers/env.py</code> <pre><code>def next_field(\n    self, field: FieldInfo | Any | None, key: str, case_sensitive: bool | None = None\n) -&gt; FieldInfo | None:\n    \"\"\"\n    Find the field in a sub model by key(env name)\n\n    By having the following models:\n\n        ```py\n        class SubSubModel(BaseSettings):\n            dvals: Dict\n\n        class SubModel(BaseSettings):\n            vals: list[str]\n            sub_sub_model: SubSubModel\n\n        class Cfg(BaseSettings):\n            sub_model: SubModel\n        ```\n\n    Then:\n        next_field(sub_model, 'vals') Returns the `vals` field of `SubModel` class\n        next_field(sub_model, 'sub_sub_model') Returns `sub_sub_model` field of `SubModel` class\n\n    Args:\n        field: The field.\n        key: The key (env name).\n        case_sensitive: Whether to search for key case sensitively.\n\n    Returns:\n        Field if it finds the next field otherwise `None`.\n    \"\"\"\n    if not field:\n        return None\n\n    annotation = field.annotation if isinstance(field, FieldInfo) else field\n    for type_ in get_args(annotation):\n        type_has_key = self.next_field(type_, key, case_sensitive)\n        if type_has_key:\n            return type_has_key\n    if is_model_class(annotation) or is_pydantic_dataclass(annotation):  # type: ignore[arg-type]\n        fields = _get_model_fields(annotation)\n        # `case_sensitive is None` is here to be compatible with the old behavior.\n        # Has to be removed in V3.\n        for field_name, f in fields.items():\n            for _, env_name, _ in self._extract_field_info(f, field_name):\n                if case_sensitive is None or case_sensitive:\n                    if field_name == key or env_name == key:\n                        return f\n                elif field_name.lower() == key.lower() or env_name.lower() == key.lower():\n                    return f\n    return None\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.EnvSettingsSource.explode_env_vars","title":"explode_env_vars","text":"<pre><code>explode_env_vars(field_name: str, field: FieldInfo, env_vars: Mapping[str, str | None]) -&gt; dict[str, Any]\n</code></pre> <p>Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.</p> <p>This is applied to a single field, hence filtering by env_var prefix.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>env_vars</code> <code>Mapping[str, str | None]</code> <p>Environment variables.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any]</code> <p>A dictionary contains extracted values from nested env values.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/providers/env.py</code> <pre><code>def explode_env_vars(self, field_name: str, field: FieldInfo, env_vars: Mapping[str, str | None]) -&gt; dict[str, Any]:\n    \"\"\"\n    Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.\n\n    This is applied to a single field, hence filtering by env_var prefix.\n\n    Args:\n        field_name: The field name.\n        field: The field.\n        env_vars: Environment variables.\n\n    Returns:\n        A dictionary contains extracted values from nested env values.\n    \"\"\"\n    if not self.env_nested_delimiter:\n        return {}\n\n    ann = field.annotation\n    is_dict = ann is dict or _lenient_issubclass(get_origin(ann), dict)\n\n    prefixes = [\n        f'{env_name}{self.env_nested_delimiter}' for _, env_name, _ in self._extract_field_info(field, field_name)\n    ]\n    result: dict[str, Any] = {}\n    for env_name, env_val in env_vars.items():\n        try:\n            prefix = next(prefix for prefix in prefixes if env_name.startswith(prefix))\n        except StopIteration:\n            continue\n        # we remove the prefix before splitting in case the prefix has characters in common with the delimiter\n        env_name_without_prefix = env_name[len(prefix) :]\n        *keys, last_key = env_name_without_prefix.split(self.env_nested_delimiter, self.maxsplit)\n        env_var = result\n        target_field: FieldInfo | None = field\n        for key in keys:\n            target_field = self.next_field(target_field, key, self.case_sensitive)\n            if isinstance(env_var, dict):\n                env_var = env_var.setdefault(key, {})\n\n        # get proper field with last_key\n        target_field = self.next_field(target_field, last_key, self.case_sensitive)\n\n        # check if env_val maps to a complex field and if so, parse the env_val\n        if (target_field or is_dict) and env_val:\n            if target_field:\n                is_complex, allow_json_failure = self._field_is_complex(target_field)\n                if self.env_parse_enums:\n                    enum_val = _annotation_enum_name_to_val(target_field.annotation, env_val)\n                    env_val = env_val if enum_val is None else enum_val\n            else:\n                # nested field type is dict\n                is_complex, allow_json_failure = True, True\n            if is_complex:\n                try:\n                    env_val = self.decode_complex_value(last_key, target_field, env_val)  # type: ignore\n                except ValueError as e:\n                    if not allow_json_failure:\n                        raise e\n        if isinstance(env_var, dict):\n            if last_key not in env_var or not isinstance(env_val, EnvNoneType) or env_var[last_key] == {}:\n                env_var[last_key] = env_val\n\n    return result\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.ForceDecode","title":"ForceDecode","text":"<p>Annotation to force decoding of a field value.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.InitSettingsSource","title":"InitSettingsSource","text":"<pre><code>InitSettingsSource(settings_cls: type[BaseSettings], init_kwargs: dict[str, Any], nested_model_default_partial_update: bool | None = None)\n</code></pre> <p>               Bases: <code>PydanticBaseSettingsSource</code></p> <p>Source class for loading values provided during settings class initialization.</p> Source code in <code>pydantic_settings/sources/base.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    init_kwargs: dict[str, Any],\n    nested_model_default_partial_update: bool | None = None,\n):\n    self.init_kwargs = {}\n    init_kwarg_names = set(init_kwargs.keys())\n    for field_name, field_info in settings_cls.model_fields.items():\n        alias_names, *_ = _get_alias_names(field_name, field_info)\n        init_kwarg_name = init_kwarg_names &amp; set(alias_names)\n        if init_kwarg_name:\n            preferred_alias = alias_names[0]\n            preferred_set_alias = next(alias for alias in alias_names if alias in init_kwarg_name)\n            init_kwarg_names -= init_kwarg_name\n            self.init_kwargs[preferred_alias] = init_kwargs[preferred_set_alias]\n    self.init_kwargs.update({key: val for key, val in init_kwargs.items() if key in init_kwarg_names})\n\n    super().__init__(settings_cls)\n    self.nested_model_default_partial_update = (\n        nested_model_default_partial_update\n        if nested_model_default_partial_update is not None\n        else self.config.get('nested_model_default_partial_update', False)\n    )\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.JsonConfigSettingsSource","title":"JsonConfigSettingsSource","text":"<pre><code>JsonConfigSettingsSource(settings_cls: type[BaseSettings], json_file: PathType | None = DEFAULT_PATH, json_file_encoding: str | None = None)\n</code></pre> <p>               Bases: <code>InitSettingsSource</code>, <code>ConfigFileSourceMixin</code></p> <p>A source class that loads variables from a JSON file</p> Source code in <code>pydantic_settings/sources/providers/json.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    json_file: PathType | None = DEFAULT_PATH,\n    json_file_encoding: str | None = None,\n):\n    self.json_file_path = json_file if json_file != DEFAULT_PATH else settings_cls.model_config.get('json_file')\n    self.json_file_encoding = (\n        json_file_encoding\n        if json_file_encoding is not None\n        else settings_cls.model_config.get('json_file_encoding')\n    )\n    self.json_data = self._read_files(self.json_file_path)\n    super().__init__(settings_cls, self.json_data)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.NoDecode","title":"NoDecode","text":"<p>Annotation to prevent decoding of a field value.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource","title":"PydanticBaseSettingsSource","text":"<pre><code>PydanticBaseSettingsSource(settings_cls: type[BaseSettings])\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Abstract base class for settings sources, every settings source classes should inherit from it.</p> Source code in <code>pydantic_settings/sources/base.py</code> <pre><code>def __init__(self, settings_cls: type[BaseSettings]):\n    self.settings_cls = settings_cls\n    self.config = settings_cls.model_config\n    self._current_state: dict[str, Any] = {}\n    self._settings_sources_data: dict[str, dict[str, Any]] = {}\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource.current_state","title":"current_state  <code>property</code>","text":"<pre><code>current_state: dict[str, Any]\n</code></pre> <p>The current state of the settings, populated by the previous settings sources.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource.settings_sources_data","title":"settings_sources_data  <code>property</code>","text":"<pre><code>settings_sources_data: dict[str, dict[str, Any]]\n</code></pre> <p>The state of all previous settings sources.</p>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource.get_field_value","title":"get_field_value  <code>abstractmethod</code>","text":"<pre><code>get_field_value(field: FieldInfo, field_name: str) -&gt; tuple[Any, str, bool]\n</code></pre> <p>Gets the value, the key for model creation, and a flag to determine whether value is complex.</p> <p>This is an abstract method that should be overridden in every settings source classes.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[Any, str, bool]</code> <p>A tuple that contains the value, key and a flag to determine whether value is complex.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/base.py</code> <pre><code>@abstractmethod\ndef get_field_value(self, field: FieldInfo, field_name: str) -&gt; tuple[Any, str, bool]:\n    \"\"\"\n    Gets the value, the key for model creation, and a flag to determine whether value is complex.\n\n    This is an abstract method that should be overridden in every settings source classes.\n\n    Args:\n        field: The field.\n        field_name: The field name.\n\n    Returns:\n        A tuple that contains the value, key and a flag to determine whether value is complex.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource.field_is_complex","title":"field_is_complex","text":"<pre><code>field_is_complex(field: FieldInfo) -&gt; bool\n</code></pre> <p>Checks whether a field is complex, in which case it will attempt to be parsed as JSON.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool</code> <p>Whether the field is complex.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/base.py</code> <pre><code>def field_is_complex(self, field: FieldInfo) -&gt; bool:\n    \"\"\"\n    Checks whether a field is complex, in which case it will attempt to be parsed as JSON.\n\n    Args:\n        field: The field.\n\n    Returns:\n        Whether the field is complex.\n    \"\"\"\n    return _annotation_is_complex(field.annotation, field.metadata)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource.prepare_field_value","title":"prepare_field_value","text":"<pre><code>prepare_field_value(field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -&gt; Any\n</code></pre> <p>Prepares the value of a field.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>value</code> <code>Any</code> <p>The value of the field that has to be prepared.</p> \u5fc5\u9700 <code>value_is_complex</code> <code>bool</code> <p>A flag to determine whether value is complex.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The prepared value.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/base.py</code> <pre><code>def prepare_field_value(self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool) -&gt; Any:\n    \"\"\"\n    Prepares the value of a field.\n\n    Args:\n        field_name: The field name.\n        field: The field.\n        value: The value of the field that has to be prepared.\n        value_is_complex: A flag to determine whether value is complex.\n\n    Returns:\n        The prepared value.\n    \"\"\"\n    if value is not None and (self.field_is_complex(field) or value_is_complex):\n        return self.decode_complex_value(field_name, field, value)\n    return value\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.PydanticBaseSettingsSource.decode_complex_value","title":"decode_complex_value","text":"<pre><code>decode_complex_value(field_name: str, field: FieldInfo, value: Any) -&gt; Any\n</code></pre> <p>Decode the value for a complex field</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>value</code> <code>Any</code> <p>The value of the field that has to be prepared.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The decoded value for further preparation</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/base.py</code> <pre><code>def decode_complex_value(self, field_name: str, field: FieldInfo, value: Any) -&gt; Any:\n    \"\"\"\n    Decode the value for a complex field\n\n    Args:\n        field_name: The field name.\n        field: The field.\n        value: The value of the field that has to be prepared.\n\n    Returns:\n        The decoded value for further preparation\n    \"\"\"\n    if field and (\n        NoDecode in field.metadata\n        or (self.config.get('enable_decoding') is False and ForceDecode not in field.metadata)\n    ):\n        return value\n\n    return json.loads(value)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.PyprojectTomlConfigSettingsSource","title":"PyprojectTomlConfigSettingsSource","text":"<pre><code>PyprojectTomlConfigSettingsSource(settings_cls: type[BaseSettings], toml_file: Path | None = None)\n</code></pre> <p>               Bases: <code>TomlConfigSettingsSource</code></p> <p>A source class that loads variables from a <code>pyproject.toml</code> file.</p> Source code in <code>pydantic_settings/sources/providers/pyproject.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    toml_file: Path | None = None,\n) -&gt; None:\n    self.toml_file_path = self._pick_pyproject_toml_file(\n        toml_file, settings_cls.model_config.get('pyproject_toml_depth', 0)\n    )\n    self.toml_table_header: tuple[str, ...] = settings_cls.model_config.get(\n        'pyproject_toml_table_header', ('tool', 'pydantic-settings')\n    )\n    self.toml_data = self._read_files(self.toml_file_path)\n    for key in self.toml_table_header:\n        self.toml_data = self.toml_data.get(key, {})\n    super(TomlConfigSettingsSource, self).__init__(settings_cls, self.toml_data)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.SecretsSettingsSource","title":"SecretsSettingsSource","text":"<pre><code>SecretsSettingsSource(settings_cls: type[BaseSettings], secrets_dir: PathType | None = None, case_sensitive: bool | None = None, env_prefix: str | None = None, env_ignore_empty: bool | None = None, env_parse_none_str: str | None = None, env_parse_enums: bool | None = None)\n</code></pre> <p>               Bases: <code>PydanticBaseEnvSettingsSource</code></p> <p>Source class for loading settings values from secret files.</p> Source code in <code>pydantic_settings/sources/providers/secrets.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    secrets_dir: PathType | None = None,\n    case_sensitive: bool | None = None,\n    env_prefix: str | None = None,\n    env_ignore_empty: bool | None = None,\n    env_parse_none_str: str | None = None,\n    env_parse_enums: bool | None = None,\n) -&gt; None:\n    super().__init__(\n        settings_cls, case_sensitive, env_prefix, env_ignore_empty, env_parse_none_str, env_parse_enums\n    )\n    self.secrets_dir = secrets_dir if secrets_dir is not None else self.config.get('secrets_dir')\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.SecretsSettingsSource.find_case_path","title":"find_case_path  <code>classmethod</code>","text":"<pre><code>find_case_path(dir_path: Path, file_name: str, case_sensitive: bool) -&gt; Path | None\n</code></pre> <p>Find a file within path's directory matching filename, optionally ignoring case.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>dir_path</code> <code>Path</code> <p>Directory path.</p> \u5fc5\u9700 <code>file_name</code> <code>str</code> <p>File name.</p> \u5fc5\u9700 <code>case_sensitive</code> <code>bool</code> <p>Whether to search for file name case sensitively.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Path | None</code> <p>Whether file path or <code>None</code> if file does not exist in directory.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/providers/secrets.py</code> <pre><code>@classmethod\ndef find_case_path(cls, dir_path: Path, file_name: str, case_sensitive: bool) -&gt; Path | None:\n    \"\"\"\n    Find a file within path's directory matching filename, optionally ignoring case.\n\n    Args:\n        dir_path: Directory path.\n        file_name: File name.\n        case_sensitive: Whether to search for file name case sensitively.\n\n    Returns:\n        Whether file path or `None` if file does not exist in directory.\n    \"\"\"\n    for f in dir_path.iterdir():\n        if f.name == file_name:\n            return f\n        elif not case_sensitive and f.name.lower() == file_name.lower():\n            return f\n    return None\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.SecretsSettingsSource.get_field_value","title":"get_field_value","text":"<pre><code>get_field_value(field: FieldInfo, field_name: str) -&gt; tuple[Any, str, bool]\n</code></pre> <p>Gets the value for field from secret file and a flag to determine whether value is complex.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>field</code> <code>FieldInfo</code> <p>The field.</p> \u5fc5\u9700 <code>field_name</code> <code>str</code> <p>The field name.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[Any, str, bool]</code> <p>A tuple that contains the value (<code>None</code> if the file does not exist), key, and a flag to determine whether value is complex.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/providers/secrets.py</code> <pre><code>def get_field_value(self, field: FieldInfo, field_name: str) -&gt; tuple[Any, str, bool]:\n    \"\"\"\n    Gets the value for field from secret file and a flag to determine whether value is complex.\n\n    Args:\n        field: The field.\n        field_name: The field name.\n\n    Returns:\n        A tuple that contains the value (`None` if the file does not exist), key, and\n            a flag to determine whether value is complex.\n    \"\"\"\n\n    for field_key, env_name, value_is_complex in self._extract_field_info(field, field_name):\n        # paths reversed to match the last-wins behaviour of `env_file`\n        for secrets_path in reversed(self.secrets_paths):\n            path = self.find_case_path(secrets_path, env_name, self.case_sensitive)\n            if not path:\n                # path does not exist, we currently don't return a warning for this\n                continue\n\n            if path.is_file():\n                return path.read_text().strip(), field_key, value_is_complex\n            else:\n                warnings.warn(\n                    f'attempted to load secret file \"{path}\" but found a {path_type_label(path)} instead.',\n                    stacklevel=4,\n                )\n\n    return None, field_key, value_is_complex\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.TomlConfigSettingsSource","title":"TomlConfigSettingsSource","text":"<pre><code>TomlConfigSettingsSource(settings_cls: type[BaseSettings], toml_file: PathType | None = DEFAULT_PATH)\n</code></pre> <p>               Bases: <code>InitSettingsSource</code>, <code>ConfigFileSourceMixin</code></p> <p>A source class that loads variables from a TOML file</p> Source code in <code>pydantic_settings/sources/providers/toml.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    toml_file: PathType | None = DEFAULT_PATH,\n):\n    self.toml_file_path = toml_file if toml_file != DEFAULT_PATH else settings_cls.model_config.get('toml_file')\n    self.toml_data = self._read_files(self.toml_file_path)\n    super().__init__(settings_cls, self.toml_data)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.YamlConfigSettingsSource","title":"YamlConfigSettingsSource","text":"<pre><code>YamlConfigSettingsSource(settings_cls: type[BaseSettings], yaml_file: PathType | None = DEFAULT_PATH, yaml_file_encoding: str | None = None, yaml_config_section: str | None = None)\n</code></pre> <p>               Bases: <code>InitSettingsSource</code>, <code>ConfigFileSourceMixin</code></p> <p>A source class that loads variables from a yaml file</p> Source code in <code>pydantic_settings/sources/providers/yaml.py</code> <pre><code>def __init__(\n    self,\n    settings_cls: type[BaseSettings],\n    yaml_file: PathType | None = DEFAULT_PATH,\n    yaml_file_encoding: str | None = None,\n    yaml_config_section: str | None = None,\n):\n    self.yaml_file_path = yaml_file if yaml_file != DEFAULT_PATH else settings_cls.model_config.get('yaml_file')\n    self.yaml_file_encoding = (\n        yaml_file_encoding\n        if yaml_file_encoding is not None\n        else settings_cls.model_config.get('yaml_file_encoding')\n    )\n    self.yaml_config_section = (\n        yaml_config_section\n        if yaml_config_section is not None\n        else settings_cls.model_config.get('yaml_config_section')\n    )\n    self.yaml_data = self._read_files(self.yaml_file_path)\n\n    if self.yaml_config_section:\n        try:\n            self.yaml_data = self.yaml_data[self.yaml_config_section]\n        except KeyError:\n            raise KeyError(\n                f'yaml_config_section key \"{self.yaml_config_section}\" not found in {self.yaml_file_path}'\n            )\n    super().__init__(settings_cls, self.yaml_data)\n</code></pre>"},{"location":"api/pydantic_settings/#pydantic_settings.get_subcommand","title":"get_subcommand","text":"<pre><code>get_subcommand(model: PydanticModel, is_required: bool = True, cli_exit_on_error: bool | None = None) -&gt; Optional[PydanticModel]\n</code></pre> <p>Get the subcommand from a model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>model</code> <code>PydanticModel</code> <p>The model to get the subcommand from.</p> \u5fc5\u9700 <code>is_required</code> <code>bool</code> <p>Determines whether a model must have subcommand set and raises error if not found. Defaults to <code>True</code>.</p> <code>True</code> <code>cli_exit_on_error</code> <code>bool | None</code> <p>Determines whether this function exits with error if no subcommand is found. Defaults to model_config <code>cli_exit_on_error</code> value if set. Otherwise, defaults to <code>True</code>.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Optional[PydanticModel]</code> <p>The subcommand model if found, otherwise <code>None</code>.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>SystemExit</code> <p>When no subcommand is found and is_required=<code>True</code> and cli_exit_on_error=<code>True</code> (the default).</p> <code>SettingsError</code> <p>When no subcommand is found and is_required=<code>True</code> and cli_exit_on_error=<code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>pydantic_settings/sources/base.py</code> <pre><code>def get_subcommand(\n    model: PydanticModel, is_required: bool = True, cli_exit_on_error: bool | None = None\n) -&gt; Optional[PydanticModel]:\n    \"\"\"\n    Get the subcommand from a model.\n\n    Args:\n        model: The model to get the subcommand from.\n        is_required: Determines whether a model must have subcommand set and raises error if not\n            found. Defaults to `True`.\n        cli_exit_on_error: Determines whether this function exits with error if no subcommand is found.\n            Defaults to model_config `cli_exit_on_error` value if set. Otherwise, defaults to `True`.\n\n    Returns:\n        The subcommand model if found, otherwise `None`.\n\n    Raises:\n        SystemExit: When no subcommand is found and is_required=`True` and cli_exit_on_error=`True`\n            (the default).\n        SettingsError: When no subcommand is found and is_required=`True` and\n            cli_exit_on_error=`False`.\n    \"\"\"\n\n    model_cls = type(model)\n    if cli_exit_on_error is None and is_model_class(model_cls):\n        model_default = model_cls.model_config.get('cli_exit_on_error')\n        if isinstance(model_default, bool):\n            cli_exit_on_error = model_default\n    if cli_exit_on_error is None:\n        cli_exit_on_error = True\n\n    subcommands: list[str] = []\n    for field_name, field_info in _get_model_fields(model_cls).items():\n        if _CliSubCommand in field_info.metadata:\n            if getattr(model, field_name) is not None:\n                return getattr(model, field_name)\n            subcommands.append(field_name)\n\n    if is_required:\n        error_message = (\n            f'Error: CLI subcommand is required {{{\", \".join(subcommands)}}}'\n            if subcommands\n            else 'Error: CLI subcommand is required but no subcommands were found.'\n        )\n        raise SystemExit(error_message) if cli_exit_on_error else SettingsError(error_message)\n\n    return None\n</code></pre>"},{"location":"api/root_model/","title":"RootModel","text":"<p>RootModel class and type definitions.</p>"},{"location":"api/root_model/#pydantic.root_model.RootModel","title":"RootModel","text":"<pre><code>RootModel(root: RootModelRootType = PydanticUndefined, **data)\n</code></pre> <p>               Bases: <code>BaseModel</code>, <code>Generic[RootModelRootType]</code></p> <p>Usage Documentation</p> <p><code>RootModel</code> and Custom Root Types</p> <p>A Pydantic <code>BaseModel</code> for the root object of the model.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>root</code> <code>RootModelRootType</code> <p>The root object of the model.</p> <code>__pydantic_root_model__</code> <p>Whether the model is a RootModel.</p> <code>__pydantic_private__</code> <p>Private fields in the model.</p> <code>__pydantic_extra__</code> <p>Extra fields in the model.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/root_model.py</code> <pre><code>def __init__(self, /, root: RootModelRootType = PydanticUndefined, **data) -&gt; None:  # type: ignore\n    __tracebackhide__ = True\n    if data:\n        if root is not PydanticUndefined:\n            raise ValueError(\n                '\"RootModel.__init__\" accepts either a single positional argument or arbitrary keyword arguments'\n            )\n        root = data  # type: ignore\n    self.__pydantic_validator__.validate_python(root, self_instance=self)\n</code></pre>"},{"location":"api/root_model/#pydantic.root_model.RootModel.model_construct","title":"model_construct  <code>classmethod</code>","text":"<pre><code>model_construct(root: RootModelRootType, _fields_set: set[str] | None = None) -&gt; Self\n</code></pre> <p>Create a new model using the provided root object and update fields set.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>root</code> <code>RootModelRootType</code> <p>The root object of the model.</p> \u5fc5\u9700 <code>_fields_set</code> <code>set[str] | None</code> <p>The set of fields to be updated.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Self</code> <p>The new model.</p> <p>\u5f15\u53d1\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>NotImplemented</code> <p>If the model is not a subclass of <code>RootModel</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/root_model.py</code> <pre><code>@classmethod\ndef model_construct(cls, root: RootModelRootType, _fields_set: set[str] | None = None) -&gt; Self:  # type: ignore\n    \"\"\"Create a new model using the provided root object and update fields set.\n\n    Args:\n        root: The root object of the model.\n        _fields_set: The set of fields to be updated.\n\n    Returns:\n        The new model.\n\n    Raises:\n        NotImplemented: If the model is not a subclass of `RootModel`.\n    \"\"\"\n    return super().model_construct(root=root, _fields_set=_fields_set)\n</code></pre>"},{"location":"api/root_model/#pydantic.root_model.RootModel.model_dump","title":"model_dump","text":"<pre><code>model_dump(*, mode: Literal['json', 'python'] | str = 'python', include: Any = None, exclude: Any = None, context: dict[str, Any] | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, serialize_as_any: bool = False) -&gt; Any\n</code></pre> <p>This method is included just to get a more accurate return type for type checkers. It is included in this <code>if TYPE_CHECKING:</code> block since no override is actually necessary.</p> <p>See the documentation of <code>BaseModel.model_dump</code> for more details about the arguments.</p> <p>Generally, this method will have a return type of <code>RootModelRootType</code>, assuming that <code>RootModelRootType</code> is not a <code>BaseModel</code> subclass. If <code>RootModelRootType</code> is a <code>BaseModel</code> subclass, then the return type will likely be <code>dict[str, Any]</code>, as <code>model_dump</code> calls are recursive. The return type could even be something different, in the case of a custom serializer. Thus, <code>Any</code> is used here to catch all of these cases.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/root_model.py</code> <pre><code>def model_dump(  # type: ignore\n    self,\n    *,\n    mode: Literal['json', 'python'] | str = 'python',\n    include: Any = None,\n    exclude: Any = None,\n    context: dict[str, Any] | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    serialize_as_any: bool = False,\n) -&gt; Any:\n    \"\"\"This method is included just to get a more accurate return type for type checkers.\n    It is included in this `if TYPE_CHECKING:` block since no override is actually necessary.\n\n    See the documentation of `BaseModel.model_dump` for more details about the arguments.\n\n    Generally, this method will have a return type of `RootModelRootType`, assuming that `RootModelRootType` is\n    not a `BaseModel` subclass. If `RootModelRootType` is a `BaseModel` subclass, then the return\n    type will likely be `dict[str, Any]`, as `model_dump` calls are recursive. The return type could\n    even be something different, in the case of a custom serializer.\n    Thus, `Any` is used here to catch all of these cases.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/standard_library_types/","title":"Standard Library Types","text":"<p>This section enumerates the supported built-in and standard library types: the allowed values, the possible constraints, and whether strictness can be configured.</p> <p>See also the conversion table for a summary of the allowed values for each type.</p> <p>Note</p> <p>Unless specified otherwise, values are serialized as-is, in both Python and JSON modes.</p>"},{"location":"api/standard_library_types/#booleans","title":"Booleans","text":"<p>Built-in type: <code>bool</code></p> Validation <ul> <li>A valid <code>bool</code> instance, i.e. <code>True</code> or <code>False</code>.</li> <li>The integers <code>0</code> or <code>1</code>.</li> <li>A string, which when converted to lowercase is one of <code>'0'</code>, <code>'off'</code>, <code>'f'</code>, <code>'false'</code>, <code>'n'</code>, <code>'no'</code>, <code>'1'</code>, <code>'on'</code> <code>'t'</code>, <code>'true'</code>, <code>'y'</code>, <code>'yes'</code>.</li> <li><code>bytes</code> objects that are valid per the previous rule when decoded to a string.</li> </ul> Strictness <p>In strict mode, only boolean values are valid. Pydantic provides the <code>StrictBool</code> type as a convenience to using the <code>Strict()</code> metadata class.</p> Example <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\n#&gt; bool_value=False\nprint(BooleanModel(bool_value='False'))\n#&gt; bool_value=False\nprint(BooleanModel(bool_value=1))\n#&gt; bool_value=True\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for BooleanModel\n    bool_value\n      Input should be a valid boolean [type=bool_type, input_value=[], input_type=list]\n    \"\"\"\n</code></pre>"},{"location":"api/standard_library_types/#strings","title":"Strings","text":"<p>Built-in type: <code>str</code></p> Validation <ul> <li>Strings are accepted as-is.</li> <li><code>bytes</code> and <code>bytearray</code> are decoded to UTF-8 strings.</li> <li>Enums are converted using the <code>value</code> attribute, by calling <code>str()</code>   on it.</li> <li>If <code>coerce_numbers_to_str</code> is set, any number type   (<code>int</code>, <code>float</code> and <code>Decimal</code>) will be coerced to a string and accepted   as-is.</li> </ul> Constraints <p>Strings support the following constraints:</p> Constraint Description JSON Schema <code>pattern</code> A regex pattern that the string must match <code>pattern</code> keyword (see note below). <code>min_length</code> The minimum length of the string <code>minLength</code> keyword <code>max_length</code> The maximum length of the string <code>maxLength</code> keyword <code>strip_whitespace</code> Whether to remove leading and trailing whitespace N/A <code>to_upper</code> Whether to convert the string to uppercase N/A <code>to_lower</code> Whether to convert the string to lowercase N/A <p>These constraints can be provided using the <code>StringConstraints</code> metadata type, or using the <code>Field()</code> function (except for <code>to_upper</code> and <code>to_lower</code>). The <code>MinLen</code>, <code>MaxLen</code>, <code>Len</code>, <code>LowerCase</code>, <code>UpperCase</code> metadata types from the <code>annotated-types</code> library can also be used.</p> <p></p> <p><code>pattern</code> constraint</p> <p>By default, Pydantic will use the <code>regex</code> Rust crate to enforce the <code>pattern</code> constraint. The regex engine can be controlled using the <code>regex_engine</code> configuration value. If a compiled regular expression object is used for <code>pattern</code>, the Python engine will automatically be used.</p> <p>While the JSON Schema specification recommends using patterns valid according to dialect described in ECMA-262, Pydantic will not enforce it.</p> Strictness <p>In strict mode, only string values are valid. Pydantic provides the <code>StrictStr</code> type as a convenience to using the <code>Strict()</code> metadata class.</p> Example <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, StringConstraints\n\n\nclass StringModel(BaseModel):\n    str_value: str = \"\"\n    constrained_str_value: Annotated[str, StringConstraints(to_lower=True)] = \"\"\n\n\nprint(StringModel(str_value=\"test\").str_value)\n#&gt; test\nprint(StringModel(constrained_str_value='TEST').constrained_str_value)\n#&gt; test\n</code></pre>"},{"location":"api/standard_library_types/#bytes","title":"Bytes","text":"<p>Built-in type: <code>bytes</code>.</p> <p>See also: <code>ByteSize</code>.</p> Validation <ul> <li><code>bytes</code> instances are validated as is.</li> <li>Strings and <code>bytearray</code> instances are converted as bytes, following the <code>val_json_bytes</code> configuration value   (despite its name, it applies to both Python and JSON modes).</li> </ul> Constraints <p>Strings support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The minimum length of the bytes <code>minLength</code> keyword <code>max_length</code> The maximum length of the bytes <code>maxLength</code> keyword <p>The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Strictness <p>In strict mode, only <code>bytes</code> instances are valid. Pydantic provides the <code>StrictBytes</code> type as a convenience to using the <code>Strict()</code> metadata class.</p> <p>In JSON mode, strict mode has no effect.</p> <p></p>"},{"location":"api/standard_library_types/#numbers","title":"Numbers","text":"<p>Pydantic supports the following numeric types from the Python standard library:</p> <p></p>"},{"location":"api/standard_library_types/#integers","title":"Integers","text":"<p>Built-in type: <code>int</code>.</p> Validation <ul> <li>Integers are validated as-is.</li> <li>Strings and bytes are attempted to be converted to integers and validated as-is   (see the jiter implementation for details).</li> <li>Floats are validated as integers, provided the float input is not infinite or a NaN (not-a-number)   and the fractional part is 0.</li> <li><code>Decimal</code> instances, provided they are finite and the   denominator is 1.</li> <li><code>Fraction</code> instances, provided they are integers.</li> <li>Enums are converted using the <code>value</code> attribute.</li> </ul> Constraints <p>Integers support the following constraints (numbers must be coercible to integers):</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this number <code>maximum</code> keyword <code>ge</code> The value must be greater than or equal to this number <code>minimum</code> keyword <code>lt</code> The value must be strictly less than this number <code>exclusiveMaximum</code> keyword <code>gt</code> The value must be strictly greater than this number <code>exclusiveMinimum</code> keyword <code>multiple_of</code> The value must be a multiple of this number <code>multipleOf</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code>, <code>Gt</code> and <code>MultipleOf</code> metadata types from the <code>annotated-types</code> library can also be used.</p> <p>Pydantic also provides the following types to further constrain the allowed integer values:</p> <ul> <li><code>PositiveInt</code>: Requires the input to be greater than zero.</li> <li><code>NegativeInt</code>: Requires the input to be less than zero.</li> <li><code>NonPositiveInt</code>: Requires the input to be less than or equal to zero.</li> <li><code>NonNegativeInt</code>: Requires the input to be greater than or equal to zero.</li> </ul> Strictness <p>In strict mode, only integer values are valid. Pydantic provides the <code>StrictInt</code> type as a convenience to using the <code>Strict()</code> metadata class.</p> <p></p>"},{"location":"api/standard_library_types/#floats","title":"Floats","text":"<p>Built-in type: <code>float</code>.</p> Validation <ul> <li>Floats are validated as-is.</li> <li>String and bytes are attempted to be converted to floats and validated as-is.   (see the Rust implementation for details).</li> <li>If the input has a <code>__float__()</code> method, it will be called to convert the input into   a float. If <code>__float__()</code> is not defined, it falls back to <code>__index__()</code>. This includes   (but not limited to) the <code>Decimal</code> and <code>Fraction</code> types.</li> </ul> Constraints <p>Floats support the following constraints:</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this number <code>maximum</code> keyword <code>ge</code> The value must be greater than or equal to this number <code>minimum</code> keyword <code>lt</code> The value must be strictly less than this number <code>exclusiveMaximum</code> keyword <code>gt</code> The value must be strictly greater than this number <code>exclusiveMinimum</code> keyword <code>multiple_of</code> The value must be a multiple of this number <code>multipleOf</code> keyword <code>allow_inf_nan</code> Whether to allow NaN (not-a-number) and infinite values N/A <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code>, <code>Gt</code> and <code>MultipleOf</code> metadata types from the <code>annotated-types</code> library and the <code>AllowInfNan</code> type can also be used.</p> <p>Pydantic also provides the following types as convenience aliases:</p> <ul> <li><code>PositiveFloat</code>: Requires the input to be greater than zero.</li> <li><code>NegativeFloat</code>: Requires the input to be less than zero.</li> <li><code>NonPositiveFloat</code>: Requires the input to be less than or equal to zero.</li> <li><code>NonNegativeFloat</code>: Requires the input to be greater than or equal to zero.</li> <li><code>FiniteFloat</code>: Prevents NaN (not-a-number) and infinite values.</li> </ul> Strictness <p>In strict mode, only float values and inputs having a <code>__float__()</code> or <code>__index__()</code> method are valid. Pydantic provides the <code>StrictFloat</code> type as a convenience to using the <code>Strict()</code> metadata class.</p> <p></p>"},{"location":"api/standard_library_types/#integer-enums","title":"Integer enums","text":"<p>Standard library type: <code>enum.IntEnum</code>.</p> Validation <ul> <li>If the <code>enum.IntEnum</code> type is used directly, any <code>enum.IntEnum</code> instance is validated as-is</li> <li>Id an <code>enum.IntEnum</code> subclass is used as a type, any enum member or value that correspond to the   enum members values is validated as-is.</li> </ul> <p>See Enums for more details.</p> <p></p>"},{"location":"api/standard_library_types/#decimals","title":"Decimals","text":"<p>Standard library type: <code>decimal.Decimal</code>.</p> Validation <ul> <li><code>Decimal</code> instances are validated as is.</li> <li>Any value accepted by the <code>Decimal</code> constructor (apart from the   three-tuple input) will validate.</li> </ul> Constraints <p>Decimals support the following constraints (numbers must be coercible to decimals):</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this number <code>maximum</code> keyword <code>ge</code> The value must be greater than or equal to this number <code>minimum</code> keyword <code>lt</code> The value must be strictly less than this number <code>exclusiveMaximum</code> keyword <code>gt</code> The value must be strictly greater than this number <code>exclusiveMinimum</code> keyword <code>multiple_of</code> The value must be a multiple of this number <code>multipleOf</code> keyword <code>allow_inf_nan</code> Whether to allow NaN (not-a-number) and infinite values N/A <code>max_digits</code> The maximum number of decimal digits allowed. The zero before the decimal point and trailing zeros are not counted. <code>pattern</code> keyword, to describe the string pattern <code>decimal_places</code> The maximum number of decimal places allowed. Trailing zeros are not counted. <code>pattern</code> keyword, to describe the string pattern <p>Note that the JSON Schema <code>pattern</code> keyword will be specified in the JSON Schema to describe the string pattern in all cases (and can vary if <code>max_digits</code> and/or <code>decimal_places</code> is specified).</p> <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code>, <code>Gt</code> and <code>MultipleOf</code> metadata types from the <code>annotated-types</code> library and the <code>AllowInfNan</code> type can also be used.</p> Strictness <p>In strict mode, only <code>decimal.Decimal</code> instances are accepted. In JSON mode, strict mode has no effect.</p> Serialization <p>In Python mode, <code>Decimal</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings. A serializer can be used to override this behavior:</p> <pre><code>from decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\n\nclass Model(BaseModel):\n    f: Annotated[Decimal, PlainSerializer(float, when_used='json')]\n\n\nmy_model = Model(f=Decimal('2.1'))\n\nprint(my_model.model_dump())  # (1)!\n#&gt; {'f': Decimal('2.1')}\nprint(my_model.model_dump_json())  # (2)!\n#&gt; {\"f\":2.1}\n</code></pre> <ol> <li>In Python mode, <code>f</code>remains a <code>Decimal</code> instance.</li> <li>In JSON mode, <code>f</code> is serialized as a float.</li> </ol> <p></p>"},{"location":"api/standard_library_types/#complex-numbers","title":"Complex numbers","text":"<p>Built-in type: <code>complex</code>.</p> Validation <ul> <li><code>complex</code> instances are validated as-is.</li> <li>Strings are validated using the <code>complex()</code> constructor.</li> <li>Numbers (integers and floats) are used as the real part.</li> <li>Objects defining <code>__complex__()</code>, <code>__float__()</code>.   or <code>__index__()</code> are currently not accepted.</li> </ul> Strictness <p>In strict mode, only <code>complex</code> instances are accepted. In JSON mode, only strings that are accepted by the <code>complex()</code> constructor are allowed.</p> Serialization <p>In Python mode, <code>complex</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p> <p></p>"},{"location":"api/standard_library_types/#fractions","title":"Fractions","text":"<p>Standard library type: <code>fractions.Fraction</code>.</p> Validation <ul> <li><code>Fraction</code> instances are validated as is.</li> <li>Floats, strings and <code>decimal.Decimal</code> instances are validated using the <code>Fraction()</code>   constructor.</li> </ul> Strictness <p>In strict mode, only <code>Fraction</code> instances are accepted. In JSON mode, strict mode has no effect.</p> Serialization <p>Fractions are serialized as strings, both in Python and JSON modes.</p> <p></p>"},{"location":"api/standard_library_types/#date-and-time-types","title":"Date and time types","text":"<p>Pydantic supports the following date and time types from the <code>datetime</code> standard library:</p> <p></p>"},{"location":"api/standard_library_types/#datetimes","title":"Datetimes","text":"<p>Standard library type: <code>datetime.datetime</code>.</p> Validation <ul> <li><code>datetime</code> instances are validated as is.</li> <li>Strings and bytes are validated in two ways:<ul> <li>Strings complying to the RFC 3339 format (both datetime and date).   See the speedate documentation for more details.</li> <li>Unix timestamps, both as seconds or milliseconds sinch the epoch.   See the <code>val_temporal_unit</code> configuration value for more details.</li> </ul> </li> <li>Integers and floats (or types that can be coerced as integers or floats) are validated as unix timestamps, following the   same semantics as strings.</li> <li><code>datetime.date</code> instances are accepted, and converted to a <code>datetime</code> instance   by setting the <code>hour</code>, <code>minute</code>, <code>second</code> and   <code>microsecond</code> attributes to <code>0</code>, and the <code>tzinfo</code> attribute to <code>None</code>.</li> </ul> <p>Note</p> <p>Named timezone support (as specified in RFC 9557) can be tracked in this issue.</p> Serialization <p>In Python mode, <code>datetime</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p> Constraints <p>Datetimes support the following constraints (constraint values must be coercible to a <code>datetime</code> instance):</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this datetime N/A <code>ge</code> The value must be greater than or equal to this datetime N/A <code>lt</code> The value must be strictly less than this datetime N/A <code>gt</code> The value must be strictly greater than this datetime N/A <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code> and <code>Gt</code> metadata types from the <code>annotated-types</code> library can also be used.</p> <p>Pydantic also provides the following types to further constrain the allowed datetime values:</p> <ul> <li><code>AwareDatetime</code>: Requires the input to have a timezone.</li> <li><code>NaiveDatetime</code>: Requires the input to not have a timezone.</li> <li><code>PastDatetime</code>: Requires the input to be in the past when validated.</li> <li><code>FutureDatetime</code>: Requires the input to be in the future when validated.</li> </ul> Strictness <p>In strict mode, only <code>datetime</code> instances are accepted. In JSON mode, only strings complying to the RFC 3339 format (only datetime) or as unix timestamps are accepted.</p> Example <pre><code>from datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import AwareDatetime, BaseModel, Field\n\n\nclass Event(BaseModel):\n    dt: Annotated[AwareDatetime, Field(gt=datetime(2000, 1, 1))]\n\n\nevent = Event(dt='2032-04-23T10:20:30.400+02:30')\n\nprint(event.model_dump())\n\"\"\"\n{'dt': datetime.datetime(2032, 4, 23, 10, 20, 30, 400000, tzinfo=TzInfo(9000))}\n\"\"\"\nprint(event.model_dump_json())\n#&gt; {\"dt\":\"2032-04-23T10:20:30.400000+02:30\"}\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#dates","title":"Dates","text":"<p>Standard library type: <code>datetime.date</code>.</p> Validation <ul> <li><code>date</code> instances are validated as is.</li> <li>Strings and bytes are validated in two ways:<ul> <li>Strings complying to the RFC 3339 date format.   See the speedate documentation for more details.</li> <li>Unix timestamps, both as seconds or milliseconds sinch the epoch.   See the <code>val_temporal_unit</code> configuration value for more details.</li> </ul> </li> <li>If the validation fails, the input can be validated as a datetime (including as numbers),   provided that the time component is 0 and that it is naive.</li> </ul> Serialization <p>In Python mode, <code>date</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p> Constraints <p>Dates support the following constraints (constraint values must be coercible to a <code>date</code> instance):</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this date N/A <code>ge</code> The value must be greater than or equal to this date N/A <code>lt</code> The value must be strictly less than this date N/A <code>gt</code> The value must be strictly greater than this date N/A <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code> and <code>Gt</code> metadata types from the <code>annotated-types</code> library can also be used.</p> <p>Pydantic also provides the following types to further constrain the allowed date values:</p> <ul> <li><code>PastDate</code>: Requires the input to be in the past when validated.</li> <li><code>FutureDate</code>: Requires the input to be in the future when validated.</li> </ul> Strictness <p>In strict mode, only <code>date</code> instances are accepted. In JSON mode, only strings complying to the RFC 3339 format (only date) or as unix timestamps are accepted.</p> Example <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass Birthday(BaseModel):\n    d: date\n\n\nmy_birthday = Birthday(d=1679616000.0)\n\nprint(my_birthday.model_dump())\n#&gt; {'d': datetime.date(2023, 3, 24)}\nprint(my_birthday.model_dump_json())\n#&gt; {\"d\":\"2023-03-24\"}\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#time","title":"Time","text":"<p>Standard library type: <code>datetime.time</code>.</p> Validation <ul> <li><code>time</code> instances are validated as is.</li> <li>Strings and bytes are validated according to the RFC 3339 time format.</li> <li>Integers and floats (or values that can be coerced to such numbers) are validated as seconds. The value should not exceed 86 399.</li> </ul> Serialization <p>In Python mode, <code>time</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p> <p>Note</p> <p>Named timezones from the IANA time zone database (see the <code>zoneinfo</code> module) are not serialized with time objects. This is consistent with the <code>time.isoformat()</code> method.</p> Constraints <p>Time support the following constraints (constraint values must be coercible to a <code>time</code> instance):</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this time N/A <code>ge</code> The value must be greater than or equal to this time N/A <code>lt</code> The value must be strictly less than this time N/A <code>gt</code> The value must be strictly greater than this time N/A <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code> and <code>Gt</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Strictness <p>In strict mode, only <code>time</code> instances are accepted. In JSON mode, only strings complying to the RFC 3339 format are accepted.</p> Example <pre><code>from datetime import time\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    t: time\n\n\nm = Meeting(t=time(4, 8, 16))\n\nprint(m.model_dump())\n#&gt; {'t': datetime.time(4, 8, 16)}\nprint(m.model_dump_json())\n#&gt; {\"t\":\"04:08:16\"}\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#timedeltas","title":"Timedeltas","text":"<p>Standard library type: <code>datetime.timedelta</code>.</p> Validation <ul> <li><code>timedelta</code> instances are validated as is.</li> <li>Strings and bytes are validated according to the RFC 3339 time format.</li> <li>Integers and floats (or values that can be coerced to such numbers) are validated as seconds.</li> </ul> Constraints <p>Timedeltas support the following constraints (constraint values must be coercible to a <code>timedata</code> instance):</p> Constraint Description JSON Schema <code>le</code> The value must be less than or equal to this timedelta N/A <code>ge</code> The value must be greater than or equal to this timedelta N/A <code>lt</code> The value must be strictly less than this timedelta N/A <code>gt</code> The value must be strictly greater than this timedelta N/A <p>These constraints can be provided using the <code>Field()</code> function. The <code>Le</code>, <code>Ge</code>, <code>Lt</code> and <code>Gt</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Serialization <p>In Python mode, <code>timedelta</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p> Strictness <p>In strict mode, only <code>timedelta</code> instances are accepted. In JSON mode, only strings complying to the RFC 3339 format are accepted.</p> Example <pre><code>from datetime import timedelta\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    td: timedelta\n\n\nm = Model(td='P3DT12H30M5S')\n\nprint(m.model_dump())\n#&gt; {'td': datetime.timedelta(days=3, seconds=45005)}\nprint(m.model_dump_json())\n#&gt; {\"td\":\"P3DT12H30M5S\"}\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#enums","title":"Enums","text":"<p>Standard library type: <code>enum.Enum</code>.</p> Validation <ul> <li>If the <code>enum.Enum</code> type is used directly, any <code>enum.Enum</code> instance is validated as-is.</li> <li>Id an <code>enum.Enum</code> subclass is used as a type, any enum member or value that correspond to the   enum members values is validated as-is.</li> </ul> Serialization <p>In Python mode, enum instances are serialized as is. The <code>use_enum_values</code> configuration value can be set to use the enum value during validation (so that it is also used during serialization).</p> <p>In JSON mode, enum instances are serialized using their value.</p> Example <pre><code>from enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    PEAR = 'pear'\n    BANANA = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    SPANNER = 1\n    WRENCH = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.PEAR\n    tool: ToolEnum = ToolEnum.SPANNER\n\n\nprint(CookingModel())\n#&gt; fruit=&lt;FruitEnum.PEAR: 'pear'&gt; tool=&lt;ToolEnum.SPANNER: 1&gt;\nprint(CookingModel(tool=2, fruit='banana'))\n#&gt; fruit=&lt;FruitEnum.BANANA: 'banana'&gt; tool=&lt;ToolEnum.WRENCH: 2&gt;\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for CookingModel\n    fruit\n      Input should be 'pear' or 'banana' [type=enum, input_value='other', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"api/standard_library_types/#none-types","title":"None types","text":"<p>Supported types: <code>None</code>, <code>NoneType</code> or <code>Literal[None]</code> (they are equivalent).</p> <p>Allows only <code>None</code> as a value.</p>"},{"location":"api/standard_library_types/#generic-collection-types","title":"Generic collection types","text":"<p>Pydantic supports a wide variety of generic collection types, both built-ins (such as <code>list</code>) and abstract base classes from the <code>collections.abc</code> module (such as <code>Sequence</code>).</p> <p>In most cases, it is recommended to make use of the built-in types over the abstract ones. Due to data coercion, using <code>list</code> or <code>tuple</code> will allow most other iterables as input, with better performance.</p> <p>Strictness on collection types</p> <p>When applying strict mode on collection types, strictness will not apply to the inner types. This may change in the future, see this issue.</p>"},{"location":"api/standard_library_types/#lists","title":"Lists","text":"<p>Built-in type: <code>list</code> (deprecated alias: <code>typing.List</code>).</p> Validation <ul> <li>Allows <code>list</code>, <code>tuple</code>, <code>set</code> and <code>frozenset</code> instances, or any iterable that is not a   string, bytes, bytearray, dict or mapping. Produces a <code>list</code> instance.</li> <li>If a generic parameter is provided, the appropriate validation is applied to all items of the list.</li> </ul> Constraints <p>Lists support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The list must have at least this many items <code>minItems</code> keyword <code>max_length</code> The list must have at most this many items <code>maxItems</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Strictness <p>In strict mode, only <code>list</code> instances are valid. Strict mode does not apply to the items of the list. The strict constraint must be applied to the parameter type for this to work.</p> Example Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    simple_list: Optional[list[object]] = None\n    list_of_ints: Optional[list[int]] = Field(default=None, strict=True)\n\n\nprint(Model(simple_list=('1', '2', '3')).simple_list)\n#&gt; ['1', '2', '3']\nprint(Model(list_of_ints=['1', 2, 3]).list_of_ints)\n#&gt; [1, 2, 3]\n</code></pre> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    simple_list: list[object] | None = None\n    list_of_ints: list[int] | None = Field(default=None, strict=True)\n\n\nprint(Model(simple_list=('1', '2', '3')).simple_list)\n#&gt; ['1', '2', '3']\nprint(Model(list_of_ints=['1', 2, 3]).list_of_ints)\n#&gt; [1, 2, 3]\n</code></pre>"},{"location":"api/standard_library_types/#tuples","title":"Tuples","text":"<p>Built-in type: <code>tuple</code> (deprecated alias: <code>typing.Tuple</code>).</p> <p>Note</p> <p>Unpacked tuple types (as specified by PEP 646) are not yet supported, and can be tracked in this issue.</p> Validation <ul> <li>Allows <code>tuple</code>, <code>list</code>, <code>set</code> and <code>frozenset</code> instances, or any iterable that is not a   string, bytes, bytearray, dict or mapping. Produces a <code>tuple</code> instance.</li> <li>Appropriate validation is applied to items of the tuple, if element types   are specified.</li> </ul> Constraints <p>Lists support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The tuple must have at least this many items <code>minItems</code> keyword <code>max_length</code> The tuple must have at most this many items <code>maxItems</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> <p>Additionally, the <code>prefixItems</code> JSON Schema keyword may be used depending on the tuple shape.</p> Strictness <p>In strict mode, only <code>tuple</code> instances are valid. Strict mode does not apply to the items of the tuple. The strict constraint must be applied to the parameter types for this to work.</p> Example Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_tuple: Optional[tuple] = None\n    tuple_of_different_types: Optional[tuple[int, float, bool]] = None\n\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#&gt; (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[3, 2, 1]).tuple_of_different_types)\n#&gt; (3, 2.0, True)\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_tuple: tuple | None = None\n    tuple_of_different_types: tuple[int, float, bool] | None = None\n\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#&gt; (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[3, 2, 1]).tuple_of_different_types)\n#&gt; (3, 2.0, True)\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#named-tuples","title":"Named tuples","text":"<p>Standard library type: <code>typing.NamedTuple</code> (and types created by the <code>collections.namedtuple()</code> factory function \u2013 each field will implicitly have the type <code>Any</code>).</p> Validation <ul> <li>Allows <code>tuple</code> and <code>list</code> instances. Validate each item according to the field definition.</li> <li>Allows <code>dict</code> instances. Keys must match the named tuple field names, and values are validated according to the field definition.</li> </ul> Serialization <p>In Python mode, named tuples are serialized as tuples. In JSON mode, they are serialized as arrays.</p> Example <pre><code>from typing import NamedTuple\n\nfrom pydantic import BaseModel\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\nmodel = Model(p=('1', 2))\n\nprint(model.model_dump())\n#&gt; {'p': (1, 2)}\n</code></pre>"},{"location":"api/standard_library_types/#sets","title":"Sets","text":"<p>Types: <code>set</code> (or <code>collections.abc.MutableSet</code>) and <code>frozenset</code> (or <code>collections.abc.Set</code>) (deprecated aliases: <code>typing.Set</code> and <code>typing.FrozenSet</code>).</p> Validation <ul> <li>Allows <code>set</code>, <code>frozenset</code>, <code>tuple</code> and <code>list</code> instances, or any iterable that is not a   string, bytes, bytearray, dict or mapping. Produces a <code>set</code> or <code>frozenset</code> instance.</li> <li>If a generic parameter is provided, the appropriate validation is applied to all items of the set/frozenset.</li> </ul> Constraints <p>Sets support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The set must have at least this many items <code>minItems</code> keyword <code>max_length</code> The set must have at most this many items <code>maxItems</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Strictness <p>In strict mode, only <code>set</code>/<code>frozenset</code> instances are valid. Strict mode does not apply to the items of the set. The strict constraint must be applied to the parameter type for this to work.</p> Serialization <p>In Python mode, sets are serialized as is. In JSON mode, they are serialized as arrays.</p> Example Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_set: Optional[set] = None\n    set_of_ints: Optional[frozenset[int]] = None\n\n\nprint(Model(simple_set=['1', '2', '3']).simple_set)\n#&gt; {'1', '2', '3'}\nprint(Model(set_of_ints=['1', '2', '3']).set_of_ints)\n#&gt; frozenset({1, 2, 3})\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_set: set | None = None\n    set_of_ints: frozenset[int] | None = None\n\n\nprint(Model(simple_set=['1', '2', '3']).simple_set)\n#&gt; {'1', '2', '3'}\nprint(Model(set_of_ints=['1', '2', '3']).set_of_ints)\n#&gt; frozenset({1, 2, 3})\n</code></pre>"},{"location":"api/standard_library_types/#deque","title":"Deque","text":"<p>Standard library type: <code>collections.deque</code> (deprecated alias: <code>typing.Deque</code>).</p> Validation <p>Values are first validated as a list, and then passed to the <code>deque</code> constructor.</p> Constraints <p>Deques support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The deque must have at least this many items <code>minItems</code> keyword <code>max_length</code> The deque must have at most this many items <code>maxItems</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Strictness <p>In strict mode, only <code>deque</code> instances are valid. Strict mode does not apply to the items of the deque. The strict constraint must be applied to the parameter type for this to work.</p> Serialization <p>In Python mode, deques are serialized as is. In JSON mode, they are serialized as arrays.</p> Example <pre><code>from collections import deque\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    deque: deque[int]\n\n\nprint(Model(deque=[1, 2, 3]).deque)\n#&gt; deque([1, 2, 3])\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#sequences","title":"Sequences","text":"<p>Standard library type: <code>collections.abc.Sequence</code> (deprecated alias: <code>typing.Sequence</code>).</p> <p>In most cases, you will want to use the built-in types (such as list or tuple) as type coercion will apply. The <code>Sequence</code> type can be used when you want to preserve the input type during serialization.</p> Validation <p>Any <code>collections.abc.Sequence</code> instance (expect strings and bytes) is accepted. It is converted to a list using the <code>list()</code> constructor, and then converted back to the original input type.</p> <p>Strings aren't treated as sequences</p> <p>While strings are technically valid sequence instances, this is frequently not intended as is a common source of bugs.</p> <p>As a result, Pydantic will not accept strings and bytes for the <code>Sequence</code> type (see example below).</p> Constraints <p>Sequences support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The sequence must have at least this many items <code>minItems</code> keyword <code>max_length</code> The sequence must have at most this many items <code>maxItems</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Serialization <p>In Python mode, sequences are serialized as is. In JSON mode, they are serialized as arrays.</p> Example <pre><code>from collections.abc import Sequence\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    sequence_of_strs: Sequence[str]\n\n\nprint(Model(sequence_of_strs=['a', 'bc']).sequence_of_strs)\n#&gt; ['a', 'bc']\nprint(Model(sequence_of_strs=('a', 'bc')).sequence_of_strs)\n#&gt; ('a', 'bc')\n\ntry:\n    Model(sequence_of_strs='abc')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    sequence_of_strs\n      'str' instances are not allowed as a Sequence value [type=sequence_str, input_value='abc', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"api/standard_library_types/#dictionaries","title":"Dictionaries","text":"<p>Built-in type: <code>dict</code>.</p> Validation <ul> <li><code>dict</code> instances are accepted as is.</li> <li>mappings instances are accepted and coerced to a <code>dict</code>.</li> <li>If generic parameters for keys and values are provided, the appropriate validation is applied.</li> </ul> Constraints <p>Dictionaries support the following constraints:</p> Constraint Description JSON Schema <code>min_length</code> The dictionary must have at least this many items <code>minItems</code> keyword <code>max_length</code> The dictionary must have at most this many items <code>maxItems</code> keyword <p>These constraints can be provided using the <code>Field()</code> function. The <code>MinLen</code> and <code>MaxLen</code> metadata types from the <code>annotated-types</code> library can also be used.</p> Strictness <p>In strict mode, only <code>dict</code> instances are valid. Strict mode does not apply to the keys and values of the dictionaries. The strict constraint must be applied to the parameter types for this to work.</p> Example <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict[str, int]\n\n\nm = Model(x={'foo': 1})\nprint(m.model_dump())\n#&gt; {'x': {'foo': 1}}\n\ntry:\n    Model(x='test')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid dictionary [type=dict_type, input_value='test', input_type=str]\n    \"\"\"\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#typed-dictionaries","title":"Typed dictionaries","text":"<p>Standard library type: <code>typing.TypedDict</code> (see also: the typing specification).</p> <p>Note</p> <p>Because of runtime limitations, Pydantic will require using the <code>TypedDict</code> type from <code>typing_extensions</code> when using Python 3.12 and lower.</p> <p><code>TypedDict</code> declares a dictionary type that expects all of its instances to have a certain set of keys  where each key is associated with a value of a consistent type.</p> <p>This type supports configuration.</p> Strictness <p>In strict mode, only <code>dict</code> instances are valid (unlike mappings in lax mode). Strict mode does not apply to the values of the typed dictionary. The strict constraint must be applied to the value types for this to work.</p> Example Python 3.9 and abovePython 3.13 and above <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n#&gt; {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n    \"\"\"\n</code></pre> <pre><code>from typing import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n#&gt; {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n    \"\"\"\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#iterables","title":"Iterables","text":"<p>Standard library type: <code>collections.abc.Iterable</code> (deprecated alias: <code>typing.Iterable</code>).</p> Validation <p>Iterables are lazily validated, and wrapped in an internal datastructure that can be iterated over (and will validated the items type while doing so). This means that even if you provide a concrete container such as a list, the validated type will not be of type <code>list</code>. However, Pydantic will ensure that the input value is iterable by getting an iterator from it (by calling <code>iter()</code> on the value).</p> <p>It is recommended to use concrete collection types (such as lists) instead, unless you are using an infinite iterator (in which case eagerly validating the input would result in an infinite loop).</p> Example <pre><code>from collections.abc import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    f: Iterable[str]\n\n\nm = Model(f=[1, 2])  # Validates fine\n\ntry:\n    next(m.f)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ValidatorIterator\n    0\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    \"\"\"\n</code></pre>"},{"location":"api/standard_library_types/#callable","title":"Callable","text":"<p>Standard library type: <code>collections.abc.Callable</code> (deprecated alias: <code>typing.Callable</code>).</p> Validation <p>Pydantic only validates that the input is a callable (using the <code>callable()</code> function). It does not validate the number of parameters or their type, nor the type of the return value.</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#&gt; callback=&lt;function &lt;lambda&gt; at 0x0123456789ab&gt;\n</code></pre> <pre><code>from collections.abc import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#&gt; callback=&lt;function &lt;lambda&gt; at 0x0123456789ab&gt;\n</code></pre> Serialization <p>Callables are serialized as is. Callables can't be serialized in JSON mode (a <code>PydanticSerializationError</code> is raised).</p> <p></p>"},{"location":"api/standard_library_types/#ip-addresses","title":"IP Addresses","text":"<p>Standard library types:</p> <ul> <li><code>ipaddress.IPv4Address</code></li> <li><code>ipaddress.IPv4Interface</code></li> <li><code>ipaddress.IPv4Network</code></li> <li><code>ipaddress.IPv6Address</code></li> <li><code>ipaddress.IPv6Interface</code></li> <li><code>ipaddress.IPv6Network</code></li> </ul> <p>See also: the <code>IPvAnyAddress</code>, <code>IPvAnyInterface</code> and <code>IPvAnyNetwork</code> Pydantic types.</p> Validation <ul> <li>Instances are validated as is.</li> <li>Other input values are passed to the constructor of the relevant address type.</li> </ul> Strictness <p>In strict mode, only the address types are accepted. In JSON mode, strict mode has no effect.</p> Serialization <p>In Python mode, IP addresses are serialized as is. In JSON mode, they are serialized as strings.</p>"},{"location":"api/standard_library_types/#uuid","title":"UUID","text":"<p>Standard library type: <code>uuid.UUID</code>.</p> Validation <ul> <li><code>UUID</code> instances are validated as is.</li> <li>Strings and bytes are validated as UUIDs, and casted to a <code>UUID</code> instance.</li> </ul> Constraints <p>The <code>UUID</code> type supports a <code>version</code> constraint. The <code>UuidVersion</code> metadata type can be used.</p> <p>Pydantic also provides the following types as convenience aliases: <code>UUID1</code>, <code>UUID3</code>, <code>UUID4</code>, <code>UUID5</code>, <code>UUID6</code>, <code>UUID7</code>, <code>UUID8</code>.</p> Strictness <p>In strict mode, only <code>UUID</code> instances are accepted. In JSON mode, strict mode has no effect.</p> Serialization <p>In Python mode, UUIDs are serialized as is. In JSON mode, they are serialized as strings.</p> Example <pre><code>from typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\nfrom pydantic.types import UUID7, UuidVersion\n\n\nclass Model(BaseModel):\n    u1: UUID7\n    u2: Annotated[UUID, UuidVersion(4)]\n\n\nprint(\n    Model(\n        u1='01999b2c-8353-749b-8dac-859307fae22b',\n        u2=UUID('125725f3-e1b4-44e3-90c3-1a20eab12da5'),\n    )\n)\n\"\"\"\nu1=UUID('01999b2c-8353-749b-8dac-859307fae22b') u2=UUID('125725f3-e1b4-44e3-90c3-1a20eab12da5')\n\"\"\"\n</code></pre>"},{"location":"api/standard_library_types/#type","title":"Type","text":"<p>Built-in type: <code>type</code> (deprecated alias: <code>typing.Type</code>).</p> Validation <p>Allows any type that is a subclass of the type argument. For instance, with <code>type[str]</code>, allows the <code>str</code> class or any <code>str</code> subclass as an input. If no type argument is provided (i.e. <code>type</code> is used as an annotation), allow any class.</p> Serialization <p>Types are serialized as is. Types can't be serialized in JSON mode (a <code>PydanticSerializationError</code> is raised).</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      Input should be a subclass of Foo [type=is_subclass_of, input_value=&lt;class '__main__.Other'&gt;, input_type=type]\n    \"\"\"\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#literals","title":"Literals","text":"<p>Typing construct: <code>typing.Literal</code> (see also: the typing specification).</p> <p>Literals can be used to only allow specific literal values.</p> <p>Note that Pydantic applies strict mode behavior when validating literal values (see this issue).</p> Example <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n    quantity: Literal[1, 2] = 1\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    flavor\n      Input should be 'apple' or 'pumpkin' [type=literal_error, input_value='cherry', input_type=str]\n    \"\"\"\n\ntry:\n    Pie(flavor='apple', quantity='1')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    quantity\n      Input should be 1 or 2 [type=literal_error, input_value='1', input_type=str]\n    \"\"\"\n</code></pre> <p></p>"},{"location":"api/standard_library_types/#any","title":"Any","text":"<p>Types: <code>typing.Any</code> or <code>object</code>.</p> <p>Allows any value, including <code>None</code>.</p> <p></p>"},{"location":"api/standard_library_types/#hashables","title":"Hashables","text":"<p>Standard library type: <code>collections.abc.Hashable</code> (deprecated alias: <code>typing.Hashable</code>).</p> Validation <p>Any value that is hashable (using <code>isinstance(value, Hashable)</code>).</p> <p></p>"},{"location":"api/standard_library_types/#regex-patterns","title":"Regex patterns","text":"<p>Standard library type: <code>re.Pattern</code> (deprecated alias: <code>typing.Pattern</code>).</p> Validation <ul> <li>For <code>Pattern</code> instances, check that the <code>pattern</code> attribute   is of the right type (<code>str</code> or <code>bytes</code> depending on the <code>Pattern</code> type   parameter).</li> <li>If the type parameter is <code>str</code> or <code>bytes</code>, input values of type <code>str</code> (or <code>bytes</code> respectively)   are attempted to be compiled using <code>re.compile()</code>.</li> </ul> Serialization <p>In Python mode, <code>Pattern</code> instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p> <p></p>"},{"location":"api/standard_library_types/#paths","title":"Paths","text":"<p>Standard library types:</p> <ul> <li><code>pathlib.Path</code>.</li> <li><code>pathlib.PurePath</code>.</li> <li><code>pathlib.PosixPath</code>.</li> <li><code>pathlib.PurePosixPath</code>.</li> <li><code>pathlib.PureWindowsPath</code>.</li> <li><code>os.PathLike</code> (must be parameterized with <code>str</code>, <code>bytes</code> or <code>Any</code>).</li> </ul> Validation <ul> <li>Path instances are validated as is.</li> <li>Strings are accepted and passed to the type constructor. If <code>os.PathLike</code> was used,   bytes are accepted if it was parameterized with the <code>bytes</code> type.</li> </ul> Strictness <p>In strict mode, only Path instances are accepted. In JSON mode, strict mode has no effect.</p> Serialization <p>In Python mode, Path instances are serialized as is.</p> <p>In JSON mode, they are serialized as strings.</p>"},{"location":"api/type_adapter/","title":"TypeAdapter","text":"<p>               Bases: <code>Generic[T]</code></p> <p>Usage Documentation</p> <p><code>TypeAdapter</code></p> <p>Type adapters provide a flexible way to perform validation and serialization based on a Python type.</p> <p>A <code>TypeAdapter</code> instance exposes some of the functionality from <code>BaseModel</code> instance methods for types that do not have such methods (such as dataclasses, primitive types, and more).</p> <p>Note: <code>TypeAdapter</code> instances are not types, and cannot be used as type annotations for fields.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>type</code> <code>Any</code> <p>The type associated with the <code>TypeAdapter</code>.</p> \u5fc5\u9700 <code>config</code> <code>ConfigDict | None</code> <p>Configuration for the <code>TypeAdapter</code>, should be a dictionary conforming to <code>ConfigDict</code>.</p> <p>Note</p> <p>You cannot provide a configuration when instantiating a <code>TypeAdapter</code> if the type you're using has its own config that cannot be overridden (ex: <code>BaseModel</code>, <code>TypedDict</code>, and <code>dataclass</code>). A <code>type-adapter-config-unused</code> error will be raised in this case.</p> <code>None</code> <code>_parent_depth</code> <code>int</code> <p>Depth at which to search for the parent frame. This frame is used when resolving forward annotations during schema building, by looking for the globals and locals of this frame. Defaults to 2, which will result in the frame where the <code>TypeAdapter</code> was instantiated.</p> <p>Note</p> <p>This parameter is named with an underscore to suggest its private nature and discourage use. It may be deprecated in a minor version, so we only recommend using it if you're comfortable with potential change in behavior/support. It's default value is 2 because internally, the <code>TypeAdapter</code> class makes another call to fetch the frame.</p> <code>2</code> <code>module</code> <code>str | None</code> <p>The module that passes to plugin if provided.</p> <code>None</code> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>core_schema</code> <code>CoreSchema</code> <p>The core schema for the type.</p> <code>validator</code> <code>SchemaValidator | PluggableSchemaValidator</code> <p>The schema validator for the type.</p> <code>serializer</code> <code>SchemaSerializer</code> <p>The schema serializer for the type.</p> <code>pydantic_complete</code> <code>bool</code> <p>Whether the core schema for the type is successfully built.</p> Compatibility with <code>mypy</code> <p>Depending on the type used, <code>mypy</code> might raise an error when instantiating a <code>TypeAdapter</code>. As a workaround, you can explicitly annotate your variable:</p> <pre><code>from typing import Union\n\nfrom pydantic import TypeAdapter\n\nta: TypeAdapter[Union[str, int]] = TypeAdapter(Union[str, int])  # type: ignore[arg-type]\n</code></pre> Namespace management nuances and implementation details <p>Here, we collect some notes on namespace management, and subtle differences from <code>BaseModel</code>:</p> <p><code>BaseModel</code> uses its own <code>__module__</code> to find out where it was defined and then looks for symbols to resolve forward references in those globals. On the other hand, <code>TypeAdapter</code> can be initialized with arbitrary objects, which may not be types and thus do not have a <code>__module__</code> available. So instead we look at the globals in our parent stack frame.</p> <p>It is expected that the <code>ns_resolver</code> passed to this function will have the correct namespace for the type we're adapting. See the source code for <code>TypeAdapter.__init__</code> and <code>TypeAdapter.rebuild</code> for various ways to construct this namespace.</p> <p>This works for the case where this function is called in a module that has the target of forward references in its scope, but does not always work for more complex cases.</p> <p>For example, take the following:</p> a.py<pre><code>IntList = list[int]\nOuterDict = dict[str, 'IntList']\n</code></pre> b.py<pre><code>from a import OuterDict\n\nfrom pydantic import TypeAdapter\n\nIntList = int  # replaces the symbol the forward reference is looking for\nv = TypeAdapter(OuterDict)\nv({'x': 1})  # should fail but doesn't\n</code></pre> <p>If <code>OuterDict</code> were a <code>BaseModel</code>, this would work because it would resolve the forward reference within the <code>a.py</code> namespace. But <code>TypeAdapter(OuterDict)</code> can't determine what module <code>OuterDict</code> came from.</p> <p>In other words, the assumption that all forward references exist in the module we are being called from is not technically always true. Although most of the time it is and it works fine for recursive models and such, <code>BaseModel</code>'s behavior isn't perfect either and can break in similar ways, so there is no right or wrong between the two.</p> <p>But at the very least this behavior is subtly different from <code>BaseModel</code>'s.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def __init__(\n    self,\n    type: Any,\n    *,\n    config: ConfigDict | None = None,\n    _parent_depth: int = 2,\n    module: str | None = None,\n) -&gt; None:\n    if _type_has_config(type) and config is not None:\n        raise PydanticUserError(\n            'Cannot use `config` when the type is a BaseModel, dataclass or TypedDict.'\n            ' These types can have their own config and setting the config via the `config`'\n            ' parameter to TypeAdapter will not override it, thus the `config` you passed to'\n            ' TypeAdapter becomes meaningless, which is probably not what you want.',\n            code='type-adapter-config-unused',\n        )\n\n    self._type = type\n    self._config = config\n    self._parent_depth = _parent_depth\n    self.pydantic_complete = False\n\n    parent_frame = self._fetch_parent_frame()\n    if isinstance(type, types.FunctionType):\n        # Special case functions, which are *not* pushed to the `NsResolver` stack and without this special case\n        # would only have access to the parent namespace where the `TypeAdapter` was instantiated (if the function is defined\n        # in another module, we need to look at that module's globals).\n        if parent_frame is not None:\n            # `f_locals` is the namespace where the type adapter was instantiated (~ to `f_globals` if at the module level):\n            parent_ns = parent_frame.f_locals\n        else:  # pragma: no cover\n            parent_ns = None\n        globalns, localns = _namespace_utils.ns_for_function(\n            type,\n            parent_namespace=parent_ns,\n        )\n        parent_namespace = None\n    else:\n        if parent_frame is not None:\n            globalns = parent_frame.f_globals\n            # Do not provide a local ns if the type adapter happens to be instantiated at the module level:\n            localns = parent_frame.f_locals if parent_frame.f_locals is not globalns else {}\n        else:  # pragma: no cover\n            globalns = {}\n            localns = {}\n        parent_namespace = localns\n\n    self._module_name = module or cast(str, globalns.get('__name__', ''))\n    self._init_core_attrs(\n        ns_resolver=_namespace_utils.NsResolver(\n            namespaces_tuple=_namespace_utils.NamespacesTuple(locals=localns, globals=globalns),\n            parent_namespace=parent_namespace,\n        ),\n        force=False,\n    )\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.rebuild","title":"rebuild","text":"<pre><code>rebuild(*, force: bool = False, raise_errors: bool = True, _parent_namespace_depth: int = 2, _types_namespace: MappingNamespace | None = None) -&gt; bool | None\n</code></pre> <p>Try to rebuild the pydantic-core schema for the adapter's type.</p> <p>This may be necessary when one of the annotations is a ForwardRef which could not be resolved during the initial attempt to build the schema, and automatic rebuilding fails.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>force</code> <code>bool</code> <p>Whether to force the rebuilding of the type adapter's schema, defaults to <code>False</code>.</p> <code>False</code> <code>raise_errors</code> <code>bool</code> <p>Whether to raise errors, defaults to <code>True</code>.</p> <code>True</code> <code>_parent_namespace_depth</code> <code>int</code> <p>Depth at which to search for the parent frame. This frame is used when resolving forward annotations during schema rebuilding, by looking for the locals of this frame. Defaults to 2, which will result in the frame where the method was called.</p> <code>2</code> <code>_types_namespace</code> <code>MappingNamespace | None</code> <p>An explicit types namespace to use, instead of using the local namespace from the parent frame. Defaults to <code>None</code>.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bool | None</code> <p>Returns <code>None</code> if the schema is already \"complete\" and rebuilding was not required.</p> <code>bool | None</code> <p>If rebuilding was required, returns <code>True</code> if rebuilding was successful, otherwise <code>False</code>.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def rebuild(\n    self,\n    *,\n    force: bool = False,\n    raise_errors: bool = True,\n    _parent_namespace_depth: int = 2,\n    _types_namespace: _namespace_utils.MappingNamespace | None = None,\n) -&gt; bool | None:\n    \"\"\"Try to rebuild the pydantic-core schema for the adapter's type.\n\n    This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n    the initial attempt to build the schema, and automatic rebuilding fails.\n\n    Args:\n        force: Whether to force the rebuilding of the type adapter's schema, defaults to `False`.\n        raise_errors: Whether to raise errors, defaults to `True`.\n        _parent_namespace_depth: Depth at which to search for the [parent frame][frame-objects]. This\n            frame is used when resolving forward annotations during schema rebuilding, by looking for\n            the locals of this frame. Defaults to 2, which will result in the frame where the method\n            was called.\n        _types_namespace: An explicit types namespace to use, instead of using the local namespace\n            from the parent frame. Defaults to `None`.\n\n    Returns:\n        Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n        If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n    \"\"\"\n    if not force and self.pydantic_complete:\n        return None\n\n    if _types_namespace is not None:\n        rebuild_ns = _types_namespace\n    elif _parent_namespace_depth &gt; 0:\n        rebuild_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth, force=True) or {}\n    else:\n        rebuild_ns = {}\n\n    # we have to manually fetch globals here because there's no type on the stack of the NsResolver\n    # and so we skip the globalns = get_module_ns_of(typ) call that would normally happen\n    globalns = sys._getframe(max(_parent_namespace_depth - 1, 1)).f_globals\n    ns_resolver = _namespace_utils.NsResolver(\n        namespaces_tuple=_namespace_utils.NamespacesTuple(locals=rebuild_ns, globals=globalns),\n        parent_namespace=rebuild_ns,\n    )\n    return self._init_core_attrs(ns_resolver=ns_resolver, force=True, raise_errors=raise_errors)\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.validate_python","title":"validate_python","text":"<pre><code>validate_python(object: Any, /, *, strict: bool | None = None, extra: ExtraValues | None = None, from_attributes: bool | None = None, context: Any | None = None, experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False, by_alias: bool | None = None, by_name: bool | None = None) -&gt; T\n</code></pre> <p>Validate a Python object against the model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>object</code> <code>Any</code> <p>The Python object to validate against the model.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to strictly check types.</p> <code>None</code> <code>extra</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the <code>extra</code> configuration value for details.</p> <code>None</code> <code>from_attributes</code> <code>bool | None</code> <p>Whether to extract data from object attributes.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <code>experimental_allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Experimental whether to enable partial validation, e.g. to process streams. * False / 'off': Default behavior, no partial validation. * True / 'on': Enable partial validation. * 'trailing-strings': Enable partial validation and allow trailing strings in the input.</p> <code>False</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>Note</p> <p>When using <code>TypeAdapter</code> with a Pydantic <code>dataclass</code>, the use of the <code>from_attributes</code> argument is not supported.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>T</code> <p>The validated object.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def validate_python(\n    self,\n    object: Any,\n    /,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    from_attributes: bool | None = None,\n    context: Any | None = None,\n    experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; T:\n    \"\"\"Validate a Python object against the model.\n\n    Args:\n        object: The Python object to validate against the model.\n        strict: Whether to strictly check types.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        from_attributes: Whether to extract data from object attributes.\n        context: Additional context to pass to the validator.\n        experimental_allow_partial: **Experimental** whether to enable\n            [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n            * False / 'off': Default behavior, no partial validation.\n            * True / 'on': Enable partial validation.\n            * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    !!! note\n        When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`\n        argument is not supported.\n\n    Returns:\n        The validated object.\n    \"\"\"\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return self.validator.validate_python(\n        object,\n        strict=strict,\n        extra=extra,\n        from_attributes=from_attributes,\n        context=context,\n        allow_partial=experimental_allow_partial,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.validate_json","title":"validate_json","text":"<pre><code>validate_json(data: str | bytes | bytearray, /, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False, by_alias: bool | None = None, by_name: bool | None = None) -&gt; T\n</code></pre> <p>Usage Documentation</p> <p>JSON Parsing</p> <p>Validate a JSON string or bytes against the model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>str | bytes | bytearray</code> <p>The JSON data to validate against the model.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to strictly check types.</p> <code>None</code> <code>extra</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the <code>extra</code> configuration value for details.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to use during validation.</p> <code>None</code> <code>experimental_allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Experimental whether to enable partial validation, e.g. to process streams. * False / 'off': Default behavior, no partial validation. * True / 'on': Enable partial validation. * 'trailing-strings': Enable partial validation and allow trailing strings in the input.</p> <code>False</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>T</code> <p>The validated object.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def validate_json(\n    self,\n    data: str | bytes | bytearray,\n    /,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; T:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Parsing](../concepts/json.md#json-parsing)\n\n    Validate a JSON string or bytes against the model.\n\n    Args:\n        data: The JSON data to validate against the model.\n        strict: Whether to strictly check types.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Additional context to use during validation.\n        experimental_allow_partial: **Experimental** whether to enable\n            [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n            * False / 'off': Default behavior, no partial validation.\n            * True / 'on': Enable partial validation.\n            * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated object.\n    \"\"\"\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return self.validator.validate_json(\n        data,\n        strict=strict,\n        extra=extra,\n        context=context,\n        allow_partial=experimental_allow_partial,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.validate_strings","title":"validate_strings","text":"<pre><code>validate_strings(obj: Any, /, *, strict: bool | None = None, extra: ExtraValues | None = None, context: Any | None = None, experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False, by_alias: bool | None = None, by_name: bool | None = None) -&gt; T\n</code></pre> <p>Validate object contains string data against the model.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>obj</code> <code>Any</code> <p>The object contains string data to validate.</p> \u5fc5\u9700 <code>strict</code> <code>bool | None</code> <p>Whether to strictly check types.</p> <code>None</code> <code>extra</code> <code>ExtraValues | None</code> <p>Whether to ignore, allow, or forbid extra data during model validation. See the <code>extra</code> configuration value for details.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to use during validation.</p> <code>None</code> <code>experimental_allow_partial</code> <code>bool | Literal['off', 'on', 'trailing-strings']</code> <p>Experimental whether to enable partial validation, e.g. to process streams. * False / 'off': Default behavior, no partial validation. * True / 'on': Enable partial validation. * 'trailing-strings': Enable partial validation and allow trailing strings in the input.</p> <code>False</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use the field's alias when validating against the provided input data.</p> <code>None</code> <code>by_name</code> <code>bool | None</code> <p>Whether to use the field's name when validating against the provided input data.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>T</code> <p>The validated object.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def validate_strings(\n    self,\n    obj: Any,\n    /,\n    *,\n    strict: bool | None = None,\n    extra: ExtraValues | None = None,\n    context: Any | None = None,\n    experimental_allow_partial: bool | Literal['off', 'on', 'trailing-strings'] = False,\n    by_alias: bool | None = None,\n    by_name: bool | None = None,\n) -&gt; T:\n    \"\"\"Validate object contains string data against the model.\n\n    Args:\n        obj: The object contains string data to validate.\n        strict: Whether to strictly check types.\n        extra: Whether to ignore, allow, or forbid extra data during model validation.\n            See the [`extra` configuration value][pydantic.ConfigDict.extra] for details.\n        context: Additional context to use during validation.\n        experimental_allow_partial: **Experimental** whether to enable\n            [partial validation](../concepts/experimental.md#partial-validation), e.g. to process streams.\n            * False / 'off': Default behavior, no partial validation.\n            * True / 'on': Enable partial validation.\n            * 'trailing-strings': Enable partial validation and allow trailing strings in the input.\n        by_alias: Whether to use the field's alias when validating against the provided input data.\n        by_name: Whether to use the field's name when validating against the provided input data.\n\n    Returns:\n        The validated object.\n    \"\"\"\n    if by_alias is False and by_name is not True:\n        raise PydanticUserError(\n            'At least one of `by_alias` or `by_name` must be set to True.',\n            code='validate-by-alias-and-name-false',\n        )\n\n    return self.validator.validate_strings(\n        obj,\n        strict=strict,\n        extra=extra,\n        context=context,\n        allow_partial=experimental_allow_partial,\n        by_alias=by_alias,\n        by_name=by_name,\n    )\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.get_default_value","title":"get_default_value","text":"<pre><code>get_default_value(*, strict: bool | None = None, context: Any | None = None) -&gt; Some[T] | None\n</code></pre> <p>Get the default value for the wrapped type.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether to strictly check types.</p> <code>None</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the validator.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Some[T] | None</code> <p>The default value wrapped in a <code>Some</code> if there is one or None if not.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def get_default_value(self, *, strict: bool | None = None, context: Any | None = None) -&gt; Some[T] | None:\n    \"\"\"Get the default value for the wrapped type.\n\n    Args:\n        strict: Whether to strictly check types.\n        context: Additional context to pass to the validator.\n\n    Returns:\n        The default value wrapped in a `Some` if there is one or None if not.\n    \"\"\"\n    return self.validator.get_default_value(strict=strict, context=context)\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.dump_python","title":"dump_python","text":"<pre><code>dump_python(instance: T, /, *, mode: Literal['json', 'python'] = 'python', include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False, context: Any | None = None) -&gt; Any\n</code></pre> <p>Dump an instance of the adapted type to a Python object.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>instance</code> <code>T</code> <p>The Python object to serialize.</p> \u5fc5\u9700 <code>mode</code> <code>Literal['json', 'python']</code> <p>The output format.</p> <code>'python'</code> <code>include</code> <code>IncEx | None</code> <p>Fields to include in the output.</p> <code>None</code> <code>exclude</code> <code>IncEx | None</code> <p>Fields to exclude from the output.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use alias names for field names.</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude unset fields.</p> <code>False</code> <code>exclude_defaults</code> <code>bool</code> <p>Whether to exclude fields with default values.</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields with None values.</p> <code>False</code> <code>exclude_computed_fields</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>Whether to output the serialized data in a way that is compatible with deserialization.</p> <code>False</code> <code>warnings</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Any</code> <p>The serialized object.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def dump_python(\n    self,\n    instance: T,\n    /,\n    *,\n    mode: Literal['json', 'python'] = 'python',\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None,\n) -&gt; Any:\n    \"\"\"Dump an instance of the adapted type to a Python object.\n\n    Args:\n        instance: The Python object to serialize.\n        mode: The output format.\n        include: Fields to include in the output.\n        exclude: Fields to exclude from the output.\n        by_alias: Whether to use alias names for field names.\n        exclude_unset: Whether to exclude unset fields.\n        exclude_defaults: Whether to exclude fields with default values.\n        exclude_none: Whether to exclude fields with None values.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: Whether to output the serialized data in a way that is compatible with deserialization.\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n        context: Additional context to pass to the serializer.\n\n    Returns:\n        The serialized object.\n    \"\"\"\n    return self.serializer.to_python(\n        instance,\n        mode=mode,\n        by_alias=by_alias,\n        include=include,\n        exclude=exclude,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n        context=context,\n    )\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.dump_json","title":"dump_json","text":"<pre><code>dump_json(instance: T, /, *, indent: int | None = None, ensure_ascii: bool = False, include: IncEx | None = None, exclude: IncEx | None = None, by_alias: bool | None = None, exclude_unset: bool = False, exclude_defaults: bool = False, exclude_none: bool = False, exclude_computed_fields: bool = False, round_trip: bool = False, warnings: bool | Literal['none', 'warn', 'error'] = True, fallback: Callable[[Any], Any] | None = None, serialize_as_any: bool = False, context: Any | None = None) -&gt; bytes\n</code></pre> <p>Usage Documentation</p> <p>JSON Serialization</p> <p>Serialize an instance of the adapted type to JSON.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>instance</code> <code>T</code> <p>The instance to be serialized.</p> \u5fc5\u9700 <code>indent</code> <code>int | None</code> <p>Number of spaces for JSON indentation.</p> <code>None</code> <code>ensure_ascii</code> <code>bool</code> <p>If <code>True</code>, the output is guaranteed to have all incoming non-ASCII characters escaped. If <code>False</code> (the default), these characters will be output as-is.</p> <code>False</code> <code>include</code> <code>IncEx | None</code> <p>Fields to include.</p> <code>None</code> <code>exclude</code> <code>IncEx | None</code> <p>Fields to exclude.</p> <code>None</code> <code>by_alias</code> <code>bool | None</code> <p>Whether to use alias names for field names.</p> <code>None</code> <code>exclude_unset</code> <code>bool</code> <p>Whether to exclude unset fields.</p> <code>False</code> <code>exclude_defaults</code> <code>bool</code> <p>Whether to exclude fields with default values.</p> <code>False</code> <code>exclude_none</code> <code>bool</code> <p>Whether to exclude fields with a value of <code>None</code>.</p> <code>False</code> <code>exclude_computed_fields</code> <code>bool</code> <p>Whether to exclude computed fields. While this can be useful for round-tripping, it is usually recommended to use the dedicated <code>round_trip</code> parameter instead.</p> <code>False</code> <code>round_trip</code> <code>bool</code> <p>Whether to serialize and deserialize the instance to ensure round-tripping.</p> <code>False</code> <code>warnings</code> <code>bool | Literal['none', 'warn', 'error']</code> <p>How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors, \"error\" raises a <code>PydanticSerializationError</code>.</p> <code>True</code> <code>fallback</code> <code>Callable[[Any], Any] | None</code> <p>A function to call when an unknown value is encountered. If not provided, a <code>PydanticSerializationError</code> error is raised.</p> <code>None</code> <code>serialize_as_any</code> <code>bool</code> <p>Whether to serialize fields with duck-typing serialization behavior.</p> <code>False</code> <code>context</code> <code>Any | None</code> <p>Additional context to pass to the serializer.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The JSON representation of the given instance as bytes.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def dump_json(\n    self,\n    instance: T,\n    /,\n    *,\n    indent: int | None = None,\n    ensure_ascii: bool = False,\n    include: IncEx | None = None,\n    exclude: IncEx | None = None,\n    by_alias: bool | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n    exclude_computed_fields: bool = False,\n    round_trip: bool = False,\n    warnings: bool | Literal['none', 'warn', 'error'] = True,\n    fallback: Callable[[Any], Any] | None = None,\n    serialize_as_any: bool = False,\n    context: Any | None = None,\n) -&gt; bytes:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [JSON Serialization](../concepts/json.md#json-serialization)\n\n    Serialize an instance of the adapted type to JSON.\n\n    Args:\n        instance: The instance to be serialized.\n        indent: Number of spaces for JSON indentation.\n        ensure_ascii: If `True`, the output is guaranteed to have all incoming non-ASCII characters escaped.\n            If `False` (the default), these characters will be output as-is.\n        include: Fields to include.\n        exclude: Fields to exclude.\n        by_alias: Whether to use alias names for field names.\n        exclude_unset: Whether to exclude unset fields.\n        exclude_defaults: Whether to exclude fields with default values.\n        exclude_none: Whether to exclude fields with a value of `None`.\n        exclude_computed_fields: Whether to exclude computed fields.\n            While this can be useful for round-tripping, it is usually recommended to use the dedicated\n            `round_trip` parameter instead.\n        round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.\n        warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n            \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n        fallback: A function to call when an unknown value is encountered. If not provided,\n            a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError] error is raised.\n        serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n        context: Additional context to pass to the serializer.\n\n    Returns:\n        The JSON representation of the given instance as bytes.\n    \"\"\"\n    return self.serializer.to_json(\n        instance,\n        indent=indent,\n        ensure_ascii=ensure_ascii,\n        include=include,\n        exclude=exclude,\n        by_alias=by_alias,\n        exclude_unset=exclude_unset,\n        exclude_defaults=exclude_defaults,\n        exclude_none=exclude_none,\n        exclude_computed_fields=exclude_computed_fields,\n        round_trip=round_trip,\n        warnings=warnings,\n        fallback=fallback,\n        serialize_as_any=serialize_as_any,\n        context=context,\n    )\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.json_schema","title":"json_schema","text":"<pre><code>json_schema(*, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of', schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema, mode: JsonSchemaMode = 'validation') -&gt; dict[str, Any]\n</code></pre> <p>Generate a JSON schema for the adapted type.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>by_alias</code> <code>bool</code> <p>Whether to use alias names for field names.</p> <code>True</code> <code>ref_template</code> <code>str</code> <p>The format string used for generating $ref strings.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>union_format</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>schema_generator</code> <code>type[GenerateJsonSchema]</code> <p>To override the logic used to generate the JSON schema, as a subclass of <code>GenerateJsonSchema</code> with your desired modifications</p> <code>GenerateJsonSchema</code> <code>mode</code> <code>JsonSchemaMode</code> <p>The mode in which to generate the schema.</p> <code>'validation'</code> <code>schema_generator</code> <code>type[GenerateJsonSchema]</code> <p>The generator class used for creating the schema.</p> <code>GenerateJsonSchema</code> <code>mode</code> <code>JsonSchemaMode</code> <p>The mode to use for schema generation.</p> <code>'validation'</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>dict[str, Any]</code> <p>The JSON schema for the model as a dictionary.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>def json_schema(\n    self,\n    *,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n) -&gt; dict[str, Any]:\n    \"\"\"Generate a JSON schema for the adapted type.\n\n    Args:\n        by_alias: Whether to use alias names for field names.\n        ref_template: The format string used for generating $ref strings.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n            `GenerateJsonSchema` with your desired modifications\n        mode: The mode in which to generate the schema.\n        schema_generator: The generator class used for creating the schema.\n        mode: The mode to use for schema generation.\n\n    Returns:\n        The JSON schema for the model as a dictionary.\n    \"\"\"\n    schema_generator_instance = schema_generator(\n        by_alias=by_alias, ref_template=ref_template, union_format=union_format\n    )\n    if isinstance(self.core_schema, _mock_val_ser.MockCoreSchema):\n        self.core_schema.rebuild()\n        assert not isinstance(self.core_schema, _mock_val_ser.MockCoreSchema), 'this is a bug! please report it'\n    return schema_generator_instance.generate(self.core_schema, mode=mode)\n</code></pre>"},{"location":"api/type_adapter/#pydantic.type_adapter.TypeAdapter.json_schemas","title":"json_schemas  <code>staticmethod</code>","text":"<pre><code>json_schemas(inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]], /, *, by_alias: bool = True, title: str | None = None, description: str | None = None, ref_template: str = DEFAULT_REF_TEMPLATE, union_format: Literal['any_of', 'primitive_type_array'] = 'any_of', schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema) -&gt; tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]\n</code></pre> <p>Generate a JSON schema including definitions from multiple type adapters.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>inputs</code> <code>Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]]</code> <p>Inputs to schema generation. The first two items will form the keys of the (first) output mapping; the type adapters will provide the core schemas that get converted into definitions in the output JSON schema.</p> \u5fc5\u9700 <code>by_alias</code> <code>bool</code> <p>Whether to use alias names.</p> <code>True</code> <code>title</code> <code>str | None</code> <p>The title for the schema.</p> <code>None</code> <code>description</code> <code>str | None</code> <p>The description for the schema.</p> <code>None</code> <code>ref_template</code> <code>str</code> <p>The format string used for generating $ref strings.</p> <code>DEFAULT_REF_TEMPLATE</code> <code>union_format</code> <code>Literal['any_of', 'primitive_type_array']</code> <p>The format to use when combining schemas from unions together. Can be one of:</p> <ul> <li><code>'any_of'</code>: Use the <code>anyOf</code> keyword to combine schemas (the default).</li> <li><code>'primitive_type_array'</code>: Use the <code>type</code> keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive type (<code>string</code>, <code>boolean</code>, <code>null</code>, <code>integer</code> or <code>number</code>) or contains constraints/metadata, falls back to <code>any_of</code>.</li> </ul> <code>'any_of'</code> <code>schema_generator</code> <code>type[GenerateJsonSchema]</code> <p>The generator class used for creating the schema.</p> <code>GenerateJsonSchema</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]</code> <p>A tuple where:</p> <ul> <li>The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and     whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have     JsonRef references to definitions that are defined in the second returned element.)</li> <li>The second element is a JSON schema containing all definitions referenced in the first returned     element, along with the optional title and description keys.</li> </ul> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/type_adapter.py</code> <pre><code>@staticmethod\ndef json_schemas(\n    inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]],\n    /,\n    *,\n    by_alias: bool = True,\n    title: str | None = None,\n    description: str | None = None,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    union_format: Literal['any_of', 'primitive_type_array'] = 'any_of',\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n) -&gt; tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:\n    \"\"\"Generate a JSON schema including definitions from multiple type adapters.\n\n    Args:\n        inputs: Inputs to schema generation. The first two items will form the keys of the (first)\n            output mapping; the type adapters will provide the core schemas that get converted into\n            definitions in the output JSON schema.\n        by_alias: Whether to use alias names.\n        title: The title for the schema.\n        description: The description for the schema.\n        ref_template: The format string used for generating $ref strings.\n        union_format: The format to use when combining schemas from unions together. Can be one of:\n\n            - `'any_of'`: Use the [`anyOf`](https://json-schema.org/understanding-json-schema/reference/combining#anyOf)\n            keyword to combine schemas (the default).\n            - `'primitive_type_array'`: Use the [`type`](https://json-schema.org/understanding-json-schema/reference/type)\n            keyword as an array of strings, containing each type of the combination. If any of the schemas is not a primitive\n            type (`string`, `boolean`, `null`, `integer` or `number`) or contains constraints/metadata, falls back to\n            `any_of`.\n        schema_generator: The generator class used for creating the schema.\n\n    Returns:\n        A tuple where:\n\n            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions referenced in the first returned\n                element, along with the optional title and description keys.\n\n    \"\"\"\n    schema_generator_instance = schema_generator(\n        by_alias=by_alias, ref_template=ref_template, union_format=union_format\n    )\n\n    inputs_ = []\n    for key, mode, adapter in inputs:\n        # This is the same pattern we follow for model json schemas - we attempt a core schema rebuild if we detect a mock\n        if isinstance(adapter.core_schema, _mock_val_ser.MockCoreSchema):\n            adapter.core_schema.rebuild()\n            assert not isinstance(adapter.core_schema, _mock_val_ser.MockCoreSchema), (\n                'this is a bug! please report it'\n            )\n        inputs_.append((key, mode, adapter.core_schema))\n\n    json_schemas_map, definitions = schema_generator_instance.generate_definitions(inputs_)\n\n    json_schema: dict[str, Any] = {}\n    if definitions:\n        json_schema['$defs'] = definitions\n    if title:\n        json_schema['title'] = title\n    if description:\n        json_schema['description'] = description\n\n    return json_schemas_map, json_schema\n</code></pre>"},{"location":"api/types/","title":"Pydantic Types","text":""},{"location":"api/types/#pydantic.types","title":"pydantic.types","text":"<p>The types module contains custom types used by pydantic.</p>"},{"location":"api/types/#pydantic.types.StrictBool","title":"StrictBool  <code>module-attribute</code>","text":"<pre><code>StrictBool = Annotated[bool, Strict()]\n</code></pre> <p>A boolean that must be either <code>True</code> or <code>False</code>.</p>"},{"location":"api/types/#pydantic.types.PositiveInt","title":"PositiveInt  <code>module-attribute</code>","text":"<pre><code>PositiveInt = Annotated[int, Gt(0)]\n</code></pre> <p>An integer that must be greater than zero.</p> <pre><code>from pydantic import BaseModel, PositiveInt, ValidationError\n\nclass Model(BaseModel):\n    positive_int: PositiveInt\n\nm = Model(positive_int=1)\nprint(repr(m))\n#&gt; Model(positive_int=1)\n\ntry:\n    Model(positive_int=-1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('positive_int',),\n            'msg': 'Input should be greater than 0',\n            'input': -1,\n            'ctx': {'gt': 0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NegativeInt","title":"NegativeInt  <code>module-attribute</code>","text":"<pre><code>NegativeInt = Annotated[int, Lt(0)]\n</code></pre> <p>An integer that must be less than zero.</p> <pre><code>from pydantic import BaseModel, NegativeInt, ValidationError\n\nclass Model(BaseModel):\n    negative_int: NegativeInt\n\nm = Model(negative_int=-1)\nprint(repr(m))\n#&gt; Model(negative_int=-1)\n\ntry:\n    Model(negative_int=1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than',\n            'loc': ('negative_int',),\n            'msg': 'Input should be less than 0',\n            'input': 1,\n            'ctx': {'lt': 0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NonPositiveInt","title":"NonPositiveInt  <code>module-attribute</code>","text":"<pre><code>NonPositiveInt = Annotated[int, Le(0)]\n</code></pre> <p>An integer that must be less than or equal to zero.</p> <pre><code>from pydantic import BaseModel, NonPositiveInt, ValidationError\n\nclass Model(BaseModel):\n    non_positive_int: NonPositiveInt\n\nm = Model(non_positive_int=0)\nprint(repr(m))\n#&gt; Model(non_positive_int=0)\n\ntry:\n    Model(non_positive_int=1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than_equal',\n            'loc': ('non_positive_int',),\n            'msg': 'Input should be less than or equal to 0',\n            'input': 1,\n            'ctx': {'le': 0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than_equal',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NonNegativeInt","title":"NonNegativeInt  <code>module-attribute</code>","text":"<pre><code>NonNegativeInt = Annotated[int, Ge(0)]\n</code></pre> <p>An integer that must be greater than or equal to zero.</p> <pre><code>from pydantic import BaseModel, NonNegativeInt, ValidationError\n\nclass Model(BaseModel):\n    non_negative_int: NonNegativeInt\n\nm = Model(non_negative_int=0)\nprint(repr(m))\n#&gt; Model(non_negative_int=0)\n\ntry:\n    Model(non_negative_int=-1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than_equal',\n            'loc': ('non_negative_int',),\n            'msg': 'Input should be greater than or equal to 0',\n            'input': -1,\n            'ctx': {'ge': 0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than_equal',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.StrictInt","title":"StrictInt  <code>module-attribute</code>","text":"<pre><code>StrictInt = Annotated[int, Strict()]\n</code></pre> <p>An integer that must be validated in strict mode.</p> <pre><code>from pydantic import BaseModel, StrictInt, ValidationError\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for StrictIntModel\n    strict_int\n      Input should be a valid integer [type=int_type, input_value=3.14159, input_type=float]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.PositiveFloat","title":"PositiveFloat  <code>module-attribute</code>","text":"<pre><code>PositiveFloat = Annotated[float, Gt(0)]\n</code></pre> <p>A float that must be greater than zero.</p> <pre><code>from pydantic import BaseModel, PositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    positive_float: PositiveFloat\n\nm = Model(positive_float=1.0)\nprint(repr(m))\n#&gt; Model(positive_float=1.0)\n\ntry:\n    Model(positive_float=-1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('positive_float',),\n            'msg': 'Input should be greater than 0',\n            'input': -1.0,\n            'ctx': {'gt': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NegativeFloat","title":"NegativeFloat  <code>module-attribute</code>","text":"<pre><code>NegativeFloat = Annotated[float, Lt(0)]\n</code></pre> <p>A float that must be less than zero.</p> <pre><code>from pydantic import BaseModel, NegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    negative_float: NegativeFloat\n\nm = Model(negative_float=-1.0)\nprint(repr(m))\n#&gt; Model(negative_float=-1.0)\n\ntry:\n    Model(negative_float=1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than',\n            'loc': ('negative_float',),\n            'msg': 'Input should be less than 0',\n            'input': 1.0,\n            'ctx': {'lt': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NonPositiveFloat","title":"NonPositiveFloat  <code>module-attribute</code>","text":"<pre><code>NonPositiveFloat = Annotated[float, Le(0)]\n</code></pre> <p>A float that must be less than or equal to zero.</p> <pre><code>from pydantic import BaseModel, NonPositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    non_positive_float: NonPositiveFloat\n\nm = Model(non_positive_float=0.0)\nprint(repr(m))\n#&gt; Model(non_positive_float=0.0)\n\ntry:\n    Model(non_positive_float=1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than_equal',\n            'loc': ('non_positive_float',),\n            'msg': 'Input should be less than or equal to 0',\n            'input': 1.0,\n            'ctx': {'le': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than_equal',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NonNegativeFloat","title":"NonNegativeFloat  <code>module-attribute</code>","text":"<pre><code>NonNegativeFloat = Annotated[float, Ge(0)]\n</code></pre> <p>A float that must be greater than or equal to zero.</p> <pre><code>from pydantic import BaseModel, NonNegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    non_negative_float: NonNegativeFloat\n\nm = Model(non_negative_float=0.0)\nprint(repr(m))\n#&gt; Model(non_negative_float=0.0)\n\ntry:\n    Model(non_negative_float=-1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than_equal',\n            'loc': ('non_negative_float',),\n            'msg': 'Input should be greater than or equal to 0',\n            'input': -1.0,\n            'ctx': {'ge': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than_equal',\n        }\n    ]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.StrictFloat","title":"StrictFloat  <code>module-attribute</code>","text":"<pre><code>StrictFloat = Annotated[float, Strict(True)]\n</code></pre> <p>A float that must be validated in strict mode.</p> <pre><code>from pydantic import BaseModel, StrictFloat, ValidationError\n\nclass StrictFloatModel(BaseModel):\n    strict_float: StrictFloat\n\ntry:\n    StrictFloatModel(strict_float='1.0')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for StrictFloatModel\n    strict_float\n      Input should be a valid number [type=float_type, input_value='1.0', input_type=str]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.FiniteFloat","title":"FiniteFloat  <code>module-attribute</code>","text":"<pre><code>FiniteFloat = Annotated[float, AllowInfNan(False)]\n</code></pre> <p>A float that must be finite (not <code>-inf</code>, <code>inf</code>, or <code>nan</code>).</p> <pre><code>from pydantic import BaseModel, FiniteFloat\n\nclass Model(BaseModel):\n    finite: FiniteFloat\n\nm = Model(finite=1.0)\nprint(m)\n#&gt; finite=1.0\n</code></pre>"},{"location":"api/types/#pydantic.types.StrictBytes","title":"StrictBytes  <code>module-attribute</code>","text":"<pre><code>StrictBytes = Annotated[bytes, Strict()]\n</code></pre> <p>A bytes that must be validated in strict mode.</p>"},{"location":"api/types/#pydantic.types.StrictStr","title":"StrictStr  <code>module-attribute</code>","text":"<pre><code>StrictStr = Annotated[str, Strict()]\n</code></pre> <p>A string that must be validated in strict mode.</p>"},{"location":"api/types/#pydantic.types.UUID1","title":"UUID1  <code>module-attribute</code>","text":"<pre><code>UUID1 = Annotated[UUID, UuidVersion(1)]\n</code></pre> <p>A UUID that must be version 1.</p> <pre><code>import uuid\n\nfrom pydantic import UUID1, BaseModel\n\nclass Model(BaseModel):\n    uuid1: UUID1\n\nModel(uuid1=uuid.uuid1())\n</code></pre>"},{"location":"api/types/#pydantic.types.UUID3","title":"UUID3  <code>module-attribute</code>","text":"<pre><code>UUID3 = Annotated[UUID, UuidVersion(3)]\n</code></pre> <p>A UUID that must be version 3.</p> <pre><code>import uuid\n\nfrom pydantic import UUID3, BaseModel\n\nclass Model(BaseModel):\n    uuid3: UUID3\n\nModel(uuid3=uuid.uuid3(uuid.NAMESPACE_DNS, 'pydantic.org'))\n</code></pre>"},{"location":"api/types/#pydantic.types.UUID4","title":"UUID4  <code>module-attribute</code>","text":"<pre><code>UUID4 = Annotated[UUID, UuidVersion(4)]\n</code></pre> <p>A UUID that must be version 4.</p> <pre><code>import uuid\n\nfrom pydantic import UUID4, BaseModel\n\nclass Model(BaseModel):\n    uuid4: UUID4\n\nModel(uuid4=uuid.uuid4())\n</code></pre>"},{"location":"api/types/#pydantic.types.UUID5","title":"UUID5  <code>module-attribute</code>","text":"<pre><code>UUID5 = Annotated[UUID, UuidVersion(5)]\n</code></pre> <p>A UUID that must be version 5.</p> <pre><code>import uuid\n\nfrom pydantic import UUID5, BaseModel\n\nclass Model(BaseModel):\n    uuid5: UUID5\n\nModel(uuid5=uuid.uuid5(uuid.NAMESPACE_DNS, 'pydantic.org'))\n</code></pre>"},{"location":"api/types/#pydantic.types.UUID6","title":"UUID6  <code>module-attribute</code>","text":"<pre><code>UUID6 = Annotated[UUID, UuidVersion(6)]\n</code></pre> <p>A UUID that must be version 6.</p> <pre><code>import uuid\n\nfrom pydantic import UUID6, BaseModel\n\nclass Model(BaseModel):\n    uuid6: UUID6\n\nModel(uuid6=uuid.UUID('1efea953-c2d6-6790-aa0a-69db8c87df97'))\n</code></pre>"},{"location":"api/types/#pydantic.types.UUID7","title":"UUID7  <code>module-attribute</code>","text":"<pre><code>UUID7 = Annotated[UUID, UuidVersion(7)]\n</code></pre> <p>A UUID that must be version 7.</p> <pre><code>import uuid\n\nfrom pydantic import UUID7, BaseModel\n\nclass Model(BaseModel):\n    uuid7: UUID7\n\nModel(uuid7=uuid.UUID('0194fdcb-1c47-7a09-b52c-561154de0b4a'))\n</code></pre>"},{"location":"api/types/#pydantic.types.UUID8","title":"UUID8  <code>module-attribute</code>","text":"<pre><code>UUID8 = Annotated[UUID, UuidVersion(8)]\n</code></pre> <p>A UUID that must be version 8.</p> <pre><code>import uuid\n\nfrom pydantic import UUID8, BaseModel\n\nclass Model(BaseModel):\n    uuid8: UUID8\n\nModel(uuid8=uuid.UUID('81a0b92e-6078-8551-9c81-8ccb666bdab8'))\n</code></pre>"},{"location":"api/types/#pydantic.types.FilePath","title":"FilePath  <code>module-attribute</code>","text":"<pre><code>FilePath = Annotated[Path, PathType('file')]\n</code></pre> <p>A path that must point to a file.</p> <pre><code>from pathlib import Path\n\nfrom pydantic import BaseModel, FilePath, ValidationError\n\nclass Model(BaseModel):\n    f: FilePath\n\npath = Path('text.txt')\npath.touch()\nm = Model(f='text.txt')\nprint(m.model_dump())\n#&gt; {'f': PosixPath('text.txt')}\npath.unlink()\n\npath = Path('directory')\npath.mkdir(exist_ok=True)\ntry:\n    Model(f='directory')  # directory\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a file [type=path_not_file, input_value='directory', input_type=str]\n    '''\npath.rmdir()\n\ntry:\n    Model(f='not-exists-file')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a file [type=path_not_file, input_value='not-exists-file', input_type=str]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.DirectoryPath","title":"DirectoryPath  <code>module-attribute</code>","text":"<pre><code>DirectoryPath = Annotated[Path, PathType('dir')]\n</code></pre> <p>A path that must point to a directory.</p> <pre><code>from pathlib import Path\n\nfrom pydantic import BaseModel, DirectoryPath, ValidationError\n\nclass Model(BaseModel):\n    f: DirectoryPath\n\npath = Path('directory/')\npath.mkdir()\nm = Model(f='directory/')\nprint(m.model_dump())\n#&gt; {'f': PosixPath('directory')}\npath.rmdir()\n\npath = Path('file.txt')\npath.touch()\ntry:\n    Model(f='file.txt')  # file\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a directory [type=path_not_directory, input_value='file.txt', input_type=str]\n    '''\npath.unlink()\n\ntry:\n    Model(f='not-exists-directory')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a directory [type=path_not_directory, input_value='not-exists-directory', input_type=str]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.NewPath","title":"NewPath  <code>module-attribute</code>","text":"<pre><code>NewPath = Annotated[Path, PathType('new')]\n</code></pre> <p>A path for a new file or directory that must not already exist. The parent directory must already exist.</p>"},{"location":"api/types/#pydantic.types.SocketPath","title":"SocketPath  <code>module-attribute</code>","text":"<pre><code>SocketPath = Annotated[Path, PathType('socket')]\n</code></pre> <p>A path to an existing socket file</p>"},{"location":"api/types/#pydantic.types.Base64Bytes","title":"Base64Bytes  <code>module-attribute</code>","text":"<pre><code>Base64Bytes = Annotated[bytes, EncodedBytes(encoder=Base64Encoder)]\n</code></pre> <p>A bytes type that is encoded and decoded using the standard (non-URL-safe) base64 encoder.</p> Note <p>Under the hood, <code>Base64Bytes</code> uses the standard library <code>base64.b64encode</code> and <code>base64.b64decode</code> functions.</p> <p>As a result, attempting to decode url-safe base64 data using the <code>Base64Bytes</code> type may fail or produce an incorrect decoding.</p> Warning <p>In versions of Pydantic prior to v2.10, <code>Base64Bytes</code> used <code>base64.encodebytes</code> and <code>base64.decodebytes</code> functions. According to the base64 documentation, these methods are considered legacy implementation, and thus, Pydantic v2.10+ now uses the modern <code>base64.b64encode</code> and <code>base64.b64decode</code> functions.</p> <p>If you'd still like to use these legacy encoders / decoders, you can achieve this by creating a custom annotated type, like follows:</p> <pre><code>import base64\nfrom typing import Annotated, Literal\n\nfrom pydantic_core import PydanticCustomError\n\nfrom pydantic import EncodedBytes, EncoderProtocol\n\nclass LegacyBase64Encoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -&gt; bytes:\n        try:\n            return base64.decodebytes(data)\n        except ValueError as e:\n            raise PydanticCustomError(\n                'base64_decode',\n                \"Base64 decoding error: '{error}'\",\n                {'error': str(e)},\n            )\n\n    @classmethod\n    def encode(cls, value: bytes) -&gt; bytes:\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -&gt; Literal['base64']:\n        return 'base64'\n\nLegacyBase64Bytes = Annotated[bytes, EncodedBytes(encoder=LegacyBase64Encoder)]\n</code></pre> <pre><code>from pydantic import Base64Bytes, BaseModel, ValidationError\n\nclass Model(BaseModel):\n    base64_bytes: Base64Bytes\n\n# Initialize the model with base64 data\nm = Model(base64_bytes=b'VGhpcyBpcyB0aGUgd2F5')\n\n# Access decoded value\nprint(m.base64_bytes)\n#&gt; b'This is the way'\n\n# Serialize into the base64 form\nprint(m.model_dump())\n#&gt; {'base64_bytes': b'VGhpcyBpcyB0aGUgd2F5'}\n\n# Validate base64 data\ntry:\n    print(Model(base64_bytes=b'undecodable').base64_bytes)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    base64_bytes\n      Base64 decoding error: 'Incorrect padding' [type=base64_decode, input_value=b'undecodable', input_type=bytes]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64Str","title":"Base64Str  <code>module-attribute</code>","text":"<pre><code>Base64Str = Annotated[str, EncodedStr(encoder=Base64Encoder)]\n</code></pre> <p>A str type that is encoded and decoded using the standard (non-URL-safe) base64 encoder.</p> Note <p>Under the hood, <code>Base64Str</code> uses the standard library <code>base64.b64encode</code> and <code>base64.b64decode</code> functions.</p> <p>As a result, attempting to decode url-safe base64 data using the <code>Base64Str</code> type may fail or produce an incorrect decoding.</p> Warning <p>In versions of Pydantic prior to v2.10, <code>Base64Str</code> used <code>base64.encodebytes</code> and <code>base64.decodebytes</code> functions. According to the base64 documentation, these methods are considered legacy implementation, and thus, Pydantic v2.10+ now uses the modern <code>base64.b64encode</code> and <code>base64.b64decode</code> functions.</p> <p>See the <code>Base64Bytes</code> type for more information on how to replicate the old behavior with the legacy encoders / decoders.</p> <pre><code>from pydantic import Base64Str, BaseModel, ValidationError\n\nclass Model(BaseModel):\n    base64_str: Base64Str\n\n# Initialize the model with base64 data\nm = Model(base64_str='VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y')\n\n# Access decoded value\nprint(m.base64_str)\n#&gt; These aren't the droids you're looking for\n\n# Serialize into the base64 form\nprint(m.model_dump())\n#&gt; {'base64_str': 'VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y'}\n\n# Validate base64 data\ntry:\n    print(Model(base64_str='undecodable').base64_str)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    base64_str\n      Base64 decoding error: 'Incorrect padding' [type=base64_decode, input_value='undecodable', input_type=str]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64UrlBytes","title":"Base64UrlBytes  <code>module-attribute</code>","text":"<pre><code>Base64UrlBytes = Annotated[bytes, EncodedBytes(encoder=Base64UrlEncoder)]\n</code></pre> <p>A bytes type that is encoded and decoded using the URL-safe base64 encoder.</p> Note <p>Under the hood, <code>Base64UrlBytes</code> use standard library <code>base64.urlsafe_b64encode</code> and <code>base64.urlsafe_b64decode</code> functions.</p> <p>As a result, the <code>Base64UrlBytes</code> type can be used to faithfully decode \"vanilla\" base64 data (using <code>'+'</code> and <code>'/'</code>).</p> <pre><code>from pydantic import Base64UrlBytes, BaseModel\n\nclass Model(BaseModel):\n    base64url_bytes: Base64UrlBytes\n\n# Initialize the model with base64 data\nm = Model(base64url_bytes=b'SHc_dHc-TXc==')\nprint(m)\n#&gt; base64url_bytes=b'Hw?tw&gt;Mw'\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64UrlStr","title":"Base64UrlStr  <code>module-attribute</code>","text":"<pre><code>Base64UrlStr = Annotated[str, EncodedStr(encoder=Base64UrlEncoder)]\n</code></pre> <p>A str type that is encoded and decoded using the URL-safe base64 encoder.</p> Note <p>Under the hood, <code>Base64UrlStr</code> use standard library <code>base64.urlsafe_b64encode</code> and <code>base64.urlsafe_b64decode</code> functions.</p> <p>As a result, the <code>Base64UrlStr</code> type can be used to faithfully decode \"vanilla\" base64 data (using <code>'+'</code> and <code>'/'</code>).</p> <pre><code>from pydantic import Base64UrlStr, BaseModel\n\nclass Model(BaseModel):\n    base64url_str: Base64UrlStr\n\n# Initialize the model with base64 data\nm = Model(base64url_str='SHc_dHc-TXc==')\nprint(m)\n#&gt; base64url_str='Hw?tw&gt;Mw'\n</code></pre>"},{"location":"api/types/#pydantic.types.JsonValue","title":"JsonValue  <code>module-attribute</code>","text":"<pre><code>JsonValue: TypeAlias = Union[list['JsonValue'], dict[str, 'JsonValue'], str, bool, int, float, None]\n</code></pre> <p>A <code>JsonValue</code> is used to represent a value that can be serialized to JSON.</p> <p>It may be one of:</p> <ul> <li><code>list['JsonValue']</code></li> <li><code>dict[str, 'JsonValue']</code></li> <li><code>str</code></li> <li><code>bool</code></li> <li><code>int</code></li> <li><code>float</code></li> <li><code>None</code></li> </ul> <p>The following example demonstrates how to use <code>JsonValue</code> to validate JSON data, and what kind of errors to expect when input data is not json serializable.</p> <pre><code>import json\n\nfrom pydantic import BaseModel, JsonValue, ValidationError\n\nclass Model(BaseModel):\n    j: JsonValue\n\nvalid_json_data = {'j': {'a': {'b': {'c': 1, 'd': [2, None]}}}}\ninvalid_json_data = {'j': {'a': {'b': ...}}}\n\nprint(repr(Model.model_validate(valid_json_data)))\n#&gt; Model(j={'a': {'b': {'c': 1, 'd': [2, None]}}})\nprint(repr(Model.model_validate_json(json.dumps(valid_json_data))))\n#&gt; Model(j={'a': {'b': {'c': 1, 'd': [2, None]}}})\n\ntry:\n    Model.model_validate(invalid_json_data)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    j.dict.a.dict.b\n      input was not a valid JSON value [type=invalid-json-value, input_value=Ellipsis, input_type=ellipsis]\n    '''\n</code></pre>"},{"location":"api/types/#pydantic.types.OnErrorOmit","title":"OnErrorOmit  <code>module-attribute</code>","text":"<pre><code>OnErrorOmit = Annotated[T, _OnErrorOmit]\n</code></pre> <p>When used as an item in a list, the key type in a dict, optional values of a TypedDict, etc. this annotation omits the item from the iteration if there is any error validating it. That is, instead of a <code>ValidationError</code> being propagated up and the entire iterable being discarded any invalid items are discarded and the valid ones are returned.</p>"},{"location":"api/types/#pydantic.types.Strict","title":"Strict  <code>dataclass</code>","text":"<p>               Bases: <code>PydanticMetadata</code>, <code>BaseMetadata</code></p> <p>Usage Documentation</p> <p>Strict Mode with <code>Annotated</code> <code>Strict</code></p> <p>A field metadata class to indicate that a field should be validated in strict mode. Use this class as an annotation via <code>Annotated</code>, as seen below.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>strict</code> <code>bool</code> <p>Whether to validate the field in strict mode.</p> Example <pre><code>from typing import Annotated\n\nfrom pydantic.types import Strict\n\nStrictBool = Annotated[bool, Strict()]\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass\nclass Strict(_fields.PydanticMetadata, BaseMetadata):\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Strict Mode with `Annotated` `Strict`](../concepts/strict_mode.md#strict-mode-with-annotated-strict)\n\n    A field metadata class to indicate that a field should be validated in strict mode.\n    Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\n    Attributes:\n        strict: Whether to validate the field in strict mode.\n\n    Example:\n        ```python\n        from typing import Annotated\n\n        from pydantic.types import Strict\n\n        StrictBool = Annotated[bool, Strict()]\n        ```\n    \"\"\"\n\n    strict: bool = True\n\n    def __hash__(self) -&gt; int:\n        return hash(self.strict)\n</code></pre>"},{"location":"api/types/#pydantic.types.AllowInfNan","title":"AllowInfNan  <code>dataclass</code>","text":"<p>               Bases: <code>PydanticMetadata</code></p> <p>A field metadata class to indicate that a field should allow <code>-inf</code>, <code>inf</code>, and <code>nan</code>.</p> <p>Use this class as an annotation via <code>Annotated</code>, as seen below.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>allow_inf_nan</code> <code>bool</code> <p>Whether to allow <code>-inf</code>, <code>inf</code>, and <code>nan</code>. Defaults to <code>True</code>.</p> Example <pre><code>from typing import Annotated\n\nfrom pydantic.types import AllowInfNan\n\nLaxFloat = Annotated[float, AllowInfNan()]\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass\nclass AllowInfNan(_fields.PydanticMetadata):\n    \"\"\"A field metadata class to indicate that a field should allow `-inf`, `inf`, and `nan`.\n\n    Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\n    Attributes:\n        allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`. Defaults to `True`.\n\n    Example:\n        ```python\n        from typing import Annotated\n\n        from pydantic.types import AllowInfNan\n\n        LaxFloat = Annotated[float, AllowInfNan()]\n        ```\n    \"\"\"\n\n    allow_inf_nan: bool = True\n\n    def __hash__(self) -&gt; int:\n        return hash(self.allow_inf_nan)\n</code></pre>"},{"location":"api/types/#pydantic.types.StringConstraints","title":"StringConstraints  <code>dataclass</code>","text":"<p>               Bases: <code>GroupedMetadata</code></p> <p>Usage Documentation</p> <p>String types</p> <p>A field metadata class to apply constraints to <code>str</code> types. Use this class as an annotation via <code>Annotated</code>, as seen below.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>strip_whitespace</code> <code>bool | None</code> <p>Whether to remove leading and trailing whitespace.</p> <code>to_upper</code> <code>bool | None</code> <p>Whether to convert the string to uppercase.</p> <code>to_lower</code> <code>bool | None</code> <p>Whether to convert the string to lowercase.</p> <code>strict</code> <code>bool | None</code> <p>Whether to validate the string in strict mode.</p> <code>min_length</code> <code>int | None</code> <p>The minimum length of the string.</p> <code>max_length</code> <code>int | None</code> <p>The maximum length of the string.</p> <code>pattern</code> <code>str | Pattern[str] | None</code> <p>A regex pattern that the string must match.</p> Example <pre><code>from typing import Annotated\n\nfrom pydantic.types import StringConstraints\n\nConstrainedStr = Annotated[str, StringConstraints(min_length=1, max_length=10)]\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(frozen=True)\nclass StringConstraints(annotated_types.GroupedMetadata):\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [String types](./standard_library_types.md#strings)\n\n    A field metadata class to apply constraints to `str` types.\n    Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\n    Attributes:\n        strip_whitespace: Whether to remove leading and trailing whitespace.\n        to_upper: Whether to convert the string to uppercase.\n        to_lower: Whether to convert the string to lowercase.\n        strict: Whether to validate the string in strict mode.\n        min_length: The minimum length of the string.\n        max_length: The maximum length of the string.\n        pattern: A regex pattern that the string must match.\n\n    Example:\n        ```python\n        from typing import Annotated\n\n        from pydantic.types import StringConstraints\n\n        ConstrainedStr = Annotated[str, StringConstraints(min_length=1, max_length=10)]\n        ```\n    \"\"\"\n\n    strip_whitespace: bool | None = None\n    to_upper: bool | None = None\n    to_lower: bool | None = None\n    strict: bool | None = None\n    min_length: int | None = None\n    max_length: int | None = None\n    pattern: str | Pattern[str] | None = None\n\n    def __iter__(self) -&gt; Iterator[BaseMetadata]:\n        if self.min_length is not None:\n            yield MinLen(self.min_length)\n        if self.max_length is not None:\n            yield MaxLen(self.max_length)\n        if self.strict is not None:\n            yield Strict(self.strict)\n        if (\n            self.strip_whitespace is not None\n            or self.pattern is not None\n            or self.to_lower is not None\n            or self.to_upper is not None\n        ):\n            yield _fields.pydantic_general_metadata(\n                strip_whitespace=self.strip_whitespace,\n                to_upper=self.to_upper,\n                to_lower=self.to_lower,\n                pattern=self.pattern,\n            )\n</code></pre>"},{"location":"api/types/#pydantic.types.ImportString","title":"ImportString","text":"<p>A type that can be used to import a Python object from a string.</p> <p><code>ImportString</code> expects a string and loads the Python object importable at that dotted path. Attributes of modules may be separated from the module by <code>:</code> or <code>.</code>, e.g. if <code>'math:cos'</code> is provided, the resulting field value would be the function <code>cos</code>. If a <code>.</code> is used and both an attribute and submodule are present at the same path, the module will be preferred.</p> <p>On model instantiation, pointers will be evaluated and imported. There is some nuance to this behavior, demonstrated in the examples below.</p> <pre><code>import math\n\nfrom pydantic import BaseModel, Field, ImportString, ValidationError\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# A string value will cause an automatic import\nmy_cos = ImportThings(obj='math.cos')\n\n# You can use the imported function as you would expect\ncos_of_0 = my_cos.obj(0)\nassert cos_of_0 == 1\n\n# A string whose value cannot be imported will raise an error\ntry:\n    ImportThings(obj='foo.bar')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ImportThings\n    obj\n      Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]\n    '''\n\n# Actual python objects can be assigned as well\nmy_cos = ImportThings(obj=math.cos)\nmy_cos_2 = ImportThings(obj='math.cos')\nmy_cos_3 = ImportThings(obj='math:cos')\nassert my_cos == my_cos_2 == my_cos_3\n\n# You can set default field value either as Python object:\nclass ImportThingsDefaultPyObj(BaseModel):\n    obj: ImportString = math.cos\n\n# or as a string value (but only if used with `validate_default=True`)\nclass ImportThingsDefaultString(BaseModel):\n    obj: ImportString = Field(default='math.cos', validate_default=True)\n\nmy_cos_default1 = ImportThingsDefaultPyObj()\nmy_cos_default2 = ImportThingsDefaultString()\nassert my_cos_default1.obj == my_cos_default2.obj == math.cos\n\n# note: this will not work!\nclass ImportThingsMissingValidateDefault(BaseModel):\n    obj: ImportString = 'math.cos'\n\nmy_cos_default3 = ImportThingsMissingValidateDefault()\nassert my_cos_default3.obj == 'math.cos'  # just string, not evaluated\n</code></pre> <p>Serializing an <code>ImportString</code> type to json is also possible.</p> <pre><code>from pydantic import BaseModel, ImportString\n\nclass ImportThings(BaseModel):\n    obj: ImportString\n\n# Create an instance\nm = ImportThings(obj='math.cos')\nprint(m)\n#&gt; obj=&lt;built-in function cos&gt;\nprint(m.model_dump_json())\n#&gt; {\"obj\":\"math.cos\"}\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class ImportString:\n    \"\"\"A type that can be used to import a Python object from a string.\n\n    `ImportString` expects a string and loads the Python object importable at that dotted path.\n    Attributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` is provided,\n    the resulting field value would be the function `cos`. If a `.` is used and both an attribute and submodule\n    are present at the same path, the module will be preferred.\n\n    On model instantiation, pointers will be evaluated and imported. There is\n    some nuance to this behavior, demonstrated in the examples below.\n\n    ```python\n    import math\n\n    from pydantic import BaseModel, Field, ImportString, ValidationError\n\n    class ImportThings(BaseModel):\n        obj: ImportString\n\n    # A string value will cause an automatic import\n    my_cos = ImportThings(obj='math.cos')\n\n    # You can use the imported function as you would expect\n    cos_of_0 = my_cos.obj(0)\n    assert cos_of_0 == 1\n\n    # A string whose value cannot be imported will raise an error\n    try:\n        ImportThings(obj='foo.bar')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for ImportThings\n        obj\n          Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]\n        '''\n\n    # Actual python objects can be assigned as well\n    my_cos = ImportThings(obj=math.cos)\n    my_cos_2 = ImportThings(obj='math.cos')\n    my_cos_3 = ImportThings(obj='math:cos')\n    assert my_cos == my_cos_2 == my_cos_3\n\n    # You can set default field value either as Python object:\n    class ImportThingsDefaultPyObj(BaseModel):\n        obj: ImportString = math.cos\n\n    # or as a string value (but only if used with `validate_default=True`)\n    class ImportThingsDefaultString(BaseModel):\n        obj: ImportString = Field(default='math.cos', validate_default=True)\n\n    my_cos_default1 = ImportThingsDefaultPyObj()\n    my_cos_default2 = ImportThingsDefaultString()\n    assert my_cos_default1.obj == my_cos_default2.obj == math.cos\n\n    # note: this will not work!\n    class ImportThingsMissingValidateDefault(BaseModel):\n        obj: ImportString = 'math.cos'\n\n    my_cos_default3 = ImportThingsMissingValidateDefault()\n    assert my_cos_default3.obj == 'math.cos'  # just string, not evaluated\n    ```\n\n    Serializing an `ImportString` type to json is also possible.\n\n    ```python\n    from pydantic import BaseModel, ImportString\n\n    class ImportThings(BaseModel):\n        obj: ImportString\n\n    # Create an instance\n    m = ImportThings(obj='math.cos')\n    print(m)\n    #&gt; obj=&lt;built-in function cos&gt;\n    print(m.model_dump_json())\n    #&gt; {\"obj\":\"math.cos\"}\n    ```\n    \"\"\"\n\n    @classmethod\n    def __class_getitem__(cls, item: AnyType) -&gt; AnyType:\n        return Annotated[item, cls()]\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        serializer = core_schema.plain_serializer_function_ser_schema(cls._serialize, when_used='json')\n        if cls is source:\n            # Treat bare usage of ImportString (`schema is None`) as the same as ImportString[Any]\n            return core_schema.no_info_plain_validator_function(\n                function=_validators.import_string, serialization=serializer\n            )\n        else:\n            return core_schema.no_info_before_validator_function(\n                function=_validators.import_string, schema=handler(source), serialization=serializer\n            )\n\n    @classmethod\n    def __get_pydantic_json_schema__(cls, cs: CoreSchema, handler: GetJsonSchemaHandler) -&gt; JsonSchemaValue:\n        return handler(core_schema.str_schema())\n\n    @staticmethod\n    def _serialize(v: Any) -&gt; str:\n        if isinstance(v, ModuleType):\n            return v.__name__\n        elif hasattr(v, '__module__') and hasattr(v, '__name__'):\n            return f'{v.__module__}.{v.__name__}'\n        # Handle special cases for sys.XXX streams\n        # if we see more of these, we should consider a more general solution\n        elif hasattr(v, 'name'):\n            if v.name == '&lt;stdout&gt;':\n                return 'sys.stdout'\n            elif v.name == '&lt;stdin&gt;':\n                return 'sys.stdin'\n            elif v.name == '&lt;stderr&gt;':\n                return 'sys.stderr'\n        return v\n\n    def __repr__(self) -&gt; str:\n        return 'ImportString'\n</code></pre>"},{"location":"api/types/#pydantic.types.UuidVersion","title":"UuidVersion  <code>dataclass</code>","text":"<p>A field metadata class to indicate a UUID version.</p> <p>Use this class as an annotation via <code>Annotated</code>, as seen below.</p> <p>\u5c5e\u6027\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 <code>uuid_version</code> <code>Literal[1, 3, 4, 5, 6, 7, 8]</code> <p>The version of the UUID. Must be one of 1, 3, 4, 5, 6, 7 or 8.</p> Example <pre><code>from typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic.types import UuidVersion\n\nUUID1 = Annotated[UUID, UuidVersion(1)]\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass UuidVersion:\n    \"\"\"A field metadata class to indicate a [UUID](https://docs.python.org/3/library/uuid.html) version.\n\n    Use this class as an annotation via [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated), as seen below.\n\n    Attributes:\n        uuid_version: The version of the UUID. Must be one of 1, 3, 4, 5, 6, 7 or 8.\n\n    Example:\n        ```python\n        from typing import Annotated\n        from uuid import UUID\n\n        from pydantic.types import UuidVersion\n\n        UUID1 = Annotated[UUID, UuidVersion(1)]\n        ```\n    \"\"\"\n\n    uuid_version: Literal[1, 3, 4, 5, 6, 7, 8]\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        field_schema = handler(core_schema)\n        field_schema.pop('anyOf', None)  # remove the bytes/str union\n        field_schema.update(type='string', format=f'uuid{self.uuid_version}')\n        return field_schema\n\n    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        schema = handler(source)\n        _check_annotated_type(schema['type'], 'uuid', self.__class__.__name__)\n        schema['version'] = self.uuid_version  # type: ignore\n        return schema\n\n    def __hash__(self) -&gt; int:\n        return hash(type(self.uuid_version))\n</code></pre>"},{"location":"api/types/#pydantic.types.Json","title":"Json","text":"<p>A special type wrapper which loads JSON before parsing.</p> <p>You can use the <code>Json</code> data type to make Pydantic first load a raw JSON string before validating the loaded data into the parametrized type:</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, Json, ValidationError\n\nclass AnyJsonModel(BaseModel):\n    json_obj: Json[Any]\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(AnyJsonModel(json_obj='{\"b\": 1}'))\n#&gt; json_obj={'b': 1}\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n#&gt; json_obj=[1, 2, 3]\n\ntry:\n    ConstrainedJsonModel(json_obj=12)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[a, b]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for ConstrainedJsonModel\n    json_obj\n      Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]\n    '''\n\ntry:\n    ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\nexcept ValidationError as e:\n    print(e)\n    '''\n    2 validation errors for ConstrainedJsonModel\n    json_obj.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    json_obj.1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]\n    '''\n</code></pre> <p>When you dump the model using <code>model_dump</code> or <code>model_dump_json</code>, the dumped value will be the result of validation, not the original JSON string. However, you can use the argument <code>round_trip=True</code> to get the original JSON string back:</p> <pre><code>from pydantic import BaseModel, Json\n\nclass ConstrainedJsonModel(BaseModel):\n    json_obj: Json[list[int]]\n\nprint(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())\n#&gt; {\"json_obj\":[1,2,3]}\nprint(\n    ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)\n)\n#&gt; {\"json_obj\":\"[1,2,3]\"}\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class Json:\n    \"\"\"A special type wrapper which loads JSON before parsing.\n\n    You can use the `Json` data type to make Pydantic first load a raw JSON string before\n    validating the loaded data into the parametrized type:\n\n    ```python\n    from typing import Any\n\n    from pydantic import BaseModel, Json, ValidationError\n\n    class AnyJsonModel(BaseModel):\n        json_obj: Json[Any]\n\n    class ConstrainedJsonModel(BaseModel):\n        json_obj: Json[list[int]]\n\n    print(AnyJsonModel(json_obj='{\"b\": 1}'))\n    #&gt; json_obj={'b': 1}\n    print(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n    #&gt; json_obj=[1, 2, 3]\n\n    try:\n        ConstrainedJsonModel(json_obj=12)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for ConstrainedJsonModel\n        json_obj\n          JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]\n        '''\n\n    try:\n        ConstrainedJsonModel(json_obj='[a, b]')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for ConstrainedJsonModel\n        json_obj\n          Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]\n        '''\n\n    try:\n        ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\n    except ValidationError as e:\n        print(e)\n        '''\n        2 validation errors for ConstrainedJsonModel\n        json_obj.0\n          Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n        json_obj.1\n          Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]\n        '''\n    ```\n\n    When you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,\n    not the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:\n\n    ```python\n    from pydantic import BaseModel, Json\n\n    class ConstrainedJsonModel(BaseModel):\n        json_obj: Json[list[int]]\n\n    print(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())\n    #&gt; {\"json_obj\":[1,2,3]}\n    print(\n        ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)\n    )\n    #&gt; {\"json_obj\":\"[1,2,3]\"}\n    ```\n    \"\"\"\n\n    @classmethod\n    def __class_getitem__(cls, item: AnyType) -&gt; AnyType:\n        return Annotated[item, cls()]\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            return core_schema.json_schema(None)\n        else:\n            return core_schema.json_schema(handler(source))\n\n    def __repr__(self) -&gt; str:\n        return 'Json'\n\n    def __hash__(self) -&gt; int:\n        return hash(type(self))\n\n    def __eq__(self, other: Any) -&gt; bool:\n        return type(other) is type(self)\n</code></pre>"},{"location":"api/types/#pydantic.types.Secret","title":"Secret","text":"<p>               Bases: <code>_SecretBase[SecretType]</code></p> <p>A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.</p> <p>You may either directly parametrize <code>Secret</code> with a type, or subclass from <code>Secret</code> with a parametrized type. The benefit of subclassing is that you can define a custom <code>_display</code> method, which will be used for <code>repr()</code> and <code>str()</code> methods. The examples below demonstrate both ways of using <code>Secret</code> to create a new secret type.</p> <ol> <li>Directly parametrizing <code>Secret</code> with a type:</li> </ol> <pre><code>from pydantic import BaseModel, Secret\n\nSecretBool = Secret[bool]\n\nclass Model(BaseModel):\n    secret_bool: SecretBool\n\nm = Model(secret_bool=True)\nprint(m.model_dump())\n#&gt; {'secret_bool': Secret('**********')}\n\nprint(m.model_dump_json())\n#&gt; {\"secret_bool\":\"**********\"}\n\nprint(m.secret_bool.get_secret_value())\n#&gt; True\n</code></pre> <ol> <li>Subclassing from parametrized <code>Secret</code>:</li> </ol> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel, Secret\n\nclass SecretDate(Secret[date]):\n    def _display(self) -&gt; str:\n        return '****/**/**'\n\nclass Model(BaseModel):\n    secret_date: SecretDate\n\nm = Model(secret_date=date(2022, 1, 1))\nprint(m.model_dump())\n#&gt; {'secret_date': SecretDate('****/**/**')}\n\nprint(m.model_dump_json())\n#&gt; {\"secret_date\":\"****/**/**\"}\n\nprint(m.secret_date.get_secret_value())\n#&gt; 2022-01-01\n</code></pre> <p>The value returned by the <code>_display</code> method will be used for <code>repr()</code> and <code>str()</code>.</p> <p>You can enforce constraints on the underlying type through annotations: For example:</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field, Secret, ValidationError\n\nSecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]\n\nclass Model(BaseModel):\n    sensitive_int: SecretPosInt\n\nm = Model(sensitive_int=42)\nprint(m.model_dump())\n#&gt; {'sensitive_int': Secret('**********')}\n\ntry:\n    m = Model(sensitive_int=-42)  # (1)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be greater than 0',\n            'ctx': {'gt': 0},\n        }\n    ]\n    '''\n\ntry:\n    m = Model(sensitive_int='42')  # (2)!\nexcept ValidationError as exc_info:\n    print(exc_info.errors(include_url=False, include_input=False))\n    '''\n    [\n        {\n            'type': 'int_type',\n            'loc': ('sensitive_int',),\n            'msg': 'Input should be a valid integer',\n        }\n    ]\n    '''\n</code></pre> <ol> <li>The input value is not greater than 0, so it raises a validation error.</li> <li>The input value is not an integer, so it raises a validation error because the <code>SecretPosInt</code> type has strict mode enabled.</li> </ol> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class Secret(_SecretBase[SecretType]):\n    \"\"\"A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.\n\n    You may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing\n    is that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both\n    ways of using `Secret` to create a new secret type.\n\n    1. Directly parametrizing `Secret` with a type:\n\n    ```python\n    from pydantic import BaseModel, Secret\n\n    SecretBool = Secret[bool]\n\n    class Model(BaseModel):\n        secret_bool: SecretBool\n\n    m = Model(secret_bool=True)\n    print(m.model_dump())\n    #&gt; {'secret_bool': Secret('**********')}\n\n    print(m.model_dump_json())\n    #&gt; {\"secret_bool\":\"**********\"}\n\n    print(m.secret_bool.get_secret_value())\n    #&gt; True\n    ```\n\n    2. Subclassing from parametrized `Secret`:\n\n    ```python\n    from datetime import date\n\n    from pydantic import BaseModel, Secret\n\n    class SecretDate(Secret[date]):\n        def _display(self) -&gt; str:\n            return '****/**/**'\n\n    class Model(BaseModel):\n        secret_date: SecretDate\n\n    m = Model(secret_date=date(2022, 1, 1))\n    print(m.model_dump())\n    #&gt; {'secret_date': SecretDate('****/**/**')}\n\n    print(m.model_dump_json())\n    #&gt; {\"secret_date\":\"****/**/**\"}\n\n    print(m.secret_date.get_secret_value())\n    #&gt; 2022-01-01\n    ```\n\n    The value returned by the `_display` method will be used for `repr()` and `str()`.\n\n    You can enforce constraints on the underlying type through annotations:\n    For example:\n\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, Field, Secret, ValidationError\n\n    SecretPosInt = Secret[Annotated[int, Field(gt=0, strict=True)]]\n\n    class Model(BaseModel):\n        sensitive_int: SecretPosInt\n\n    m = Model(sensitive_int=42)\n    print(m.model_dump())\n    #&gt; {'sensitive_int': Secret('**********')}\n\n    try:\n        m = Model(sensitive_int=-42)  # (1)!\n    except ValidationError as exc_info:\n        print(exc_info.errors(include_url=False, include_input=False))\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('sensitive_int',),\n                'msg': 'Input should be greater than 0',\n                'ctx': {'gt': 0},\n            }\n        ]\n        '''\n\n    try:\n        m = Model(sensitive_int='42')  # (2)!\n    except ValidationError as exc_info:\n        print(exc_info.errors(include_url=False, include_input=False))\n        '''\n        [\n            {\n                'type': 'int_type',\n                'loc': ('sensitive_int',),\n                'msg': 'Input should be a valid integer',\n            }\n        ]\n        '''\n    ```\n\n    1. The input value is not greater than 0, so it raises a validation error.\n    2. The input value is not an integer, so it raises a validation error because the `SecretPosInt` type has strict mode enabled.\n    \"\"\"\n\n    def _display(self) -&gt; str | bytes:\n        return '**********' if self.get_secret_value() else ''\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        inner_type = None\n        # if origin_type is Secret, then cls is a GenericAlias, and we can extract the inner type directly\n        origin_type = get_origin(source)\n        if origin_type is not None:\n            inner_type = get_args(source)[0]\n        # otherwise, we need to get the inner type from the base class\n        else:\n            bases = getattr(cls, '__orig_bases__', getattr(cls, '__bases__', []))\n            for base in bases:\n                if get_origin(base) is Secret:\n                    inner_type = get_args(base)[0]\n            if bases == [] or inner_type is None:\n                raise TypeError(\n                    f\"Can't get secret type from {cls.__name__}. \"\n                    'Please use Secret[&lt;type&gt;], or subclass from Secret[&lt;type&gt;] instead.'\n                )\n\n        inner_schema = handler.generate_schema(inner_type)  # type: ignore\n\n        def validate_secret_value(value, handler) -&gt; Secret[SecretType]:\n            if isinstance(value, Secret):\n                value = value.get_secret_value()\n            validated_inner = handler(value)\n            return cls(validated_inner)\n\n        return core_schema.json_or_python_schema(\n            python_schema=core_schema.no_info_wrap_validator_function(\n                validate_secret_value,\n                inner_schema,\n            ),\n            json_schema=core_schema.no_info_after_validator_function(lambda x: cls(x), inner_schema),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                _serialize_secret,\n                info_arg=True,\n                when_used='always',\n            ),\n        )\n\n    __pydantic_serializer__ = SchemaSerializer(\n        core_schema.any_schema(\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                _serialize_secret,\n                info_arg=True,\n                when_used='always',\n            )\n        )\n    )\n</code></pre>"},{"location":"api/types/#pydantic.types.SecretStr","title":"SecretStr","text":"<p>               Bases: <code>_SecretField[str]</code></p> <p>A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.</p> <p>When the secret value is nonempty, it is displayed as <code>'**********'</code> instead of the underlying value in calls to <code>repr()</code> and <code>str()</code>. If the value is empty, it is displayed as <code>''</code>.</p> <pre><code>from pydantic import BaseModel, SecretStr\n\nclass User(BaseModel):\n    username: str\n    password: SecretStr\n\nuser = User(username='scolvin', password='password1')\n\nprint(user)\n#&gt; username='scolvin' password=SecretStr('**********')\nprint(user.password.get_secret_value())\n#&gt; password1\nprint((SecretStr('password'), SecretStr('')))\n#&gt; (SecretStr('**********'), SecretStr(''))\n</code></pre> <p>As seen above, by default, <code>SecretStr</code> (and <code>SecretBytes</code>) will be serialized as <code>**********</code> when serializing to json.</p> <p>You can use the <code>field_serializer</code> to dump the secret as plain-text when serializing to json.</p> <pre><code>from pydantic import BaseModel, SecretBytes, SecretStr, field_serializer\n\nclass Model(BaseModel):\n    password: SecretStr\n    password_bytes: SecretBytes\n\n    @field_serializer('password', 'password_bytes', when_used='json')\n    def dump_secret(self, v):\n        return v.get_secret_value()\n\nmodel = Model(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\nprint(model)\n#&gt; password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\nprint(model.password)\n#&gt; **********\nprint(model.model_dump())\n'''\n{\n    'password': SecretStr('**********'),\n    'password_bytes': SecretBytes(b'**********'),\n}\n'''\nprint(model.model_dump_json())\n#&gt; {\"password\":\"IAmSensitive\",\"password_bytes\":\"IAmSensitiveBytes\"}\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class SecretStr(_SecretField[str]):\n    \"\"\"A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\n    When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\n    calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `''`.\n\n    ```python\n    from pydantic import BaseModel, SecretStr\n\n    class User(BaseModel):\n        username: str\n        password: SecretStr\n\n    user = User(username='scolvin', password='password1')\n\n    print(user)\n    #&gt; username='scolvin' password=SecretStr('**********')\n    print(user.password.get_secret_value())\n    #&gt; password1\n    print((SecretStr('password'), SecretStr('')))\n    #&gt; (SecretStr('**********'), SecretStr(''))\n    ```\n\n    As seen above, by default, [`SecretStr`][pydantic.types.SecretStr] (and [`SecretBytes`][pydantic.types.SecretBytes])\n    will be serialized as `**********` when serializing to json.\n\n    You can use the [`field_serializer`][pydantic.functional_serializers.field_serializer] to dump the\n    secret as plain-text when serializing to json.\n\n    ```python\n    from pydantic import BaseModel, SecretBytes, SecretStr, field_serializer\n\n    class Model(BaseModel):\n        password: SecretStr\n        password_bytes: SecretBytes\n\n        @field_serializer('password', 'password_bytes', when_used='json')\n        def dump_secret(self, v):\n            return v.get_secret_value()\n\n    model = Model(password='IAmSensitive', password_bytes=b'IAmSensitiveBytes')\n    print(model)\n    #&gt; password=SecretStr('**********') password_bytes=SecretBytes(b'**********')\n    print(model.password)\n    #&gt; **********\n    print(model.model_dump())\n    '''\n    {\n        'password': SecretStr('**********'),\n        'password_bytes': SecretBytes(b'**********'),\n    }\n    '''\n    print(model.model_dump_json())\n    #&gt; {\"password\":\"IAmSensitive\",\"password_bytes\":\"IAmSensitiveBytes\"}\n    ```\n    \"\"\"\n\n    _inner_schema: ClassVar[CoreSchema] = core_schema.str_schema()\n    _error_kind: ClassVar[str] = 'string_type'\n\n    def __len__(self) -&gt; int:\n        return len(self._secret_value)\n\n    def _display(self) -&gt; str:\n        return _secret_display(self._secret_value)\n</code></pre>"},{"location":"api/types/#pydantic.types.SecretBytes","title":"SecretBytes","text":"<p>               Bases: <code>_SecretField[bytes]</code></p> <p>A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.</p> <p>It displays <code>b'**********'</code> instead of the string value on <code>repr()</code> and <code>str()</code> calls. When the secret value is nonempty, it is displayed as <code>b'**********'</code> instead of the underlying value in calls to <code>repr()</code> and <code>str()</code>. If the value is empty, it is displayed as <code>b''</code>.</p> <pre><code>from pydantic import BaseModel, SecretBytes\n\nclass User(BaseModel):\n    username: str\n    password: SecretBytes\n\nuser = User(username='scolvin', password=b'password1')\n#&gt; username='scolvin' password=SecretBytes(b'**********')\nprint(user.password.get_secret_value())\n#&gt; b'password1'\nprint((SecretBytes(b'password'), SecretBytes(b'')))\n#&gt; (SecretBytes(b'**********'), SecretBytes(b''))\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class SecretBytes(_SecretField[bytes]):\n    \"\"\"A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\n    It displays `b'**********'` instead of the string value on `repr()` and `str()` calls.\n    When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `b''`.\n\n    ```python\n    from pydantic import BaseModel, SecretBytes\n\n    class User(BaseModel):\n        username: str\n        password: SecretBytes\n\n    user = User(username='scolvin', password=b'password1')\n    #&gt; username='scolvin' password=SecretBytes(b'**********')\n    print(user.password.get_secret_value())\n    #&gt; b'password1'\n    print((SecretBytes(b'password'), SecretBytes(b'')))\n    #&gt; (SecretBytes(b'**********'), SecretBytes(b''))\n    ```\n    \"\"\"\n\n    _inner_schema: ClassVar[CoreSchema] = core_schema.bytes_schema()\n    _error_kind: ClassVar[str] = 'bytes_type'\n\n    def __len__(self) -&gt; int:\n        return len(self._secret_value)\n\n    def _display(self) -&gt; bytes:\n        return _secret_display(self._secret_value).encode()\n</code></pre>"},{"location":"api/types/#pydantic.types.PaymentCardNumber","title":"PaymentCardNumber","text":"<p>               Bases: <code>str</code></p> <p>Based on: https://en.wikipedia.org/wiki/Payment_card_number.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@deprecated(\n    'The `PaymentCardNumber` class is deprecated, use `pydantic_extra_types` instead. '\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.',\n    category=PydanticDeprecatedSince20,\n)\nclass PaymentCardNumber(str):\n    \"\"\"Based on: https://en.wikipedia.org/wiki/Payment_card_number.\"\"\"\n\n    strip_whitespace: ClassVar[bool] = True\n    min_length: ClassVar[int] = 12\n    max_length: ClassVar[int] = 19\n    bin: str\n    last4: str\n    brand: PaymentCardBrand\n\n    def __init__(self, card_number: str):\n        self.validate_digits(card_number)\n\n        card_number = self.validate_luhn_check_digit(card_number)\n\n        self.bin = card_number[:6]\n        self.last4 = card_number[-4:]\n        self.brand = self.validate_brand(card_number)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            cls.validate,\n            core_schema.str_schema(\n                min_length=cls.min_length, max_length=cls.max_length, strip_whitespace=cls.strip_whitespace\n            ),\n        )\n\n    @classmethod\n    def validate(cls, input_value: str, /, _: core_schema.ValidationInfo) -&gt; PaymentCardNumber:\n        \"\"\"Validate the card number and return a `PaymentCardNumber` instance.\"\"\"\n        return cls(input_value)\n\n    @property\n    def masked(self) -&gt; str:\n        \"\"\"Mask all but the last 4 digits of the card number.\n\n        Returns:\n            A masked card number string.\n        \"\"\"\n        num_masked = len(self) - 10  # len(bin) + len(last4) == 10\n        return f'{self.bin}{\"*\" * num_masked}{self.last4}'\n\n    @classmethod\n    def validate_digits(cls, card_number: str) -&gt; None:\n        \"\"\"Validate that the card number is all digits.\"\"\"\n        if not card_number.isdigit():\n            raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits')\n\n    @classmethod\n    def validate_luhn_check_digit(cls, card_number: str) -&gt; str:\n        \"\"\"Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.\"\"\"\n        sum_ = int(card_number[-1])\n        length = len(card_number)\n        parity = length % 2\n        for i in range(length - 1):\n            digit = int(card_number[i])\n            if i % 2 == parity:\n                digit *= 2\n            if digit &gt; 9:\n                digit -= 9\n            sum_ += digit\n        valid = sum_ % 10 == 0\n        if not valid:\n            raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')\n        return card_number\n\n    @staticmethod\n    def validate_brand(card_number: str) -&gt; PaymentCardBrand:\n        \"\"\"Validate length based on BIN for major brands:\n        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).\n        \"\"\"\n        if card_number[0] == '4':\n            brand = PaymentCardBrand.visa\n        elif 51 &lt;= int(card_number[:2]) &lt;= 55:\n            brand = PaymentCardBrand.mastercard\n        elif card_number[:2] in {'34', '37'}:\n            brand = PaymentCardBrand.amex\n        else:\n            brand = PaymentCardBrand.other\n\n        required_length: None | int | str = None\n        if brand in PaymentCardBrand.mastercard:\n            required_length = 16\n            valid = len(card_number) == required_length\n        elif brand == PaymentCardBrand.visa:\n            required_length = '13, 16 or 19'\n            valid = len(card_number) in {13, 16, 19}\n        elif brand == PaymentCardBrand.amex:\n            required_length = 15\n            valid = len(card_number) == required_length\n        else:\n            valid = True\n\n        if not valid:\n            raise PydanticCustomError(\n                'payment_card_number_brand',\n                'Length for a {brand} card must be {required_length}',\n                {'brand': brand, 'required_length': required_length},\n            )\n        return brand\n</code></pre>"},{"location":"api/types/#pydantic.types.PaymentCardNumber.masked","title":"masked  <code>property</code>","text":"<pre><code>masked: str\n</code></pre> <p>Mask all but the last 4 digits of the card number.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>A masked card number string.</p>"},{"location":"api/types/#pydantic.types.PaymentCardNumber.validate","title":"validate  <code>classmethod</code>","text":"<pre><code>validate(input_value: str, /, _: ValidationInfo) -&gt; PaymentCardNumber\n</code></pre> <p>Validate the card number and return a <code>PaymentCardNumber</code> instance.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef validate(cls, input_value: str, /, _: core_schema.ValidationInfo) -&gt; PaymentCardNumber:\n    \"\"\"Validate the card number and return a `PaymentCardNumber` instance.\"\"\"\n    return cls(input_value)\n</code></pre>"},{"location":"api/types/#pydantic.types.PaymentCardNumber.validate_digits","title":"validate_digits  <code>classmethod</code>","text":"<pre><code>validate_digits(card_number: str) -&gt; None\n</code></pre> <p>Validate that the card number is all digits.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef validate_digits(cls, card_number: str) -&gt; None:\n    \"\"\"Validate that the card number is all digits.\"\"\"\n    if not card_number.isdigit():\n        raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits')\n</code></pre>"},{"location":"api/types/#pydantic.types.PaymentCardNumber.validate_luhn_check_digit","title":"validate_luhn_check_digit  <code>classmethod</code>","text":"<pre><code>validate_luhn_check_digit(card_number: str) -&gt; str\n</code></pre> <p>Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef validate_luhn_check_digit(cls, card_number: str) -&gt; str:\n    \"\"\"Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.\"\"\"\n    sum_ = int(card_number[-1])\n    length = len(card_number)\n    parity = length % 2\n    for i in range(length - 1):\n        digit = int(card_number[i])\n        if i % 2 == parity:\n            digit *= 2\n        if digit &gt; 9:\n            digit -= 9\n        sum_ += digit\n    valid = sum_ % 10 == 0\n    if not valid:\n        raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')\n    return card_number\n</code></pre>"},{"location":"api/types/#pydantic.types.PaymentCardNumber.validate_brand","title":"validate_brand  <code>staticmethod</code>","text":"<pre><code>validate_brand(card_number: str) -&gt; PaymentCardBrand\n</code></pre> <p>Validate length based on BIN for major brands: https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@staticmethod\ndef validate_brand(card_number: str) -&gt; PaymentCardBrand:\n    \"\"\"Validate length based on BIN for major brands:\n    https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).\n    \"\"\"\n    if card_number[0] == '4':\n        brand = PaymentCardBrand.visa\n    elif 51 &lt;= int(card_number[:2]) &lt;= 55:\n        brand = PaymentCardBrand.mastercard\n    elif card_number[:2] in {'34', '37'}:\n        brand = PaymentCardBrand.amex\n    else:\n        brand = PaymentCardBrand.other\n\n    required_length: None | int | str = None\n    if brand in PaymentCardBrand.mastercard:\n        required_length = 16\n        valid = len(card_number) == required_length\n    elif brand == PaymentCardBrand.visa:\n        required_length = '13, 16 or 19'\n        valid = len(card_number) in {13, 16, 19}\n    elif brand == PaymentCardBrand.amex:\n        required_length = 15\n        valid = len(card_number) == required_length\n    else:\n        valid = True\n\n    if not valid:\n        raise PydanticCustomError(\n            'payment_card_number_brand',\n            'Length for a {brand} card must be {required_length}',\n            {'brand': brand, 'required_length': required_length},\n        )\n    return brand\n</code></pre>"},{"location":"api/types/#pydantic.types.ByteSize","title":"ByteSize","text":"<p>               Bases: <code>int</code></p> <p>Converts a string representing a number of bytes with units (such as <code>'1KB'</code> or <code>'11.5MiB'</code>) into an integer.</p> <p>You can use the <code>ByteSize</code> data type to (case-insensitively) convert a string representation of a number of bytes into an integer, and also to print out human-readable strings representing a number of bytes.</p> <p>In conformance with IEC 80000-13 Standard we interpret <code>'1KB'</code> to mean 1000 bytes, and <code>'1KiB'</code> to mean 1024 bytes. In general, including a middle <code>'i'</code> will cause the unit to be interpreted as a power of 2, rather than a power of 10 (so, for example, <code>'1 MB'</code> is treated as <code>1_000_000</code> bytes, whereas <code>'1 MiB'</code> is treated as <code>1_048_576</code> bytes).</p> <p>Info</p> <p>Note that <code>1b</code> will be parsed as \"1 byte\" and not \"1 bit\".</p> <pre><code>from pydantic import BaseModel, ByteSize\n\nclass MyModel(BaseModel):\n    size: ByteSize\n\nprint(MyModel(size=52000).size)\n#&gt; 52000\nprint(MyModel(size='3000 KiB').size)\n#&gt; 3072000\n\nm = MyModel(size='50 PB')\nprint(m.size.human_readable())\n#&gt; 44.4PiB\nprint(m.size.human_readable(decimal=True))\n#&gt; 50.0PB\nprint(m.size.human_readable(separator=' '))\n#&gt; 44.4 PiB\n\nprint(m.size.to('TiB'))\n#&gt; 45474.73508864641\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class ByteSize(int):\n    \"\"\"Converts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.\n\n    You can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\n    an integer, and also to print out human-readable strings representing a number of bytes.\n\n    In conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,\n    and `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\n    rather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).\n\n    !!! info\n        Note that `1b` will be parsed as \"1 byte\" and not \"1 bit\".\n\n    ```python\n    from pydantic import BaseModel, ByteSize\n\n    class MyModel(BaseModel):\n        size: ByteSize\n\n    print(MyModel(size=52000).size)\n    #&gt; 52000\n    print(MyModel(size='3000 KiB').size)\n    #&gt; 3072000\n\n    m = MyModel(size='50 PB')\n    print(m.size.human_readable())\n    #&gt; 44.4PiB\n    print(m.size.human_readable(decimal=True))\n    #&gt; 50.0PB\n    print(m.size.human_readable(separator=' '))\n    #&gt; 44.4 PiB\n\n    print(m.size.to('TiB'))\n    #&gt; 45474.73508864641\n    ```\n    \"\"\"\n\n    byte_sizes = {\n        'b': 1,\n        'kb': 10**3,\n        'mb': 10**6,\n        'gb': 10**9,\n        'tb': 10**12,\n        'pb': 10**15,\n        'eb': 10**18,\n        'kib': 2**10,\n        'mib': 2**20,\n        'gib': 2**30,\n        'tib': 2**40,\n        'pib': 2**50,\n        'eib': 2**60,\n        'bit': 1 / 8,\n        'kbit': 10**3 / 8,\n        'mbit': 10**6 / 8,\n        'gbit': 10**9 / 8,\n        'tbit': 10**12 / 8,\n        'pbit': 10**15 / 8,\n        'ebit': 10**18 / 8,\n        'kibit': 2**10 / 8,\n        'mibit': 2**20 / 8,\n        'gibit': 2**30 / 8,\n        'tibit': 2**40 / 8,\n        'pibit': 2**50 / 8,\n        'eibit': 2**60 / 8,\n    }\n    byte_sizes.update({k.lower()[0]: v for k, v in byte_sizes.items() if 'i' not in k})\n\n    byte_string_pattern = r'^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?'\n    byte_string_re = re.compile(byte_string_pattern, re.IGNORECASE)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            function=cls._validate,\n            schema=core_schema.union_schema(\n                [\n                    core_schema.str_schema(pattern=cls.byte_string_pattern),\n                    core_schema.int_schema(ge=0),\n                ],\n                custom_error_type='byte_size',\n                custom_error_message='could not parse value and unit from byte string',\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                int, return_schema=core_schema.int_schema(ge=0)\n            ),\n        )\n\n    @classmethod\n    def _validate(cls, input_value: Any, /, _: core_schema.ValidationInfo) -&gt; ByteSize:\n        try:\n            return cls(int(input_value))\n        except ValueError:\n            pass\n\n        str_match = cls.byte_string_re.match(str(input_value))\n        if str_match is None:\n            raise PydanticCustomError('byte_size', 'could not parse value and unit from byte string')\n\n        scalar, unit = str_match.groups()\n        if unit is None:\n            unit = 'b'\n\n        try:\n            unit_mult = cls.byte_sizes[unit.lower()]\n        except KeyError:\n            raise PydanticCustomError('byte_size_unit', 'could not interpret byte unit: {unit}', {'unit': unit})\n\n        return cls(int(float(scalar) * unit_mult))\n\n    def human_readable(self, decimal: bool = False, separator: str = '') -&gt; str:\n        \"\"\"Converts a byte size to a human readable string.\n\n        Args:\n            decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units\n                (e.g. 1024 bytes per KiB).\n            separator: A string used to split the value and unit. Defaults to an empty string ('').\n\n        Returns:\n            A human readable string representation of the byte size.\n        \"\"\"\n        if decimal:\n            divisor = 1000\n            units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = 'B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'\n            final_unit = 'EiB'\n\n        num = float(self)\n        for unit in units:\n            if abs(num) &lt; divisor:\n                if unit == 'B':\n                    return f'{num:0.0f}{separator}{unit}'\n                else:\n                    return f'{num:0.1f}{separator}{unit}'\n            num /= divisor\n\n        return f'{num:0.1f}{separator}{final_unit}'\n\n    def to(self, unit: str) -&gt; float:\n        \"\"\"Converts a byte size to another unit, including both byte and bit units.\n\n        Args:\n            unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,\n                KiB, MiB, GiB, TiB, PiB, EiB (byte units) and\n                bit, kbit, mbit, gbit, tbit, pbit, ebit,\n                kibit, mibit, gibit, tibit, pibit, eibit (bit units).\n\n        Returns:\n            The byte size in the new unit.\n        \"\"\"\n        try:\n            unit_div = self.byte_sizes[unit.lower()]\n        except KeyError:\n            raise PydanticCustomError('byte_size_unit', 'Could not interpret byte unit: {unit}', {'unit': unit})\n\n        return self / unit_div\n</code></pre>"},{"location":"api/types/#pydantic.types.ByteSize.human_readable","title":"human_readable","text":"<pre><code>human_readable(decimal: bool = False, separator: str = '') -&gt; str\n</code></pre> <p>Converts a byte size to a human readable string.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>decimal</code> <code>bool</code> <p>If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units (e.g. 1024 bytes per KiB).</p> <code>False</code> <code>separator</code> <code>str</code> <p>A string used to split the value and unit. Defaults to an empty string ('').</p> <code>''</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>A human readable string representation of the byte size.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def human_readable(self, decimal: bool = False, separator: str = '') -&gt; str:\n    \"\"\"Converts a byte size to a human readable string.\n\n    Args:\n        decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units\n            (e.g. 1024 bytes per KiB).\n        separator: A string used to split the value and unit. Defaults to an empty string ('').\n\n    Returns:\n        A human readable string representation of the byte size.\n    \"\"\"\n    if decimal:\n        divisor = 1000\n        units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n        final_unit = 'EB'\n    else:\n        divisor = 1024\n        units = 'B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'\n        final_unit = 'EiB'\n\n    num = float(self)\n    for unit in units:\n        if abs(num) &lt; divisor:\n            if unit == 'B':\n                return f'{num:0.0f}{separator}{unit}'\n            else:\n                return f'{num:0.1f}{separator}{unit}'\n        num /= divisor\n\n    return f'{num:0.1f}{separator}{final_unit}'\n</code></pre>"},{"location":"api/types/#pydantic.types.ByteSize.to","title":"to","text":"<pre><code>to(unit: str) -&gt; float\n</code></pre> <p>Converts a byte size to another unit, including both byte and bit units.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>unit</code> <code>str</code> <p>The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB, KiB, MiB, GiB, TiB, PiB, EiB (byte units) and bit, kbit, mbit, gbit, tbit, pbit, ebit, kibit, mibit, gibit, tibit, pibit, eibit (bit units).</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>float</code> <p>The byte size in the new unit.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def to(self, unit: str) -&gt; float:\n    \"\"\"Converts a byte size to another unit, including both byte and bit units.\n\n    Args:\n        unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,\n            KiB, MiB, GiB, TiB, PiB, EiB (byte units) and\n            bit, kbit, mbit, gbit, tbit, pbit, ebit,\n            kibit, mibit, gibit, tibit, pibit, eibit (bit units).\n\n    Returns:\n        The byte size in the new unit.\n    \"\"\"\n    try:\n        unit_div = self.byte_sizes[unit.lower()]\n    except KeyError:\n        raise PydanticCustomError('byte_size_unit', 'Could not interpret byte unit: {unit}', {'unit': unit})\n\n    return self / unit_div\n</code></pre>"},{"location":"api/types/#pydantic.types.PastDate","title":"PastDate","text":"<p>A date in the past.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class PastDate:\n    \"\"\"A date in the past.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            # used directly as a type\n            return core_schema.date_schema(now_op='past')\n        else:\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'date', cls.__name__)\n            schema['now_op'] = 'past'\n            return schema\n\n    def __repr__(self) -&gt; str:\n        return 'PastDate'\n</code></pre>"},{"location":"api/types/#pydantic.types.FutureDate","title":"FutureDate","text":"<p>A date in the future.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class FutureDate:\n    \"\"\"A date in the future.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            # used directly as a type\n            return core_schema.date_schema(now_op='future')\n        else:\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'date', cls.__name__)\n            schema['now_op'] = 'future'\n            return schema\n\n    def __repr__(self) -&gt; str:\n        return 'FutureDate'\n</code></pre>"},{"location":"api/types/#pydantic.types.AwareDatetime","title":"AwareDatetime","text":"<p>A datetime that requires timezone info.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class AwareDatetime:\n    \"\"\"A datetime that requires timezone info.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            # used directly as a type\n            return core_schema.datetime_schema(tz_constraint='aware')\n        else:\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n            schema['tz_constraint'] = 'aware'\n            return schema\n\n    def __repr__(self) -&gt; str:\n        return 'AwareDatetime'\n</code></pre>"},{"location":"api/types/#pydantic.types.NaiveDatetime","title":"NaiveDatetime","text":"<p>A datetime that doesn't require timezone info.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class NaiveDatetime:\n    \"\"\"A datetime that doesn't require timezone info.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            # used directly as a type\n            return core_schema.datetime_schema(tz_constraint='naive')\n        else:\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n            schema['tz_constraint'] = 'naive'\n            return schema\n\n    def __repr__(self) -&gt; str:\n        return 'NaiveDatetime'\n</code></pre>"},{"location":"api/types/#pydantic.types.PastDatetime","title":"PastDatetime","text":"<p>A datetime that must be in the past.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class PastDatetime:\n    \"\"\"A datetime that must be in the past.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            # used directly as a type\n            return core_schema.datetime_schema(now_op='past')\n        else:\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n            schema['now_op'] = 'past'\n            return schema\n\n    def __repr__(self) -&gt; str:\n        return 'PastDatetime'\n</code></pre>"},{"location":"api/types/#pydantic.types.FutureDatetime","title":"FutureDatetime","text":"<p>A datetime that must be in the future.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class FutureDatetime:\n    \"\"\"A datetime that must be in the future.\"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if cls is source:\n            # used directly as a type\n            return core_schema.datetime_schema(now_op='future')\n        else:\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n            schema['now_op'] = 'future'\n            return schema\n\n    def __repr__(self) -&gt; str:\n        return 'FutureDatetime'\n</code></pre>"},{"location":"api/types/#pydantic.types.EncoderProtocol","title":"EncoderProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for encoding and decoding data to and from bytes.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class EncoderProtocol(Protocol):\n    \"\"\"Protocol for encoding and decoding data to and from bytes.\"\"\"\n\n    @classmethod\n    def decode(cls, data: bytes) -&gt; bytes:\n        \"\"\"Decode the data using the encoder.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        ...\n\n    @classmethod\n    def encode(cls, value: bytes) -&gt; bytes:\n        \"\"\"Encode the data using the encoder.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        ...\n\n    @classmethod\n    def get_json_format(cls) -&gt; str:\n        \"\"\"Get the JSON format for the encoded data.\n\n        Returns:\n            The JSON format for the encoded data.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/types/#pydantic.types.EncoderProtocol.decode","title":"decode  <code>classmethod</code>","text":"<pre><code>decode(data: bytes) -&gt; bytes\n</code></pre> <p>Decode the data using the encoder.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>bytes</code> <p>The data to decode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The decoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef decode(cls, data: bytes) -&gt; bytes:\n    \"\"\"Decode the data using the encoder.\n\n    Args:\n        data: The data to decode.\n\n    Returns:\n        The decoded data.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/types/#pydantic.types.EncoderProtocol.encode","title":"encode  <code>classmethod</code>","text":"<pre><code>encode(value: bytes) -&gt; bytes\n</code></pre> <p>Encode the data using the encoder.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>bytes</code> <p>The data to encode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef encode(cls, value: bytes) -&gt; bytes:\n    \"\"\"Encode the data using the encoder.\n\n    Args:\n        value: The data to encode.\n\n    Returns:\n        The encoded data.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/types/#pydantic.types.EncoderProtocol.get_json_format","title":"get_json_format  <code>classmethod</code>","text":"<pre><code>get_json_format() -&gt; str\n</code></pre> <p>Get the JSON format for the encoded data.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The JSON format for the encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef get_json_format(cls) -&gt; str:\n    \"\"\"Get the JSON format for the encoded data.\n\n    Returns:\n        The JSON format for the encoded data.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64Encoder","title":"Base64Encoder","text":"<p>               Bases: <code>EncoderProtocol</code></p> <p>Standard (non-URL-safe) Base64 encoder.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class Base64Encoder(EncoderProtocol):\n    \"\"\"Standard (non-URL-safe) Base64 encoder.\"\"\"\n\n    @classmethod\n    def decode(cls, data: bytes) -&gt; bytes:\n        \"\"\"Decode the data from base64 encoded bytes to original bytes data.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        try:\n            return base64.b64decode(data)\n        except ValueError as e:\n            raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})\n\n    @classmethod\n    def encode(cls, value: bytes) -&gt; bytes:\n        \"\"\"Encode the data from bytes to a base64 encoded bytes.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return base64.b64encode(value)\n\n    @classmethod\n    def get_json_format(cls) -&gt; Literal['base64']:\n        \"\"\"Get the JSON format for the encoded data.\n\n        Returns:\n            The JSON format for the encoded data.\n        \"\"\"\n        return 'base64'\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64Encoder.decode","title":"decode  <code>classmethod</code>","text":"<pre><code>decode(data: bytes) -&gt; bytes\n</code></pre> <p>Decode the data from base64 encoded bytes to original bytes data.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>bytes</code> <p>The data to decode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The decoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef decode(cls, data: bytes) -&gt; bytes:\n    \"\"\"Decode the data from base64 encoded bytes to original bytes data.\n\n    Args:\n        data: The data to decode.\n\n    Returns:\n        The decoded data.\n    \"\"\"\n    try:\n        return base64.b64decode(data)\n    except ValueError as e:\n        raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64Encoder.encode","title":"encode  <code>classmethod</code>","text":"<pre><code>encode(value: bytes) -&gt; bytes\n</code></pre> <p>Encode the data from bytes to a base64 encoded bytes.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>bytes</code> <p>The data to encode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef encode(cls, value: bytes) -&gt; bytes:\n    \"\"\"Encode the data from bytes to a base64 encoded bytes.\n\n    Args:\n        value: The data to encode.\n\n    Returns:\n        The encoded data.\n    \"\"\"\n    return base64.b64encode(value)\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64Encoder.get_json_format","title":"get_json_format  <code>classmethod</code>","text":"<pre><code>get_json_format() -&gt; Literal['base64']\n</code></pre> <p>Get the JSON format for the encoded data.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Literal['base64']</code> <p>The JSON format for the encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef get_json_format(cls) -&gt; Literal['base64']:\n    \"\"\"Get the JSON format for the encoded data.\n\n    Returns:\n        The JSON format for the encoded data.\n    \"\"\"\n    return 'base64'\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64UrlEncoder","title":"Base64UrlEncoder","text":"<p>               Bases: <code>EncoderProtocol</code></p> <p>URL-safe Base64 encoder.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>class Base64UrlEncoder(EncoderProtocol):\n    \"\"\"URL-safe Base64 encoder.\"\"\"\n\n    @classmethod\n    def decode(cls, data: bytes) -&gt; bytes:\n        \"\"\"Decode the data from base64 encoded bytes to original bytes data.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        try:\n            return base64.urlsafe_b64decode(data)\n        except ValueError as e:\n            raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})\n\n    @classmethod\n    def encode(cls, value: bytes) -&gt; bytes:\n        \"\"\"Encode the data from bytes to a base64 encoded bytes.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return base64.urlsafe_b64encode(value)\n\n    @classmethod\n    def get_json_format(cls) -&gt; Literal['base64url']:\n        \"\"\"Get the JSON format for the encoded data.\n\n        Returns:\n            The JSON format for the encoded data.\n        \"\"\"\n        return 'base64url'\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64UrlEncoder.decode","title":"decode  <code>classmethod</code>","text":"<pre><code>decode(data: bytes) -&gt; bytes\n</code></pre> <p>Decode the data from base64 encoded bytes to original bytes data.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>bytes</code> <p>The data to decode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The decoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef decode(cls, data: bytes) -&gt; bytes:\n    \"\"\"Decode the data from base64 encoded bytes to original bytes data.\n\n    Args:\n        data: The data to decode.\n\n    Returns:\n        The decoded data.\n    \"\"\"\n    try:\n        return base64.urlsafe_b64decode(data)\n    except ValueError as e:\n        raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64UrlEncoder.encode","title":"encode  <code>classmethod</code>","text":"<pre><code>encode(value: bytes) -&gt; bytes\n</code></pre> <p>Encode the data from bytes to a base64 encoded bytes.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>bytes</code> <p>The data to encode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef encode(cls, value: bytes) -&gt; bytes:\n    \"\"\"Encode the data from bytes to a base64 encoded bytes.\n\n    Args:\n        value: The data to encode.\n\n    Returns:\n        The encoded data.\n    \"\"\"\n    return base64.urlsafe_b64encode(value)\n</code></pre>"},{"location":"api/types/#pydantic.types.Base64UrlEncoder.get_json_format","title":"get_json_format  <code>classmethod</code>","text":"<pre><code>get_json_format() -&gt; Literal['base64url']\n</code></pre> <p>Get the JSON format for the encoded data.</p> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>Literal['base64url']</code> <p>The JSON format for the encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@classmethod\ndef get_json_format(cls) -&gt; Literal['base64url']:\n    \"\"\"Get the JSON format for the encoded data.\n\n    Returns:\n        The JSON format for the encoded data.\n    \"\"\"\n    return 'base64url'\n</code></pre>"},{"location":"api/types/#pydantic.types.EncodedBytes","title":"EncodedBytes  <code>dataclass</code>","text":"<p>A bytes type that is encoded and decoded using the specified encoder.</p> <p><code>EncodedBytes</code> needs an encoder that implements <code>EncoderProtocol</code> to operate.</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -&gt; bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -&gt; bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -&gt; str:\n        return 'my-encoder'\n\nMyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_bytes: MyEncodedBytes\n\n# Initialize the model with encoded data\nm = Model(my_encoded_bytes=b'**encoded**: some bytes')\n\n# Access decoded value\nprint(m.my_encoded_bytes)\n#&gt; b'some bytes'\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#&gt; {'my_encoded_bytes': b'**encoded**: some bytes'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_bytes=b'**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_bytes\n      Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]\n    '''\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass EncodedBytes:\n    \"\"\"A bytes type that is encoded and decoded using the specified encoder.\n\n    `EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.\n\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError\n\n    class MyEncoder(EncoderProtocol):\n        @classmethod\n        def decode(cls, data: bytes) -&gt; bytes:\n            if data == b'**undecodable**':\n                raise ValueError('Cannot decode data')\n            return data[13:]\n\n        @classmethod\n        def encode(cls, value: bytes) -&gt; bytes:\n            return b'**encoded**: ' + value\n\n        @classmethod\n        def get_json_format(cls) -&gt; str:\n            return 'my-encoder'\n\n    MyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]\n\n    class Model(BaseModel):\n        my_encoded_bytes: MyEncodedBytes\n\n    # Initialize the model with encoded data\n    m = Model(my_encoded_bytes=b'**encoded**: some bytes')\n\n    # Access decoded value\n    print(m.my_encoded_bytes)\n    #&gt; b'some bytes'\n\n    # Serialize into the encoded form\n    print(m.model_dump())\n    #&gt; {'my_encoded_bytes': b'**encoded**: some bytes'}\n\n    # Validate encoded data\n    try:\n        Model(my_encoded_bytes=b'**undecodable**')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        my_encoded_bytes\n          Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]\n        '''\n    ```\n    \"\"\"\n\n    encoder: type[EncoderProtocol]\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        field_schema = handler(core_schema)\n        field_schema.update(type='string', format=self.encoder.get_json_format())\n        return field_schema\n\n    def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        schema = handler(source)\n        _check_annotated_type(schema['type'], 'bytes', self.__class__.__name__)\n        return core_schema.with_info_after_validator_function(\n            function=self.decode,\n            schema=schema,\n            serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode),\n        )\n\n    def decode(self, data: bytes, _: core_schema.ValidationInfo) -&gt; bytes:\n        \"\"\"Decode the data using the specified encoder.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        return self.encoder.decode(data)\n\n    def encode(self, value: bytes) -&gt; bytes:\n        \"\"\"Encode the data using the specified encoder.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return self.encoder.encode(value)\n\n    def __hash__(self) -&gt; int:\n        return hash(self.encoder)\n</code></pre>"},{"location":"api/types/#pydantic.types.EncodedBytes.decode","title":"decode","text":"<pre><code>decode(data: bytes, _: ValidationInfo) -&gt; bytes\n</code></pre> <p>Decode the data using the specified encoder.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>bytes</code> <p>The data to decode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The decoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def decode(self, data: bytes, _: core_schema.ValidationInfo) -&gt; bytes:\n    \"\"\"Decode the data using the specified encoder.\n\n    Args:\n        data: The data to decode.\n\n    Returns:\n        The decoded data.\n    \"\"\"\n    return self.encoder.decode(data)\n</code></pre>"},{"location":"api/types/#pydantic.types.EncodedBytes.encode","title":"encode","text":"<pre><code>encode(value: bytes) -&gt; bytes\n</code></pre> <p>Encode the data using the specified encoder.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>bytes</code> <p>The data to encode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>bytes</code> <p>The encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def encode(self, value: bytes) -&gt; bytes:\n    \"\"\"Encode the data using the specified encoder.\n\n    Args:\n        value: The data to encode.\n\n    Returns:\n        The encoded data.\n    \"\"\"\n    return self.encoder.encode(value)\n</code></pre>"},{"location":"api/types/#pydantic.types.EncodedStr","title":"EncodedStr  <code>dataclass</code>","text":"<p>A str type that is encoded and decoded using the specified encoder.</p> <p><code>EncodedStr</code> needs an encoder that implements <code>EncoderProtocol</code> to operate.</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError\n\nclass MyEncoder(EncoderProtocol):\n    @classmethod\n    def decode(cls, data: bytes) -&gt; bytes:\n        if data == b'**undecodable**':\n            raise ValueError('Cannot decode data')\n        return data[13:]\n\n    @classmethod\n    def encode(cls, value: bytes) -&gt; bytes:\n        return b'**encoded**: ' + value\n\n    @classmethod\n    def get_json_format(cls) -&gt; str:\n        return 'my-encoder'\n\nMyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]\n\nclass Model(BaseModel):\n    my_encoded_str: MyEncodedStr\n\n# Initialize the model with encoded data\nm = Model(my_encoded_str='**encoded**: some str')\n\n# Access decoded value\nprint(m.my_encoded_str)\n#&gt; some str\n\n# Serialize into the encoded form\nprint(m.model_dump())\n#&gt; {'my_encoded_str': '**encoded**: some str'}\n\n# Validate encoded data\ntry:\n    Model(my_encoded_str='**undecodable**')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    my_encoded_str\n      Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]\n    '''\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass EncodedStr:\n    \"\"\"A str type that is encoded and decoded using the specified encoder.\n\n    `EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.\n\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError\n\n    class MyEncoder(EncoderProtocol):\n        @classmethod\n        def decode(cls, data: bytes) -&gt; bytes:\n            if data == b'**undecodable**':\n                raise ValueError('Cannot decode data')\n            return data[13:]\n\n        @classmethod\n        def encode(cls, value: bytes) -&gt; bytes:\n            return b'**encoded**: ' + value\n\n        @classmethod\n        def get_json_format(cls) -&gt; str:\n            return 'my-encoder'\n\n    MyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]\n\n    class Model(BaseModel):\n        my_encoded_str: MyEncodedStr\n\n    # Initialize the model with encoded data\n    m = Model(my_encoded_str='**encoded**: some str')\n\n    # Access decoded value\n    print(m.my_encoded_str)\n    #&gt; some str\n\n    # Serialize into the encoded form\n    print(m.model_dump())\n    #&gt; {'my_encoded_str': '**encoded**: some str'}\n\n    # Validate encoded data\n    try:\n        Model(my_encoded_str='**undecodable**')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        my_encoded_str\n          Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]\n        '''\n    ```\n    \"\"\"\n\n    encoder: type[EncoderProtocol]\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        field_schema = handler(core_schema)\n        field_schema.update(type='string', format=self.encoder.get_json_format())\n        return field_schema\n\n    def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -&gt; core_schema.CoreSchema:\n        schema = handler(source)\n        _check_annotated_type(schema['type'], 'str', self.__class__.__name__)\n        return core_schema.with_info_after_validator_function(\n            function=self.decode_str,\n            schema=schema,\n            serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode_str),\n        )\n\n    def decode_str(self, data: str, _: core_schema.ValidationInfo) -&gt; str:\n        \"\"\"Decode the data using the specified encoder.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        return self.encoder.decode(data.encode()).decode()\n\n    def encode_str(self, value: str) -&gt; str:\n        \"\"\"Encode the data using the specified encoder.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return self.encoder.encode(value.encode()).decode()  # noqa: UP008\n\n    def __hash__(self) -&gt; int:\n        return hash(self.encoder)\n</code></pre>"},{"location":"api/types/#pydantic.types.EncodedStr.decode_str","title":"decode_str","text":"<pre><code>decode_str(data: str, _: ValidationInfo) -&gt; str\n</code></pre> <p>Decode the data using the specified encoder.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>data</code> <code>str</code> <p>The data to decode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The decoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def decode_str(self, data: str, _: core_schema.ValidationInfo) -&gt; str:\n    \"\"\"Decode the data using the specified encoder.\n\n    Args:\n        data: The data to decode.\n\n    Returns:\n        The decoded data.\n    \"\"\"\n    return self.encoder.decode(data.encode()).decode()\n</code></pre>"},{"location":"api/types/#pydantic.types.EncodedStr.encode_str","title":"encode_str","text":"<pre><code>encode_str(value: str) -&gt; str\n</code></pre> <p>Encode the data using the specified encoder.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>value</code> <code>str</code> <p>The data to encode.</p> \u5fc5\u9700 <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>str</code> <p>The encoded data.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def encode_str(self, value: str) -&gt; str:\n    \"\"\"Encode the data using the specified encoder.\n\n    Args:\n        value: The data to encode.\n\n    Returns:\n        The encoded data.\n    \"\"\"\n    return self.encoder.encode(value.encode()).decode()  # noqa: UP008\n</code></pre>"},{"location":"api/types/#pydantic.types.GetPydanticSchema","title":"GetPydanticSchema  <code>dataclass</code>","text":"<p>Usage Documentation</p> <p>Using <code>GetPydanticSchema</code> to Reduce Boilerplate</p> <p>A convenience class for creating an annotation that provides pydantic custom type hooks.</p> <p>This class is intended to eliminate the need to create a custom \"marker\" which defines the  <code>__get_pydantic_core_schema__</code> and <code>__get_pydantic_json_schema__</code> custom hook methods.</p> <p>For example, to have a field treated by type checkers as <code>int</code>, but by pydantic as <code>Any</code>, you can do: <pre><code>from typing import Annotated, Any\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\nHandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))\n\nclass Model(BaseModel):\n    x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`\n\nprint(repr(Model(x='abc').x))\n#&gt; 'abc'\n</code></pre></p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass GetPydanticSchema:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Using `GetPydanticSchema` to Reduce Boilerplate](../concepts/types.md#using-getpydanticschema-to-reduce-boilerplate)\n\n    A convenience class for creating an annotation that provides pydantic custom type hooks.\n\n    This class is intended to eliminate the need to create a custom \"marker\" which defines the\n     `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.\n\n    For example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:\n    ```python\n    from typing import Annotated, Any\n\n    from pydantic import BaseModel, GetPydanticSchema\n\n    HandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))\n\n    class Model(BaseModel):\n        x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`\n\n    print(repr(Model(x='abc').x))\n    #&gt; 'abc'\n    ```\n    \"\"\"\n\n    get_pydantic_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema] | None = None\n    get_pydantic_json_schema: Callable[[Any, GetJsonSchemaHandler], JsonSchemaValue] | None = None\n\n    # Note: we may want to consider adding a convenience staticmethod `def for_type(type_: Any) -&gt; GetPydanticSchema:`\n    #   which returns `GetPydanticSchema(lambda _s, h: h(type_))`\n\n    if not TYPE_CHECKING:\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n\n        def __getattr__(self, item: str) -&gt; Any:\n            \"\"\"Use this rather than defining `__get_pydantic_core_schema__` etc. to reduce the number of nested calls.\"\"\"\n            if item == '__get_pydantic_core_schema__' and self.get_pydantic_core_schema:\n                return self.get_pydantic_core_schema\n            elif item == '__get_pydantic_json_schema__' and self.get_pydantic_json_schema:\n                return self.get_pydantic_json_schema\n            else:\n                return object.__getattribute__(self, item)\n\n    __hash__ = object.__hash__\n</code></pre>"},{"location":"api/types/#pydantic.types.Tag","title":"Tag  <code>dataclass</code>","text":"<p>Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.</p> <p>Also provides a way to label a union case in error messages.</p> <p>When using a callable <code>Discriminator</code>, attach a <code>Tag</code> to each case in the <code>Union</code> to specify the tag that should be used to identify that case. For example, in the below example, the <code>Tag</code> is used to specify that if <code>get_discriminator_value</code> returns <code>'apple'</code>, the input should be validated as an <code>ApplePie</code>, and if it returns <code>'pumpkin'</code>, the input should be validated as a <code>PumpkinPie</code>.</p> <p>The primary role of the <code>Tag</code> here is to map the return value from the callable <code>Discriminator</code> function to the appropriate member of the <code>Union</code> in question.</p> <pre><code>from typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -&gt; str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n</code></pre> <p>Note</p> <p>You must specify a <code>Tag</code> for every case in a <code>Tag</code> that is associated with a callable <code>Discriminator</code>. Failing to do so will result in a <code>PydanticUserError</code> with code <code>callable-discriminator-no-tag</code>.</p> <p>See the Discriminated Unions concepts docs for more details on how to use <code>Tag</code>s.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\nclass Tag:\n    \"\"\"Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.\n\n    Also provides a way to label a union case in error messages.\n\n    When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify that case. For example, in the below example, the `Tag` is used to specify that\n    if `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it\n    returns `'pumpkin'`, the input should be validated as a `PumpkinPie`.\n\n    The primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to\n    the appropriate member of the `Union` in question.\n\n    ```python\n    from typing import Annotated, Any, Literal, Union\n\n    from pydantic import BaseModel, Discriminator, Tag\n\n    class Pie(BaseModel):\n        time_to_cook: int\n        num_ingredients: int\n\n    class ApplePie(Pie):\n        fruit: Literal['apple'] = 'apple'\n\n    class PumpkinPie(Pie):\n        filling: Literal['pumpkin'] = 'pumpkin'\n\n    def get_discriminator_value(v: Any) -&gt; str:\n        if isinstance(v, dict):\n            return v.get('fruit', v.get('filling'))\n        return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n    class ThanksgivingDinner(BaseModel):\n        dessert: Annotated[\n            Union[\n                Annotated[ApplePie, Tag('apple')],\n                Annotated[PumpkinPie, Tag('pumpkin')],\n            ],\n            Discriminator(get_discriminator_value),\n        ]\n\n    apple_variation = ThanksgivingDinner.model_validate(\n        {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n    )\n    print(repr(apple_variation))\n    '''\n    ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n    '''\n\n    pumpkin_variation = ThanksgivingDinner.model_validate(\n        {\n            'dessert': {\n                'filling': 'pumpkin',\n                'time_to_cook': 40,\n                'num_ingredients': 6,\n            }\n        }\n    )\n    print(repr(pumpkin_variation))\n    '''\n    ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n    '''\n    ```\n\n    !!! note\n        You must specify a `Tag` for every case in a `Tag` that is associated with a\n        callable `Discriminator`. Failing to do so will result in a `PydanticUserError` with code\n        [`callable-discriminator-no-tag`](../errors/usage_errors.md#callable-discriminator-no-tag).\n\n    See the [Discriminated Unions] concepts docs for more details on how to use `Tag`s.\n\n    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    tag: str\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n        schema = handler(source_type)\n        metadata = cast('CoreMetadata', schema.setdefault('metadata', {}))\n        metadata['pydantic_internal_union_tag_key'] = self.tag\n        return schema\n</code></pre>"},{"location":"api/types/#pydantic.types.Discriminator","title":"Discriminator  <code>dataclass</code>","text":"<p>Usage Documentation</p> <p>Discriminated Unions with <code>Callable</code> <code>Discriminator</code></p> <p>Provides a way to use a custom callable as the way to extract the value of a union discriminator.</p> <p>This allows you to get validation behavior like you'd get from <code>Field(discriminator=&lt;field_name&gt;)</code>, but without needing to have a single shared field across all the union choices. This also makes it possible to handle unions of models and primitive types with discriminated-union-style validation errors. Finally, this allows you to use a custom callable as the way to identify which member of a union a value belongs to, while still seeing all the performance benefits of a discriminated union.</p> <p>Consider this example, which is much more performant with the use of <code>Discriminator</code> and thus a <code>TaggedUnion</code> than it would be as a normal <code>Union</code>.</p> <pre><code>from typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\ndef get_discriminator_value(v: Any) -&gt; str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n'''\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n'''\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n'''\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n'''\n</code></pre> <p>See the Discriminated Unions concepts docs for more details on how to use <code>Discriminator</code>s.</p> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\nclass Discriminator:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Discriminated Unions with `Callable` `Discriminator`](../concepts/unions.md#discriminated-unions-with-callable-discriminator)\n\n    Provides a way to use a custom callable as the way to extract the value of a union discriminator.\n\n    This allows you to get validation behavior like you'd get from `Field(discriminator=&lt;field_name&gt;)`,\n    but without needing to have a single shared field across all the union choices. This also makes it\n    possible to handle unions of models and primitive types with discriminated-union-style validation errors.\n    Finally, this allows you to use a custom callable as the way to identify which member of a union a value\n    belongs to, while still seeing all the performance benefits of a discriminated union.\n\n    Consider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\n    than it would be as a normal `Union`.\n\n    ```python\n    from typing import Annotated, Any, Literal, Union\n\n    from pydantic import BaseModel, Discriminator, Tag\n\n    class Pie(BaseModel):\n        time_to_cook: int\n        num_ingredients: int\n\n    class ApplePie(Pie):\n        fruit: Literal['apple'] = 'apple'\n\n    class PumpkinPie(Pie):\n        filling: Literal['pumpkin'] = 'pumpkin'\n\n    def get_discriminator_value(v: Any) -&gt; str:\n        if isinstance(v, dict):\n            return v.get('fruit', v.get('filling'))\n        return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n    class ThanksgivingDinner(BaseModel):\n        dessert: Annotated[\n            Union[\n                Annotated[ApplePie, Tag('apple')],\n                Annotated[PumpkinPie, Tag('pumpkin')],\n            ],\n            Discriminator(get_discriminator_value),\n        ]\n\n    apple_variation = ThanksgivingDinner.model_validate(\n        {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n    )\n    print(repr(apple_variation))\n    '''\n    ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n    '''\n\n    pumpkin_variation = ThanksgivingDinner.model_validate(\n        {\n            'dessert': {\n                'filling': 'pumpkin',\n                'time_to_cook': 40,\n                'num_ingredients': 6,\n            }\n        }\n    )\n    print(repr(pumpkin_variation))\n    '''\n    ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n    '''\n    ```\n\n    See the [Discriminated Unions] concepts docs for more details on how to use `Discriminator`s.\n\n    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    discriminator: str | Callable[[Any], Hashable]\n    \"\"\"The callable or field name for discriminating the type in a tagged union.\n\n    A `Callable` discriminator must extract the value of the discriminator from the input.\n    A `str` discriminator must be the name of a field to discriminate against.\n    \"\"\"\n    custom_error_type: str | None = None\n    \"\"\"Type to use in [custom errors](../errors/errors.md) replacing the standard discriminated union\n    validation errors.\n    \"\"\"\n    custom_error_message: str | None = None\n    \"\"\"Message to use in custom errors.\"\"\"\n    custom_error_context: dict[str, int | str | float] | None = None\n    \"\"\"Context to use in custom errors.\"\"\"\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -&gt; CoreSchema:\n        if not is_union_origin(get_origin(source_type)):\n            raise TypeError(f'{type(self).__name__} must be used with a Union type, not {source_type}')\n\n        if isinstance(self.discriminator, str):\n            from pydantic import Field\n\n            return handler(Annotated[source_type, Field(discriminator=self.discriminator)])\n        else:\n            original_schema = handler(source_type)\n            return self._convert_schema(original_schema, handler)\n\n    def _convert_schema(\n        self, original_schema: core_schema.CoreSchema, handler: GetCoreSchemaHandler | None = None\n    ) -&gt; core_schema.TaggedUnionSchema:\n        if original_schema['type'] != 'union':\n            # This likely indicates that the schema was a single-item union that was simplified.\n            # In this case, we do the same thing we do in\n            # `pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root`, namely,\n            # package the generated schema back into a single-item union.\n            original_schema = core_schema.union_schema([original_schema])\n\n        tagged_union_choices = {}\n        for choice in original_schema['choices']:\n            tag = None\n            if isinstance(choice, tuple):\n                choice, tag = choice\n            metadata = cast('CoreMetadata | None', choice.get('metadata'))\n            if metadata is not None:\n                tag = metadata.get('pydantic_internal_union_tag_key') or tag\n            if tag is None:\n                # `handler` is None when this method is called from `apply_discriminator()` (deferred discriminators)\n                if handler is not None and choice['type'] == 'definition-ref':\n                    # If choice was built from a PEP 695 type alias, try to resolve the def:\n                    try:\n                        choice = handler.resolve_ref_schema(choice)\n                    except LookupError:\n                        pass\n                    else:\n                        metadata = cast('CoreMetadata | None', choice.get('metadata'))\n                        if metadata is not None:\n                            tag = metadata.get('pydantic_internal_union_tag_key')\n\n                if tag is None:\n                    raise PydanticUserError(\n                        f'`Tag` not provided for choice {choice} used with `Discriminator`',\n                        code='callable-discriminator-no-tag',\n                    )\n            tagged_union_choices[tag] = choice\n\n        # Have to do these verbose checks to ensure falsy values ('' and {}) don't get ignored\n        custom_error_type = self.custom_error_type\n        if custom_error_type is None:\n            custom_error_type = original_schema.get('custom_error_type')\n\n        custom_error_message = self.custom_error_message\n        if custom_error_message is None:\n            custom_error_message = original_schema.get('custom_error_message')\n\n        custom_error_context = self.custom_error_context\n        if custom_error_context is None:\n            custom_error_context = original_schema.get('custom_error_context')\n\n        custom_error_type = original_schema.get('custom_error_type') if custom_error_type is None else custom_error_type\n        return core_schema.tagged_union_schema(\n            tagged_union_choices,\n            self.discriminator,\n            custom_error_type=custom_error_type,\n            custom_error_message=custom_error_message,\n            custom_error_context=custom_error_context,\n            strict=original_schema.get('strict'),\n            ref=original_schema.get('ref'),\n            metadata=original_schema.get('metadata'),\n            serialization=original_schema.get('serialization'),\n        )\n</code></pre>"},{"location":"api/types/#pydantic.types.Discriminator.discriminator","title":"discriminator  <code>instance-attribute</code>","text":"<pre><code>discriminator: str | Callable[[Any], Hashable]\n</code></pre> <p>The callable or field name for discriminating the type in a tagged union.</p> <p>A <code>Callable</code> discriminator must extract the value of the discriminator from the input. A <code>str</code> discriminator must be the name of a field to discriminate against.</p>"},{"location":"api/types/#pydantic.types.Discriminator.custom_error_type","title":"custom_error_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_error_type: str | None = None\n</code></pre> <p>Type to use in custom errors replacing the standard discriminated union validation errors.</p>"},{"location":"api/types/#pydantic.types.Discriminator.custom_error_message","title":"custom_error_message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_error_message: str | None = None\n</code></pre> <p>Message to use in custom errors.</p>"},{"location":"api/types/#pydantic.types.Discriminator.custom_error_context","title":"custom_error_context  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>custom_error_context: dict[str, int | str | float] | None = None\n</code></pre> <p>Context to use in custom errors.</p>"},{"location":"api/types/#pydantic.types.FailFast","title":"FailFast  <code>dataclass</code>","text":"<p>               Bases: <code>PydanticMetadata</code>, <code>BaseMetadata</code></p> <p>A <code>FailFast</code> annotation can be used to specify that validation should stop at the first error.</p> <p>This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.</p> <p>You might want to enable this setting if you want to validate your data faster (basically, if you use this, validation will be more performant with the caveat that you get less information).</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, FailFast, ValidationError\n\nclass Model(BaseModel):\n    x: Annotated[list[int], FailFast()]\n\n# This will raise a single error for the first invalid value and stop validation\ntry:\n    obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    x.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    '''\n</code></pre> Source code in <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>@_dataclasses.dataclass\nclass FailFast(_fields.PydanticMetadata, BaseMetadata):\n    \"\"\"A `FailFast` annotation can be used to specify that validation should stop at the first error.\n\n    This can be useful when you want to validate a large amount of data and you only need to know if it's valid or not.\n\n    You might want to enable this setting if you want to validate your data faster (basically, if you use this,\n    validation will be more performant with the caveat that you get less information).\n\n    ```python\n    from typing import Annotated\n\n    from pydantic import BaseModel, FailFast, ValidationError\n\n    class Model(BaseModel):\n        x: Annotated[list[int], FailFast()]\n\n    # This will raise a single error for the first invalid value and stop validation\n    try:\n        obj = Model(x=[1, 2, 'a', 4, 5, 'b', 7, 8, 9, 'c'])\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        x.2\n          Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n        '''\n    ```\n    \"\"\"\n\n    fail_fast: bool = True\n</code></pre>"},{"location":"api/types/#pydantic.types.conint","title":"conint","text":"<pre><code>conint(*, strict: bool | None = None, gt: int | None = None, ge: int | None = None, lt: int | None = None, le: int | None = None, multiple_of: int | None = None) -&gt; type[int]\n</code></pre> <p>Discouraged</p> <p>This function is discouraged in favor of using <code>Annotated</code> with <code>Field</code> instead.</p> <p>This function will be deprecated in Pydantic 3.0.</p> <p>The reason is that <code>conint</code> returns a type, which doesn't play well with static analysis tools.</p>  Don't do this Do this <pre><code>from pydantic import BaseModel, conint\n\nclass Foo(BaseModel):\n    bar: conint(strict=True, gt=0)\n</code></pre> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    bar: Annotated[int, Field(strict=True, gt=0)]\n</code></pre> <p>A wrapper around <code>int</code> that allows for additional constraints.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether to validate the integer in strict mode. Defaults to <code>None</code>.</p> <code>None</code> <code>gt</code> <code>int | None</code> <p>The value must be greater than this.</p> <code>None</code> <code>ge</code> <code>int | None</code> <p>The value must be greater than or equal to this.</p> <code>None</code> <code>lt</code> <code>int | None</code> <p>The value must be less than this.</p> <code>None</code> <code>le</code> <code>int | None</code> <p>The value must be less than or equal to this.</p> <code>None</code> <code>multiple_of</code> <code>int | None</code> <p>The value must be a multiple of this.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[int]</code> <p>The wrapped integer type.</p> <pre><code>from pydantic import BaseModel, ValidationError, conint\n\nclass ConstrainedExample(BaseModel):\n    constrained_int: conint(gt=1)\n\nm = ConstrainedExample(constrained_int=2)\nprint(repr(m))\n#&gt; ConstrainedExample(constrained_int=2)\n\ntry:\n    ConstrainedExample(constrained_int=0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_int',),\n            'msg': 'Input should be greater than 1',\n            'input': 0,\n            'ctx': {'gt': 1},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n</code></pre> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def conint(\n    *,\n    strict: bool | None = None,\n    gt: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    le: int | None = None,\n    multiple_of: int | None = None,\n) -&gt; type[int]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.fields.Field] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `conint` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```python\n            from pydantic import BaseModel, conint\n\n            class Foo(BaseModel):\n                bar: conint(strict=True, gt=0)\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```python\n            from typing import Annotated\n\n            from pydantic import BaseModel, Field\n\n            class Foo(BaseModel):\n                bar: Annotated[int, Field(strict=True, gt=0)]\n            ```\n\n    A wrapper around `int` that allows for additional constraints.\n\n    Args:\n        strict: Whether to validate the integer in strict mode. Defaults to `None`.\n        gt: The value must be greater than this.\n        ge: The value must be greater than or equal to this.\n        lt: The value must be less than this.\n        le: The value must be less than or equal to this.\n        multiple_of: The value must be a multiple of this.\n\n    Returns:\n        The wrapped integer type.\n\n    ```python\n    from pydantic import BaseModel, ValidationError, conint\n\n    class ConstrainedExample(BaseModel):\n        constrained_int: conint(gt=1)\n\n    m = ConstrainedExample(constrained_int=2)\n    print(repr(m))\n    #&gt; ConstrainedExample(constrained_int=2)\n\n    try:\n        ConstrainedExample(constrained_int=0)\n    except ValidationError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('constrained_int',),\n                'msg': 'Input should be greater than 1',\n                'input': 0,\n                'ctx': {'gt': 1},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        '''\n    ```\n\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        int,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,\n    ]\n</code></pre>"},{"location":"api/types/#pydantic.types.confloat","title":"confloat","text":"<pre><code>confloat(*, strict: bool | None = None, gt: float | None = None, ge: float | None = None, lt: float | None = None, le: float | None = None, multiple_of: float | None = None, allow_inf_nan: bool | None = None) -&gt; type[float]\n</code></pre> <p>Discouraged</p> <p>This function is discouraged in favor of using <code>Annotated</code> with <code>Field</code> instead.</p> <p>This function will be deprecated in Pydantic 3.0.</p> <p>The reason is that <code>confloat</code> returns a type, which doesn't play well with static analysis tools.</p>  Don't do this Do this <pre><code>from pydantic import BaseModel, confloat\n\nclass Foo(BaseModel):\n    bar: confloat(strict=True, gt=0)\n</code></pre> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    bar: Annotated[float, Field(strict=True, gt=0)]\n</code></pre> <p>A wrapper around <code>float</code> that allows for additional constraints.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether to validate the float in strict mode.</p> <code>None</code> <code>gt</code> <code>float | None</code> <p>The value must be greater than this.</p> <code>None</code> <code>ge</code> <code>float | None</code> <p>The value must be greater than or equal to this.</p> <code>None</code> <code>lt</code> <code>float | None</code> <p>The value must be less than this.</p> <code>None</code> <code>le</code> <code>float | None</code> <p>The value must be less than or equal to this.</p> <code>None</code> <code>multiple_of</code> <code>float | None</code> <p>The value must be a multiple of this.</p> <code>None</code> <code>allow_inf_nan</code> <code>bool | None</code> <p>Whether to allow <code>-inf</code>, <code>inf</code>, and <code>nan</code>.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[float]</code> <p>The wrapped float type.</p> <pre><code>from pydantic import BaseModel, ValidationError, confloat\n\nclass ConstrainedExample(BaseModel):\n    constrained_float: confloat(gt=1.0)\n\nm = ConstrainedExample(constrained_float=1.1)\nprint(repr(m))\n#&gt; ConstrainedExample(constrained_float=1.1)\n\ntry:\n    ConstrainedExample(constrained_float=0.9)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_float',),\n            'msg': 'Input should be greater than 1',\n            'input': 0.9,\n            'ctx': {'gt': 1.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n</code></pre> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def confloat(\n    *,\n    strict: bool | None = None,\n    gt: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    le: float | None = None,\n    multiple_of: float | None = None,\n    allow_inf_nan: bool | None = None,\n) -&gt; type[float]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.fields.Field] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `confloat` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```python\n            from pydantic import BaseModel, confloat\n\n            class Foo(BaseModel):\n                bar: confloat(strict=True, gt=0)\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```python\n            from typing import Annotated\n\n            from pydantic import BaseModel, Field\n\n            class Foo(BaseModel):\n                bar: Annotated[float, Field(strict=True, gt=0)]\n            ```\n\n    A wrapper around `float` that allows for additional constraints.\n\n    Args:\n        strict: Whether to validate the float in strict mode.\n        gt: The value must be greater than this.\n        ge: The value must be greater than or equal to this.\n        lt: The value must be less than this.\n        le: The value must be less than or equal to this.\n        multiple_of: The value must be a multiple of this.\n        allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.\n\n    Returns:\n        The wrapped float type.\n\n    ```python\n    from pydantic import BaseModel, ValidationError, confloat\n\n    class ConstrainedExample(BaseModel):\n        constrained_float: confloat(gt=1.0)\n\n    m = ConstrainedExample(constrained_float=1.1)\n    print(repr(m))\n    #&gt; ConstrainedExample(constrained_float=1.1)\n\n    try:\n        ConstrainedExample(constrained_float=0.9)\n    except ValidationError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('constrained_float',),\n                'msg': 'Input should be greater than 1',\n                'input': 0.9,\n                'ctx': {'gt': 1.0},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        '''\n    ```\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        float,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,\n        AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,\n    ]\n</code></pre>"},{"location":"api/types/#pydantic.types.conbytes","title":"conbytes","text":"<pre><code>conbytes(*, min_length: int | None = None, max_length: int | None = None, strict: bool | None = None) -&gt; type[bytes]\n</code></pre> <p>A wrapper around <code>bytes</code> that allows for additional constraints.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>min_length</code> <code>int | None</code> <p>The minimum length of the bytes.</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The maximum length of the bytes.</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether to validate the bytes in strict mode.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[bytes]</code> <p>The wrapped bytes type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def conbytes(\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None,\n) -&gt; type[bytes]:\n    \"\"\"A wrapper around `bytes` that allows for additional constraints.\n\n    Args:\n        min_length: The minimum length of the bytes.\n        max_length: The maximum length of the bytes.\n        strict: Whether to validate the bytes in strict mode.\n\n    Returns:\n        The wrapped bytes type.\n    \"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        bytes,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Len(min_length or 0, max_length),\n    ]\n</code></pre>"},{"location":"api/types/#pydantic.types.constr","title":"constr","text":"<pre><code>constr(*, strip_whitespace: bool | None = None, to_upper: bool | None = None, to_lower: bool | None = None, strict: bool | None = None, min_length: int | None = None, max_length: int | None = None, pattern: str | Pattern[str] | None = None) -&gt; type[str]\n</code></pre> <p>Discouraged</p> <p>This function is discouraged in favor of using <code>Annotated</code> with <code>StringConstraints</code> instead.</p> <p>This function will be deprecated in Pydantic 3.0.</p> <p>The reason is that <code>constr</code> returns a type, which doesn't play well with static analysis tools.</p>  Don't do this Do this <pre><code>from pydantic import BaseModel, constr\n\nclass Foo(BaseModel):\n    bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')\n</code></pre> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, StringConstraints\n\nclass Foo(BaseModel):\n    bar: Annotated[\n        str,\n        StringConstraints(\n            strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$'\n        ),\n    ]\n</code></pre> <p>A wrapper around <code>str</code> that allows for additional constraints.</p> <pre><code>from pydantic import BaseModel, constr\n\nclass Foo(BaseModel):\n    bar: constr(strip_whitespace=True, to_upper=True)\n\nfoo = Foo(bar='  hello  ')\nprint(foo)\n#&gt; bar='HELLO'\n</code></pre> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strip_whitespace</code> <code>bool | None</code> <p>Whether to remove leading and trailing whitespace.</p> <code>None</code> <code>to_upper</code> <code>bool | None</code> <p>Whether to turn all characters to uppercase.</p> <code>None</code> <code>to_lower</code> <code>bool | None</code> <p>Whether to turn all characters to lowercase.</p> <code>None</code> <code>strict</code> <code>bool | None</code> <p>Whether to validate the string in strict mode.</p> <code>None</code> <code>min_length</code> <code>int | None</code> <p>The minimum length of the string.</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The maximum length of the string.</p> <code>None</code> <code>pattern</code> <code>str | Pattern[str] | None</code> <p>A regex pattern to validate the string against.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[str]</code> <p>The wrapped string type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def constr(\n    *,\n    strip_whitespace: bool | None = None,\n    to_upper: bool | None = None,\n    to_lower: bool | None = None,\n    strict: bool | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    pattern: str | Pattern[str] | None = None,\n) -&gt; type[str]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`StringConstraints`][pydantic.types.StringConstraints] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `constr` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```python\n            from pydantic import BaseModel, constr\n\n            class Foo(BaseModel):\n                bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```python\n            from typing import Annotated\n\n            from pydantic import BaseModel, StringConstraints\n\n            class Foo(BaseModel):\n                bar: Annotated[\n                    str,\n                    StringConstraints(\n                        strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$'\n                    ),\n                ]\n            ```\n\n    A wrapper around `str` that allows for additional constraints.\n\n    ```python\n    from pydantic import BaseModel, constr\n\n    class Foo(BaseModel):\n        bar: constr(strip_whitespace=True, to_upper=True)\n\n    foo = Foo(bar='  hello  ')\n    print(foo)\n    #&gt; bar='HELLO'\n    ```\n\n    Args:\n        strip_whitespace: Whether to remove leading and trailing whitespace.\n        to_upper: Whether to turn all characters to uppercase.\n        to_lower: Whether to turn all characters to lowercase.\n        strict: Whether to validate the string in strict mode.\n        min_length: The minimum length of the string.\n        max_length: The maximum length of the string.\n        pattern: A regex pattern to validate the string against.\n\n    Returns:\n        The wrapped string type.\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        str,\n        StringConstraints(\n            strip_whitespace=strip_whitespace,\n            to_upper=to_upper,\n            to_lower=to_lower,\n            strict=strict,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n        ),\n    ]\n</code></pre>"},{"location":"api/types/#pydantic.types.conset","title":"conset","text":"<pre><code>conset(item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None) -&gt; type[set[HashableItemType]]\n</code></pre> <p>A wrapper around <code>typing.Set</code> that allows for additional constraints.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>item_type</code> <code>type[HashableItemType]</code> <p>The type of the items in the set.</p> \u5fc5\u9700 <code>min_length</code> <code>int | None</code> <p>The minimum length of the set.</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The maximum length of the set.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[set[HashableItemType]]</code> <p>The wrapped set type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def conset(\n    item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None\n) -&gt; type[set[HashableItemType]]:\n    \"\"\"A wrapper around `typing.Set` that allows for additional constraints.\n\n    Args:\n        item_type: The type of the items in the set.\n        min_length: The minimum length of the set.\n        max_length: The maximum length of the set.\n\n    Returns:\n        The wrapped set type.\n    \"\"\"\n    return Annotated[set[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/types/#pydantic.types.confrozenset","title":"confrozenset","text":"<pre><code>confrozenset(item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None) -&gt; type[frozenset[HashableItemType]]\n</code></pre> <p>A wrapper around <code>typing.FrozenSet</code> that allows for additional constraints.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>item_type</code> <code>type[HashableItemType]</code> <p>The type of the items in the frozenset.</p> \u5fc5\u9700 <code>min_length</code> <code>int | None</code> <p>The minimum length of the frozenset.</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The maximum length of the frozenset.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[frozenset[HashableItemType]]</code> <p>The wrapped frozenset type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def confrozenset(\n    item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None\n) -&gt; type[frozenset[HashableItemType]]:\n    \"\"\"A wrapper around `typing.FrozenSet` that allows for additional constraints.\n\n    Args:\n        item_type: The type of the items in the frozenset.\n        min_length: The minimum length of the frozenset.\n        max_length: The maximum length of the frozenset.\n\n    Returns:\n        The wrapped frozenset type.\n    \"\"\"\n    return Annotated[frozenset[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/types/#pydantic.types.conlist","title":"conlist","text":"<pre><code>conlist(item_type: type[AnyItemType], *, min_length: int | None = None, max_length: int | None = None, unique_items: bool | None = None) -&gt; type[list[AnyItemType]]\n</code></pre> <p>A wrapper around <code>list</code> that adds validation.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>item_type</code> <code>type[AnyItemType]</code> <p>The type of the items in the list.</p> \u5fc5\u9700 <code>min_length</code> <code>int | None</code> <p>The minimum length of the list. Defaults to None.</p> <code>None</code> <code>max_length</code> <code>int | None</code> <p>The maximum length of the list. Defaults to None.</p> <code>None</code> <code>unique_items</code> <code>bool | None</code> <p>Whether the items in the list must be unique. Defaults to None.</p> <p>Warning</p> <p>The <code>unique_items</code> parameter is deprecated, use <code>Set</code> instead. See this issue for more details.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[list[AnyItemType]]</code> <p>The wrapped list type.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def conlist(\n    item_type: type[AnyItemType],\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    unique_items: bool | None = None,\n) -&gt; type[list[AnyItemType]]:\n    \"\"\"A wrapper around [`list`][] that adds validation.\n\n    Args:\n        item_type: The type of the items in the list.\n        min_length: The minimum length of the list. Defaults to None.\n        max_length: The maximum length of the list. Defaults to None.\n        unique_items: Whether the items in the list must be unique. Defaults to None.\n            !!! warning Deprecated\n                The `unique_items` parameter is deprecated, use `Set` instead.\n                See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details.\n\n    Returns:\n        The wrapped list type.\n    \"\"\"\n    if unique_items is not None:\n        raise PydanticUserError(\n            (\n                '`unique_items` is removed, use `Set` instead'\n                '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'\n            ),\n            code='removed-kwargs',\n        )\n    return Annotated[list[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n</code></pre>"},{"location":"api/types/#pydantic.types.condecimal","title":"condecimal","text":"<pre><code>condecimal(*, strict: bool | None = None, gt: int | Decimal | None = None, ge: int | Decimal | None = None, lt: int | Decimal | None = None, le: int | Decimal | None = None, multiple_of: int | Decimal | None = None, max_digits: int | None = None, decimal_places: int | None = None, allow_inf_nan: bool | None = None) -&gt; type[Decimal]\n</code></pre> <p>Discouraged</p> <p>This function is discouraged in favor of using <code>Annotated</code> with <code>Field</code> instead.</p> <p>This function will be deprecated in Pydantic 3.0.</p> <p>The reason is that <code>condecimal</code> returns a type, which doesn't play well with static analysis tools.</p>  Don't do this Do this <pre><code>from pydantic import BaseModel, condecimal\n\nclass Foo(BaseModel):\n    bar: condecimal(strict=True, allow_inf_nan=True)\n</code></pre> <pre><code>from decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]\n</code></pre> <p>A wrapper around Decimal that adds validation.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether to validate the value in strict mode. Defaults to <code>None</code>.</p> <code>None</code> <code>gt</code> <code>int | Decimal | None</code> <p>The value must be greater than this. Defaults to <code>None</code>.</p> <code>None</code> <code>ge</code> <code>int | Decimal | None</code> <p>The value must be greater than or equal to this. Defaults to <code>None</code>.</p> <code>None</code> <code>lt</code> <code>int | Decimal | None</code> <p>The value must be less than this. Defaults to <code>None</code>.</p> <code>None</code> <code>le</code> <code>int | Decimal | None</code> <p>The value must be less than or equal to this. Defaults to <code>None</code>.</p> <code>None</code> <code>multiple_of</code> <code>int | Decimal | None</code> <p>The value must be a multiple of this. Defaults to <code>None</code>.</p> <code>None</code> <code>max_digits</code> <code>int | None</code> <p>The maximum number of digits. Defaults to <code>None</code>.</p> <code>None</code> <code>decimal_places</code> <code>int | None</code> <p>The number of decimal places. Defaults to <code>None</code>.</p> <code>None</code> <code>allow_inf_nan</code> <code>bool | None</code> <p>Whether to allow infinity and NaN. Defaults to <code>None</code>.</p> <code>None</code> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, ValidationError, condecimal\n\nclass ConstrainedExample(BaseModel):\n    constrained_decimal: condecimal(gt=Decimal('1.0'))\n\nm = ConstrainedExample(constrained_decimal=Decimal('1.1'))\nprint(repr(m))\n#&gt; ConstrainedExample(constrained_decimal=Decimal('1.1'))\n\ntry:\n    ConstrainedExample(constrained_decimal=Decimal('0.9'))\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('constrained_decimal',),\n            'msg': 'Input should be greater than 1.0',\n            'input': Decimal('0.9'),\n            'ctx': {'gt': Decimal('1.0')},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n</code></pre> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def condecimal(\n    *,\n    strict: bool | None = None,\n    gt: int | Decimal | None = None,\n    ge: int | Decimal | None = None,\n    lt: int | Decimal | None = None,\n    le: int | Decimal | None = None,\n    multiple_of: int | Decimal | None = None,\n    max_digits: int | None = None,\n    decimal_places: int | None = None,\n    allow_inf_nan: bool | None = None,\n) -&gt; type[Decimal]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.fields.Field] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```python\n            from pydantic import BaseModel, condecimal\n\n            class Foo(BaseModel):\n                bar: condecimal(strict=True, allow_inf_nan=True)\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```python\n            from decimal import Decimal\n            from typing import Annotated\n\n            from pydantic import BaseModel, Field\n\n            class Foo(BaseModel):\n                bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]\n            ```\n\n    A wrapper around Decimal that adds validation.\n\n    Args:\n        strict: Whether to validate the value in strict mode. Defaults to `None`.\n        gt: The value must be greater than this. Defaults to `None`.\n        ge: The value must be greater than or equal to this. Defaults to `None`.\n        lt: The value must be less than this. Defaults to `None`.\n        le: The value must be less than or equal to this. Defaults to `None`.\n        multiple_of: The value must be a multiple of this. Defaults to `None`.\n        max_digits: The maximum number of digits. Defaults to `None`.\n        decimal_places: The number of decimal places. Defaults to `None`.\n        allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.\n\n    ```python\n    from decimal import Decimal\n\n    from pydantic import BaseModel, ValidationError, condecimal\n\n    class ConstrainedExample(BaseModel):\n        constrained_decimal: condecimal(gt=Decimal('1.0'))\n\n    m = ConstrainedExample(constrained_decimal=Decimal('1.1'))\n    print(repr(m))\n    #&gt; ConstrainedExample(constrained_decimal=Decimal('1.1'))\n\n    try:\n        ConstrainedExample(constrained_decimal=Decimal('0.9'))\n    except ValidationError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('constrained_decimal',),\n                'msg': 'Input should be greater than 1.0',\n                'input': Decimal('0.9'),\n                'ctx': {'gt': Decimal('1.0')},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        '''\n    ```\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        Decimal,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,\n        _fields.pydantic_general_metadata(max_digits=max_digits, decimal_places=decimal_places),\n        AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,\n    ]\n</code></pre>"},{"location":"api/types/#pydantic.types.condate","title":"condate","text":"<pre><code>condate(*, strict: bool | None = None, gt: date | None = None, ge: date | None = None, lt: date | None = None, le: date | None = None) -&gt; type[date]\n</code></pre> <p>A wrapper for date that adds constraints.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>strict</code> <code>bool | None</code> <p>Whether to validate the date value in strict mode. Defaults to <code>None</code>.</p> <code>None</code> <code>gt</code> <code>date | None</code> <p>The value must be greater than this. Defaults to <code>None</code>.</p> <code>None</code> <code>ge</code> <code>date | None</code> <p>The value must be greater than or equal to this. Defaults to <code>None</code>.</p> <code>None</code> <code>lt</code> <code>date | None</code> <p>The value must be less than this. Defaults to <code>None</code>.</p> <code>None</code> <code>le</code> <code>date | None</code> <p>The value must be less than or equal to this. Defaults to <code>None</code>.</p> <code>None</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>type[date]</code> <p>A date type with the specified constraints.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/types.py</code> <pre><code>def condate(\n    *,\n    strict: bool | None = None,\n    gt: date | None = None,\n    ge: date | None = None,\n    lt: date | None = None,\n    le: date | None = None,\n) -&gt; type[date]:\n    \"\"\"A wrapper for date that adds constraints.\n\n    Args:\n        strict: Whether to validate the date value in strict mode. Defaults to `None`.\n        gt: The value must be greater than this. Defaults to `None`.\n        ge: The value must be greater than or equal to this. Defaults to `None`.\n        lt: The value must be less than this. Defaults to `None`.\n        le: The value must be less than or equal to this. Defaults to `None`.\n\n    Returns:\n        A date type with the specified constraints.\n    \"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        date,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n    ]\n</code></pre>"},{"location":"api/validate_call/","title":"Validate Call","text":"<p>Decorator for validating function calls.</p>"},{"location":"api/validate_call/#pydantic.validate_call_decorator.validate_call","title":"validate_call","text":"<pre><code>validate_call(*, config: ConfigDict | None = None, validate_return: bool = False) -&gt; Callable[[AnyCallableT], AnyCallableT]\n</code></pre><pre><code>validate_call(func: AnyCallableT) -&gt; AnyCallableT\n</code></pre> <pre><code>validate_call(func: AnyCallableT | None = None, /, *, config: ConfigDict | None = None, validate_return: bool = False) -&gt; AnyCallableT | Callable[[AnyCallableT], AnyCallableT]\n</code></pre> <p>Usage Documentation</p> <p>Validation Decorator</p> <p>Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.</p> <p>Usage may be either as a plain decorator <code>@validate_call</code> or with arguments <code>@validate_call(...)</code>.</p> <p>\u53c2\u6570\uff1a</p> \u540d\u79f0 \u7c7b\u578b \u63cf\u8ff0 \u9ed8\u8ba4 <code>func</code> <code>AnyCallableT | None</code> <p>The function to be decorated.</p> <code>None</code> <code>config</code> <code>ConfigDict | None</code> <p>The configuration dictionary.</p> <code>None</code> <code>validate_return</code> <code>bool</code> <p>Whether to validate the return value.</p> <code>False</code> <p>\u8fd4\u56de\uff1a</p> \u7c7b\u578b \u63cf\u8ff0 <code>AnyCallableT | Callable[[AnyCallableT], AnyCallableT]</code> <p>The decorated function.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/validate_call_decorator.py</code> <pre><code>def validate_call(\n    func: AnyCallableT | None = None,\n    /,\n    *,\n    config: ConfigDict | None = None,\n    validate_return: bool = False,\n) -&gt; AnyCallableT | Callable[[AnyCallableT], AnyCallableT]:\n    \"\"\"!!! abstract \"Usage Documentation\"\n        [Validation Decorator](../concepts/validation_decorator.md)\n\n    Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.\n\n    Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.\n\n    Args:\n        func: The function to be decorated.\n        config: The configuration dictionary.\n        validate_return: Whether to validate the return value.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n    parent_namespace = _typing_extra.parent_frame_namespace()\n\n    def validate(function: AnyCallableT) -&gt; AnyCallableT:\n        _check_function_type(function)\n        validate_call_wrapper = _validate_call.ValidateCallWrapper(\n            cast(_generate_schema.ValidateCallSupportedTypes, function), config, validate_return, parent_namespace\n        )\n        return _validate_call.update_wrapper_attributes(function, validate_call_wrapper.__call__)  # type: ignore\n\n    if func is not None:\n        return validate(func)\n    else:\n        return validate\n</code></pre>"},{"location":"api/version/","title":"Version Information","text":""},{"location":"api/version/#pydantic.__version__","title":"pydantic.__version__  <code>module-attribute</code>","text":"<pre><code>__version__ = VERSION\n</code></pre>"},{"location":"api/version/#pydantic.version.version_info","title":"pydantic.version.version_info","text":"<pre><code>version_info() -&gt; str\n</code></pre> <p>Return complete version information for Pydantic and its dependencies.</p> \u6e90\u4ee3\u7801\u4f4d\u4e8e\uff1a <code>.venv/lib/python3.13/site-packages/pydantic/version.py</code> <pre><code>def version_info() -&gt; str:\n    \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"\n    import importlib.metadata\n    import platform\n    from pathlib import Path\n\n    import pydantic_core._pydantic_core as pdc\n\n    from ._internal import _git as git\n\n    # get data about packages that are closely related to pydantic, use pydantic or often conflict with pydantic\n    package_names = {\n        'email-validator',\n        'fastapi',\n        'mypy',\n        'pydantic-extra-types',\n        'pydantic-settings',\n        'pyright',\n        'typing_extensions',\n    }\n    related_packages = []\n\n    for dist in importlib.metadata.distributions():\n        name = dist.metadata['Name']\n        if name in package_names:\n            related_packages.append(f'{name}-{dist.version}')\n\n    pydantic_dir = Path(__file__).parents[1].resolve()\n    most_recent_commit = (\n        git.git_revision(pydantic_dir) if git.is_git_repo(pydantic_dir) and git.have_git() else 'unknown'\n    )\n\n    info = {\n        'pydantic version': VERSION,\n        'pydantic-core version': __pydantic_core_version__,\n        'pydantic-core build': getattr(pdc, 'build_info', None) or pdc.build_profile,  # pyright: ignore[reportPrivateImportUsage]\n        'python version': sys.version,\n        'platform': platform.platform(),\n        'related packages': ' '.join(related_packages),\n        'commit': most_recent_commit,\n    }\n    return '\\n'.join('{:&gt;30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items())\n</code></pre>"},{"location":"concepts/alias/","title":"Alias","text":"<p>\u522b\u540d\u662f\u5b57\u6bb5\u7684\u66ff\u4ee3\u540d\u79f0\uff0c\u5728\u5e8f\u5217\u5316\u548c\u53cd\u5e8f\u5217\u5316\u6570\u636e\u65f6\u4f7f\u7528\u3002</p> <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u6307\u5b9a\u522b\u540d\uff1a</p> <ul> <li>\u5728 <code>Field</code> \u4e0a\u4f7f\u7528 <code>alias</code><ul> <li>\u5fc5\u987b\u662f\u4e00\u4e2a <code>str</code></li> </ul> </li> <li>\u5728 <code>Field</code> \u4e0a\u4f7f\u7528 <code>validation_alias</code><ul> <li>\u53ef\u4ee5\u662f <code>str</code>\u3001<code>AliasPath</code> \u6216 <code>AliasChoices</code> \u7684\u5b9e\u4f8b</li> </ul> </li> <li>\u5728 <code>Field</code> \u4e0a\u4f7f\u7528 <code>serialization_alias</code><ul> <li>\u5fc5\u987b\u662f\u4e00\u4e2a <code>str</code></li> </ul> </li> <li>\u5728 <code>Config</code> \u4e0a\u4f7f\u7528 <code>alias_generator</code><ul> <li>\u53ef\u4ee5\u662f\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\u6216 <code>AliasGenerator</code> \u7684\u5b9e\u4f8b</li> </ul> </li> </ul> <p>\u6709\u5173\u5982\u4f55\u4f7f\u7528 <code>alias</code>\u3001<code>validation_alias</code> \u548c <code>serialization_alias</code> \u7684\u793a\u4f8b\uff0c\u8bf7\u53c2\u9605 \u5b57\u6bb5\u522b\u540d\u3002</p>"},{"location":"concepts/alias/#aliaspath-and-aliaschoices","title":"<code>AliasPath</code> \u548c <code>AliasChoices</code>","text":"API \u6587\u6863 <p><code>pydantic.aliases.AliasPath</code> <code>pydantic.aliases.AliasChoices</code></p> <p>Pydantic \u63d0\u4f9b\u4e86\u4e24\u79cd\u7279\u6b8a\u7c7b\u578b\uff0c\u65b9\u4fbf\u5728\u4f7f\u7528 <code>validation_alias</code> \u65f6\u4f7f\u7528\uff1a<code>AliasPath</code> \u548c <code>AliasChoices</code>\u3002</p> <p><code>AliasPath</code> \u7528\u4e8e\u4f7f\u7528\u522b\u540d\u6307\u5b9a\u5b57\u6bb5\u7684\u8def\u5f84\u3002\u4f8b\u5982\uff1a</p> <pre><code>from pydantic import BaseModel, Field, AliasPath\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasPath('names', 0))\n    last_name: str = Field(validation_alias=AliasPath('names', 1))\n\nuser = User.model_validate({'names': ['John', 'Doe']})  # (1)!\nprint(user)\n#&gt; first_name='John' last_name='Doe'\n</code></pre> <ol> <li> <p>\u6211\u4eec\u4f7f\u7528 <code>model_validate</code> \u6765\u4f7f\u7528\u5b57\u6bb5\u522b\u540d\u9a8c\u8bc1\u5b57\u5178\u3002</p> <p>\u60a8\u53ef\u4ee5\u5728 API \u53c2\u8003\u4e2d\u67e5\u770b\u66f4\u591a\u5173\u4e8e <code>model_validate</code> \u7684\u8be6\u7ec6\u4fe1\u606f\u3002</p> </li> </ol> <p>\u5728 <code>'first_name'</code> \u5b57\u6bb5\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u522b\u540d <code>'names'</code> \u548c\u7d22\u5f15 <code>0</code> \u6765\u6307\u5b9a\u540d\u5b57\u7684\u8def\u5f84\u3002 \u5728 <code>'last_name'</code> \u5b57\u6bb5\u4e2d\uff0c\u6211\u4eec\u4f7f\u7528\u522b\u540d <code>'names'</code> \u548c\u7d22\u5f15 <code>1</code> \u6765\u6307\u5b9a\u59d3\u6c0f\u7684\u8def\u5f84\u3002</p> <p><code>AliasChoices</code> \u7528\u4e8e\u6307\u5b9a\u522b\u540d\u7684\u9009\u62e9\u3002\u4f8b\u5982\uff1a</p> <pre><code>from pydantic import BaseModel, Field, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', 'fname'))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', 'lname'))\n\nuser = User.model_validate({'fname': 'John', 'lname': 'Doe'})  # (1)!\nprint(user)\n#&gt; first_name='John' last_name='Doe'\nuser = User.model_validate({'first_name': 'John', 'lname': 'Doe'})  # (2)!\nprint(user)\n#&gt; first_name='John' last_name='Doe'\n</code></pre> <ol> <li>\u6211\u4eec\u4e3a\u4e24\u4e2a\u5b57\u6bb5\u90fd\u4f7f\u7528\u4e86\u7b2c\u4e8c\u4e2a\u522b\u540d\u9009\u62e9\u3002</li> <li>\u6211\u4eec\u4e3a\u5b57\u6bb5 <code>'first_name'</code> \u4f7f\u7528\u4e86\u7b2c\u4e00\u4e2a\u522b\u540d\u9009\u62e9\uff0c\u4e3a\u5b57\u6bb5 <code>'last_name'</code> \u4f7f\u7528\u4e86\u7b2c\u4e8c\u4e2a\u522b\u540d\u9009\u62e9\u3002</li> </ol> <p>\u60a8\u4e5f\u53ef\u4ee5\u5c06 <code>AliasChoices</code> \u4e0e <code>AliasPath</code> \u4e00\u8d77\u4f7f\u7528\uff1a</p> <pre><code>from pydantic import BaseModel, Field, AliasPath, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', AliasPath('names', 0)))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', AliasPath('names', 1)))\n\n\nuser = User.model_validate({'first_name': 'John', 'last_name': 'Doe'})\nprint(user)\n#&gt; first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John', 'Doe']})\nprint(user)\n#&gt; first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John'], 'last_name': 'Doe'})\nprint(user)\n#&gt; first_name='John' last_name='Doe'\n</code></pre>"},{"location":"concepts/alias/#using-alias-generators","title":"\u4f7f\u7528\u522b\u540d\u751f\u6210\u5668","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>Config</code> \u7684 <code>alias_generator</code> \u53c2\u6570\u6765\u6307\u5b9a\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\uff08\u6216\u901a\u8fc7 <code>AliasGenerator</code> \u6307\u5b9a\u4e00\u7ec4\u53ef\u8c03\u7528\u5bf9\u8c61\uff09\uff0c\u8be5\u5bf9\u8c61\u5c06\u4e3a\u6a21\u578b\u4e2d\u7684\u6240\u6709\u5b57\u6bb5\u751f\u6210\u522b\u540d\u3002 \u5982\u679c\u60a8\u60f3\u4e3a\u6a21\u578b\u4e2d\u7684\u6240\u6709\u5b57\u6bb5\u4f7f\u7528\u4e00\u81f4\u7684\u547d\u540d\u7ea6\u5b9a\uff0c\u4f46\u4e0d\u60f3\u4e3a\u6bcf\u4e2a\u5b57\u6bb5\u5355\u72ec\u6307\u5b9a\u522b\u540d\uff0c\u8fd9\u5c06\u975e\u5e38\u6709\u7528\u3002</p> <p>Note</p> <p>Pydantic \u63d0\u4f9b\u4e86\u4e09\u4e2a\u5185\u7f6e\u7684\u522b\u540d\u751f\u6210\u5668\uff0c\u60a8\u53ef\u4ee5\u5f00\u7bb1\u5373\u7528\uff1a</p> <p><code>to_pascal</code> <code>to_camel</code> <code>to_snake</code></p>"},{"location":"concepts/alias/#_1","title":"\u4f7f\u7528\u53ef\u8c03\u7528\u5bf9\u8c61","text":"<p>\u8fd9\u662f\u4e00\u4e2a\u4f7f\u7528\u53ef\u8c03\u7528\u5bf9\u8c61\u7684\u57fa\u672c\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=lambda field_name: field_name.upper()\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#&gt; {'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'}\n</code></pre>"},{"location":"concepts/alias/#aliasgenerator","title":"\u4f7f\u7528 <code>AliasGenerator</code>","text":"API \u6587\u6863 <p><code>pydantic.aliases.AliasGenerator</code></p> <p><code>AliasGenerator</code> \u662f\u4e00\u4e2a\u7c7b\uff0c\u5141\u8bb8\u60a8\u4e3a\u6a21\u578b\u6307\u5b9a\u591a\u4e2a\u522b\u540d\u751f\u6210\u5668\u3002 \u60a8\u53ef\u4ee5\u4f7f\u7528 <code>AliasGenerator</code> \u4e3a\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u6307\u5b9a\u4e0d\u540c\u7684\u522b\u540d\u751f\u6210\u5668\u3002</p> <p>\u5982\u679c\u60a8\u9700\u8981\u4e3a\u52a0\u8f7d\u548c\u4fdd\u5b58\u6570\u636e\u4f7f\u7528\u4e0d\u540c\u7684\u547d\u540d\u7ea6\u5b9a\uff0c\u4f46\u4e0d\u60f3\u4e3a\u6bcf\u4e2a\u5b57\u6bb5\u5355\u72ec\u6307\u5b9a\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u522b\u540d\uff0c\u8fd9\u5c06\u7279\u522b\u6709\u7528\u3002</p> <p>\u4f8b\u5982\uff1a</p> <pre><code>from pydantic import AliasGenerator, BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=lambda field_name: field_name.upper(),\n            serialization_alias=lambda field_name: field_name.title(),\n        )\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#&gt; {'Age': 12, 'Height': 1.2, 'Kind': 'oak'}\n</code></pre>"},{"location":"concepts/alias/#alias-precedence","title":"\u522b\u540d\u4f18\u5148\u7ea7","text":"<p>\u5982\u679c\u60a8\u5728 <code>Field</code> \u4e0a\u6307\u5b9a\u4e86 <code>alias</code>\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u5b83\u5c06\u4f18\u5148\u4e8e\u751f\u6210\u7684\u522b\u540d\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\ndef to_camel(string: str) -&gt; str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\nclass Voice(BaseModel):\n    model_config = ConfigDict(alias_generator=to_camel)\n\n    name: str\n    language_code: str = Field(alias='lang')\n\n\nvoice = Voice(Name='Filiz', lang='tr-TR')\nprint(voice.language_code)\n#&gt; tr-TR\nprint(voice.model_dump(by_alias=True))\n#&gt; {'Name': 'Filiz', 'lang': 'tr-TR'}\n</code></pre>"},{"location":"concepts/alias/#_2","title":"\u522b\u540d\u4f18\u5148\u7ea7","text":"<p>\u60a8\u53ef\u4ee5\u5728\u5b57\u6bb5\u4e0a\u8bbe\u7f6e <code>alias_priority</code> \u6765\u6539\u53d8\u6b64\u884c\u4e3a\uff1a</p> <ul> <li><code>alias_priority=2</code> \u522b\u540d\u5c06\u4e0d\u4f1a\u88ab\u522b\u540d\u751f\u6210\u5668\u8986\u76d6\u3002</li> <li><code>alias_priority=1</code> \u522b\u540d\u5c06\u88ab\u522b\u540d\u751f\u6210\u5668\u8986\u76d6\u3002</li> <li>\u672a\u8bbe\u7f6e <code>alias_priority</code>\uff1a<ul> <li>\u5982\u679c\u8bbe\u7f6e\u4e86\u522b\u540d\uff1a\u522b\u540d\u5c06\u4e0d\u4f1a\u88ab\u522b\u540d\u751f\u6210\u5668\u8986\u76d6\u3002</li> <li>\u5982\u679c\u672a\u8bbe\u7f6e\u522b\u540d\uff1a\u522b\u540d\u5c06\u88ab\u522b\u540d\u751f\u6210\u5668\u8986\u76d6\u3002</li> </ul> </li> </ul> <p>\u76f8\u540c\u7684\u4f18\u5148\u7ea7\u89c4\u5219\u9002\u7528\u4e8e <code>validation_alias</code> \u548c <code>serialization_alias</code>\u3002 \u6709\u5173\u4e0d\u540c\u5b57\u6bb5\u522b\u540d\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u5b57\u6bb5\u522b\u540d\u3002</p>"},{"location":"concepts/alias/#_3","title":"\u522b\u540d\u914d\u7f6e","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>ConfigDict</code> \u8bbe\u7f6e\u6216\u8fd0\u884c\u65f6\u9a8c\u8bc1/\u5e8f\u5217\u5316\u8bbe\u7f6e\u6765\u63a7\u5236\u662f\u5426\u4f7f\u7528\u522b\u540d\u3002</p>"},{"location":"concepts/alias/#configdict-settings","title":"<code>ConfigDict</code> \u8bbe\u7f6e","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 \u914d\u7f6e\u8bbe\u7f6e \u5728\u6a21\u578b\u7ea7\u522b\u63a7\u5236\u662f\u5426\u4f7f\u7528\u522b\u540d\u8fdb\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u3002\u5982\u679c\u60a8\u60f3\u4e3a\u5d4c\u5957\u6a21\u578b/\u8de8\u8d8a\u914d\u7f6e\u6a21\u578b\u8fb9\u754c\u63a7\u5236\u6b64\u884c\u4e3a\uff0c\u8bf7\u4f7f\u7528 \u8fd0\u884c\u65f6\u8bbe\u7f6e\u3002</p>"},{"location":"concepts/alias/#_4","title":"\u9a8c\u8bc1","text":"<p>\u5728\u9a8c\u8bc1\u6570\u636e\u65f6\uff0c\u60a8\u53ef\u4ee5\u6309\u5c5e\u6027\u540d\u79f0\u3001\u522b\u540d\u6216\u4e24\u8005\u542f\u7528\u5c5e\u6027\u586b\u5145\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u4f7f\u7528\u522b\u540d\u8fdb\u884c\u9a8c\u8bc1\u3002\u53ef\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u8fdb\u4e00\u6b65\u914d\u7f6e\uff1a</p> <ul> <li><code>ConfigDict.validate_by_alias</code>\uff1a\u9ed8\u8ba4\u4e3a <code>True</code></li> <li><code>ConfigDict.validate_by_name</code>\uff1a\u9ed8\u8ba4\u4e3a <code>False</code></li> </ul> <code>validate_by_alias</code><code>validate_by_name</code><code>validate_by_alias</code> \u548c <code>validate_by_name</code> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)!\n#&gt; Model(my_field='foo')\n</code></pre> <ol> <li>\u4f7f\u7528\u522b\u540d <code>my_alias</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n\n\nprint(repr(Model(my_field='foo')))  # (1)!\n#&gt; Model(my_field='foo')\n</code></pre> <ol> <li>\u4f7f\u7528\u5c5e\u6027\u6807\u8bc6\u7b26 <code>my_field</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)!\n#&gt; Model(my_field='foo')\n\nprint(repr(Model(my_field='foo')))  # (2)!\n#&gt; Model(my_field='foo')\n</code></pre> <ol> <li>\u4f7f\u7528\u522b\u540d <code>my_alias</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> <li>\u4f7f\u7528\u5c5e\u6027\u6807\u8bc6\u7b26 <code>my_field</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol> <p>Warning</p> <p>\u60a8\u4e0d\u80fd\u540c\u65f6\u5c06 <code>validate_by_alias</code> \u548c <code>validate_by_name</code> \u8bbe\u7f6e\u4e3a <code>False</code>\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u4f1a\u5f15\u53d1 \u7528\u6237\u9519\u8bef\u3002</p>"},{"location":"concepts/alias/#_5","title":"\u5e8f\u5217\u5316","text":"<p>\u5728\u5e8f\u5217\u5316\u6570\u636e\u65f6\uff0c\u60a8\u53ef\u4ee5\u542f\u7528\u6309\u522b\u540d\u5e8f\u5217\u5316\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u662f\u7981\u7528\u7684\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>ConfigDict.serialize_by_alias</code> API \u6587\u6863\u3002</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n    model_config = ConfigDict(serialize_by_alias=True)\n\n\nm = Model(my_field='foo')\nprint(m.model_dump())  # (1)!\n#&gt; {'my_alias': 'foo'}\n</code></pre> <ol> <li>\u4f7f\u7528\u522b\u540d <code>my_alias</code> \u8fdb\u884c\u5e8f\u5217\u5316\u3002</li> </ol> <p>Note</p> <p>\u6309\u522b\u540d\u5e8f\u5217\u5316\u9ed8\u8ba4\u7981\u7528\u7684\u4e8b\u5b9e\u4e0e\u9a8c\u8bc1\u7684\u9ed8\u8ba4\u8bbe\u7f6e\uff08\u9ed8\u8ba4\u4f7f\u7528\u522b\u540d\uff09\u660e\u663e\u4e0d\u4e00\u81f4\u3002\u6211\u4eec\u9884\u8ba1\u5728 V3 \u4e2d\u66f4\u6539\u6b64\u9ed8\u8ba4\u8bbe\u7f6e\u3002</p>"},{"location":"concepts/alias/#runtime-settings","title":"\u8fd0\u884c\u65f6\u8bbe\u7f6e","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u8fd0\u884c\u65f6\u522b\u540d\u6807\u5fd7\u6765\u63a7\u5236\u6bcf\u6b21\u8c03\u7528\u65f6\u522b\u540d\u7684\u4f7f\u7528\uff0c\u7528\u4e8e\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u3002 \u5982\u679c\u60a8\u60f3\u5728\u6a21\u578b\u7ea7\u522b\u63a7\u5236\u6b64\u884c\u4e3a\uff0c\u8bf7\u4f7f\u7528 <code>ConfigDict</code> \u8bbe\u7f6e\u3002</p>"},{"location":"concepts/alias/#_6","title":"\u9a8c\u8bc1","text":"<p>\u5728\u9a8c\u8bc1\u6570\u636e\u65f6\uff0c\u60a8\u53ef\u4ee5\u6309\u5c5e\u6027\u540d\u79f0\u3001\u522b\u540d\u6216\u4e24\u8005\u542f\u7528\u5c5e\u6027\u586b\u5145\u3002</p> <p><code>by_alias</code> \u548c <code>by_name</code> \u6807\u5fd7\u53ef\u5728 <code>model_validate()</code>\u3001 <code>model_validate_json()</code> \u548c <code>model_validate_strings()</code> \u65b9\u6cd5\u4ee5\u53ca <code>TypeAdapter</code> \u9a8c\u8bc1\u65b9\u6cd5\u4e0a\u4f7f\u7528\u3002</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff1a</p> <ul> <li><code>by_alias</code> \u4e3a <code>True</code></li> <li><code>by_name</code> \u4e3a <code>False</code></li> </ul> <code>by_alias</code><code>by_name</code><code>validate_by_alias</code> \u548c <code>validate_by_name</code> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_alias': 'foo'},  # (1)!\n    by_alias=True,\n    by_name=False,\n)\nprint(repr(m))\n#&gt; Model(my_field='foo')\n</code></pre> <ol> <li>\u4f7f\u7528\u522b\u540d <code>my_alias</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_field': 'foo'}, by_alias=False, by_name=True  # (1)!\n)\nprint(repr(m))\n#&gt; Model(my_field='foo')\n</code></pre> <ol> <li>\u4f7f\u7528\u5c5e\u6027\u540d\u79f0 <code>my_field</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n\nm = Model.model_validate(\n    {'my_alias': 'foo'}, by_alias=True, by_name=True  # (1)!\n)\nprint(repr(m))\n#&gt; Model(my_field='foo')\n\nm = Model.model_validate(\n    {'my_field': 'foo'}, by_alias=True, by_name=True  # (2)!\n)\nprint(repr(m))\n#&gt; Model(my_field='foo')\n</code></pre> <ol> <li>\u4f7f\u7528\u522b\u540d <code>my_alias</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> <li>\u4f7f\u7528\u5c5e\u6027\u540d\u79f0 <code>my_field</code> \u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol> <p>Warning</p> <p>\u60a8\u4e0d\u80fd\u540c\u65f6\u5c06 <code>by_alias</code> \u548c <code>by_name</code> \u8bbe\u7f6e\u4e3a <code>False</code>\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u4f1a\u5f15\u53d1 \u7528\u6237\u9519\u8bef\u3002</p>"},{"location":"concepts/alias/#_7","title":"\u5e8f\u5217\u5316","text":"<p>\u5728\u5e8f\u5217\u5316\u6570\u636e\u65f6\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7 <code>by_alias</code> \u6807\u5fd7\u542f\u7528\u6309\u522b\u540d\u5e8f\u5217\u5316\uff0c \u8be5\u6807\u5fd7\u53ef\u5728 <code>model_dump()</code> \u548c <code>model_dump_json()</code> \u65b9\u6cd5\u4ee5\u53ca <code>TypeAdapter</code> \u65b9\u6cd5\u4e0a\u4f7f\u7528\u3002</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>by_alias</code> \u4e3a <code>False</code>\u3002</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n\nm = Model(my_field='foo')\nprint(m.model_dump(by_alias=True))  # (1)!\n#&gt; {'my_alias': 'foo'}\n</code></pre> <ol> <li>\u4f7f\u7528\u522b\u540d <code>my_alias</code> \u8fdb\u884c\u5e8f\u5217\u5316\u3002</li> </ol> <p>Note</p> <p>\u6309\u522b\u540d\u5e8f\u5217\u5316\u9ed8\u8ba4\u7981\u7528\u7684\u4e8b\u5b9e\u4e0e\u9a8c\u8bc1\u7684\u9ed8\u8ba4\u8bbe\u7f6e\uff08\u9ed8\u8ba4\u4f7f\u7528\u522b\u540d\uff09\u660e\u663e\u4e0d\u4e00\u81f4\u3002\u6211\u4eec\u9884\u8ba1\u5728 V3 \u4e2d\u66f4\u6539\u6b64\u9ed8\u8ba4\u8bbe\u7f6e\u3002</p>"},{"location":"concepts/config/","title":"Configuration","text":"<p>Pydantic \u7684\u884c\u4e3a\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u914d\u7f6e\u503c\u6765\u63a7\u5236\uff0c\u8fd9\u4e9b\u914d\u7f6e\u503c\u8bb0\u5f55\u5728 <code>ConfigDict</code> \u7c7b\u4e2d\u3002\u672c\u9875\u63cf\u8ff0\u4e86\u5982\u4f55\u4e3a Pydantic \u652f\u6301\u7684\u7c7b\u578b\u6307\u5b9a\u914d\u7f6e\u3002</p>"},{"location":"concepts/config/#pydantic","title":"Pydantic \u6a21\u578b\u4e0a\u7684\u914d\u7f6e","text":"<p>\u5728 Pydantic \u6a21\u578b\u4e0a\uff0c\u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u6307\u5b9a\u914d\u7f6e\uff1a</p> <ul> <li> <p>\u4f7f\u7528 <code>model_config</code> \u7c7b\u5c5e\u6027\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    model_config = ConfigDict(str_max_length=5)  # (1)!\n\n    v: str\n\n\ntry:\n    m = Model(v='abcdef')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    v\n      String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u4e5f\u53ef\u4ee5\u4f7f\u7528\u666e\u901a\u5b57\u5178\uff08\u5373 <code>{'str_max_length': 5}</code>\uff09\u3002</li> </ol> <p>Note</p> <p>\u5728 Pydantic V1 \u4e2d\uff0c\u4f7f\u7528\u4e86 <code>Config</code> \u7c7b\u3002\u8fd9\u4ecd\u7136\u53d7\u652f\u6301\uff0c\u4f46\u5df2\u5f03\u7528\u3002</p> </li> <li> <p>\u4f7f\u7528\u7c7b\u53c2\u6570\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel, frozen=True):\n    a: str\n</code></pre> </li> </ul> <p>\u4e0e <code>model_config</code> \u7c7b\u5c5e\u6027\u4e0d\u540c\uff0c   \u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u5c06\u8bc6\u522b\u7c7b\u53c2\u6570\u3002\u5bf9\u4e8e <code>frozen</code>\uff0c\u4efb\u4f55\u5b9e\u4f8b   \u7a81\u53d8\u90fd\u5c06\u88ab\u6807\u8bb0\u4e3a\u7c7b\u578b\u68c0\u67e5\u9519\u8bef\u3002</p>"},{"location":"concepts/config/#pydantic_1","title":"Pydantic \u6570\u636e\u7c7b\u4e0a\u7684\u914d\u7f6e","text":"<p>Pydantic \u6570\u636e\u7c7b \u4e5f\u652f\u6301\u914d\u7f6e\uff08\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u9605 \u4e13\u7528\u7ae0\u8282\uff09\u3002</p> <pre><code>from pydantic import ConfigDict, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(str_max_length=10, validate_assignment=True))\nclass User:\n    name: str\n\n\nuser = User(name='John Doe')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"concepts/config/#typeadapter","title":"<code>TypeAdapter</code> \u4e0a\u7684\u914d\u7f6e","text":"<p>\u7c7b\u578b\u9002\u914d\u5668\uff08\u4f7f\u7528 <code>TypeAdapter</code> \u7c7b\uff09\u652f\u6301\u914d\u7f6e\uff0c \u901a\u8fc7\u63d0\u4f9b <code>config</code> \u53c2\u6570\u3002</p> <pre><code>from pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter(list[str], config=ConfigDict(coerce_numbers_to_str=True))\n\nprint(ta.validate_python([1, 2]))\n#&gt; ['1', '2']\n</code></pre> <p>\u5982\u679c\u7c7b\u578b\u9002\u914d\u5668\u76f4\u63a5\u5305\u88c5\u652f\u6301\u914d\u7f6e\u7684\u7c7b\u578b\uff0c\u5219\u65e0\u6cd5\u63d0\u4f9b\u914d\u7f6e\uff0c\u5e76\u4e14\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u4f1a\u5f15\u53d1 \u4f7f\u7528\u9519\u8bef\u3002 \u914d\u7f6e\u4f20\u64ad \u89c4\u5219\u4e5f\u9002\u7528\u3002</p>"},{"location":"concepts/config/#configuration-on-other-supported-types","title":"\u5176\u4ed6\u652f\u6301\u7c7b\u578b\u4e0a\u7684\u914d\u7f6e","text":"<p>\u5982\u679c\u60a8\u4f7f\u7528 \u6807\u51c6\u5e93\u6570\u636e\u7c7b \u6216 <code>TypedDict</code> \u7c7b\uff0c \u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u8bbe\u7f6e\u914d\u7f6e\uff1a</p> <ul> <li> <p>\u4f7f\u7528 <code>__pydantic_config__</code> \u7c7b\u5c5e\u6027\uff1a</p> <pre><code>from dataclasses import dataclass\n\nfrom pydantic import ConfigDict\n\n\n@dataclass\nclass User:\n    __pydantic_config__ = ConfigDict(strict=True)\n\n    id: int\n    name: str = 'John Doe'\n</code></pre> </li> <li> <p>\u4f7f\u7528 <code>@with_config</code> \u88c5\u9970\u5668\uff08\u8fd9\u53ef\u4ee5\u907f\u514d\u4e0e   <code>TypedDict</code> \u76f8\u5173\u7684\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u9519\u8bef\uff09\uff1a</p> <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, with_config\n\n\n@with_config(ConfigDict(str_to_lower=True))\nclass Model(TypedDict):\n    x: str\n</code></pre> </li> </ul>"},{"location":"concepts/config/#validate_call","title":"<code>@validate_call</code> \u88c5\u9970\u5668\u4e0a\u7684\u914d\u7f6e","text":"<p><code>@validate_call</code> \u88c5\u9970\u5668\u4e5f\u652f\u6301\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u914d\u7f6e\u3002\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u8bf7\u53c2\u9605 \u4e13\u7528\u7ae0\u8282\u3002</p>"},{"location":"concepts/config/#_1","title":"\u5168\u5c40\u66f4\u6539\u884c\u4e3a","text":"<p>\u5982\u679c\u60a8\u5e0c\u671b\u5168\u5c40\u66f4\u6539 Pydantic \u7684\u884c\u4e3a\uff0c\u53ef\u4ee5\u521b\u5efa\u81ea\u5df1\u7684\u81ea\u5b9a\u4e49\u7236\u7c7b \u5e76\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u914d\u7f6e\uff0c\u56e0\u4e3a\u914d\u7f6e\u662f\u53ef\u7ee7\u627f\u7684\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow')\n\n\nclass Model(Parent):\n    x: str\n\n\nm = Model(x='foo', y='bar')\nprint(m.model_dump())\n#&gt; {'x': 'foo', 'y': 'bar'}\n</code></pre> <p>\u5982\u679c\u60a8\u4e3a\u5b50\u7c7b\u63d0\u4f9b\u914d\u7f6e\uff0c\u5b83\u5c06\u4e0e\u7236\u914d\u7f6e\u5408\u5e76\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow', str_to_lower=False)\n\n\nclass Model(Parent):\n    model_config = ConfigDict(str_to_lower=True)\n\n    x: str\n\n\nm = Model(x='FOO', y='bar')\nprint(m.model_dump())\n#&gt; {'x': 'foo', 'y': 'bar'}\nprint(Model.model_config)\n#&gt; {'extra': 'allow', 'str_to_lower': True}\n</code></pre> <p>Warning</p> <p>\u5982\u679c\u60a8\u7684\u6a21\u578b\u7ee7\u627f\u81ea\u591a\u4e2a\u57fa\u7c7b\uff0cPydantic \u76ee\u524d\u4e0d\u9075\u5faa MRO\u3002\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6b64\u95ee\u9898\u3002</p>"},{"location":"concepts/config/#configuration-propagation","title":"\u914d\u7f6e\u4f20\u64ad","text":"<p>\u5f53\u4f7f\u7528\u652f\u6301\u914d\u7f6e\u7684\u7c7b\u578b\u4f5c\u4e3a\u5b57\u6bb5\u6ce8\u89e3\u65f6\uff0c\u914d\u7f6e\u53ef\u80fd\u4e0d\u4f1a\u88ab\u4f20\u64ad\uff1a</p> <ul> <li> <p>\u5bf9\u4e8e Pydantic \u6a21\u578b\u548c\u6570\u636e\u7c7b\uff0c\u914d\u7f6e\u5c06\u4e0d\u4f1a\u88ab\u4f20\u64ad\uff0c\u6bcf\u4e2a\u6a21\u578b\u90fd\u6709\u81ea\u5df1\u7684   \"\u914d\u7f6e\u8fb9\u754c\"\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass Parent(BaseModel):\n    user: User\n\n    model_config = ConfigDict(str_to_lower=True)\n\n\nprint(Parent(user={'name': 'JOHN'}))\n#&gt; user=User(name='JOHN')\n</code></pre> </li> <li> <p>\u5bf9\u4e8e\u6807\u51c6\u5e93\u7c7b\u578b\uff08\u6570\u636e\u7c7b\u548c\u7c7b\u578b\u5316\u5b57\u5178\uff09\uff0c\u914d\u7f6e\u5c06\u88ab\u4f20\u64ad\uff0c\u9664\u975e   \u8be5\u7c7b\u578b\u6709\u81ea\u5df1\u7684\u914d\u7f6e\u8bbe\u7f6e\uff1a</p> <pre><code>from dataclasses import dataclass\n\nfrom pydantic import BaseModel, ConfigDict, with_config\n\n\n@dataclass\nclass UserWithoutConfig:\n    name: str\n\n\n@dataclass\n@with_config(str_to_lower=False)\nclass UserWithConfig:\n    name: str\n\n\nclass Parent(BaseModel):\n    user_1: UserWithoutConfig\n    user_2: UserWithConfig\n\n    model_config = ConfigDict(str_to_lower=True)\n\n\nprint(Parent(user_1={'name': 'JOHN'}, user_2={'name': 'JOHN'}))\n#&gt; user_1=UserWithoutConfig(name='john') user_2=UserWithConfig(name='JOHN')\n</code></pre> </li> </ul>"},{"location":"concepts/conversion_table/","title":"Conversion Table","text":"<p>\u4ee5\u4e0b\u8868\u683c\u8be6\u7ec6\u8bf4\u660e\u4e86 Pydantic \u5728\u4e25\u683c\u6a21\u5f0f\u548c\u5bbd\u677e\u6a21\u5f0f\u4e0b\u8fdb\u884c\u9a8c\u8bc1\u65f6\u5982\u4f55\u8f6c\u6362\u6570\u636e\u3002</p> <p>\"Strict\" \u5217\u5305\u542b\u5728 \u4e25\u683c\u6a21\u5f0f \u4e0b\u9a8c\u8bc1\u65f6\u5141\u8bb8\u7684\u7c7b\u578b\u8f6c\u6362\u7684\u52fe\u9009\u6807\u8bb0\u3002</p> \u5168\u90e8JSONJSON - \u4e25\u683c\u6a21\u5f0fPythonPython - \u4e25\u683c\u6a21\u5f0f Field Type Input Strict Input Source Conditions <code>bool</code> <code>bool</code> \u2713 Python &amp; JSON <code>bool</code> <code>float</code> Python &amp; JSON Allowed values: <code>0.0, 1.0</code>. <code>bool</code> <code>int</code> Python &amp; JSON Allowed values: <code>0, 1</code>. <code>bool</code> <code>str</code> Python &amp; JSON Allowed values: <code>'f'</code>, <code>'n'</code>, <code>'no'</code>, <code>'off'</code>, <code>'false'</code>, <code>'False'</code>, <code>'t'</code>, <code>'y'</code>, <code>'on'</code>, <code>'yes'</code>, <code>'true'</code>, <code>'True'</code>. <code>bool</code> <code>Decimal</code> Python Allowed values: <code>Decimal(0), Decimal(1)</code>. <code>bytes</code> <code>bytearray</code> Python <code>bytes</code> <code>bytes</code> \u2713 Python <code>bytes</code> <code>str</code> \u2713 JSON <code>bytes</code> <code>str</code> Python <code>callable</code> <code>-</code> JSON Never valid. <code>callable</code> <code>Any</code> \u2713 Python <code>callable()</code> check must return <code>True</code>. <code>date</code> <code>bytes</code> Python Format: <code>YYYY-MM-DD</code> (UTF-8). <code>date</code> <code>date</code> \u2713 Python <code>date</code> <code>datetime</code> Python Must be exact date, eg. no <code>H</code>, <code>M</code>, <code>S</code>, <code>f</code>. <code>date</code> <code>float</code> Python &amp; JSON Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>date</code> <code>int</code> Python &amp; JSON Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>date</code> <code>str</code> Python &amp; JSON Format: <code>YYYY-MM-DD</code>. <code>date</code> <code>Decimal</code> Python Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>datetime</code> <code>bytes</code> Python Format: <code>YYYY-MM-DDTHH:MM:SS.f</code> or <code>YYYY-MM-DD</code>. See speedate, (UTF-8). <code>datetime</code> <code>date</code> Python <code>datetime</code> <code>datetime</code> \u2713 Python <code>datetime</code> <code>float</code> Python &amp; JSON Interpreted as seconds or ms from epoch, see speedate. <code>datetime</code> <code>int</code> Python &amp; JSON Interpreted as seconds or ms from epoch, see speedate. <code>datetime</code> <code>str</code> Python &amp; JSON Format: <code>YYYY-MM-DDTHH:MM:SS.f</code> or <code>YYYY-MM-DD</code>. See speedate. <code>datetime</code> <code>Decimal</code> Python Interpreted as seconds or ms from epoch, see speedate. <code>deque</code> <code>deque</code> \u2713 Python <code>deque</code> <code>frozenset</code> Python <code>deque</code> <code>list</code> Python <code>deque</code> <code>set</code> Python <code>deque</code> <code>tuple</code> Python <code>deque</code> <code>Array</code> \u2713 JSON <code>dict</code> <code>dict</code> \u2713 Python <code>dict</code> <code>Mapping</code> Python Must implement the mapping interface and have an <code>items()</code> method. <code>dict</code> <code>Object</code> \u2713 JSON <code>float</code> <code>bool</code> Python &amp; JSON <code>float</code> <code>bytes</code> Python Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>float</code> <code>float</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>float</code> <code>int</code> \u2713 Python &amp; JSON <code>float</code> <code>str</code> Python &amp; JSON Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>float</code> <code>Decimal</code> Python <code>frozenset</code> <code>deque</code> Python <code>frozenset</code> <code>dict_keys</code> Python <code>frozenset</code> <code>dict_values</code> Python <code>frozenset</code> <code>frozenset</code> \u2713 Python <code>frozenset</code> <code>list</code> Python <code>frozenset</code> <code>set</code> Python <code>frozenset</code> <code>tuple</code> Python <code>frozenset</code> <code>Array</code> \u2713 JSON <code>int</code> <code>bool</code> Python &amp; JSON <code>int</code> <code>bytes</code> Python Must be numeric only, e.g. <code>[0-9]+</code>. <code>int</code> <code>float</code> Python &amp; JSON Must be exact int, e.g. <code>val % 1 == 0</code>, raises error for <code>nan</code>, <code>inf</code>. <code>int</code> <code>int</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>int</code> <code>int</code> Python &amp; JSON <code>int</code> <code>str</code> Python &amp; JSON Must be numeric only, e.g. <code>[0-9]+</code>. <code>int</code> <code>Decimal</code> Python Must be exact int, e.g. <code>val % 1 == 0</code>. <code>list</code> <code>deque</code> Python <code>list</code> <code>dict_keys</code> Python <code>list</code> <code>dict_values</code> Python <code>list</code> <code>frozenset</code> Python <code>list</code> <code>list</code> \u2713 Python <code>list</code> <code>set</code> Python <code>list</code> <code>tuple</code> Python <code>list</code> <code>Array</code> \u2713 JSON <code>namedtuple</code> <code>dict</code> \u2713 Python <code>namedtuple</code> <code>list</code> \u2713 Python <code>namedtuple</code> <code>namedtuple</code> \u2713 Python <code>namedtuple</code> <code>tuple</code> \u2713 Python <code>namedtuple</code> <code>Array</code> \u2713 JSON <code>namedtuple</code> <code>NamedTuple</code> \u2713 Python <code>set</code> <code>deque</code> Python <code>set</code> <code>dict_keys</code> Python <code>set</code> <code>dict_values</code> Python <code>set</code> <code>frozenset</code> Python <code>set</code> <code>list</code> Python <code>set</code> <code>set</code> \u2713 Python <code>set</code> <code>tuple</code> Python <code>set</code> <code>Array</code> \u2713 JSON <code>str</code> <code>bytearray</code> Python Assumes UTF-8, error on unicode decoding error. <code>str</code> <code>bytes</code> Python Assumes UTF-8, error on unicode decoding error. <code>str</code> <code>str</code> \u2713 Python &amp; JSON <code>time</code> <code>bytes</code> Python Format: <code>HH:MM:SS.FFFFFF</code>. See speedate. <code>time</code> <code>float</code> Python &amp; JSON Interpreted as seconds, range <code>0 - 86399.9*</code>. <code>time</code> <code>int</code> Python &amp; JSON Interpreted as seconds, range <code>0 - 86399</code>. <code>time</code> <code>str</code> Python &amp; JSON Format: <code>HH:MM:SS.FFFFFF</code>. See speedate. <code>time</code> <code>time</code> \u2713 Python <code>time</code> <code>Decimal</code> Python Interpreted as seconds, range <code>0 - 86399.9*</code>. <code>timedelta</code> <code>bytes</code> Python Format: <code>ISO8601</code>. See speedate, (UTF-8). <code>timedelta</code> <code>float</code> Python &amp; JSON Interpreted as seconds. <code>timedelta</code> <code>int</code> Python &amp; JSON Interpreted as seconds. <code>timedelta</code> <code>str</code> Python &amp; JSON Format: <code>ISO8601</code>. See speedate. <code>timedelta</code> <code>timedelta</code> \u2713 Python <code>timedelta</code> <code>Decimal</code> Python Interpreted as seconds. <code>tuple</code> <code>deque</code> Python <code>tuple</code> <code>dict_keys</code> Python <code>tuple</code> <code>dict_values</code> Python <code>tuple</code> <code>frozenset</code> Python <code>tuple</code> <code>list</code> Python <code>tuple</code> <code>set</code> Python <code>tuple</code> <code>tuple</code> \u2713 Python <code>tuple</code> <code>Array</code> \u2713 JSON <code>type</code> <code>type</code> \u2713 Python <code>Any</code> <code>Any</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>float</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>int</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>str</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>Decimal</code> \u2713 Python <code>Decimal</code> <code>float</code> \u2713 JSON <code>Decimal</code> <code>float</code> Python &amp; JSON <code>Decimal</code> <code>int</code> \u2713 JSON <code>Decimal</code> <code>int</code> Python &amp; JSON <code>Decimal</code> <code>str</code> \u2713 JSON <code>Decimal</code> <code>str</code> Python &amp; JSON Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>Decimal</code> <code>Decimal</code> \u2713 Python <code>Enum</code> <code>Any</code> \u2713 JSON Input value must be convertible to enum values. <code>Enum</code> <code>Any</code> Python Input value must be convertible to enum values. <code>Enum</code> <code>Enum</code> \u2713 Python <code>IPv4Address</code> <code>bytes</code> Python <code>IPv4Address</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**32</code> <code>IPv4Address</code> <code>str</code> \u2713 JSON <code>IPv4Address</code> <code>str</code> Python &amp; JSON <code>IPv4Address</code> <code>IPv4Address</code> \u2713 Python <code>IPv4Address</code> <code>IPv4Interface</code> \u2713 Python <code>IPv4Interface</code> <code>bytes</code> Python <code>IPv4Interface</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**32</code> <code>IPv4Interface</code> <code>str</code> \u2713 JSON <code>IPv4Interface</code> <code>str</code> Python &amp; JSON <code>IPv4Interface</code> <code>tuple</code> Python <code>IPv4Interface</code> <code>IPv4Address</code> Python <code>IPv4Interface</code> <code>IPv4Interface</code> \u2713 Python <code>IPv4Network</code> <code>bytes</code> Python <code>IPv4Network</code> <code>int</code> Python integer representing the IP network, must be less than <code>2**32</code> <code>IPv4Network</code> <code>str</code> \u2713 JSON <code>IPv4Network</code> <code>str</code> Python &amp; JSON <code>IPv4Network</code> <code>IPv4Address</code> Python <code>IPv4Network</code> <code>IPv4Interface</code> Python <code>IPv4Network</code> <code>IPv4Network</code> \u2713 Python <code>IPv6Address</code> <code>bytes</code> Python <code>IPv6Address</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**128</code> <code>IPv6Address</code> <code>str</code> \u2713 JSON <code>IPv6Address</code> <code>str</code> Python &amp; JSON <code>IPv6Address</code> <code>IPv6Address</code> \u2713 Python <code>IPv6Address</code> <code>IPv6Interface</code> \u2713 Python <code>IPv6Interface</code> <code>bytes</code> Python <code>IPv6Interface</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**128</code> <code>IPv6Interface</code> <code>str</code> \u2713 JSON <code>IPv6Interface</code> <code>str</code> Python &amp; JSON <code>IPv6Interface</code> <code>tuple</code> Python <code>IPv6Interface</code> <code>IPv6Address</code> Python <code>IPv6Interface</code> <code>IPv6Interface</code> \u2713 Python <code>IPv6Network</code> <code>bytes</code> Python <code>IPv6Network</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**128</code> <code>IPv6Network</code> <code>str</code> \u2713 JSON <code>IPv6Network</code> <code>str</code> Python &amp; JSON <code>IPv6Network</code> <code>IPv6Address</code> Python <code>IPv6Network</code> <code>IPv6Interface</code> Python <code>IPv6Network</code> <code>IPv6Network</code> \u2713 Python <code>InstanceOf</code> <code>-</code> JSON Never valid. <code>InstanceOf</code> <code>Any</code> \u2713 Python <code>isinstance()</code> check must return <code>True</code>. <code>IntEnum</code> <code>Any</code> \u2713 JSON Input value must be convertible to enum values. <code>IntEnum</code> <code>Any</code> Python Input value must be convertible to enum values. <code>IntEnum</code> <code>IntEnum</code> \u2713 Python <code>Iterable</code> <code>deque</code> \u2713 Python <code>Iterable</code> <code>frozenset</code> \u2713 Python <code>Iterable</code> <code>list</code> \u2713 Python <code>Iterable</code> <code>set</code> \u2713 Python <code>Iterable</code> <code>tuple</code> \u2713 Python <code>Iterable</code> <code>Array</code> \u2713 JSON <code>NamedTuple</code> <code>dict</code> \u2713 Python <code>NamedTuple</code> <code>list</code> \u2713 Python <code>NamedTuple</code> <code>namedtuple</code> \u2713 Python <code>NamedTuple</code> <code>tuple</code> \u2713 Python <code>NamedTuple</code> <code>Array</code> \u2713 JSON <code>NamedTuple</code> <code>NamedTuple</code> \u2713 Python <code>None</code> <code>None</code> \u2713 Python &amp; JSON <code>Path</code> <code>str</code> \u2713 JSON <code>Path</code> <code>str</code> Python <code>Path</code> <code>Path</code> \u2713 Python <code>Pattern</code> <code>bytes</code> \u2713 Python Input must be a valid pattern. <code>Pattern</code> <code>str</code> \u2713 Python &amp; JSON Input must be a valid pattern. <code>Sequence</code> <code>deque</code> Python <code>Sequence</code> <code>list</code> \u2713 Python <code>Sequence</code> <code>tuple</code> Python <code>Sequence</code> <code>Array</code> \u2713 JSON <code>TypedDict</code> <code>dict</code> \u2713 Python <code>TypedDict</code> <code>Any</code> \u2713 Python <code>TypedDict</code> <code>Mapping</code> Python Must implement the mapping interface and have an <code>items()</code> method. <code>TypedDict</code> <code>Object</code> \u2713 JSON <code>UUID</code> <code>str</code> \u2713 JSON <code>UUID</code> <code>str</code> Python <code>UUID</code> <code>UUID</code> \u2713 Python Field Type Input Strict Input Source Conditions <code>bool</code> <code>bool</code> \u2713 Python &amp; JSON <code>bool</code> <code>float</code> Python &amp; JSON Allowed values: <code>0.0, 1.0</code>. <code>bool</code> <code>int</code> Python &amp; JSON Allowed values: <code>0, 1</code>. <code>bool</code> <code>str</code> Python &amp; JSON Allowed values: <code>'f'</code>, <code>'n'</code>, <code>'no'</code>, <code>'off'</code>, <code>'false'</code>, <code>'False'</code>, <code>'t'</code>, <code>'y'</code>, <code>'on'</code>, <code>'yes'</code>, <code>'true'</code>, <code>'True'</code>. <code>bytes</code> <code>str</code> \u2713 JSON <code>callable</code> <code>-</code> JSON Never valid. <code>date</code> <code>float</code> Python &amp; JSON Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>date</code> <code>int</code> Python &amp; JSON Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>date</code> <code>str</code> Python &amp; JSON Format: <code>YYYY-MM-DD</code>. <code>datetime</code> <code>float</code> Python &amp; JSON Interpreted as seconds or ms from epoch, see speedate. <code>datetime</code> <code>int</code> Python &amp; JSON Interpreted as seconds or ms from epoch, see speedate. <code>datetime</code> <code>str</code> Python &amp; JSON Format: <code>YYYY-MM-DDTHH:MM:SS.f</code> or <code>YYYY-MM-DD</code>. See speedate. <code>deque</code> <code>Array</code> \u2713 JSON <code>dict</code> <code>Object</code> \u2713 JSON <code>float</code> <code>bool</code> Python &amp; JSON <code>float</code> <code>float</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>float</code> <code>int</code> \u2713 Python &amp; JSON <code>float</code> <code>str</code> Python &amp; JSON Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>frozenset</code> <code>Array</code> \u2713 JSON <code>int</code> <code>bool</code> Python &amp; JSON <code>int</code> <code>float</code> Python &amp; JSON Must be exact int, e.g. <code>val % 1 == 0</code>, raises error for <code>nan</code>, <code>inf</code>. <code>int</code> <code>int</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>int</code> <code>int</code> Python &amp; JSON <code>int</code> <code>str</code> Python &amp; JSON Must be numeric only, e.g. <code>[0-9]+</code>. <code>list</code> <code>Array</code> \u2713 JSON <code>namedtuple</code> <code>Array</code> \u2713 JSON <code>set</code> <code>Array</code> \u2713 JSON <code>str</code> <code>str</code> \u2713 Python &amp; JSON <code>time</code> <code>float</code> Python &amp; JSON Interpreted as seconds, range <code>0 - 86399.9*</code>. <code>time</code> <code>int</code> Python &amp; JSON Interpreted as seconds, range <code>0 - 86399</code>. <code>time</code> <code>str</code> Python &amp; JSON Format: <code>HH:MM:SS.FFFFFF</code>. See speedate. <code>timedelta</code> <code>float</code> Python &amp; JSON Interpreted as seconds. <code>timedelta</code> <code>int</code> Python &amp; JSON Interpreted as seconds. <code>timedelta</code> <code>str</code> Python &amp; JSON Format: <code>ISO8601</code>. See speedate. <code>tuple</code> <code>Array</code> \u2713 JSON <code>Any</code> <code>Any</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>float</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>int</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>str</code> \u2713 Python &amp; JSON <code>Decimal</code> <code>float</code> \u2713 JSON <code>Decimal</code> <code>float</code> Python &amp; JSON <code>Decimal</code> <code>int</code> \u2713 JSON <code>Decimal</code> <code>int</code> Python &amp; JSON <code>Decimal</code> <code>str</code> \u2713 JSON <code>Decimal</code> <code>str</code> Python &amp; JSON Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>Enum</code> <code>Any</code> \u2713 JSON Input value must be convertible to enum values. <code>IPv4Address</code> <code>str</code> \u2713 JSON <code>IPv4Address</code> <code>str</code> Python &amp; JSON <code>IPv4Interface</code> <code>str</code> \u2713 JSON <code>IPv4Interface</code> <code>str</code> Python &amp; JSON <code>IPv4Network</code> <code>str</code> \u2713 JSON <code>IPv4Network</code> <code>str</code> Python &amp; JSON <code>IPv6Address</code> <code>str</code> \u2713 JSON <code>IPv6Address</code> <code>str</code> Python &amp; JSON <code>IPv6Interface</code> <code>str</code> \u2713 JSON <code>IPv6Interface</code> <code>str</code> Python &amp; JSON <code>IPv6Network</code> <code>str</code> \u2713 JSON <code>IPv6Network</code> <code>str</code> Python &amp; JSON <code>InstanceOf</code> <code>-</code> JSON Never valid. <code>IntEnum</code> <code>Any</code> \u2713 JSON Input value must be convertible to enum values. <code>Iterable</code> <code>Array</code> \u2713 JSON <code>NamedTuple</code> <code>Array</code> \u2713 JSON <code>None</code> <code>None</code> \u2713 Python &amp; JSON <code>Path</code> <code>str</code> \u2713 JSON <code>Pattern</code> <code>str</code> \u2713 Python &amp; JSON Input must be a valid pattern. <code>Sequence</code> <code>Array</code> \u2713 JSON <code>TypedDict</code> <code>Object</code> \u2713 JSON <code>UUID</code> <code>str</code> \u2713 JSON Field Type Input Strict Input Source Conditions <code>bool</code> <code>bool</code> \u2713 Python &amp; JSON <code>bytes</code> <code>str</code> \u2713 JSON <code>deque</code> <code>Array</code> \u2713 JSON <code>dict</code> <code>Object</code> \u2713 JSON <code>float</code> <code>float</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>float</code> <code>int</code> \u2713 Python &amp; JSON <code>frozenset</code> <code>Array</code> \u2713 JSON <code>int</code> <code>int</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>list</code> <code>Array</code> \u2713 JSON <code>namedtuple</code> <code>Array</code> \u2713 JSON <code>set</code> <code>Array</code> \u2713 JSON <code>str</code> <code>str</code> \u2713 Python &amp; JSON <code>tuple</code> <code>Array</code> \u2713 JSON <code>Any</code> <code>Any</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>float</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>int</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>str</code> \u2713 Python &amp; JSON <code>Decimal</code> <code>float</code> \u2713 JSON <code>Decimal</code> <code>int</code> \u2713 JSON <code>Decimal</code> <code>str</code> \u2713 JSON <code>Enum</code> <code>Any</code> \u2713 JSON Input value must be convertible to enum values. <code>IPv4Address</code> <code>str</code> \u2713 JSON <code>IPv4Interface</code> <code>str</code> \u2713 JSON <code>IPv4Network</code> <code>str</code> \u2713 JSON <code>IPv6Address</code> <code>str</code> \u2713 JSON <code>IPv6Interface</code> <code>str</code> \u2713 JSON <code>IPv6Network</code> <code>str</code> \u2713 JSON <code>IntEnum</code> <code>Any</code> \u2713 JSON Input value must be convertible to enum values. <code>Iterable</code> <code>Array</code> \u2713 JSON <code>NamedTuple</code> <code>Array</code> \u2713 JSON <code>None</code> <code>None</code> \u2713 Python &amp; JSON <code>Path</code> <code>str</code> \u2713 JSON <code>Pattern</code> <code>str</code> \u2713 Python &amp; JSON Input must be a valid pattern. <code>Sequence</code> <code>Array</code> \u2713 JSON <code>TypedDict</code> <code>Object</code> \u2713 JSON <code>UUID</code> <code>str</code> \u2713 JSON Field Type Input Strict Input Source Conditions <code>bool</code> <code>bool</code> \u2713 Python &amp; JSON <code>bool</code> <code>float</code> Python &amp; JSON Allowed values: <code>0.0, 1.0</code>. <code>bool</code> <code>int</code> Python &amp; JSON Allowed values: <code>0, 1</code>. <code>bool</code> <code>str</code> Python &amp; JSON Allowed values: <code>'f'</code>, <code>'n'</code>, <code>'no'</code>, <code>'off'</code>, <code>'false'</code>, <code>'False'</code>, <code>'t'</code>, <code>'y'</code>, <code>'on'</code>, <code>'yes'</code>, <code>'true'</code>, <code>'True'</code>. <code>bool</code> <code>Decimal</code> Python Allowed values: <code>Decimal(0), Decimal(1)</code>. <code>bytes</code> <code>bytearray</code> Python <code>bytes</code> <code>bytes</code> \u2713 Python <code>bytes</code> <code>str</code> Python <code>callable</code> <code>Any</code> \u2713 Python <code>callable()</code> check must return <code>True</code>. <code>date</code> <code>bytes</code> Python Format: <code>YYYY-MM-DD</code> (UTF-8). <code>date</code> <code>date</code> \u2713 Python <code>date</code> <code>datetime</code> Python Must be exact date, eg. no <code>H</code>, <code>M</code>, <code>S</code>, <code>f</code>. <code>date</code> <code>float</code> Python &amp; JSON Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>date</code> <code>int</code> Python &amp; JSON Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>date</code> <code>str</code> Python &amp; JSON Format: <code>YYYY-MM-DD</code>. <code>date</code> <code>Decimal</code> Python Interpreted as seconds or ms from epoch. See speedate. Must be exact date. <code>datetime</code> <code>bytes</code> Python Format: <code>YYYY-MM-DDTHH:MM:SS.f</code> or <code>YYYY-MM-DD</code>. See speedate, (UTF-8). <code>datetime</code> <code>date</code> Python <code>datetime</code> <code>datetime</code> \u2713 Python <code>datetime</code> <code>float</code> Python &amp; JSON Interpreted as seconds or ms from epoch, see speedate. <code>datetime</code> <code>int</code> Python &amp; JSON Interpreted as seconds or ms from epoch, see speedate. <code>datetime</code> <code>str</code> Python &amp; JSON Format: <code>YYYY-MM-DDTHH:MM:SS.f</code> or <code>YYYY-MM-DD</code>. See speedate. <code>datetime</code> <code>Decimal</code> Python Interpreted as seconds or ms from epoch, see speedate. <code>deque</code> <code>deque</code> \u2713 Python <code>deque</code> <code>frozenset</code> Python <code>deque</code> <code>list</code> Python <code>deque</code> <code>set</code> Python <code>deque</code> <code>tuple</code> Python <code>dict</code> <code>dict</code> \u2713 Python <code>dict</code> <code>Mapping</code> Python Must implement the mapping interface and have an <code>items()</code> method. <code>float</code> <code>bool</code> Python &amp; JSON <code>float</code> <code>bytes</code> Python Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>float</code> <code>float</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>float</code> <code>int</code> \u2713 Python &amp; JSON <code>float</code> <code>str</code> Python &amp; JSON Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>float</code> <code>Decimal</code> Python <code>frozenset</code> <code>deque</code> Python <code>frozenset</code> <code>dict_keys</code> Python <code>frozenset</code> <code>dict_values</code> Python <code>frozenset</code> <code>frozenset</code> \u2713 Python <code>frozenset</code> <code>list</code> Python <code>frozenset</code> <code>set</code> Python <code>frozenset</code> <code>tuple</code> Python <code>int</code> <code>bool</code> Python &amp; JSON <code>int</code> <code>bytes</code> Python Must be numeric only, e.g. <code>[0-9]+</code>. <code>int</code> <code>float</code> Python &amp; JSON Must be exact int, e.g. <code>val % 1 == 0</code>, raises error for <code>nan</code>, <code>inf</code>. <code>int</code> <code>int</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>int</code> <code>int</code> Python &amp; JSON <code>int</code> <code>str</code> Python &amp; JSON Must be numeric only, e.g. <code>[0-9]+</code>. <code>int</code> <code>Decimal</code> Python Must be exact int, e.g. <code>val % 1 == 0</code>. <code>list</code> <code>deque</code> Python <code>list</code> <code>dict_keys</code> Python <code>list</code> <code>dict_values</code> Python <code>list</code> <code>frozenset</code> Python <code>list</code> <code>list</code> \u2713 Python <code>list</code> <code>set</code> Python <code>list</code> <code>tuple</code> Python <code>namedtuple</code> <code>dict</code> \u2713 Python <code>namedtuple</code> <code>list</code> \u2713 Python <code>namedtuple</code> <code>namedtuple</code> \u2713 Python <code>namedtuple</code> <code>tuple</code> \u2713 Python <code>namedtuple</code> <code>NamedTuple</code> \u2713 Python <code>set</code> <code>deque</code> Python <code>set</code> <code>dict_keys</code> Python <code>set</code> <code>dict_values</code> Python <code>set</code> <code>frozenset</code> Python <code>set</code> <code>list</code> Python <code>set</code> <code>set</code> \u2713 Python <code>set</code> <code>tuple</code> Python <code>str</code> <code>bytearray</code> Python Assumes UTF-8, error on unicode decoding error. <code>str</code> <code>bytes</code> Python Assumes UTF-8, error on unicode decoding error. <code>str</code> <code>str</code> \u2713 Python &amp; JSON <code>time</code> <code>bytes</code> Python Format: <code>HH:MM:SS.FFFFFF</code>. See speedate. <code>time</code> <code>float</code> Python &amp; JSON Interpreted as seconds, range <code>0 - 86399.9*</code>. <code>time</code> <code>int</code> Python &amp; JSON Interpreted as seconds, range <code>0 - 86399</code>. <code>time</code> <code>str</code> Python &amp; JSON Format: <code>HH:MM:SS.FFFFFF</code>. See speedate. <code>time</code> <code>time</code> \u2713 Python <code>time</code> <code>Decimal</code> Python Interpreted as seconds, range <code>0 - 86399.9*</code>. <code>timedelta</code> <code>bytes</code> Python Format: <code>ISO8601</code>. See speedate, (UTF-8). <code>timedelta</code> <code>float</code> Python &amp; JSON Interpreted as seconds. <code>timedelta</code> <code>int</code> Python &amp; JSON Interpreted as seconds. <code>timedelta</code> <code>str</code> Python &amp; JSON Format: <code>ISO8601</code>. See speedate. <code>timedelta</code> <code>timedelta</code> \u2713 Python <code>timedelta</code> <code>Decimal</code> Python Interpreted as seconds. <code>tuple</code> <code>deque</code> Python <code>tuple</code> <code>dict_keys</code> Python <code>tuple</code> <code>dict_values</code> Python <code>tuple</code> <code>frozenset</code> Python <code>tuple</code> <code>list</code> Python <code>tuple</code> <code>set</code> Python <code>tuple</code> <code>tuple</code> \u2713 Python <code>type</code> <code>type</code> \u2713 Python <code>Any</code> <code>Any</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>float</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>int</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>str</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>Decimal</code> \u2713 Python <code>Decimal</code> <code>float</code> Python &amp; JSON <code>Decimal</code> <code>int</code> Python &amp; JSON <code>Decimal</code> <code>str</code> Python &amp; JSON Must match <code>[0-9]+(\\.[0-9]+)?</code>. <code>Decimal</code> <code>Decimal</code> \u2713 Python <code>Enum</code> <code>Any</code> Python Input value must be convertible to enum values. <code>Enum</code> <code>Enum</code> \u2713 Python <code>IPv4Address</code> <code>bytes</code> Python <code>IPv4Address</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**32</code> <code>IPv4Address</code> <code>str</code> Python &amp; JSON <code>IPv4Address</code> <code>IPv4Address</code> \u2713 Python <code>IPv4Address</code> <code>IPv4Interface</code> \u2713 Python <code>IPv4Interface</code> <code>bytes</code> Python <code>IPv4Interface</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**32</code> <code>IPv4Interface</code> <code>str</code> Python &amp; JSON <code>IPv4Interface</code> <code>tuple</code> Python <code>IPv4Interface</code> <code>IPv4Address</code> Python <code>IPv4Interface</code> <code>IPv4Interface</code> \u2713 Python <code>IPv4Network</code> <code>bytes</code> Python <code>IPv4Network</code> <code>int</code> Python integer representing the IP network, must be less than <code>2**32</code> <code>IPv4Network</code> <code>str</code> Python &amp; JSON <code>IPv4Network</code> <code>IPv4Address</code> Python <code>IPv4Network</code> <code>IPv4Interface</code> Python <code>IPv4Network</code> <code>IPv4Network</code> \u2713 Python <code>IPv6Address</code> <code>bytes</code> Python <code>IPv6Address</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**128</code> <code>IPv6Address</code> <code>str</code> Python &amp; JSON <code>IPv6Address</code> <code>IPv6Address</code> \u2713 Python <code>IPv6Address</code> <code>IPv6Interface</code> \u2713 Python <code>IPv6Interface</code> <code>bytes</code> Python <code>IPv6Interface</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**128</code> <code>IPv6Interface</code> <code>str</code> Python &amp; JSON <code>IPv6Interface</code> <code>tuple</code> Python <code>IPv6Interface</code> <code>IPv6Address</code> Python <code>IPv6Interface</code> <code>IPv6Interface</code> \u2713 Python <code>IPv6Network</code> <code>bytes</code> Python <code>IPv6Network</code> <code>int</code> Python integer representing the IP address, must be less than <code>2**128</code> <code>IPv6Network</code> <code>str</code> Python &amp; JSON <code>IPv6Network</code> <code>IPv6Address</code> Python <code>IPv6Network</code> <code>IPv6Interface</code> Python <code>IPv6Network</code> <code>IPv6Network</code> \u2713 Python <code>InstanceOf</code> <code>Any</code> \u2713 Python <code>isinstance()</code> check must return <code>True</code>. <code>IntEnum</code> <code>Any</code> Python Input value must be convertible to enum values. <code>IntEnum</code> <code>IntEnum</code> \u2713 Python <code>Iterable</code> <code>deque</code> \u2713 Python <code>Iterable</code> <code>frozenset</code> \u2713 Python <code>Iterable</code> <code>list</code> \u2713 Python <code>Iterable</code> <code>set</code> \u2713 Python <code>Iterable</code> <code>tuple</code> \u2713 Python <code>NamedTuple</code> <code>dict</code> \u2713 Python <code>NamedTuple</code> <code>list</code> \u2713 Python <code>NamedTuple</code> <code>namedtuple</code> \u2713 Python <code>NamedTuple</code> <code>tuple</code> \u2713 Python <code>NamedTuple</code> <code>NamedTuple</code> \u2713 Python <code>None</code> <code>None</code> \u2713 Python &amp; JSON <code>Path</code> <code>str</code> Python <code>Path</code> <code>Path</code> \u2713 Python <code>Pattern</code> <code>bytes</code> \u2713 Python Input must be a valid pattern. <code>Pattern</code> <code>str</code> \u2713 Python &amp; JSON Input must be a valid pattern. <code>Sequence</code> <code>deque</code> Python <code>Sequence</code> <code>list</code> \u2713 Python <code>Sequence</code> <code>tuple</code> Python <code>TypedDict</code> <code>dict</code> \u2713 Python <code>TypedDict</code> <code>Any</code> \u2713 Python <code>TypedDict</code> <code>Mapping</code> Python Must implement the mapping interface and have an <code>items()</code> method. <code>UUID</code> <code>str</code> Python <code>UUID</code> <code>UUID</code> \u2713 Python Field Type Input Strict Input Source Conditions <code>bool</code> <code>bool</code> \u2713 Python &amp; JSON <code>bytes</code> <code>bytes</code> \u2713 Python <code>callable</code> <code>Any</code> \u2713 Python <code>callable()</code> check must return <code>True</code>. <code>date</code> <code>date</code> \u2713 Python <code>datetime</code> <code>datetime</code> \u2713 Python <code>deque</code> <code>deque</code> \u2713 Python <code>dict</code> <code>dict</code> \u2713 Python <code>float</code> <code>float</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>float</code> <code>int</code> \u2713 Python &amp; JSON <code>frozenset</code> <code>frozenset</code> \u2713 Python <code>int</code> <code>int</code> \u2713 Python &amp; JSON <code>bool</code> is explicitly forbidden. <code>list</code> <code>list</code> \u2713 Python <code>namedtuple</code> <code>dict</code> \u2713 Python <code>namedtuple</code> <code>list</code> \u2713 Python <code>namedtuple</code> <code>namedtuple</code> \u2713 Python <code>namedtuple</code> <code>tuple</code> \u2713 Python <code>namedtuple</code> <code>NamedTuple</code> \u2713 Python <code>set</code> <code>set</code> \u2713 Python <code>str</code> <code>str</code> \u2713 Python &amp; JSON <code>time</code> <code>time</code> \u2713 Python <code>timedelta</code> <code>timedelta</code> \u2713 Python <code>tuple</code> <code>tuple</code> \u2713 Python <code>type</code> <code>type</code> \u2713 Python <code>Any</code> <code>Any</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>float</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>int</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>str</code> \u2713 Python &amp; JSON <code>ByteSize</code> <code>Decimal</code> \u2713 Python <code>Decimal</code> <code>Decimal</code> \u2713 Python <code>Enum</code> <code>Enum</code> \u2713 Python <code>IPv4Address</code> <code>IPv4Address</code> \u2713 Python <code>IPv4Address</code> <code>IPv4Interface</code> \u2713 Python <code>IPv4Interface</code> <code>IPv4Interface</code> \u2713 Python <code>IPv4Network</code> <code>IPv4Network</code> \u2713 Python <code>IPv6Address</code> <code>IPv6Address</code> \u2713 Python <code>IPv6Address</code> <code>IPv6Interface</code> \u2713 Python <code>IPv6Interface</code> <code>IPv6Interface</code> \u2713 Python <code>IPv6Network</code> <code>IPv6Network</code> \u2713 Python <code>InstanceOf</code> <code>Any</code> \u2713 Python <code>isinstance()</code> check must return <code>True</code>. <code>IntEnum</code> <code>IntEnum</code> \u2713 Python <code>Iterable</code> <code>deque</code> \u2713 Python <code>Iterable</code> <code>frozenset</code> \u2713 Python <code>Iterable</code> <code>list</code> \u2713 Python <code>Iterable</code> <code>set</code> \u2713 Python <code>Iterable</code> <code>tuple</code> \u2713 Python <code>NamedTuple</code> <code>dict</code> \u2713 Python <code>NamedTuple</code> <code>list</code> \u2713 Python <code>NamedTuple</code> <code>namedtuple</code> \u2713 Python <code>NamedTuple</code> <code>tuple</code> \u2713 Python <code>NamedTuple</code> <code>NamedTuple</code> \u2713 Python <code>None</code> <code>None</code> \u2713 Python &amp; JSON <code>Path</code> <code>Path</code> \u2713 Python <code>Pattern</code> <code>bytes</code> \u2713 Python Input must be a valid pattern. <code>Pattern</code> <code>str</code> \u2713 Python &amp; JSON Input must be a valid pattern. <code>Sequence</code> <code>list</code> \u2713 Python <code>TypedDict</code> <code>dict</code> \u2713 Python <code>TypedDict</code> <code>Any</code> \u2713 Python <code>UUID</code> <code>UUID</code> \u2713 Python"},{"location":"concepts/dataclasses/","title":"Dataclasses","text":"API \u6587\u6863 <p><code>@pydantic.dataclasses.dataclass</code></p> <p>\u5982\u679c\u60a8\u4e0d\u60f3\u4f7f\u7528 Pydantic \u7684 <code>BaseModel</code>\uff0c\u60a8\u53ef\u4ee5\u5728\u6807\u51c6 dataclasses \u4e0a\u83b7\u5f97\u76f8\u540c\u7684\u6570\u636e\u9a8c\u8bc1\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n\"\"\"\nUser(id=42, name='John Doe', signup_ts=datetime.datetime(2032, 6, 21, 12, 0))\n\"\"\"\n</code></pre> <pre><code>from datetime import datetime\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n\"\"\"\nUser(id=42, name='John Doe', signup_ts=datetime.datetime(2032, 6, 21, 12, 0))\n\"\"\"\n</code></pre> <p>Note</p> <p>\u8bf7\u8bb0\u4f4f\uff0cPydantic \u6570\u636e\u7c7b\u4e0d\u662f Pydantic \u6a21\u578b \u7684\u66ff\u4ee3\u54c1\u3002 \u5b83\u4eec\u63d0\u4f9b\u4e86\u4e0e\u6807\u51c6\u5e93\u6570\u636e\u7c7b\u7c7b\u4f3c\u7684\u529f\u80fd\uff0c\u4f46\u589e\u52a0\u4e86 Pydantic \u9a8c\u8bc1\u3002</p> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528 Pydantic \u6a21\u578b\u8fdb\u884c\u5b50\u7c7b\u5316\u662f\u66f4\u597d\u7684\u9009\u62e9\u3002</p> <p>\u66f4\u591a\u4fe1\u606f\u548c\u8ba8\u8bba\u8bf7\u53c2\u89c1 pydantic/pydantic#710\u3002</p> <p>Pydantic \u6570\u636e\u7c7b\u548c\u6a21\u578b\u4e4b\u95f4\u7684\u76f8\u4f3c\u6027\u5305\u62ec\u5bf9\u4ee5\u4e0b\u5185\u5bb9\u7684\u652f\u6301\uff1a</p> <ul> <li>\u914d\u7f6e \u652f\u6301</li> <li>\u5d4c\u5957 \u7c7b</li> <li>\u6cdb\u578b</li> </ul> <p>Pydantic \u6570\u636e\u7c7b\u548c\u6a21\u578b\u4e4b\u95f4\u7684\u4e00\u4e9b\u5dee\u5f02\u5305\u62ec\uff1a</p> <ul> <li>\u9a8c\u8bc1\u5668</li> <li>\u4e0e <code>extra</code> \u914d\u7f6e\u503c\u7684\u884c\u4e3a</li> </ul> <p>\u4e0e Pydantic \u6a21\u578b\u7c7b\u4f3c\uff0c\u7528\u4e8e\u5b9e\u4f8b\u5316\u6570\u636e\u7c7b\u7684\u53c2\u6570\u4f1a\u88ab\u590d\u5236\u3002</p> <p>\u8981\u4f7f\u7528\u5404\u79cd\u65b9\u6cd5\u6765\u9a8c\u8bc1\u3001\u8f6c\u50a8\u548c\u751f\u6210 JSON \u6a21\u5f0f\uff0c \u60a8\u53ef\u4ee5\u4f7f\u7528 <code>TypeAdapter</code> \u5305\u88c5\u6570\u636e\u7c7b\u5e76\u5229\u7528\u5176\u65b9\u6cd5\u3002</p> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 Pydantic \u7684 <code>Field()</code> \u548c\u6807\u51c6\u5e93\u7684 <code>field()</code> \u51fd\u6570\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>import dataclasses\nfrom typing import Optional\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata={'title': 'The age of the user', 'description': 'do not lie!'},\n    )\n    height: Optional[int] = Field(\n        default=None, title='The height in cm', ge=50, le=300\n    )\n\n\nuser = User(id='42', height='250')\nprint(user)\n#&gt; User(id=42, name='John Doe', friends=[0], age=None, height=250)\n</code></pre> <pre><code>import dataclasses\n\nfrom pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: int | None = dataclasses.field(\n        default=None,\n        metadata={'title': 'The age of the user', 'description': 'do not lie!'},\n    )\n    height: int | None = Field(\n        default=None, title='The height in cm', ge=50, le=300\n    )\n\n\nuser = User(id='42', height='250')\nprint(user)\n#&gt; User(id=42, name='John Doe', friends=[0], age=None, height=250)\n</code></pre> <p>Pydantic <code>@dataclass</code> \u88c5\u9970\u5668\u63a5\u53d7\u4e0e\u6807\u51c6\u88c5\u9970\u5668\u76f8\u540c\u7684\u53c2\u6570\uff0c \u4f46\u989d\u5916\u589e\u52a0\u4e86\u4e00\u4e2a <code>config</code> \u53c2\u6570\u3002</p>"},{"location":"concepts/dataclasses/#dataclass-config","title":"\u6570\u636e\u7c7b\u914d\u7f6e","text":"<p>\u5982\u679c\u60a8\u60f3\u50cf\u4f7f\u7528 <code>BaseModel</code> \u4e00\u6837\u4fee\u6539\u914d\u7f6e\uff0c\u60a8\u6709\u4e24\u4e2a\u9009\u9879\uff1a</p> <ul> <li>\u4f7f\u7528\u88c5\u9970\u5668\u7684 <code>config</code> \u53c2\u6570\u3002</li> <li>\u4f7f\u7528 <code>__pydantic_config__</code> \u5c5e\u6027\u5b9a\u4e49\u914d\u7f6e\u3002</li> </ul> <pre><code>from pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass\n\n\n# \u9009\u9879 1 -- \u4f7f\u7528\u88c5\u9970\u5668\u53c2\u6570\uff1a\n@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\nclass MyDataclass1:\n    a: int\n\n\n# \u9009\u9879 2 -- \u4f7f\u7528\u5c5e\u6027\uff1a\n@dataclass\nclass MyDataclass2:\n    a: int\n\n    __pydantic_config__ = ConfigDict(validate_assignment=True)\n</code></pre> <ol> <li>\u60a8\u53ef\u4ee5\u5728 API \u53c2\u8003 \u4e2d\u9605\u8bfb\u66f4\u591a\u5173\u4e8e <code>validate_assignment</code> \u7684\u4fe1\u606f\u3002</li> </ol> <p>Note</p> <p>\u867d\u7136 Pydantic \u6570\u636e\u7c7b\u652f\u6301 <code>extra</code> \u914d\u7f6e\u503c\uff0c\u4f46\u6807\u51c6\u5e93\u6570\u636e\u7c7b\u7684\u67d0\u4e9b\u9ed8\u8ba4 \u884c\u4e3a\u53ef\u80fd\u4f1a\u5360\u4e3b\u5bfc\u5730\u4f4d\u3002\u4f8b\u5982\uff0c\u5728 Pydantic \u6570\u636e\u7c7b\u4e0a\u5b58\u5728\u7684\u4efb\u4f55\u989d\u5916\u5b57\u6bb5\uff08\u5f53 <code>extra</code> \u8bbe\u7f6e\u4e3a <code>'allow'</code> \u65f6\uff09\u5728\u6570\u636e\u7c7b\u7684\u5b57\u7b26\u4e32\u8868\u793a\u4e2d\u4f1a\u88ab\u7701\u7565\u3002 \u4e5f\u6ca1\u6709\u529e\u6cd5\u4f7f\u7528 <code>__pydantic_extra__</code> \u5c5e\u6027\u63d0\u4f9b\u9a8c\u8bc1\u3002</p>"},{"location":"concepts/dataclasses/#_1","title":"\u91cd\u5efa\u6570\u636e\u7c7b\u6a21\u5f0f","text":"<p><code>rebuild_dataclass()</code> \u51fd\u6570\u53ef\u7528\u4e8e\u91cd\u5efa\u6570\u636e\u7c7b\u7684\u6838\u5fc3\u6a21\u5f0f\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u91cd\u5efa\u6a21\u578b\u6a21\u5f0f\u90e8\u5206\u3002</p>"},{"location":"concepts/dataclasses/#pydantic","title":"\u6807\u51c6\u5e93\u6570\u636e\u7c7b\u548c Pydantic \u6570\u636e\u7c7b","text":""},{"location":"concepts/dataclasses/#_2","title":"\u4ece\u6807\u51c6\u5e93\u6570\u636e\u7c7b\u7ee7\u627f","text":"<p>\u6807\u51c6\u5e93\u6570\u636e\u7c7b\uff08\u5d4c\u5957\u6216\u4e0d\u5d4c\u5957\uff09\u4e5f\u53ef\u4ee5\u88ab\u7ee7\u627f\uff0cPydantic \u5c06\u81ea\u52a8\u9a8c\u8bc1\u6240\u6709\u7ee7\u627f\u7684\u5b57\u6bb5\u3002</p> <pre><code>import dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n#&gt; X(z=3, y=2, x=1)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for X\n    z\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='pika', input_type=str]\n    \"\"\"\n</code></pre> <p>\u88c5\u9970\u5668\u4e5f\u53ef\u4ee5\u76f4\u63a5\u5e94\u7528\u4e8e\u6807\u51c6\u5e93\u6570\u636e\u7c7b\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u5c06\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5b50\u7c7b\uff1a</p> <pre><code>import dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass A:\n    a: int\n\n\nPydanticA = pydantic.dataclasses.dataclass(A)\nprint(PydanticA(a='1'))\n#&gt; A(a=1)\n</code></pre>"},{"location":"concepts/dataclasses/#basemodel","title":"\u5728 <code>BaseModel</code> \u4e2d\u4f7f\u7528\u6807\u51c6\u5e93\u6570\u636e\u7c7b","text":"<p>\u5f53\u6807\u51c6\u5e93\u6570\u636e\u7c7b\u5728 Pydantic \u6a21\u578b\u3001Pydantic \u6570\u636e\u7c7b\u6216 <code>TypeAdapter</code> \u4e2d\u4f7f\u7528\u65f6\uff0c \u5c06\u5e94\u7528\u9a8c\u8bc1\uff08\u5e76\u4e14\u914d\u7f6e\u4fdd\u6301\u4e0d\u53d8\uff09\u3002\u8fd9\u610f\u5473\u7740\u4f7f\u7528\u6807\u51c6\u5e93\u6216 Pydantic \u6570\u636e\u7c7b\u4f5c\u4e3a\u5b57\u6bb5\u6ce8\u91ca\u5728\u529f\u80fd\u4e0a\u662f\u7b49\u6548\u7684\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>import dataclasses\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # \u5fc5\u9700\uff0c\u4ee5\u4fbf pydantic \u91cd\u65b0\u9a8c\u8bc1\u6a21\u578b\u5c5e\u6027\uff1a\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: Optional[User] = None\n\n\n# \u5982\u9884\u671f\u7684\u90a3\u6837\uff0c\u6ca1\u6709\u8fdb\u884c\u9a8c\u8bc1\uff1a\nuser = User(name=['not', 'a', 'string'])\nprint(user)\n#&gt; User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #&gt; cannot assign to field 'name'\n</code></pre> <pre><code>import dataclasses\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # \u5fc5\u9700\uff0c\u4ee5\u4fbf pydantic \u91cd\u65b0\u9a8c\u8bc1\u6a21\u578b\u5c5e\u6027\uff1a\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: User | None = None\n\n\n# \u5982\u9884\u671f\u7684\u90a3\u6837\uff0c\u6ca1\u6709\u8fdb\u884c\u9a8c\u8bc1\uff1a\nuser = User(name=['not', 'a', 'string'])\nprint(user)\n#&gt; User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #&gt; cannot assign to field 'name'\n</code></pre>"},{"location":"concepts/dataclasses/#_3","title":"\u4f7f\u7528\u81ea\u5b9a\u4e49\u7c7b\u578b","text":"<p>\u5982\u4e0a\u6240\u8ff0\uff0c\u9a8c\u8bc1\u5e94\u7528\u4e8e\u6807\u51c6\u5e93\u6570\u636e\u7c7b\u3002\u5982\u679c\u60a8\u4f7f\u7528\u81ea\u5b9a\u4e49\u7c7b\u578b\uff0c\u5728\u5c1d\u8bd5\u5f15\u7528\u6570\u636e\u7c7b\u65f6\u4f1a\u51fa\u9519\u3002\u8981\u89c4\u907f \u6b64\u95ee\u9898\uff0c\u60a8\u53ef\u4ee5\u5728\u6570\u636e\u7c7b\u4e0a\u8bbe\u7f6e <code>arbitrary_types_allowed</code> \u914d\u7f6e\u503c\uff1a</p> <pre><code>import dataclasses\n\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.errors import PydanticSchemaGenerationError\n\n\nclass ArbitraryType:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return f'ArbitraryType(value={self.value!r})'\n\n\n@dataclasses.dataclass\nclass DC:\n    a: ArbitraryType\n    b: str\n\n\n# \u6709\u6548\uff0c\u56e0\u4e3a\u5b83\u662f\u6ca1\u6709\u9a8c\u8bc1\u7684\u6807\u51c6\u5e93\u6570\u636e\u7c7b\uff1a\nmy_dc = DC(a=ArbitraryType(value=3), b='qwe')\n\ntry:\n\n    class Model(BaseModel):\n        dc: DC\n        other: str\n\n    # \u65e0\u6548\uff0c\u56e0\u4e3a dc \u73b0\u5728\u4f7f\u7528 pydantic \u8fdb\u884c\u9a8c\u8bc1\uff0c\u800c ArbitraryType \u4e0d\u662f\u5df2\u77e5\u7c7b\u578b\n    Model(dc=my_dc, other='other')\n\nexcept PydanticSchemaGenerationError as e:\n    print(e.message)\n    \"\"\"\n    Unable to generate pydantic-core schema for &lt;class '__main__.ArbitraryType'&gt;. Set `arbitrary_types_allowed=True` in the model_config to ignore this error or implement `__get_pydantic_core_schema__` on your type to fully support it.\n\n    If you got this error by calling handler(&lt;some type&gt;) within `__get_pydantic_core_schema__` then you likely need to call `handler.generate_schema(&lt;some type&gt;)` since we do not call `__get_pydantic_core_schema__` on `&lt;some type&gt;` otherwise to avoid infinite recursion.\n    \"\"\"\n\n\n# \u6709\u6548\uff0c\u56e0\u4e3a\u6211\u4eec\u8bbe\u7f6e\u4e86 arbitrary_types_allowed=True\uff0c\u5e76\u4e14\u8be5\u914d\u7f6e\u4f1a\u4f20\u9012\u5230\u5d4c\u5957\u7684\u666e\u901a\u6570\u636e\u7c7b\nclass Model(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    dc: DC\n    other: str\n\n\nm = Model(dc=my_dc, other='other')\nprint(repr(m))\n#&gt; Model(dc=DC(a=ArbitraryType(value=3), b='qwe'), other='other')\n</code></pre>"},{"location":"concepts/dataclasses/#pydantic_1","title":"\u68c0\u67e5\u6570\u636e\u7c7b\u662f\u5426\u4e3a Pydantic \u6570\u636e\u7c7b","text":"<p>Pydantic \u6570\u636e\u7c7b\u4ecd\u7136\u88ab\u8ba4\u4e3a\u662f\u6570\u636e\u7c7b\uff0c\u56e0\u6b64\u4f7f\u7528 <code>dataclasses.is_dataclass()</code> \u5c06\u8fd4\u56de <code>True</code>\u3002\u8981\u68c0\u67e5\u7c7b\u578b\u662f\u5426\u7279\u5b9a\u4e3a Pydantic \u6570\u636e\u7c7b\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>is_pydantic_dataclass()</code> \u51fd\u6570\u3002</p> <pre><code>import dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass StdLibDataclass:\n    id: int\n\n\nPydanticDataclass = pydantic.dataclasses.dataclass(StdLibDataclass)\n\nprint(dataclasses.is_dataclass(StdLibDataclass))\n#&gt; True\nprint(pydantic.dataclasses.is_pydantic_dataclass(StdLibDataclass))\n#&gt; False\n\nprint(dataclasses.is_dataclass(PydanticDataclass))\n#&gt; True\nprint(pydantic.dataclasses.is_pydantic_dataclass(PydanticDataclass))\n#&gt; True\n</code></pre>"},{"location":"concepts/dataclasses/#validators-and-initialization-hooks","title":"\u9a8c\u8bc1\u5668\u548c\u521d\u59cb\u5316\u94a9\u5b50","text":"<p>\u9a8c\u8bc1\u5668\u4e5f\u9002\u7528\u4e8e Pydantic \u6570\u636e\u7c7b\uff1a</p> <pre><code>from pydantic import field_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    product_id: str  # \u5e94\u8be5\u662f\u4e00\u4e2a\u4e94\u4f4d\u6570\u5b57\u7b26\u4e32\uff0c\u53ef\u80fd\u6709\u524d\u5bfc\u96f6\n\n    @field_validator('product_id', mode='before')\n    @classmethod\n    def convert_int_serial(cls, v):\n        if isinstance(v, int):\n            v = str(v).zfill(5)\n        return v\n\n\nprint(DemoDataclass(product_id='01234'))\n#&gt; DemoDataclass(product_id='01234')\nprint(DemoDataclass(product_id=2468))\n#&gt; DemoDataclass(product_id='02468')\n</code></pre> <p>\u6570\u636e\u7c7b\u7684 <code>__post_init__()</code> \u65b9\u6cd5\u4e5f\u53d7\u652f\u6301\uff0c\u5e76\u4e14\u5c06\u5728 before \u548c after \u6a21\u578b\u9a8c\u8bc1\u5668\u8c03\u7528\u4e4b\u95f4\u88ab\u8c03\u7528\u3002</p> Example <pre><code>from pydantic_core import ArgsKwargs\nfrom typing_extensions import Self\n\nfrom pydantic import model_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    @model_validator(mode='before')\n    @classmethod\n    def before(cls, values: ArgsKwargs) -&gt; ArgsKwargs:\n        print(f'First: {values}')  # (1)!\n        \"\"\"\n        First: ArgsKwargs((), {'birth': {'year': 1995, 'month': 3, 'day': 2}})\n        \"\"\"\n        return values\n\n    @model_validator(mode='after')\n    def after(self) -&gt; Self:\n        print(f'Third: {self}')\n        #&gt; Third: User(birth=Birth(year=1995, month=3, day=2))\n        return self\n\n    def __post_init__(self):\n        print(f'Second: {self.birth}')\n        #&gt; Second: Birth(year=1995, month=3, day=2)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n</code></pre> <ol> <li>\u4e0e Pydantic \u6a21\u578b\u4e0d\u540c\uff0c<code>values</code> \u53c2\u6570\u7684\u7c7b\u578b\u662f <code>ArgsKwargs</code></li> </ol>"},{"location":"concepts/experimental/","title":"\u5b9e\u9a8c\u7279\u6027","text":"<p>\u5728\u672c\u8282\u4e2d\uff0c\u60a8\u5c06\u627e\u5230 Pydantic \u4e2d\u65b0\u7684\u5b9e\u9a8c\u7279\u6027\u7684\u6587\u6863\u3002\u8fd9\u4e9b\u7279\u6027\u53ef\u80fd\u4f1a\u53d1\u751f\u53d8\u5316\u6216\u88ab\u79fb\u9664\uff0c\u5728\u5c06\u5b83\u4eec\u4f5c\u4e3a Pydantic \u7684\u6c38\u4e45\u90e8\u5206\u4e4b\u524d\uff0c\u6211\u4eec\u6b63\u5728\u5bfb\u6c42\u53cd\u9988\u548c\u5efa\u8bae\u3002</p> <p>\u6709\u5173\u5b9e\u9a8c\u7279\u6027\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6211\u4eec\u7684\u7248\u672c\u7b56\u7565\u3002</p>"},{"location":"concepts/experimental/#feedback","title":"\u53cd\u9988","text":"<p>\u6211\u4eec\u6b22\u8fce\u5bf9\u5b9e\u9a8c\u7279\u6027\u7684\u53cd\u9988\uff01\u8bf7\u5728 Pydantic GitHub \u4ed3\u5e93 \u4e0a\u521b\u5efa\u4e00\u4e2a issue \u6765\u5206\u4eab\u60a8\u7684\u60f3\u6cd5\u3001\u8bf7\u6c42\u6216\u5efa\u8bae\u3002</p> <p>\u6211\u4eec\u4e5f\u9f13\u52b1\u60a8\u9605\u8bfb\u73b0\u6709\u7684\u53cd\u9988\u5e76\u5728\u73b0\u6709 issue \u4e2d\u6dfb\u52a0\u60a8\u7684\u60f3\u6cd5\u3002</p>"},{"location":"concepts/experimental/#pipeline-api","title":"Pipeline API","text":"<p>Pydantic v2.8.0 \u5f15\u5165\u4e86\u4e00\u4e2a\u5b9e\u9a8c\u6027\u7684 \"pipeline\" API\uff0c\u5141\u8bb8\u4ee5\u6bd4\u73b0\u6709 API \u66f4\u7c7b\u578b\u5b89\u5168\u7684\u65b9\u5f0f\u7ec4\u5408\u89e3\u6790\uff08\u9a8c\u8bc1\uff09\u3001\u7ea6\u675f\u548c\u8f6c\u6362\u3002\u6b64 API \u53ef\u80fd\u4f1a\u53d1\u751f\u53d8\u5316\u6216\u88ab\u79fb\u9664\uff0c\u5728\u5c06\u5176\u4f5c\u4e3a Pydantic \u7684\u6c38\u4e45\u90e8\u5206\u4e4b\u524d\uff0c\u6211\u4eec\u6b63\u5728\u5bfb\u6c42\u53cd\u9988\u548c\u5efa\u8bae\u3002</p> API \u6587\u6863 <p><code>pydantic.experimental.pipeline</code></p> <p>\u901a\u5e38\uff0cpipeline API \u7528\u4e8e\u5b9a\u4e49\u5728\u9a8c\u8bc1\u671f\u95f4\u5e94\u7528\u4e8e\u4f20\u5165\u6570\u636e\u7684\u4e00\u7cfb\u5217\u6b65\u9aa4\u3002Pipeline API \u88ab\u8bbe\u8ba1\u4e3a\u6bd4\u73b0\u6709\u7684 Pydantic API \u66f4\u7c7b\u578b\u5b89\u5168\u548c\u53ef\u7ec4\u5408\u3002</p> <p>\u7ba1\u9053\u4e2d\u7684\u6bcf\u4e2a\u6b65\u9aa4\u53ef\u4ee5\u662f\uff1a</p> <ul> <li>\u9a8c\u8bc1\u6b65\u9aa4\uff1a\u5bf9\u63d0\u4f9b\u7684\u7c7b\u578b\u8fd0\u884c pydantic \u9a8c\u8bc1</li> <li>\u8f6c\u6362\u6b65\u9aa4\uff1a\u4fee\u6539\u6570\u636e</li> <li>\u7ea6\u675f\u6b65\u9aa4\uff1a\u6839\u636e\u6761\u4ef6\u68c0\u67e5\u6570\u636e</li> <li>\u65ad\u8a00\u6b65\u9aa4\uff1a\u6839\u636e\u6761\u4ef6\u68c0\u67e5\u6570\u636e\uff0c\u5982\u679c\u8fd4\u56de <code>False</code> \u5219\u5f15\u53d1\u9519\u8bef</li> </ul> <p>\u8bf7\u6ce8\u610f\uff0c\u4ee5\u4e0b\u793a\u4f8b\u8bd5\u56fe\u4ee5\u590d\u6742\u6027\u4e3a\u4ee3\u4ef7\u505a\u5230\u8be6\u5c3d\uff1a\u5982\u679c\u60a8\u53d1\u73b0\u81ea\u5df1\u5728\u7c7b\u578b\u6ce8\u89e3\u4e2d\u7f16\u5199\u8fd9\u4e48\u591a\u8f6c\u6362\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u8003\u8651\u4f7f\u7528 <code>UserIn</code> \u548c <code>UserOut</code> \u6a21\u578b\uff08\u5982\u4e0b\u4f8b\u6240\u793a\uff09\u6216\u7c7b\u4f3c\u7684\u6a21\u5f0f\uff0c\u901a\u8fc7\u60ef\u7528\u7684\u666e\u901a Python \u4ee3\u7801\u8fdb\u884c\u8f6c\u6362\u3002 \u8fd9\u4e9b API \u9002\u7528\u4e8e\u4ee3\u7801\u8282\u7701\u663e\u8457\u4e14\u589e\u52a0\u7684\u590d\u6742\u6027\u76f8\u5bf9\u8f83\u5c0f\u7684\u60c5\u51b5\u3002</p> <pre><code>from __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.pipeline import validate_as\n\n\nclass User(BaseModel):\n    name: Annotated[str, validate_as(str).str_lower()]  # (1)!\n    age: Annotated[int, validate_as(int).gt(0)]  # (2)!\n    username: Annotated[str, validate_as(str).str_pattern(r'[a-z]+')]  # (3)!\n    password: Annotated[\n        str,\n        validate_as(str)\n        .transform(str.lower)\n        .predicate(lambda x: x != 'password'),  # (4)!\n    ]\n    favorite_number: Annotated[  # (5)!\n        int,\n        (validate_as(int) | validate_as(str).str_strip().validate_as(int)).gt(\n            0\n        ),\n    ]\n    friends: Annotated[list[User], validate_as(...).len(0, 100)]  # (6)!\n    bio: Annotated[\n        datetime,\n        validate_as(int)\n        .transform(lambda x: x / 1_000_000)\n        .validate_as(...),  # (8)!\n    ]\n</code></pre> <ol> <li>\u5c06\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3a\u5c0f\u5199\u3002</li> <li>\u7ea6\u675f\u6574\u6570\u5927\u4e8e\u96f6\u3002</li> <li>\u7ea6\u675f\u5b57\u7b26\u4e32\u5339\u914d\u6b63\u5219\u8868\u8fbe\u5f0f\u6a21\u5f0f\u3002</li> <li>\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528\u8f83\u4f4e\u7ea7\u522b\u7684\u8f6c\u6362\u3001\u7ea6\u675f\u548c\u65ad\u8a00\u65b9\u6cd5\u3002</li> <li>\u4f7f\u7528 <code>|</code> \u6216 <code>&amp;</code> \u8fd0\u7b97\u7b26\u7ec4\u5408\u6b65\u9aa4\uff08\u7c7b\u4f3c\u4e8e\u903b\u8f91 OR \u6216 AND\uff09\u3002</li> <li>\u4f7f\u7528 <code>Ellipsis</code>\u3001<code>...</code> \u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u4f4d\u7f6e\u53c2\u6570\u8c03\u7528 <code>validate_as(...)</code> \u610f\u5473\u7740 <code>validate_as(&lt;\u5b57\u6bb5\u7c7b\u578b&gt;)</code>\u3002\u4f7f\u7528 <code>validate_as(Any)</code> \u63a5\u53d7\u4efb\u4f55\u7c7b\u578b\u3002</li> <li>\u60a8\u53ef\u4ee5\u5728\u5176\u4ed6\u6b65\u9aa4\u4e4b\u524d\u6216\u4e4b\u540e\u8c03\u7528 <code>validate_as()</code> \u6765\u8fdb\u884c\u9884\u5904\u7406\u6216\u540e\u5904\u7406\u3002</li> </ol>"},{"location":"concepts/experimental/#beforevalidatoraftervalidator-wrapvalidator","title":"\u4ece <code>BeforeValidator</code>\u3001<code>AfterValidator</code> \u548c <code>WrapValidator</code> \u6620\u5c04","text":"<p><code>validate_as</code> \u65b9\u6cd5\u662f\u5b9a\u4e49 <code>BeforeValidator</code>\u3001<code>AfterValidator</code> \u548c <code>WrapValidator</code> \u7684\u66f4\u7c7b\u578b\u5b89\u5168\u7684\u65b9\u5f0f\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic.experimental.pipeline import transform, validate_as\n\n# BeforeValidator\nAnnotated[int, validate_as(str).str_strip().validate_as(...)]  # (1)!\n# AfterValidator\nAnnotated[int, transform(lambda x: x * 2)]  # (2)!\n# WrapValidator\nAnnotated[\n    int,\n    validate_as(str)\n    .str_strip()\n    .validate_as(...)\n    .transform(lambda x: x * 2),  # (3)!\n]\n</code></pre> <ol> <li>\u5728\u5c06\u5b57\u7b26\u4e32\u89e3\u6790\u4e3a\u6574\u6570\u4e4b\u524d\u53bb\u9664\u7a7a\u683c\u3002</li> <li>\u5728\u89e3\u6790\u6574\u6570\u540e\u5c06\u5176\u4e58\u4ee5 2\u3002</li> <li>\u53bb\u9664\u5b57\u7b26\u4e32\u7684\u7a7a\u683c\uff0c\u5c06\u5176\u9a8c\u8bc1\u4e3a\u6574\u6570\uff0c\u7136\u540e\u4e58\u4ee5 2\u3002</li> </ol>"},{"location":"concepts/experimental/#_2","title":"\u66ff\u4ee3\u6a21\u5f0f","text":"<p>\u6839\u636e\u573a\u666f\u6709\u8bb8\u591a\u66ff\u4ee3\u6a21\u5f0f\u53ef\u4ee5\u4f7f\u7528\u3002 \u4f5c\u4e3a\u4e00\u4e2a\u4f8b\u5b50\uff0c\u8003\u8651\u4e0a\u9762\u63d0\u5230\u7684 <code>UserIn</code> \u548c <code>UserOut</code> \u6a21\u5f0f\uff1a</p> <pre><code>from __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass UserIn(BaseModel):\n    favorite_number: int | str\n\n\nclass UserOut(BaseModel):\n    favorite_number: int\n\n\ndef my_api(user: UserIn) -&gt; UserOut:\n    favorite_number = user.favorite_number\n    if isinstance(favorite_number, str):\n        favorite_number = int(user.favorite_number.strip())\n\n    return UserOut(favorite_number=favorite_number)\n\n\nassert my_api(UserIn(favorite_number=' 1 ')).favorite_number == 1\n</code></pre> <p>\u8fd9\u4e2a\u793a\u4f8b\u4f7f\u7528\u666e\u901a\u7684\u60ef\u7528 Python \u4ee3\u7801\uff0c\u53ef\u80fd\u6bd4\u4e0a\u9762\u7684\u793a\u4f8b\u66f4\u5bb9\u6613\u7406\u89e3\u3001\u7c7b\u578b\u68c0\u67e5\u7b49\u3002 \u60a8\u9009\u62e9\u7684\u65b9\u6cd5\u5e94\u8be5\u771f\u6b63\u53d6\u51b3\u4e8e\u60a8\u7684\u7528\u4f8b\u3002 \u60a8\u9700\u8981\u6bd4\u8f83\u5197\u957f\u6027\u3001\u6027\u80fd\u3001\u5411\u7528\u6237\u8fd4\u56de\u6709\u610f\u4e49\u7684\u9519\u8bef\u7684\u96be\u6613\u7a0b\u5ea6\u7b49\uff0c\u4ee5\u9009\u62e9\u6b63\u786e\u7684\u6a21\u5f0f\u3002 \u8bf7\u6ce8\u610f\u4e0d\u8981\u4ec5\u4ec5\u56e0\u4e3a\u53ef\u4ee5\u4f7f\u7528\u5c31\u6ee5\u7528\u50cf pipeline API \u8fd9\u6837\u7684\u9ad8\u7ea7\u6a21\u5f0f\u3002</p>"},{"location":"concepts/experimental/#_3","title":"\u90e8\u5206\u9a8c\u8bc1","text":"<p>Pydantic v2.10.0 \u5f15\u5165\u4e86\u5bf9\"\u90e8\u5206\u9a8c\u8bc1\"\u7684\u5b9e\u9a8c\u6027\u652f\u6301\u3002</p> <p>\u8fd9\u5141\u8bb8\u60a8\u9a8c\u8bc1\u4e0d\u5b8c\u6574\u7684 JSON \u5b57\u7b26\u4e32\uff0c\u6216\u8868\u793a\u4e0d\u5b8c\u6574\u8f93\u5165\u6570\u636e\u7684 Python \u5bf9\u8c61\u3002</p> <p>\u90e8\u5206\u9a8c\u8bc1\u5728\u5904\u7406 LLM \u7684\u8f93\u51fa\u65f6\u7279\u522b\u6709\u7528\uff0c\u6a21\u578b\u4f1a\u6d41\u5f0f\u4f20\u8f93\u7ed3\u6784\u5316\u54cd\u5e94\uff0c\u60a8\u53ef\u80fd\u5e0c\u671b\u5728\u4ecd\u5728\u63a5\u6536\u6570\u636e\u65f6\u5f00\u59cb\u9a8c\u8bc1\u6d41\uff08\u4f8b\u5982\uff0c\u5411\u7528\u6237\u663e\u793a\u90e8\u5206\u6570\u636e\uff09\u3002</p> <p>Warning</p> <p>\u90e8\u5206\u9a8c\u8bc1\u662f\u4e00\u4e2a\u5b9e\u9a8c\u6027\u7279\u6027\uff0c\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u7684 Pydantic \u7248\u672c\u4e2d\u53d1\u751f\u53d8\u5316\u3002\u5f53\u524d\u7684\u5b9e\u73b0\u5e94\u88ab\u89c6\u4e3a\u6982\u5ff5\u9a8c\u8bc1\uff0c\u5e76\u4e14\u6709\u4e00\u4e9b\u9650\u5236\u3002</p> <p>\u90e8\u5206\u9a8c\u8bc1\u53ef\u4ee5\u5728\u4f7f\u7528 <code>TypeAdapter</code> \u7684\u4e09\u79cd\u9a8c\u8bc1\u65b9\u6cd5\u65f6\u542f\u7528\uff1a<code>TypeAdapter.validate_json()</code>\u3001<code>TypeAdapter.validate_python()</code> \u548c <code>TypeAdapter.validate_strings()</code>\u3002\u8fd9\u5141\u8bb8\u60a8\u89e3\u6790\u548c\u9a8c\u8bc1\u4e0d\u5b8c\u6574\u7684 JSON\uff0c\u8fd8\u53ef\u4ee5\u9a8c\u8bc1\u901a\u8fc7\u89e3\u6790\u4efb\u4f55\u683c\u5f0f\u7684\u4e0d\u5b8c\u6574\u6570\u636e\u521b\u5efa\u7684 Python \u5bf9\u8c61\u3002</p> <p>\u53ef\u4ee5\u5411\u8fd9\u4e9b\u65b9\u6cd5\u4f20\u9012 <code>experimental_allow_partial</code> \u6807\u5fd7\u6765\u542f\u7528\u90e8\u5206\u9a8c\u8bc1\u3002 \u5b83\u53ef\u4ee5\u91c7\u7528\u4ee5\u4e0b\u503c\uff08\u9ed8\u8ba4\u4e3a <code>False</code>\uff09\uff1a</p> <ul> <li><code>False</code> \u6216 <code>'off'</code> - \u7981\u7528\u90e8\u5206\u9a8c\u8bc1</li> <li><code>True</code> \u6216 <code>'on'</code> - \u542f\u7528\u90e8\u5206\u9a8c\u8bc1\uff0c\u4f46\u4e0d\u652f\u6301\u5c3e\u968f\u5b57\u7b26\u4e32</li> <li><code>'trailing-strings'</code> - \u542f\u7528\u90e8\u5206\u9a8c\u8bc1\u5e76\u652f\u6301\u5c3e\u968f\u5b57\u7b26\u4e32</li> </ul> <p><code>'trailing-strings'</code> \u6a21\u5f0f</p> <p><code>'trailing-strings'</code> \u6a21\u5f0f\u5141\u8bb8\u5c06\u90e8\u5206 JSON \u672b\u5c3e\u7684\u4e0d\u5b8c\u6574\u5c3e\u968f\u5b57\u7b26\u4e32\u5305\u542b\u5728\u8f93\u51fa\u4e2d\u3002 \u4f8b\u5982\uff0c\u5982\u679c\u60a8\u9488\u5bf9\u4ee5\u4e0b\u6a21\u578b\u8fdb\u884c\u9a8c\u8bc1\uff1a</p> <pre><code>from typing import TypedDict\n\n\nclass Model(TypedDict):\n    a: str\n    b: str\n</code></pre> <p>\u90a3\u4e48\u4ee5\u4e0b JSON \u8f93\u5165\u5c06\u88ab\u89c6\u4e3a\u6709\u6548\uff0c\u5c3d\u7ba1\u672b\u5c3e\u6709\u4e0d\u5b8c\u6574\u7684\u5b57\u7b26\u4e32\uff1a</p> <pre><code>'{\"a\": \"hello\", \"b\": \"wor'\n</code></pre> <p>\u5e76\u5c06\u9a8c\u8bc1\u4e3a\uff1a</p> <pre><code>{'a': 'hello', 'b': 'wor'}\n</code></pre> <p><code>experiment_allow_partial</code> \u5b9e\u9645\u5e94\u7528\u793a\u4f8b\uff1a</p> <pre><code>from typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):  # (1)!\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_json('[{\"a\": 1, \"b\"', experimental_allow_partial=True)  # (2)!\nprint(v)\n#&gt; [{'a': 1}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcd', experimental_allow_partial=True  # (3)!\n)\nprint(v)\n#&gt; [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"b\": 1.0, \"c\": \"abcde\"', experimental_allow_partial=True  # (4)!\n)\nprint(v)\n#&gt; []\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcde\"},{\"a\": ', experimental_allow_partial=True\n)\nprint(v)\n#&gt; [{'a': 1, 'b': 1.0, 'c': 'abcde'}]\n\nv = ta.validate_python([{'a': 1}], experimental_allow_partial=True)  # (5)!\nprint(v)\n#&gt; [{'a': 1}]\n\nv = ta.validate_python(\n    [{'a': 1, 'b': 1.0, 'c': 'abcd'}], experimental_allow_partial=True  # (6)!\n)\nprint(v)\n#&gt; [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcdefg',\n    experimental_allow_partial='trailing-strings',  # (7)!\n)\nprint(v)\n#&gt; [{'a': 1, 'b': 1.0, 'c': 'abcdefg'}]\n</code></pre> <ol> <li>TypedDict <code>Foobar</code> \u6709\u4e09\u4e2a\u5b57\u6bb5\uff0c\u4f46\u53ea\u6709 <code>a</code> \u662f\u5fc5\u9700\u7684\uff0c\u8fd9\u610f\u5473\u7740\u5373\u4f7f <code>b</code> \u548c <code>c</code> \u5b57\u6bb5\u7f3a\u5931\uff0c\u4e5f\u53ef\u4ee5\u521b\u5efa <code>Foobar</code> \u7684\u6709\u6548\u5b9e\u4f8b\u3002</li> <li>\u89e3\u6790 JSON\uff0c\u8f93\u5165\u5728\u5b57\u7b26\u4e32\u88ab\u622a\u65ad\u4e4b\u524d\u662f\u6709\u6548\u7684 JSON\u3002</li> <li>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u8f93\u5165\u7684\u622a\u65ad\u610f\u5473\u7740 <code>c</code> \u7684\u503c\uff08<code>abcd</code>\uff09\u4f5c\u4e3a <code>c</code> \u5b57\u6bb5\u7684\u8f93\u5165\u65e0\u6548\uff0c\u56e0\u6b64\u88ab\u7701\u7565\u3002</li> <li><code>a</code> \u5b57\u6bb5\u662f\u5fc5\u9700\u7684\uff0c\u56e0\u6b64\u5217\u8868\u4e2d\u552f\u4e00\u9879\u7684\u9a8c\u8bc1\u5931\u8d25\u5e76\u88ab\u4e22\u5f03\u3002</li> <li>\u90e8\u5206\u9a8c\u8bc1\u4e5f\u9002\u7528\u4e8e Python \u5bf9\u8c61\uff0c\u5b83\u5e94\u8be5\u5177\u6709\u4e0e JSON \u76f8\u540c\u7684\u8bed\u4e49\uff0c\u5f53\u7136\u60a8\u4e0d\u80fd\u62e5\u6709\u771f\u6b63\"\u4e0d\u5b8c\u6574\"\u7684 Python \u5bf9\u8c61\u3002</li> <li>\u4e0e\u4e0a\u9762\u76f8\u540c\uff0c\u4f46\u4f7f\u7528 Python \u5bf9\u8c61\uff0c<code>c</code> \u88ab\u4e22\u5f03\uff0c\u56e0\u4e3a\u5b83\u4e0d\u662f\u5fc5\u9700\u7684\u4e14\u9a8c\u8bc1\u5931\u8d25\u3002</li> <li><code>trailing-strings</code> \u6a21\u5f0f\u5141\u8bb8\u5c06\u90e8\u5206 JSON \u672b\u5c3e\u7684\u4e0d\u5b8c\u6574\u5b57\u7b26\u4e32\u5305\u542b\u5728\u8f93\u51fa\u4e2d\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u8f93\u5165\u5728\u5b57\u7b26\u4e32\u88ab\u622a\u65ad\u4e4b\u524d\u662f\u6709\u6548\u7684 JSON\uff0c\u56e0\u6b64\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u4e32\u88ab\u5305\u542b\u3002</li> </ol>"},{"location":"concepts/experimental/#_4","title":"\u90e8\u5206\u9a8c\u8bc1\u7684\u5de5\u4f5c\u539f\u7406","text":"<p>\u90e8\u5206\u9a8c\u8bc1\u9075\u5faa Pydantic \u7684\u7985\u610f\u2014\u2014\u5b83\u4e0d\u4fdd\u8bc1\u8f93\u5165\u6570\u636e\u53ef\u80fd\u662f\u4ec0\u4e48\uff0c\u4f46\u786e\u5b9e\u4fdd\u8bc1\u8fd4\u56de\u60a8\u6240\u9700\u7c7b\u578b\u7684\u6709\u6548\u5b9e\u4f8b\uff0c\u6216\u8005\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\u3002</p> <p>\u4e3a\u6b64\uff0c<code>experimental_allow_partial</code> \u6807\u5fd7\u542f\u7528\u4e86\u4e24\u79cd\u884c\u4e3a\uff1a</p>"},{"location":"concepts/experimental/#1-json","title":"1. \u90e8\u5206 JSON \u89e3\u6790","text":"<p>Pydantic \u4f7f\u7528\u7684 jiter JSON \u89e3\u6790\u5668\u5df2\u7ecf\u652f\u6301\u89e3\u6790\u90e8\u5206 JSON\uff0c <code>experimental_allow_partial</code> \u53ea\u662f\u901a\u8fc7 <code>allow_partial</code> \u53c2\u6570\u4f20\u9012\u7ed9 jiter\u3002</p> <p>Note</p> <p>\u5982\u679c\u60a8\u53ea\u60f3\u8981\u652f\u6301\u90e8\u5206 JSON \u7684\u7eaf JSON \u89e3\u6790\uff0c\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 <code>jiter</code> Python \u5e93\uff0c\u6216\u8005\u5728\u8c03\u7528 <code>pydantic_core.from_json</code> \u65f6\u4f20\u9012 <code>allow_partial</code> \u53c2\u6570\u3002</p>"},{"location":"concepts/experimental/#2-ignore-errors-in-last","title":"2. \u5ffd\u7565\u8f93\u5165\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u7684\u9519\u8bef","text":"<p>\u53ea\u80fd\u8bbf\u95ee\u90e8\u5206\u8f93\u5165\u6570\u636e\u610f\u5473\u7740\u9519\u8bef\u901a\u5e38\u4f1a\u5728\u8f93\u5165\u6570\u636e\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u53d1\u751f\u3002</p> <p>\u4f8b\u5982\uff1a</p> <ul> <li>\u5982\u679c\u5b57\u7b26\u4e32\u6709\u7ea6\u675f <code>MinLen(5)</code>\uff0c\u5f53\u60a8\u53ea\u770b\u5230\u90e8\u5206\u8f93\u5165\u65f6\uff0c\u9a8c\u8bc1\u53ef\u80fd\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u90e8\u5206\u5b57\u7b26\u4e32\u7f3a\u5931\uff08\u4f8b\u5982 <code>{\"name\": \"Sam</code> \u800c\u4e0d\u662f <code>{\"name\": \"Samuel\"}</code>\uff09</li> <li>\u5982\u679c <code>int</code> \u5b57\u6bb5\u6709\u7ea6\u675f <code>Ge(10)</code>\uff0c\u5f53\u60a8\u53ea\u770b\u5230\u90e8\u5206\u8f93\u5165\u65f6\uff0c\u9a8c\u8bc1\u53ef\u80fd\u4f1a\u5931\u8d25\uff0c\u56e0\u4e3a\u6570\u5b57\u592a\u5c0f\uff08\u4f8b\u5982 <code>1</code> \u800c\u4e0d\u662f <code>10</code>\uff09</li> <li>\u5982\u679c <code>TypedDict</code> \u5b57\u6bb5\u6709 3 \u4e2a\u5fc5\u9700\u5b57\u6bb5\uff0c\u4f46\u90e8\u5206\u8f93\u5165\u53ea\u6709\u4e24\u4e2a\u5b57\u6bb5\uff0c\u9a8c\u8bc1\u5c06\u5931\u8d25\uff0c\u56e0\u4e3a\u7f3a\u5c11\u67d0\u4e9b\u5b57\u6bb5</li> <li>\u7b49\u7b49\u2014\u2014\u8fd8\u6709\u66f4\u591a\u7c7b\u4f3c\u7684\u60c5\u51b5</li> </ul> <p>\u5173\u952e\u662f\u5982\u679c\u60a8\u53ea\u770b\u5230\u67d0\u4e9b\u6709\u6548\u8f93\u5165\u6570\u636e\u7684\u4e00\u90e8\u5206\uff0c\u9a8c\u8bc1\u9519\u8bef\u901a\u5e38\u4f1a\u5728\u5e8f\u5217\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u6216\u6620\u5c04\u7684\u6700\u540e\u4e00\u4e2a\u503c\u4e2d\u53d1\u751f\u3002</p> <p>\u4e3a\u4e86\u907f\u514d\u8fd9\u4e9b\u9519\u8bef\u7834\u574f\u90e8\u5206\u9a8c\u8bc1\uff0cPydantic \u5c06\u5ffd\u7565\u8f93\u5165\u6570\u636e\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u7684\u6240\u6709\u9519\u8bef\u3002</p> Errors in last element ignored<pre><code>from typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass MyModel(BaseModel):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(list[MyModel])\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": \"12345\"}, {\"a\": 1,',\n    experimental_allow_partial=True,\n)\nprint(v)\n#&gt; [MyModel(a=1, b='12345')]\n</code></pre>"},{"location":"concepts/experimental/#limitations-of-partial-validation","title":"\u90e8\u5206\u9a8c\u8bc1\u7684\u9650\u5236","text":""},{"location":"concepts/experimental/#typeadapter","title":"\u4ec5\u9650 TypeAdapter","text":"<p>\u60a8\u53ea\u80fd\u5c06 <code>experiment_allow_partial</code> \u4f20\u9012\u7ed9 <code>TypeAdapter</code> \u65b9\u6cd5\uff0c\u5c1a\u4e0d\u652f\u6301\u901a\u8fc7\u5176\u4ed6 Pydantic \u5165\u53e3\u70b9\uff08\u5982 <code>BaseModel</code>\uff09\u4f7f\u7528\u3002</p>"},{"location":"concepts/experimental/#_5","title":"\u652f\u6301\u7684\u7c7b\u578b","text":"<p>\u76ee\u524d\u53ea\u6709\u4e00\u90e8\u5206\u96c6\u5408\u9a8c\u8bc1\u5668\u77e5\u9053\u5982\u4f55\u5904\u7406\u90e8\u5206\u9a8c\u8bc1\uff1a</p> <ul> <li><code>list</code></li> <li><code>set</code></li> <li><code>frozenset</code></li> <li><code>dict</code>\uff08\u5982 <code>dict[X, Y]</code>\uff09</li> <li><code>TypedDict</code> \u2014 \u53ea\u6709\u975e\u5fc5\u9700\u5b57\u6bb5\u53ef\u80fd\u7f3a\u5931\uff0c\u4f8b\u5982\u901a\u8fc7 <code>NotRequired</code> \u6216 <code>total=False</code>\uff09</li> </ul> <p>\u867d\u7136\u60a8\u53ef\u4ee5\u5728\u9a8c\u8bc1\u5305\u542b\u5176\u4ed6\u96c6\u5408\u9a8c\u8bc1\u5668\u7684\u7c7b\u578b\u65f6\u4f7f\u7528 <code>experimental_allow_partial</code>\uff0c\u4f46\u8fd9\u4e9b\u7c7b\u578b\u5c06\u88ab\"\u5168\u6709\u6216\u5168\u65e0\"\u5730\u9a8c\u8bc1\uff0c\u90e8\u5206\u9a8c\u8bc1\u5c06\u65e0\u6cd5\u5728\u66f4\u5d4c\u5957\u7684\u7c7b\u578b\u4e0a\u5de5\u4f5c\u3002</p> <p>\u4f8b\u5982\uff0c\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u90e8\u5206\u9a8c\u8bc1\u6709\u6548\uff0c\u5c3d\u7ba1\u5217\u8868\u4e2d\u7684\u7b2c\u4e8c\u9879\u88ab\u5b8c\u5168\u4e22\u5f03\uff0c\u56e0\u4e3a <code>BaseModel</code> \u5c1a\u4e0d\u652f\u6301\u90e8\u5206\u9a8c\u8bc1\u3002</p> <p>\u4f46\u90e8\u5206\u9a8c\u8bc1\u5728\u4ee5\u4e0b\u793a\u4f8b\u4e2d\u6839\u672c\u4e0d\u8d77\u4f5c\u7528\uff0c\u56e0\u4e3a <code>BaseModel</code> \u4e0d\u652f\u6301\u90e8\u5206\u9a8c\u8bc1\uff0c\u56e0\u6b64\u5b83\u4e0d\u4f1a\u5c06 <code>allow_partial</code> \u6307\u4ee4\u8f6c\u53d1\u7ed9 <code>b</code> \u4e2d\u7684\u5217\u8868\u9a8c\u8bc1\u5668\uff1a</p> <pre><code>from typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter, ValidationError\n\n\nclass MyModel(BaseModel):\n    a: int = 1\n    b: list[Annotated[str, MinLen(5)]] = []  # (1)!\n\n\nta = TypeAdapter(MyModel)\ntry:\n    v = ta.validate_json(\n        '{\"a\": 1, \"b\": [\"12345\", \"12', experimental_allow_partial=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    b.1\n      String should have at least 5 characters [type=string_too_short, input_value='12', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li><code>b</code> \u7684\u5217\u8868\u9a8c\u8bc1\u5668\u6ca1\u6709\u4ece\u6a21\u578b\u9a8c\u8bc1\u5668\u63a5\u6536\u5230 <code>allow_partial</code> \u6307\u4ee4\uff0c\u56e0\u6b64\u5b83\u4e0d\u77e5\u9053\u5ffd\u7565\u8f93\u5165\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u7684\u9519\u8bef\u3002</li> </ol>"},{"location":"concepts/experimental/#json","title":"\u4e00\u4e9b\u65e0\u6548\u4f46\u5b8c\u6574\u7684 JSON \u5c06\u88ab\u63a5\u53d7","text":"<p>jiter\uff08Pydantic \u4f7f\u7528\u7684 JSON \u89e3\u6790\u5668\uff09\u7684\u5de5\u4f5c\u65b9\u5f0f\u610f\u5473\u7740\u76ee\u524d\u65e0\u6cd5\u533a\u5206\u50cf <code>{\"a\": 1, \"b\": \"12\"}</code> \u8fd9\u6837\u7684\u5b8c\u6574 JSON \u548c\u50cf <code>{\"a\": 1, \"b\": \"12</code> \u8fd9\u6837\u7684\u4e0d\u5b8c\u6574 JSON\u3002</p> <p>\u8fd9\u610f\u5473\u7740\u5728\u4f7f\u7528 <code>experimental_allow_partial</code> \u65f6\uff0c\u4e00\u4e9b\u65e0\u6548\u7684 JSON \u5c06\u88ab Pydantic \u63a5\u53d7\uff0c\u4f8b\u5982\uff1a</p> Python 3.9 and abovePython 3.13 and above <pre><code>from typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)!\n)\nprint(v)\n#&gt; {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)!\n)\nprint(v)\n#&gt; {'a': 1}\n</code></pre> <ol> <li>\u8fd9\u5c06\u6309\u9884\u671f\u901a\u8fc7\u9a8c\u8bc1\uff0c\u5c3d\u7ba1\u6700\u540e\u4e00\u4e2a\u5b57\u6bb5\u5c06\u56e0\u9a8c\u8bc1\u5931\u8d25\u800c\u88ab\u7701\u7565\u3002</li> <li>\u8fd9\u4e5f\u5c06\u901a\u8fc7\u9a8c\u8bc1\uff0c\u56e0\u4e3a\u4f20\u9012\u7ed9 pydantic-core \u7684 JSON \u6570\u636e\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e0e\u524d\u9762\u7684\u60c5\u51b5\u65e0\u6cd5\u533a\u5206\u3002</li> </ol> <pre><code>from typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)!\n)\nprint(v)\n#&gt; {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)!\n)\nprint(v)\n#&gt; {'a': 1}\n</code></pre> <ol> <li>\u8fd9\u5c06\u6309\u9884\u671f\u901a\u8fc7\u9a8c\u8bc1\uff0c\u5c3d\u7ba1\u6700\u540e\u4e00\u4e2a\u5b57\u6bb5\u5c06\u56e0\u9a8c\u8bc1\u5931\u8d25\u800c\u88ab\u7701\u7565\u3002</li> <li>\u8fd9\u4e5f\u5c06\u901a\u8fc7\u9a8c\u8bc1\uff0c\u56e0\u4e3a\u4f20\u9012\u7ed9 pydantic-core \u7684 JSON \u6570\u636e\u7684\u4e8c\u8fdb\u5236\u8868\u793a\u4e0e\u524d\u9762\u7684\u60c5\u51b5\u65e0\u6cd5\u533a\u5206\u3002</li> </ol>"},{"location":"concepts/experimental/#_6","title":"\u8f93\u5165\u6700\u540e\u4e00\u4e2a\u5b57\u6bb5\u4e2d\u7684\u4efb\u4f55\u9519\u8bef\u90fd\u5c06\u88ab\u5ffd\u7565","text":"<p>\u5982\u4e0a\u9762\u6240\u8ff0\uff0c\u622a\u65ad\u8f93\u5165\u53ef\u80fd\u5bfc\u81f4\u8bb8\u591a\u9519\u8bef\u3002Pydantic \u4e0d\u662f\u5c1d\u8bd5\u4e13\u95e8\u5ffd\u7565\u53ef\u80fd\u7531\u622a\u65ad\u5f15\u8d77\u7684\u9519\u8bef\uff0c\u800c\u662f\u5728\u90e8\u5206\u9a8c\u8bc1\u6a21\u5f0f\u4e0b\u5ffd\u7565\u8f93\u5165\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u4e2d\u7684\u6240\u6709\u9519\u8bef\u3002</p> <p>\u8fd9\u610f\u5473\u7740\u5982\u679c\u9519\u8bef\u5728\u8f93\u5165\u7684\u6700\u540e\u4e00\u4e2a\u5b57\u6bb5\u4e2d\uff0c\u660e\u663e\u65e0\u6548\u7684\u6570\u636e\u5c06\u901a\u8fc7\u9a8c\u8bc1\uff1a</p> <pre><code>from typing import Annotated\n\nfrom annotated_types import Ge\n\nfrom pydantic import TypeAdapter\n\nta = TypeAdapter(list[Annotated[int, Ge(10)]])\nv = ta.validate_python([20, 30, 4], experimental_allow_partial=True)  # (1)!\nprint(v)\n#&gt; [20, 30]\n\nta = TypeAdapter(list[int])\n\nv = ta.validate_python([1, 2, 'wrong'], experimental_allow_partial=True)  # (2)!\nprint(v)\n#&gt; [1, 2]\n</code></pre> <ol> <li>\u6b63\u5982\u60a8\u6240\u671f\u671b\u7684\uff0c\u8fd9\u5c06\u901a\u8fc7\u9a8c\u8bc1\uff0c\u56e0\u4e3a Pydantic \u6b63\u786e\u5730\u5ffd\u7565\u4e86\uff08\u622a\u65ad\u7684\uff09\u6700\u540e\u4e00\u9879\u4e2d\u7684\u9519\u8bef\u3002</li> <li>\u8fd9\u4e5f\u5c06\u901a\u8fc7\u9a8c\u8bc1\uff0c\u56e0\u4e3a\u6700\u540e\u4e00\u9879\u4e2d\u7684\u9519\u8bef\u88ab\u5ffd\u7565\u4e86\u3002</li> </ol>"},{"location":"concepts/experimental/#_7","title":"\u53ef\u8c03\u7528\u53c2\u6570\u7684\u9a8c\u8bc1","text":"<p>Pydantic \u63d0\u4f9b\u4e86 <code>@validate_call</code> \u88c5\u9970\u5668\u6765\u5bf9\u53ef\u8c03\u7528\u5bf9\u8c61\u7684\u53c2\u6570\uff08\u4ee5\u53ca\u8fd4\u56de\u7c7b\u578b\uff09\u8fdb\u884c\u9a8c\u8bc1\u3002\u7136\u800c\uff0c\u5b83\u53ea\u5141\u8bb8\u901a\u8fc7\u5b9e\u9645\u8c03\u7528\u88c5\u9970\u540e\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u6765\u63d0\u4f9b\u53c2\u6570\u3002\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u53ea\u60f3\u9a8c\u8bc1\u53c2\u6570\uff0c\u4f8b\u5982\u4ece\u5176\u4ed6\u6570\u636e\u6e90\uff08\u5982 JSON \u6570\u636e\uff09\u52a0\u8f7d\u65f6\u3002</p> <p>\u56e0\u6b64\uff0c\u5b9e\u9a8c\u6027\u7684 <code>generate_arguments_schema()</code> \u51fd\u6570\u53ef\u7528\u4e8e\u6784\u5efa\u6838\u5fc3\u6a21\u5f0f\uff0c\u7a0d\u540e\u53ef\u4ee5\u4e0e <code>SchemaValidator</code> \u4e00\u8d77\u4f7f\u7528\u3002</p> <pre><code>from pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -&gt; None: ...\n\n\narguments_schema = generate_arguments_schema(func=func)\n\nval = SchemaValidator(arguments_schema, config={'coerce_numbers_to_str': True})\n\nargs, kwargs = val.validate_json(\n    '{\"p\": true, \"args\": [\"arg1\", 1], \"kwargs\": {\"extra\": 1}}'\n)\nprint(args, kwargs)  # (1)!\n#&gt; (True, 'arg1', '1') {'extra': 1}\n</code></pre> <ol> <li> <p>\u5982\u679c\u60a8\u60f3\u8981\u5c06\u9a8c\u8bc1\u540e\u7684\u53c2\u6570\u4f5c\u4e3a\u5b57\u5178\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>Signature.bind()</code>    \u65b9\u6cd5\uff1a</p> <pre><code>from inspect import signature\n\nsignature(func).bind(*args, **kwargs).arguments\n#&gt; {'p': True, 'args': ('arg1', '1'), 'kwargs': {'extra': 1}}\n</code></pre> </li> </ol> <p>Note</p> <p>\u4e0e <code>@validate_call</code> \u4e0d\u540c\uff0c\u6b64\u6838\u5fc3\u6a21\u5f0f\u53ea\u4f1a\u9a8c\u8bc1\u63d0\u4f9b\u7684\u53c2\u6570\uff1b \u5e95\u5c42\u53ef\u8c03\u7528\u5bf9\u8c61\u5c06\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002</p> <p>\u6b64\u5916\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u63d0\u4f9b\u56de\u8c03\u6765\u5ffd\u7565\u7279\u5b9a\u53c2\u6570\uff0c\u8be5\u56de\u8c03\u4f1a\u4e3a\u6bcf\u4e2a\u53c2\u6570\u8c03\u7528\uff1a</p> <pre><code>from typing import Any\n\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -&gt; None: ...\n\n\ndef skip_first_parameter(index: int, name: str, annotation: Any) -&gt; Any:\n    if index == 0:\n        return 'skip'\n\n\narguments_schema = generate_arguments_schema(\n    func=func,\n    parameters_callback=skip_first_parameter,\n)\n\nval = SchemaValidator(arguments_schema)\n\nargs, kwargs = val.validate_json('{\"args\": [\"arg1\"], \"kwargs\": {\"extra\": 1}}')\nprint(args, kwargs)\n#&gt; ('arg1',) {'extra': 1}\n</code></pre>"},{"location":"concepts/experimental/#missing-sentinel","title":"<code>MISSING</code> \u6807\u8bb0","text":"<p><code>MISSING</code> \u6807\u8bb0\u662f\u4e00\u4e2a\u5355\u4f8b\uff0c\u8868\u793a\u5728\u9a8c\u8bc1\u671f\u95f4\u672a\u63d0\u4f9b\u5b57\u6bb5\u503c\u3002</p> <p>\u6b64\u5355\u4f8b\u53ef\u7528\u4f5c\u9ed8\u8ba4\u503c\uff0c\u4f5c\u4e3a <code>None</code> \u7684\u66ff\u4ee3\u65b9\u6848\uff0c\u5f53\u5b83\u5177\u6709\u660e\u786e\u542b\u4e49\u65f6\u3002\u5728\u5e8f\u5217\u5316\u671f\u95f4\uff0c\u4efb\u4f55\u503c\u4e3a <code>MISSING</code> \u7684\u5b57\u6bb5\u90fd\u5c06\u4ece\u8f93\u51fa\u4e2d\u6392\u9664\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Union\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Configuration(BaseModel):\n    timeout: Union[int, None, MISSING] = MISSING\n\n\n# \u914d\u7f6e\u9ed8\u8ba4\u503c\uff0c\u5b58\u50a8\u5728\u5176\u4ed6\u5730\u65b9\uff1a\ndefaults = {'timeout': 200}\n\nconf = Configuration()\n\n# `timeout` \u4ece\u5e8f\u5217\u5316\u8f93\u51fa\u4e2d\u6392\u9664\uff1a\nconf.model_dump()\n# {}\n\n# `MISSING` \u503c\u4e0d\u4f1a\u51fa\u73b0\u5728 JSON Schema \u4e2d\uff1a\nConfiguration.model_json_schema()['properties']['timeout']\n#&gt; {'anyOf': [{'type': 'integer'}, {'type': 'null'}], 'title': 'Timeout'}}\n\n\n# \u53ef\u4ee5\u4f7f\u7528 `is` \u6765\u533a\u5206\u6807\u8bb0\u548c\u5176\u4ed6\u503c\uff1a\ntimeout = conf.timeout if conf.timeout is not MISSING else defaults['timeout']\n</code></pre> <pre><code>from pydantic import BaseModel\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Configuration(BaseModel):\n    timeout: int | None | MISSING = MISSING\n\n\n# \u914d\u7f6e\u9ed8\u8ba4\u503c\uff0c\u5b58\u50a8\u5728\u5176\u4ed6\u5730\u65b9\uff1a\ndefaults = {'timeout': 200}\n\nconf = Configuration()\n\n# `timeout` \u4ece\u5e8f\u5217\u5316\u8f93\u51fa\u4e2d\u6392\u9664\uff1a\nconf.model_dump()\n# {}\n\n# `MISSING` \u503c\u4e0d\u4f1a\u51fa\u73b0\u5728 JSON Schema \u4e2d\uff1a\nConfiguration.model_json_schema()['properties']['timeout']\n#&gt; {'anyOf': [{'type': 'integer'}, {'type': 'null'}], 'title': 'Timeout'}}\n\n\n# \u53ef\u4ee5\u4f7f\u7528 `is` \u6765\u533a\u5206\u6807\u8bb0\u548c\u5176\u4ed6\u503c\uff1a\ntimeout = conf.timeout if conf.timeout is not MISSING else defaults['timeout']\n</code></pre> <p>\u6b64\u529f\u80fd\u88ab\u6807\u8bb0\u4e3a\u5b9e\u9a8c\u6027\uff0c\u56e0\u4e3a\u5b83\u4f9d\u8d56\u4e8e\u8349\u6848 PEP 661\uff0c\u8be5\u8349\u6848\u5728\u6807\u51c6\u5e93\u4e2d\u5f15\u5165\u4e86\u6807\u8bb0\u3002</p> <p>\u56e0\u6b64\uff0c\u76ee\u524d\u5b58\u5728\u4ee5\u4e0b\u9650\u5236\uff1a</p> <ul> <li>\u6807\u8bb0\u7684\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u4ec5\u652f\u6301 Pyright 1.1.402 \u6216\u66f4\u9ad8\u7248\u672c\uff0c\u5e76\u4e14\u5e94\u542f\u7528 <code>enableExperimentalFeatures</code> \u7c7b\u578b\u8bc4\u4f30\u8bbe\u7f6e\u3002</li> <li>\u4e0d\u652f\u6301\u5305\u542b <code>MISSING</code> \u4f5c\u4e3a\u503c\u7684\u6a21\u578b\u7684\u5e8f\u5217\u5316\u3002</li> </ul>"},{"location":"concepts/fields/","title":"Fields","text":"API \u6587\u6863 <p><code>pydantic.fields.Field</code></p> <p>\u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4ecb\u7ecd\u53ef\u7528\u4e8e\u81ea\u5b9a\u4e49 Pydantic \u6a21\u578b\u5b57\u6bb5\u7684\u673a\u5236\uff1a \u9ed8\u8ba4\u503c\u3001JSON Schema \u5143\u6570\u636e\u3001 \u7ea6\u675f \u7b49\u3002</p> <p>\u4e3a\u6b64\uff0c<code>Field()</code> \u51fd\u6570\u88ab\u5927\u91cf\u4f7f\u7528\uff0c\u5176\u884c\u4e3a\u65b9\u5f0f\u4e0e \u6807\u51c6\u5e93\u7684 <code>field()</code> \u51fd\u6570\u76f8\u540c\u2014\u2014\u901a\u8fc7\u5206\u914d\u7ed9\u5e26\u6ce8\u89e3\u7684\u5c5e\u6027\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(frozen=True)\n</code></pre> <p>Note</p> <p>\u5373\u4f7f <code>name</code> \u88ab\u5206\u914d\u4e86\u4e00\u4e2a\u503c\uff0c\u5b83\u4ecd\u7136\u662f\u5fc5\u9700\u7684\u4e14\u6ca1\u6709\u9ed8\u8ba4\u503c\u3002\u5982\u679c\u60a8\u60f3 \u5f3a\u8c03\u5fc5\u987b\u63d0\u4f9b\u4e00\u4e2a\u503c\uff0c\u53ef\u4ee5\u4f7f\u7528 \u7701\u7565\u53f7\uff1a</p> <pre><code>class Model(BaseModel):\n    name: str = Field(..., frozen=True)\n</code></pre> <p>\u4f46\u662f\uff0c\u4e0d\u9f13\u52b1\u4f7f\u7528\u8fd9\u79cd\u65b9\u5f0f\uff0c\u56e0\u4e3a\u5b83\u4e0e\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u914d\u5408\u4e0d\u4f73\u3002</p>"},{"location":"concepts/fields/#the-annotated-pattern","title":"\u6ce8\u89e3\u6a21\u5f0f","text":"<p>\u4e3a\u4e86\u5e94\u7528\u7ea6\u675f\u6216\u5c06 <code>Field()</code> \u51fd\u6570\u9644\u52a0\u5230\u6a21\u578b\u5b57\u6bb5\uff0cPydantic \u8fd8\u652f\u6301\u4f7f\u7528 <code>Annotated</code> \u7c7b\u578b\u6784\u9020\u6765\u5c06\u5143\u6570\u636e\u9644\u52a0\u5230\u6ce8\u89e3\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    name: Annotated[str, Field(strict=True), WithJsonSchema({'extra': 'data'})]\n</code></pre> <p>\u5c31\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u800c\u8a00\uff0c<code>name</code> \u4ecd\u7136\u88ab\u7c7b\u578b\u5316\u4e3a <code>str</code>\uff0c\u4f46 Pydantic \u5229\u7528 \u53ef\u7528\u7684\u5143\u6570\u636e\u6765\u6dfb\u52a0\u9a8c\u8bc1\u903b\u8f91\u3001\u7c7b\u578b\u7ea6\u675f\u7b49\u3002</p> <p>\u4f7f\u7528\u8fd9\u79cd\u6a21\u5f0f\u6709\u4e00\u4e9b\u4f18\u52bf\uff1a</p> <ul> <li>\u4f7f\u7528 <code>f: &lt;type&gt; = Field(...)</code> \u5f62\u5f0f\u53ef\u80fd\u4f1a\u4ee4\u4eba\u56f0\u60d1\uff0c\u5e76\u53ef\u80fd\u8bef\u5bfc\u7528\u6237\u8ba4\u4e3a <code>f</code>   \u6709\u9ed8\u8ba4\u503c\uff0c\u800c\u5b9e\u9645\u4e0a\u5b83\u4ecd\u7136\u662f\u5fc5\u9700\u7684\u3002</li> <li>\u60a8\u53ef\u4ee5\u4e3a\u5b57\u6bb5\u63d0\u4f9b\u4efb\u610f\u6570\u91cf\u7684\u5143\u6570\u636e\u5143\u7d20\u3002\u5982\u4e0a\u4f8b\u6240\u793a\uff0c   <code>Field()</code> \u51fd\u6570\u4ec5\u652f\u6301\u6709\u9650\u7684\u7ea6\u675f/\u5143\u6570\u636e\u96c6\uff0c   \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u4f7f\u7528\u4e0d\u540c\u7684 Pydantic \u5b9e\u7528\u7a0b\u5e8f\uff0c\u4f8b\u5982 <code>WithJsonSchema</code>\u3002</li> <li>\u7c7b\u578b\u53ef\u4ee5\u53d8\u5f97\u53ef\u91cd\u7528\uff08\u8bf7\u53c2\u9605\u6709\u5173 \u81ea\u5b9a\u4e49\u7c7b\u578b   \u4f7f\u7528\u6b64\u6a21\u5f0f\u7684\u6587\u6863\uff09\u3002</li> </ul> <p>\u4f46\u662f\uff0c\u8bf7\u6ce8\u610f <code>Field()</code> \u51fd\u6570\u7684\u67d0\u4e9b\u53c2\u6570\uff08\u5373 <code>default</code>\u3001 <code>default_factory</code> \u548c <code>alias</code>\uff09\u4f1a\u88ab\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u8003\u8651\u4ee5\u5408\u6210\u6b63\u786e\u7684 <code>__init__()</code> \u65b9\u6cd5\u3002\u6ce8\u89e3\u6a21\u5f0f\u4e0d\u88ab\u5b83\u4eec\u7406\u89e3\uff0c\u56e0\u6b64\u60a8\u5e94\u8be5\u4f7f\u7528\u6b63\u5e38\u7684 \u8d4b\u503c\u5f62\u5f0f\u3002</p> <p>Tip</p> <p>\u6ce8\u89e3\u6a21\u5f0f\u4e5f\u53ef\u7528\u4e8e\u5411\u7c7b\u578b\u7684\u7279\u5b9a\u90e8\u5206\u6dfb\u52a0\u5143\u6570\u636e\u3002\u4f8b\u5982\uff0c \u9a8c\u8bc1\u7ea6\u675f \u53ef\u4ee5\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u6dfb\u52a0\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    int_list: list[Annotated[int, Field(gt=0)]]\n    # \u6709\u6548: [1, 3]\n    # \u65e0\u6548: [-1, 2]\n</code></pre> <p>\u6ce8\u610f\u4e0d\u8981\u6df7\u6dc6\u5b57\u6bb5\u548c\u7c7b\u578b\u5143\u6570\u636e\uff1a</p> <pre><code>class Model(BaseModel):\n    field_bad: Annotated[int, Field(deprecated=True)] | None = None  # (1)!\n    field_ok: Annotated[int | None, Field(deprecated=True)] = None  # (2)!\n</code></pre> <ol> <li> <p><code>Field()</code> \u51fd\u6570\u5e94\u7528\u4e8e <code>int</code> \u7c7b\u578b\uff0c\u56e0\u6b64      <code>deprecated</code> \u6807\u5fd7\u5c06\u4e0d\u4f1a\u4ea7\u751f\u4efb\u4f55\u6548\u679c\u3002\u867d\u7136\u8fd9\u53ef\u80fd\u4ee4\u4eba\u56f0\u60d1\uff0c\u56e0\u4e3a      <code>Field()</code> \u51fd\u6570\u7684\u540d\u79f0\u6697\u793a\u5b83\u5e94\u8be5\u5e94\u7528\u4e8e\u5b57\u6bb5\uff0c      \u4f46\u8be5 API \u662f\u5728\u6b64\u51fd\u6570\u662f\u63d0\u4f9b\u5143\u6570\u636e\u7684\u552f\u4e00\u65b9\u5f0f\u65f6\u8bbe\u8ba1\u7684\u3002\u60a8\u53ef\u4ee5      \u66ff\u4ee3\u6027\u5730\u4f7f\u7528\u73b0\u5728\u53d7 Pydantic \u652f\u6301\u7684 <code>annotated_types</code>      \u5e93\u3002</p> </li> <li> <p><code>Field()</code> \u51fd\u6570\u5e94\u7528\u4e8e\"\u9876\u5c42\"\u8054\u5408\u7c7b\u578b\uff0c      \u56e0\u6b64 <code>deprecated</code> \u6807\u5fd7\u5c06\u5e94\u7528\u4e8e\u5b57\u6bb5\u3002</p> </li> </ol>"},{"location":"concepts/fields/#default-values","title":"\u9ed8\u8ba4\u503c","text":"<p>\u53ef\u4ee5\u4f7f\u7528\u6b63\u5e38\u7684\u8d4b\u503c\u8bed\u6cd5\u6216\u901a\u8fc7\u5411 <code>default</code> \u53c2\u6570\u63d0\u4f9b\u503c\u6765\u4e3a\u5b57\u6bb5\u63d0\u4f9b\u9ed8\u8ba4\u503c\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    # \u4e24\u4e2a\u5b57\u6bb5\u90fd\u4e0d\u662f\u5fc5\u9700\u7684\uff1a\n    name: str = 'John Doe'\n    age: int = Field(default=20)\n</code></pre> <p>Warning</p> <p>\u5728 Pydantic V1 \u4e2d\uff0c\u88ab\u6ce8\u89e3\u4e3a <code>Any</code> \u6216\u88ab <code>Optional</code> \u5305\u88c5\u7684\u7c7b\u578b\u5373\u4f7f\u6ca1\u6709\u660e\u786e\u6307\u5b9a\u9ed8\u8ba4\u503c\uff0c\u4e5f\u4f1a\u88ab\u8d4b\u4e88\u9690\u5f0f\u7684 <code>None</code> \u9ed8\u8ba4\u503c\u3002 \u5728 Pydantic V2 \u4e2d\u4e0d\u518d\u662f\u8fd9\u6837\u3002</p> <p>\u60a8\u8fd8\u53ef\u4ee5\u4f20\u9012\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\u7ed9 <code>default_factory</code> \u53c2\u6570\uff0c\u8be5\u53ef\u8c03\u7528\u5bf9\u8c61\u5c06\u88ab\u8c03\u7528\u6765\u751f\u6210\u9ed8\u8ba4\u503c\uff1a</p> <pre><code>from uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: str = Field(default_factory=lambda: uuid4().hex)\n</code></pre> <p></p> <p>\u9ed8\u8ba4\u5de5\u5382\u4e5f\u53ef\u4ee5\u63a5\u53d7\u4e00\u4e2a\u5fc5\u9700\u7684\u53c2\u6570\uff0c\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5df2\u7ecf\u9a8c\u8bc1\u7684\u6570\u636e\u5c06\u4f5c\u4e3a\u5b57\u5178\u4f20\u9012\u3002</p> <pre><code>from pydantic import BaseModel, EmailStr, Field\n\n\nclass User(BaseModel):\n    email: EmailStr\n    username: str = Field(default_factory=lambda data: data['email'])\n\n\nuser = User(email='user@example.com')\nprint(user.username)\n#&gt; user@example.com\n</code></pre> <p><code>data</code> \u53c2\u6570\u5c06\u4ec5\u5305\u542b\u5df2\u7ecf\u9a8c\u8bc1\u7684\u6570\u636e\uff0c\u57fa\u4e8e \u6a21\u578b\u5b57\u6bb5\u7684\u987a\u5e8f \uff08\u5982\u679c <code>username</code> \u5728 <code>email</code> \u4e4b\u524d\u5b9a\u4e49\uff0c\u4e0a\u9762\u7684\u793a\u4f8b\u5c06\u5931\u8d25\uff09\u3002</p>"},{"location":"concepts/fields/#validate-default-values","title":"\u9a8c\u8bc1\u9ed8\u8ba4\u503c","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u4e0d\u4f1a\u9a8c\u8bc1\u9ed8\u8ba4\u503c\u3002\u53ef\u4ee5\u4f7f\u7528 <code>validate_default</code> \u5b57\u6bb5\u53c2\u6570 \uff08\u6216 <code>validate_default</code> \u914d\u7f6e\u503c\uff09\u6765\u542f\u7528\u6b64\u884c\u4e3a\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    age: int = Field(default='twelve', validate_default=True)\n\n\ntry:\n    user = User()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='twelve', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"concepts/fields/#_1","title":"\u53ef\u53d8\u9ed8\u8ba4\u503c","text":"<p>Python \u4e2d\u4e00\u4e2a\u5e38\u89c1\u7684\u9519\u8bef\u6765\u6e90\u662f\u4f7f\u7528\u53ef\u53d8\u5bf9\u8c61\u4f5c\u4e3a\u51fd\u6570\u6216\u65b9\u6cd5\u53c2\u6570\u7684\u9ed8\u8ba4\u503c\uff0c \u56e0\u4e3a\u76f8\u540c\u7684\u5b9e\u4f8b\u6700\u7ec8\u4f1a\u5728\u6bcf\u6b21\u8c03\u7528\u4e2d\u88ab\u91cd\u7528\u3002</p> <p><code>dataclasses</code> \u6a21\u5757\u5b9e\u9645\u4e0a\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u4f1a\u5f15\u53d1\u9519\u8bef\uff0c\u6307\u793a\u60a8\u5e94\u8be5\u4f7f\u7528 \u9ed8\u8ba4\u5de5\u5382 \u66ff\u4ee3\u3002</p> <p>\u867d\u7136\u53ef\u4ee5\u5728 Pydantic \u4e2d\u505a\u540c\u6837\u7684\u4e8b\u60c5\uff0c\u4f46\u8fd9\u4e0d\u662f\u5fc5\u9700\u7684\u3002\u5982\u679c\u9ed8\u8ba4\u503c\u4e0d\u53ef\u54c8\u5e0c\uff0c Pydantic \u5c06\u5728\u521b\u5efa\u6a21\u578b\u7684\u6bcf\u4e2a\u5b9e\u4f8b\u65f6\u521b\u5efa\u9ed8\u8ba4\u503c\u7684\u6df1\u62f7\u8d1d\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    item_counts: list[dict[str, int]] = [{}]\n\n\nm1 = Model()\nm1.item_counts[0]['a'] = 1\nprint(m1.item_counts)\n#&gt; [{'a': 1}]\n\n\nm2 = Model()\nprint(m2.item_counts)\n#&gt; [{}]\n</code></pre>"},{"location":"concepts/fields/#field-aliases","title":"\u5b57\u6bb5\u522b\u540d","text":"<p>Tip</p> <p>\u5728 \u4e13\u7528\u7ae0\u8282 \u4e2d\u9605\u8bfb\u66f4\u591a\u5173\u4e8e\u522b\u540d\u7684\u4fe1\u606f\u3002</p> <p>\u5bf9\u4e8e\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\uff0c\u60a8\u53ef\u4ee5\u4e3a\u5b57\u6bb5\u5b9a\u4e49\u522b\u540d\u3002</p> <p>\u6709\u4e09\u79cd\u5b9a\u4e49\u522b\u540d\u7684\u65b9\u5f0f\uff1a</p> <ul> <li><code>Field(alias='foo')</code></li> <li><code>Field(validation_alias='foo')</code></li> <li><code>Field(serialization_alias='foo')</code></li> </ul> <p><code>alias</code> \u53c2\u6570\u7528\u4e8e\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u3002\u5982\u679c\u60a8\u60f3\u5206\u522b\u4f7f\u7528\u4e0d\u540c\u7684\u522b\u540d\u8fdb\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\uff0c \u53ef\u4ee5\u4f7f\u7528 <code>validation_alias</code> \u548c <code>serialization_alias</code> \u53c2\u6570\uff0c\u8fd9\u4e9b\u53c2\u6570\u5c06\u4ec5\u5728\u5176\u5404\u81ea\u7684\u4f7f\u7528\u573a\u666f\u4e2d\u5e94\u7528\u3002</p> <p>\u4ee5\u4e0b\u662f\u4f7f\u7528 <code>alias</code> \u53c2\u6570\u7684\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\nprint(user)\n#&gt; name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#&gt; {'username': 'johndoe'}\n</code></pre> <ol> <li>\u522b\u540d <code>'username'</code> \u7528\u4e8e\u5b9e\u4f8b\u521b\u5efa\u548c\u9a8c\u8bc1\u3002</li> <li> <p>\u6211\u4eec\u4f7f\u7528 <code>model_dump()</code> \u5c06\u6a21\u578b\u8f6c\u6362\u4e3a\u53ef\u5e8f\u5217\u5316\u7684\u683c\u5f0f\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c<code>by_alias</code> \u5173\u952e\u5b57\u53c2\u6570\u9ed8\u8ba4\u4e3a <code>False</code>\uff0c\u5fc5\u987b\u660e\u786e\u6307\u5b9a\u624d\u80fd\u4f7f\u7528\u5b57\u6bb5\uff08\u5e8f\u5217\u5316\uff09\u522b\u540d \u6765\u8f6c\u50a8\u6a21\u578b\u3002</p> <p>\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528 <code>ConfigDict.serialize_by_alias</code> \u6765 \u5728\u6a21\u578b\u7ea7\u522b\u914d\u7f6e\u6b64\u884c\u4e3a\u3002</p> <p>\u5f53 <code>by_alias=True</code> \u65f6\uff0c\u522b\u540d <code>'username'</code> \u5728\u5e8f\u5217\u5316\u671f\u95f4\u4f7f\u7528\u3002</p> </li> </ol> <p>\u5982\u679c\u60a8\u60f3\u4ec5\u4e3a\u9a8c\u8bc1\u4f7f\u7528\u522b\u540d\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>validation_alias</code> \u53c2\u6570\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(validation_alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\nprint(user)\n#&gt; name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#&gt; {'name': 'johndoe'}\n</code></pre> <ol> <li>\u9a8c\u8bc1\u522b\u540d <code>'username'</code> \u5728\u9a8c\u8bc1\u671f\u95f4\u4f7f\u7528\u3002</li> <li>\u5b57\u6bb5\u540d\u79f0 <code>'name'</code> \u5728\u5e8f\u5217\u5316\u671f\u95f4\u4f7f\u7528\u3002</li> </ol> <p>\u5982\u679c\u60a8\u53ea\u60f3\u4e3a\u5e8f\u5217\u5316\u5b9a\u4e49\u522b\u540d\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>serialization_alias</code> \u53c2\u6570\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(serialization_alias='username')\n\n\nuser = User(name='johndoe')  # (1)!\nprint(user)\n#&gt; name='johndoe'\nprint(user.model_dump(by_alias=True))  # (2)!\n#&gt; {'username': 'johndoe'}\n</code></pre> <ol> <li>\u5b57\u6bb5\u540d\u79f0 <code>'name'</code> \u7528\u4e8e\u9a8c\u8bc1\u3002</li> <li>\u5e8f\u5217\u5316\u522b\u540d <code>'username'</code> \u7528\u4e8e\u5e8f\u5217\u5316\u3002</li> </ol> <p>\u522b\u540d\u4f18\u5148\u7ea7</p> <p>\u5982\u679c\u60a8\u540c\u65f6\u4f7f\u7528 <code>alias</code> \u548c <code>validation_alias</code> \u6216 <code>serialization_alias</code>\uff0c \u5bf9\u4e8e\u9a8c\u8bc1\uff0c<code>validation_alias</code> \u5c06\u4f18\u5148\u4e8e <code>alias</code>\uff0c\u5bf9\u4e8e\u5e8f\u5217\u5316\uff0c<code>serialization_alias</code> \u5c06\u4f18\u5148\u4e8e <code>alias</code>\u3002</p> <p>\u5982\u679c\u60a8\u4e3a <code>alias_generator</code> \u6a21\u578b\u8bbe\u7f6e\u63d0\u4f9b\u4e86\u503c\uff0c \u60a8\u53ef\u4ee5\u901a\u8fc7 <code>alias_priority</code> \u5b57\u6bb5\u53c2\u6570\u63a7\u5236\u5b57\u6bb5\u522b\u540d\u548c\u751f\u6210\u522b\u540d\u7684\u4f18\u5148\u7ea7\u987a\u5e8f\u3002 \u60a8\u53ef\u4ee5\u5728\u8fd9\u91cc\u9605\u8bfb\u66f4\u591a\u5173\u4e8e\u522b\u540d\u4f18\u5148\u7ea7\u7684\u4fe1\u606f\u3002</p> \u9759\u6001\u7c7b\u578b\u68c0\u67e5/IDE \u652f\u6301 <p>\u5982\u679c\u60a8\u4e3a <code>alias</code> \u5b57\u6bb5\u53c2\u6570\u63d0\u4f9b\u4e86\u503c\uff0c\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u5c06\u4f7f\u7528\u6b64\u522b\u540d\u800c\u4e0d\u662f \u5b9e\u9645\u7684\u5b57\u6bb5\u540d\u79f0\u6765\u5408\u6210 <code>__init__</code> \u65b9\u6cd5\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\n\nuser = User(username='johndoe')  # (1)!\n</code></pre> <ol> <li>\u88ab\u7c7b\u578b\u68c0\u67e5\u5668\u63a5\u53d7\u3002</li> </ol> <p>\u8fd9\u610f\u5473\u7740\u5f53\u4f7f\u7528 <code>validate_by_name</code> \u6a21\u578b\u8bbe\u7f6e\uff08\u5141\u8bb8\u5728\u6a21\u578b\u9a8c\u8bc1\u671f\u95f4\u4f7f\u7528\u5b57\u6bb5\u540d\u79f0\u548c\u522b\u540d\uff09\u65f6\uff0c \u7c7b\u578b\u68c0\u67e5\u5668\u5728\u4f7f\u7528\u5b9e\u9645\u5b57\u6bb5\u540d\u79f0\u65f6\u4f1a\u62a5\u9519\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(validate_by_name=True)\n\n    name: str = Field(alias='username')\n\n\nuser = User(name='johndoe')  # (1)!\n</code></pre> <ol> <li>\u4e0d\u88ab\u7c7b\u578b\u68c0\u67e5\u5668\u63a5\u53d7\u3002</li> </ol> <p>\u5982\u679c\u60a8\u4ecd\u7136\u5e0c\u671b\u7c7b\u578b\u68c0\u67e5\u5668\u4f7f\u7528\u5b57\u6bb5\u540d\u79f0\u800c\u4e0d\u662f\u522b\u540d\uff0c\u53ef\u4ee5\u4f7f\u7528 \u6ce8\u89e3\u6a21\u5f0f \uff08\u4ec5\u88ab Pydantic \u7406\u89e3\uff09\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(validate_by_name=True, validate_by_alias=True)\n\n    name: Annotated[str, Field(alias='username')]\n\n\nuser = User(name='johndoe')  # (1)!\nuser = User(username='johndoe')  # (2)!\n</code></pre> <ol> <li>\u88ab\u7c7b\u578b\u68c0\u67e5\u5668\u63a5\u53d7\u3002</li> <li>\u4e0d\u88ab\u7c7b\u578b\u68c0\u67e5\u5668\u63a5\u53d7\u3002</li> </ol> <p>\u9a8c\u8bc1\u522b\u540d</p> <p>\u5c3d\u7ba1 Pydantic \u5728\u521b\u5efa\u6a21\u578b\u5b9e\u4f8b\u65f6\u5c06 <code>alias</code> \u548c <code>validation_alias</code> \u89c6\u4e3a\u76f8\u540c\uff0c\u4f46\u7c7b\u578b\u68c0\u67e5\u5668 \u4ec5\u7406\u89e3 <code>alias</code> \u5b57\u6bb5\u53c2\u6570\u3002\u4f5c\u4e3a\u89e3\u51b3\u65b9\u6cd5\uff0c\u60a8\u53ef\u4ee5\u6539\u4e3a\u540c\u65f6\u6307\u5b9a <code>alias</code> \u548c <code>serialization_alias</code>\uff08\u4e0e\u5b57\u6bb5\u540d\u79f0\u76f8\u540c\uff09\uff0c\u56e0\u4e3a <code>serialization_alias</code> \u5c06\u5728\u5e8f\u5217\u5316\u671f\u95f4\u8986\u76d6 <code>alias</code>\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass MyModel(BaseModel):\n    my_field: int = Field(validation_alias='myValidationAlias')\n</code></pre> <p>\u66ff\u6362\u4e3a\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass MyModel(BaseModel):\n    my_field: int = Field(\n        alias='myValidationAlias',\n        serialization_alias='my_field',\n    )\n\n\nm = MyModel(myValidationAlias=1)\nprint(m.model_dump(by_alias=True))\n#&gt; {'my_field': 1}\n</code></pre> <p></p> <p></p> <p></p>"},{"location":"concepts/fields/#field-constraints","title":"\u5b57\u6bb5\u7ea6\u675f","text":"<p><code>Field()</code> \u51fd\u6570\u4e5f\u53ef\u7528\u4e8e\u5411\u7279\u5b9a\u7c7b\u578b\u6dfb\u52a0\u7ea6\u675f\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    positive: int = Field(gt=0)\n    short_str: str = Field(max_length=3)\n    precise_decimal: Decimal = Field(max_digits=5, decimal_places=2)\n</code></pre> <p>\u6bcf\u79cd\u7c7b\u578b\u53ef\u7528\u7684\u7ea6\u675f\uff08\u4ee5\u53ca\u5b83\u4eec\u5f71\u54cd JSON Schema \u7684\u65b9\u5f0f\uff09\u5728 \u6807\u51c6\u5e93\u7c7b\u578b \u6587\u6863\u4e2d\u6709\u63cf\u8ff0\u3002</p> <p></p>"},{"location":"concepts/fields/#_2","title":"\u4e25\u683c\u5b57\u6bb5","text":"<p><code>Field()</code> \u51fd\u6570\u7684 <code>strict</code> \u53c2\u6570\u6307\u5b9a\u5b57\u6bb5\u662f\u5426\u5e94\u5728 \u4e25\u683c\u6a21\u5f0f \u4e0b\u8fdb\u884c\u9a8c\u8bc1\u3002</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(strict=True)\n    age: int = Field(strict=False)  # (1)!\n\n\nuser = User(name='John', age='42')  # (2)!\nprint(user)\n#&gt; name='John' age=42\n</code></pre> <ol> <li>\u8fd9\u662f\u9ed8\u8ba4\u503c\u3002</li> <li><code>age</code> \u5b57\u6bb5\u5728\u5bbd\u677e\u6a21\u5f0f\u4e0b\u8fdb\u884c\u9a8c\u8bc1\u3002\u56e0\u6b64\uff0c\u5b83\u53ef\u4ee5\u88ab\u5206\u914d\u4e00\u4e2a\u5b57\u7b26\u4e32\u3002</li> </ol> <p>\u6807\u51c6\u5e93\u7c7b\u578b \u6587\u6863\u63cf\u8ff0\u4e86\u6bcf\u79cd\u7c7b\u578b\u7684\u4e25\u683c\u884c\u4e3a\u3002</p> <p></p>"},{"location":"concepts/fields/#_3","title":"\u6570\u636e\u7c7b\u5b57\u6bb5","text":"<p><code>Field()</code> \u51fd\u6570\u7684\u4e00\u4e9b\u53c2\u6570\u53ef\u7528\u4e8e \u6570\u636e\u7c7b\uff1a</p> <ul> <li><code>init</code>\uff1a\u5b57\u6bb5\u662f\u5426\u5e94\u5305\u542b\u5728\u6570\u636e\u7c7b\u7684\u5408\u6210 <code>__init__()</code> \u65b9\u6cd5\u4e2d\u3002</li> <li><code>init_var</code>\uff1a\u5b57\u6bb5\u662f\u5426\u5e94\u4e3a\u6570\u636e\u7c7b\u4e2d\u7684 \u4ec5\u521d\u59cb\u5316 \u5b57\u6bb5\u3002</li> <li><code>kw_only</code>\uff1a\u5b57\u6bb5\u662f\u5426\u5e94\u4e3a\u6570\u636e\u7c7b\u6784\u9020\u51fd\u6570\u4e2d\u7684\u4ec5\u5173\u952e\u5b57\u53c2\u6570\u3002</li> </ul> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str\n    baz: str = Field(init_var=True)\n    qux: str = Field(kw_only=True)\n\n\nclass Model(BaseModel):\n    foo: Foo\n\n\nmodel = Model(foo=Foo('bar', baz='baz', qux='qux'))\nprint(model.model_dump())  # (1)!\n#&gt; {'foo': {'bar': 'bar', 'qux': 'qux'}}\n</code></pre> <ol> <li><code>baz</code> \u5b57\u6bb5\u4e0d\u5305\u542b\u5728\u5e8f\u5217\u5316\u8f93\u51fa\u4e2d\uff0c\u56e0\u4e3a\u5b83\u662f\u4e00\u4e2a\u4ec5\u521d\u59cb\u5316\u5b57\u6bb5\u3002</li> </ol>"},{"location":"concepts/fields/#_4","title":"\u5b57\u6bb5\u8868\u793a","text":"<p>\u53c2\u6570 <code>repr</code> \u53ef\u7528\u4e8e\u63a7\u5236\u5b57\u6bb5\u662f\u5426\u5e94\u5305\u542b\u5728\u6a21\u578b\u7684\u5b57\u7b26\u4e32\u8868\u793a\u4e2d\u3002</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(repr=True)  # (1)!\n    age: int = Field(repr=False)\n\n\nuser = User(name='John', age=42)\nprint(user)\n#&gt; name='John'\n</code></pre> <ol> <li>\u8fd9\u662f\u9ed8\u8ba4\u503c\u3002</li> </ol>"},{"location":"concepts/fields/#_5","title":"\u9274\u522b\u5668","text":"<p>\u53c2\u6570 <code>discriminator</code> \u53ef\u7528\u4e8e\u63a7\u5236\u5c06\u7528\u4e8e\u533a\u5206\u8054\u5408\u4e2d\u4e0d\u540c\u6a21\u578b\u7684\u5b57\u6bb5\u3002 \u5b83\u63a5\u53d7\u5b57\u6bb5\u540d\u79f0\u6216 <code>Discriminator</code> \u5b9e\u4f8b\u3002\u5f53\u9274\u522b\u5668\u5b57\u6bb5\u5bf9\u4e8e <code>Union</code> \u4e2d\u7684\u6240\u6709\u6a21\u578b \u4e0d\u5b8c\u5168\u76f8\u540c\u65f6\uff0c<code>Discriminator</code> \u65b9\u6cd5\u53ef\u80fd\u5f88\u6709\u7528\u3002</p> <p>\u4ee5\u4e0b\u793a\u4f8b\u663e\u793a\u5982\u4f55\u4f7f\u7528\u5e26\u6709\u5b57\u6bb5\u540d\u79f0\u7684 <code>discriminator</code>\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    age: int\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n\n\nprint(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}}))  # (1)!\n#&gt; pet=Cat(pet_type='cat', age=12)\n</code></pre> <ol> <li>\u5728 [\u6a21\u578b] \u9875\u9762\u4e2d\u67e5\u770b\u66f4\u591a\u5173\u4e8e [\u9a8c\u8bc1\u6570\u636e] \u7684\u4fe1\u606f\u3002</li> </ol> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    age: int\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog = Field(discriminator='pet_type')\n\n\nprint(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}}))  # (1)!\n#&gt; pet=Cat(pet_type='cat', age=12)\n</code></pre> <ol> <li>\u5728 [\u6a21\u578b] \u9875\u9762\u4e2d\u67e5\u770b\u66f4\u591a\u5173\u4e8e [\u9a8c\u8bc1\u6570\u636e] \u7684\u4fe1\u606f\u3002</li> </ol> <p>\u4ee5\u4e0b\u793a\u4f8b\u663e\u793a\u5982\u4f55\u4f7f\u7528\u5e26\u6709 <code>Discriminator</code> \u5b9e\u4f8b\u7684 <code>discriminator</code> \u5173\u952e\u5b57\u53c2\u6570\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Union[Annotated[Cat, Tag('cat')], Annotated[Dog, Tag('dog')]] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#&gt; Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#&gt; Model(pet=Dog(pet_kind='dog', age=12))\n</code></pre> <pre><code>from typing import Annotated, Literal\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Annotated[Cat, Tag('cat')] | Annotated[Dog, Tag('dog')] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#&gt; Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#&gt; Model(pet=Dog(pet_kind='dog', age=12))\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u5229\u7528 <code>Annotated</code> \u6765\u5b9a\u4e49\u60a8\u7684\u9274\u522b\u8054\u5408\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 [\u9274\u522b\u8054\u5408] \u6587\u6863\u3002</p>"},{"location":"concepts/fields/#_6","title":"\u4e0d\u53ef\u53d8\u6027","text":"<p>\u53c2\u6570 <code>frozen</code> \u7528\u4e8e\u6a21\u62df\u51bb\u7ed3\u6570\u636e\u7c7b\u7684\u884c\u4e3a\u3002\u5b83\u7528\u4e8e\u9632\u6b62\u5728\u6a21\u578b\u521b\u5efa\u540e\u4e3a\u5b57\u6bb5\u5206\u914d\u65b0\u503c\uff08\u4e0d\u53ef\u53d8\u6027\uff09\u3002</p> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 [\u51bb\u7ed3\u6570\u636e\u7c7b\u6587\u6863]\u3002</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str = Field(frozen=True)\n    age: int\n\n\nuser = User(name='John', age=42)\n\ntry:\n    user.name = 'Jane'  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Field is frozen [type=frozen_field, input_value='Jane', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u7531\u4e8e <code>name</code> \u5b57\u6bb5\u88ab\u51bb\u7ed3\uff0c\u4e0d\u5141\u8bb8\u8d4b\u503c\u3002</li> </ol>"},{"location":"concepts/fields/#_7","title":"\u6392\u9664","text":"<p><code>exclude</code> \u53c2\u6570\u53ef\u7528\u4e8e\u63a7\u5236\u5728\u5bfc\u51fa\u6a21\u578b\u65f6\u5e94\u4ece\u6a21\u578b\u4e2d\u6392\u9664\u54ea\u4e9b\u5b57\u6bb5\u3002</p> <p>\u8bf7\u53c2\u89c1\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(exclude=True)\n\n\nuser = User(name='John', age=42)\nprint(user.model_dump())  # (1)!\n#&gt; {'name': 'John'}\n</code></pre> <ol> <li><code>age</code> \u5b57\u6bb5\u672a\u5305\u542b\u5728 <code>model_dump()</code> \u8f93\u51fa\u4e2d\uff0c\u56e0\u4e3a\u5b83\u88ab\u6392\u9664\u4e86\u3002</li> </ol> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 [\u5e8f\u5217\u5316] \u90e8\u5206\u3002</p>"},{"location":"concepts/fields/#_8","title":"\u5df2\u5f03\u7528\u5b57\u6bb5","text":"<p><code>deprecated</code> \u53c2\u6570\u53ef\u7528\u4e8e\u5c06\u5b57\u6bb5\u6807\u8bb0\u4e3a\u5df2\u5f03\u7528\u3002\u8fd9\u6837\u505a\u5c06\u5bfc\u81f4\uff1a</p> <ul> <li>\u8bbf\u95ee\u5b57\u6bb5\u65f6\u53d1\u51fa\u8fd0\u884c\u65f6\u5f03\u7528\u8b66\u544a\u3002</li> <li>\u5728\u751f\u6210\u7684 JSON Schema \u4e2d\u8bbe\u7f6e deprecated \u5173\u952e\u5b57\u3002</li> </ul> <p>\u6b64\u53c2\u6570\u63a5\u53d7\u4e0d\u540c\u7684\u7c7b\u578b\uff0c\u5982\u4e0b\u6240\u8ff0\u3002</p>"},{"location":"concepts/fields/#deprecated","title":"<code>deprecated</code> \u4f5c\u4e3a\u5b57\u7b26\u4e32","text":"<p>\u8be5\u503c\u5c06\u7528\u4f5c\u5f03\u7528\u6d88\u606f\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated='This is deprecated')]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#&gt; {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n</code></pre>"},{"location":"concepts/fields/#warningsdeprecated-deprecated","title":"\u901a\u8fc7 <code>@warnings.deprecated</code> \u88c5\u9970\u5668\u4f7f\u7528 <code>deprecated</code>","text":"<p><code>@warnings.deprecated</code> \u88c5\u9970\u5668\uff08\u6216\u5728 Python 3.12 \u53ca\u66f4\u4f4e\u7248\u672c\u4e0a\u7684 <code>typing_extensions</code> \u540e\u5907\uff09\u53ef\u7528\u4f5c\u5b9e\u4f8b\u3002</p> Python 3.9 \u53ca\u4ee5\u4e0aPython 3.13 \u53ca\u4ee5\u4e0a <pre><code>from typing import Annotated\n\nfrom typing_extensions import deprecated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, deprecated('This is deprecated')]\n\n    # \u6216\u663e\u5f0f\u4f7f\u7528 `Field`\uff1a\n    alt_form: Annotated[int, Field(deprecated=deprecated('This is deprecated'))]\n</code></pre> <pre><code>from typing import Annotated\nfrom warnings import deprecated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, deprecated('This is deprecated')]\n\n    # \u6216\u663e\u5f0f\u4f7f\u7528 `Field`\uff1a\n    alt_form: Annotated[int, Field(deprecated=deprecated('This is deprecated'))]\n</code></pre> <p>\u5bf9 <code>category</code> \u548c <code>stacklevel</code> \u7684\u652f\u6301</p> <p>\u6b64\u529f\u80fd\u7684\u5f53\u524d\u5b9e\u73b0\u672a\u8003\u8651 <code>deprecated</code> \u88c5\u9970\u5668\u7684 <code>category</code> \u548c <code>stacklevel</code> \u53c2\u6570\u3002\u8fd9\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u7684 Pydantic \u7248\u672c\u4e2d\u5b9e\u73b0\u3002</p>"},{"location":"concepts/fields/#deprecated_1","title":"<code>deprecated</code> \u4f5c\u4e3a\u5e03\u5c14\u503c","text":"<pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated=True)]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#&gt; {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n</code></pre> <p>\u5728\u9a8c\u8bc1\u5668\u4e2d\u8bbf\u95ee\u5df2\u5f03\u7528\u5b57\u6bb5</p> <p>\u5728\u9a8c\u8bc1\u5668\u5185\u90e8\u8bbf\u95ee\u5df2\u5f03\u7528\u5b57\u6bb5\u65f6\uff0c\u5c06\u53d1\u51fa\u5f03\u7528\u8b66\u544a\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>catch_warnings</code> \u663e\u5f0f\u5ffd\u7565\u5b83\uff1a</p> <pre><code>import warnings\n\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, Field, model_validator\n\n\nclass Model(BaseModel):\n    deprecated_field: int = Field(deprecated='This is deprecated')\n\n    @model_validator(mode='after')\n    def validate_model(self) -&gt; Self:\n        with warnings.catch_warnings():\n            warnings.simplefilter('ignore', DeprecationWarning)\n            self.deprecated_field = self.deprecated_field * 2\n</code></pre>"},{"location":"concepts/fields/#customizing-json-schema","title":"\u81ea\u5b9a\u4e49 JSON Schema","text":"<p>\u4e00\u4e9b\u5b57\u6bb5\u53c2\u6570\u4e13\u95e8\u7528\u4e8e\u81ea\u5b9a\u4e49\u751f\u6210\u7684 JSON Schema\u3002\u8fd9\u4e9b\u53c2\u6570\u5305\u62ec\uff1a</p> <ul> <li><code>title</code></li> <li><code>description</code></li> <li><code>examples</code></li> <li><code>json_schema_extra</code></li> </ul> <p>\u6709\u5173\u4f7f\u7528\u5b57\u6bb5\u81ea\u5b9a\u4e49/\u4fee\u6539 JSON Schema \u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 JSON Schema \u6587\u6863\u4e2d\u7684 [\u81ea\u5b9a\u4e49 JSON Schema] \u90e8\u5206\u3002</p>"},{"location":"concepts/fields/#computed_field","title":"<code>computed_field</code> \u88c5\u9970\u5668","text":"API \u6587\u6863 <p><code>computed_field</code></p> <p><code>computed_field</code> \u88c5\u9970\u5668\u53ef\u7528\u4e8e\u5728\u5e8f\u5217\u5316\u6a21\u578b\u6216\u6570\u636e\u7c7b\u65f6\u5305\u542b <code>property</code> \u6216 <code>cached_property</code> \u5c5e\u6027\u3002 \u8be5\u5c5e\u6027\u4e5f\u5c06\u5728 JSON Schema\uff08\u5e8f\u5217\u5316\u6a21\u5f0f\uff09\u4e2d\u88ab\u8003\u8651\u3002</p> <p>Note</p> <p>\u5c5e\u6027\u5bf9\u4e8e\u4ece\u5176\u4ed6\u5b57\u6bb5\u8ba1\u7b97\u7684\u5b57\u6bb5\uff0c\u6216\u8005\u8ba1\u7b97\u6210\u672c\u9ad8\u6602\u7684\u5b57\u6bb5\uff08\u56e0\u6b64\uff0c\u5982\u679c\u4f7f\u7528 <code>cached_property</code> \u5219\u4f1a\u88ab\u7f13\u5b58\uff09\u975e\u5e38\u6709\u7528\u3002</p> <p>\u4f46\u662f\uff0c\u8bf7\u6ce8\u610f Pydantic \u5c06\u4e0d\u4f1a\u5bf9\u5305\u88c5\u7684\u5c5e\u6027\u6267\u884c\u4efb\u4f55\u989d\u5916\u7684\u903b\u8f91 \uff08\u9a8c\u8bc1\u3001\u7f13\u5b58\u5931\u6548\u7b49\uff09\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e3a\u5e26\u6709\u8ba1\u7b97\u5b57\u6bb5\u7684\u6a21\u578b\u751f\u6210\u7684 JSON Schema\uff08\u5e8f\u5217\u5316\u6a21\u5f0f\uff09\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property  # (1)!\n    def volume(self) -&gt; float:\n        return self.width * self.height * self.depth\n\n\nprint(Box.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'width': {'title': 'Width', 'type': 'number'},\n        'height': {'title': 'Height', 'type': 'number'},\n        'depth': {'title': 'Depth', 'type': 'number'},\n        'volume': {'readOnly': True, 'title': 'Volume', 'type': 'number'},\n    },\n    'required': ['width', 'height', 'depth', 'volume'],\n    'title': 'Box',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <ol> <li>\u5982\u679c\u672a\u6307\u5b9a\uff0c<code>computed_field</code> \u5c06\u9690\u5f0f\u5c06\u65b9\u6cd5    \u8f6c\u6362\u4e3a <code>property</code>\u3002\u4f46\u662f\uff0c\u4e3a\u4e86\u7c7b\u578b\u68c0\u67e5\u76ee\u7684\uff0c\u6700\u597d\u663e\u5f0f\u4f7f\u7528 <code>@property</code> \u88c5\u9970\u5668\u3002</li> </ol> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528 <code>model_dump</code> \u65b9\u6cd5\u548c\u8ba1\u7b97\u5b57\u6bb5\u7684\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    def volume(self) -&gt; float:\n        return self.width * self.height * self.depth\n\n\nb = Box(width=1, height=2, depth=3)\nprint(b.model_dump())\n#&gt; {'width': 1.0, 'height': 2.0, 'depth': 3.0, 'volume': 6.0}\n</code></pre> <p>\u4e0e\u5e38\u89c4\u5b57\u6bb5\u4e00\u6837\uff0c\u8ba1\u7b97\u5b57\u6bb5\u53ef\u4ee5\u6807\u8bb0\u4e3a\u5df2\u5f03\u7528\uff1a</p> Python 3.9 and abovePython 3.13 and above <pre><code>from typing_extensions import deprecated\n\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    @deprecated(\"'volume' is deprecated\")\n    def volume(self) -&gt; float:\n        return self.width * self.height * self.depth\n</code></pre> <pre><code>from warnings import deprecated\n\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    @deprecated(\"'volume' is deprecated\")\n    def volume(self) -&gt; float:\n        return self.width * self.height * self.depth\n</code></pre>"},{"location":"concepts/forward_annotations/","title":"Forward Annotations","text":"<p>\u524d\u5411\u6ce8\u89e3\uff08\u7528\u5f15\u53f7\u5305\u88f9\uff09\u6216\u4f7f\u7528 <code>from __future__ import annotations</code> future statement \uff08\u5982 PEP563 \u4e2d\u5f15\u5165\u7684\uff09\u662f\u53d7\u652f\u6301\u7684\uff1a</p> <pre><code>from __future__ import annotations\n\nfrom pydantic import BaseModel\n\nMyInt = int\n\n\nclass Model(BaseModel):\n    a: MyInt\n    # \u5982\u679c\u6ca1\u6709 future \u5bfc\u5165\uff0c\u7b49\u4ef7\u4e8e\uff1a\n    # a: 'MyInt'\n\n\nprint(Model(a='1'))\n#&gt; a=1\n</code></pre> <p>\u5982\u4ee5\u4e0b\u90e8\u5206\u6240\u793a\uff0c\u5f53\u60a8\u60f3\u8981\u5f15\u7528\u4ee3\u7801\u4e2d\u5c1a\u672a\u5b9a\u4e49\u7684\u7c7b\u578b\u65f6\uff0c\u524d\u5411\u6ce8\u89e3\u975e\u5e38\u6709\u7528\u3002</p> <p>\u89e3\u6790\u524d\u5411\u6ce8\u89e3\u7684\u5185\u90e8\u903b\u8f91\u5728\u6b64\u7ae0\u8282\u4e2d\u6709\u8be6\u7ec6\u63cf\u8ff0\u3002</p>"},{"location":"concepts/forward_annotations/#self-referencing-or-recursive-models","title":"\u81ea\u5f15\u7528\uff08\u6216\"\u9012\u5f52\"\uff09\u6a21\u578b","text":"<p>\u652f\u6301\u5177\u6709\u81ea\u5f15\u7528\u5b57\u6bb5\u7684\u6a21\u578b\u3002\u8fd9\u4e9b\u6ce8\u89e3\u5c06\u5728\u6a21\u578b\u521b\u5efa\u671f\u95f4\u89e3\u6790\u3002</p> <p>\u5728\u6a21\u578b\u5185\u90e8\uff0c\u60a8\u53ef\u4ee5\u6dfb\u52a0 <code>from __future__ import annotations</code> \u5bfc\u5165\u6216\u5c06\u6ce8\u89e3\u5305\u88c5\u5728\u5b57\u7b26\u4e32\u4e2d\uff1a</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    sibling: 'Optional[Foo]' = None\n\n\nprint(Foo())\n#&gt; a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#&gt; a=123 sibling=Foo(a=321, sibling=None)\n</code></pre>"},{"location":"concepts/forward_annotations/#_1","title":"\u5faa\u73af\u5f15\u7528","text":"<p>\u5728\u4f7f\u7528\u81ea\u5f15\u7528\u9012\u5f52\u6a21\u578b\u65f6\uff0c\u60a8\u53ef\u80fd\u4f1a\u5728\u9a8c\u8bc1\u8f93\u5165\u4e2d\u9047\u5230\u5faa\u73af\u5f15\u7528\u3002\u4f8b\u5982\uff0c\u5f53\u9a8c\u8bc1\u5177\u6709\u6765\u81ea\u5c5e\u6027\u7684\u53cd\u5411\u5f15\u7528\u7684 ORM \u5b9e\u4f8b\u65f6\uff0c\u53ef\u80fd\u4f1a\u53d1\u751f\u8fd9\u79cd\u60c5\u51b5\u3002</p> <p>Pydantic \u4e0d\u4f1a\u5728\u5c1d\u8bd5\u9a8c\u8bc1\u5177\u6709\u5faa\u73af\u5f15\u7528\u7684\u6570\u636e\u65f6\u5f15\u53d1 <code>RecursionError</code>\uff0c\u800c\u662f\u80fd\u591f\u68c0\u6d4b\u5230\u5faa\u73af\u5f15\u7528\u5e76\u5f15\u53d1\u9002\u5f53\u7684 <code>ValidationError</code>\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass ModelA(BaseModel):\n    b: 'Optional[ModelB]' = None\n\n\nclass ModelB(BaseModel):\n    a: Optional[ModelA] = None\n\n\ncyclic_data = {}\ncyclic_data['a'] = {'b': cyclic_data}\nprint(cyclic_data)\n#&gt; {'a': {'b': {...}}}\n\ntry:\n    ModelB.model_validate(cyclic_data)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for ModelB\n    a.b\n      Recursion error - cyclic reference detected [type=recursion_loop, input_value={'a': {'b': {...}}}, input_type=dict]\n    \"\"\"\n</code></pre> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass ModelA(BaseModel):\n    b: 'Optional[ModelB]' = None\n\n\nclass ModelB(BaseModel):\n    a: ModelA | None = None\n\n\ncyclic_data = {}\ncyclic_data['a'] = {'b': cyclic_data}\nprint(cyclic_data)\n#&gt; {'a': {'b': {...}}}\n\ntry:\n    ModelB.model_validate(cyclic_data)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for ModelB\n    a.b\n      Recursion error - cyclic reference detected [type=recursion_loop, input_value={'a': {'b': {...}}}, input_type=dict]\n    \"\"\"\n</code></pre> <p>\u7531\u4e8e\u6b64\u9519\u8bef\u662f\u5728\u672a\u5b9e\u9645\u8d85\u8fc7\u6700\u5927\u9012\u5f52\u6df1\u5ea6\u7684\u60c5\u51b5\u4e0b\u5f15\u53d1\u7684\uff0c\u60a8\u53ef\u4ee5\u6355\u83b7\u5e76\u5904\u7406\u5f15\u53d1\u7684 <code>ValidationError</code>\uff0c\u800c\u65e0\u9700\u62c5\u5fc3\u6709\u9650\u7684\u5269\u4f59\u9012\u5f52\u6df1\u5ea6\uff1a</p> <pre><code>from __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom dataclasses import field\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\ndef is_recursion_validation_error(exc: ValidationError) -&gt; bool:\n    errors = exc.errors()\n    return len(errors) == 1 and errors[0]['type'] == 'recursion_loop'\n\n\n@contextmanager\ndef suppress_recursion_validation_error() -&gt; Generator[None]:\n    try:\n        yield\n    except ValidationError as exc:\n        if not is_recursion_validation_error(exc):\n            raise exc\n\n\nclass Node(BaseModel):\n    id: int\n    children: list[Node] = field(default_factory=list)\n\n    @field_validator('children', mode='wrap')\n    @classmethod\n    def drop_cyclic_references(cls, children, h):\n        try:\n            return h(children)\n        except ValidationError as exc:\n            if not (\n                is_recursion_validation_error(exc)\n                and isinstance(children, list)\n            ):\n                raise exc\n\n            value_without_cyclic_refs = []\n            for child in children:\n                with suppress_recursion_validation_error():\n                    value_without_cyclic_refs.extend(h([child]))\n            return h(value_without_cyclic_refs)\n\n\n# Create data with cyclic references representing the graph 1 -&gt; 2 -&gt; 3 -&gt; 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\nprint(Node.model_validate(node_data))\n#&gt; id=1 children=[Node(id=2, children=[Node(id=3, children=[])])]\n</code></pre> <p>\u7c7b\u4f3c\u5730\uff0c\u5982\u679c Pydantic \u5728\u5e8f\u5217\u5316\u671f\u95f4\u9047\u5230\u9012\u5f52\u5f15\u7528\uff0c\u800c\u4e0d\u662f\u7b49\u5f85\u8d85\u8fc7\u6700\u5927\u9012\u5f52\u6df1\u5ea6\uff0c\u4f1a\u7acb\u5373\u5f15\u53d1 <code>ValueError</code>\uff1a</p> <pre><code>from pydantic import TypeAdapter\n\n# Create data with cyclic references representing the graph 1 -&gt; 2 -&gt; 3 -&gt; 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\ntry:\n    # Try serializing the circular reference as JSON\n    TypeAdapter(dict).dump_json(node_data)\nexcept ValueError as exc:\n    print(exc)\n    \"\"\"\n    Error serializing to JSON: ValueError: Circular reference detected (id repeated)\n    \"\"\"\n</code></pre> <p>\u5982\u679c\u9700\u8981\uff0c\u4e5f\u53ef\u4ee5\u5904\u7406\u8fd9\u79cd\u60c5\u51b5\uff1a</p> <pre><code>from dataclasses import field\nfrom typing import Any\n\nfrom pydantic import (\n    SerializerFunctionWrapHandler,\n    TypeAdapter,\n    field_serializer,\n)\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass NodeReference:\n    id: int\n\n\n@dataclass\nclass Node(NodeReference):\n    children: list['Node'] = field(default_factory=list)\n\n    @field_serializer('children', mode='wrap')\n    def serialize(\n        self, children: list['Node'], handler: SerializerFunctionWrapHandler\n    ) -&gt; Any:\n        \"\"\"\n        \u5e8f\u5217\u5316\u8282\u70b9\u5217\u8868\uff0c\u901a\u8fc7\u6392\u9664\u5b50\u8282\u70b9\u6765\u5904\u7406\u5faa\u73af\u5f15\u7528\u3002\n        \"\"\"\n        try:\n            return handler(children)\n        except ValueError as exc:\n            if not str(exc).startswith('Circular reference'):\n                raise exc\n\n            result = []\n            for node in children:\n                try:\n                    serialized = handler([node])\n                except ValueError as exc:\n                    if not str(exc).startswith('Circular reference'):\n                        raise exc\n                    result.append({'id': node.id})\n                else:\n                    result.append(serialized)\n            return result\n\n\n# Create a cyclic graph:\nnodes = [Node(id=1), Node(id=2), Node(id=3)]\nnodes[0].children.append(nodes[1])\nnodes[1].children.append(nodes[2])\nnodes[2].children.append(nodes[0])\n\nprint(nodes[0])\n#&gt; Node(id=1, children=[Node(id=2, children=[Node(id=3, children=[...])])])\n\n# Serialize the cyclic graph:\nprint(TypeAdapter(Node).dump_python(nodes[0]))\n\"\"\"\n{\n    'id': 1,\n    'children': [{'id': 2, 'children': [{'id': 3, 'children': [{'id': 1}]}]}],\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json/","title":"JSON","text":""},{"location":"concepts/json/#json_1","title":"JSON \u89e3\u6790","text":"API \u6587\u6863 <p><code>pydantic.main.BaseModel.model_validate_json</code> <code>pydantic.type_adapter.TypeAdapter.validate_json</code> <code>pydantic_core.from_json</code></p> <p>Pydantic \u63d0\u4f9b\u4e86\u5185\u7f6e\u7684 JSON \u89e3\u6790\u529f\u80fd\uff0c\u8fd9\u6709\u52a9\u4e8e\u5b9e\u73b0\uff1a</p> <ul> <li>\u663e\u8457\u7684\u6027\u80fd\u6539\u8fdb\uff0c\u65e0\u9700\u4f7f\u7528\u7b2c\u4e09\u65b9\u5e93\u7684\u6210\u672c</li> <li>\u652f\u6301\u81ea\u5b9a\u4e49\u9519\u8bef</li> <li>\u652f\u6301 <code>strict</code> \u89c4\u8303</li> </ul> <p>\u4ee5\u4e0b\u662f Pydantic \u5185\u7f6e JSON \u89e3\u6790\u7684\u793a\u4f8b\uff0c\u901a\u8fc7 <code>model_validate_json</code> \u65b9\u6cd5\u5c55\u793a\u4e86\u5bf9 <code>strict</code> \u89c4\u8303\u7684\u652f\u6301\uff0c\u540c\u65f6\u89e3\u6790\u4e0e\u6a21\u578b\u7c7b\u578b\u6ce8\u89e3\u4e0d\u5339\u914d\u7684 JSON \u6570\u636e\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    when: date\n    where: tuple[int, int]\n\n\njson_data = '{\"when\": \"1987-01-28\", \"where\": [51, -1]}'\nprint(Event.model_validate_json(json_data))  # (1)!\n#&gt; when=datetime.date(1987, 1, 28) where=(51, -1)\n\ntry:\n    Event.model_validate({'when': '1987-01-28', 'where': [51, -1]})  # (2)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Event\n    when\n      Input should be a valid date [type=date_type, input_value='1987-01-28', input_type=str]\n    where\n      Input should be a valid tuple [type=tuple_type, input_value=[51, -1], input_type=list]\n    \"\"\"\n</code></pre> <ol> <li>JSON \u6ca1\u6709 <code>date</code> \u6216 tuple \u7c7b\u578b\uff0c\u4f46 Pydantic \u77e5\u9053\u8fd9\u4e00\u70b9\uff0c\u56e0\u6b64\u5728\u76f4\u63a5\u89e3\u6790 JSON \u65f6\u5141\u8bb8\u5206\u522b\u4f7f\u7528\u5b57\u7b26\u4e32\u548c\u6570\u7ec4\u4f5c\u4e3a\u8f93\u5165\u3002</li> <li>\u5982\u679c\u5c06\u76f8\u540c\u7684\u503c\u4f20\u9012\u7ed9 <code>model_validate</code> \u65b9\u6cd5\uff0cPydantic \u5c06\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\uff0c\u56e0\u4e3a\u542f\u7528\u4e86 <code>strict</code> \u914d\u7f6e\u3002</li> </ol> <p>\u5728 v2.5.0 \u53ca\u66f4\u9ad8\u7248\u672c\u4e2d\uff0cPydantic \u4f7f\u7528 <code>jiter</code>\uff08\u4e00\u4e2a\u5feb\u901f\u4e14\u53ef\u8fed\u4ee3\u7684 JSON \u89e3\u6790\u5668\uff09\u6765\u89e3\u6790 JSON \u6570\u636e\u3002 \u4e0e <code>serde</code> \u76f8\u6bd4\uff0c\u4f7f\u7528 <code>jiter</code> \u5e26\u6765\u4e86\u9002\u5ea6\u7684\u6027\u80fd\u6539\u8fdb\uff0c\u5e76\u4e14\u672a\u6765\u4f1a\u53d8\u5f97\u66f4\u597d\u3002</p> <p><code>jiter</code> JSON \u89e3\u6790\u5668\u51e0\u4e4e\u5b8c\u5168\u517c\u5bb9 <code>serde</code> JSON \u89e3\u6790\u5668\uff0c \u5176\u4e2d\u4e00\u4e2a\u663e\u8457\u7684\u589e\u5f3a\u662f <code>jiter</code> \u652f\u6301\u53cd\u5e8f\u5217\u5316 <code>inf</code> \u548c <code>NaN</code> \u503c\u3002 \u5728\u672a\u6765\uff0c<code>jiter</code> \u65e8\u5728\u652f\u6301\u9a8c\u8bc1\u9519\u8bef\u5305\u542b\u539f\u59cb JSON \u8f93\u5165\u4e2d\u5305\u542b\u65e0\u6548\u503c\u7684\u4f4d\u7f6e\u3002</p>"},{"location":"concepts/json/#json_2","title":"\u90e8\u5206 JSON \u89e3\u6790","text":"<p>\u4ece v2.7.0 \u5f00\u59cb\uff0cPydantic \u7684 JSON \u89e3\u6790\u5668 \u63d0\u4f9b\u4e86\u5bf9\u90e8\u5206 JSON \u89e3\u6790\u7684\u652f\u6301\uff0c\u8fd9\u901a\u8fc7 <code>pydantic_core.from_json</code> \u66b4\u9732\u3002\u4ee5\u4e0b\u662f\u6b64\u529f\u80fd\u7684\u5b9e\u9645\u793a\u4f8b\uff1a</p> <pre><code>from pydantic_core import from_json\n\npartial_json_data = '[\"aa\", \"bb\", \"c'  # (1)!\n\ntry:\n    result = from_json(partial_json_data, allow_partial=False)\nexcept ValueError as e:\n    print(e)  # (2)!\n    #&gt; EOF while parsing a string at line 1 column 15\n\nresult = from_json(partial_json_data, allow_partial=True)\nprint(result)  # (3)!\n#&gt; ['aa', 'bb']\n</code></pre> <ol> <li>JSON \u5217\u8868\u4e0d\u5b8c\u6574 - \u7f3a\u5c11\u4e00\u4e2a\u95ed\u5408\u7684 <code>\"]</code></li> <li>\u5f53 <code>allow_partial</code> \u8bbe\u7f6e\u4e3a <code>False</code>\uff08\u9ed8\u8ba4\u503c\uff09\u65f6\uff0c\u4f1a\u53d1\u751f\u89e3\u6790\u9519\u8bef\u3002</li> <li>\u5f53 <code>allow_partial</code> \u8bbe\u7f6e\u4e3a <code>True</code> \u65f6\uff0c\u90e8\u5206\u8f93\u5165\u88ab\u6210\u529f\u53cd\u5e8f\u5217\u5316\u3002</li> </ol> <p>\u8fd9\u4e5f\u9002\u7528\u4e8e\u53cd\u5e8f\u5217\u5316\u90e8\u5206\u5b57\u5178\u3002\u4f8b\u5982\uff1a</p> <pre><code>from pydantic_core import from_json\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog_dict = from_json(partial_dog_json, allow_partial=True)\nprint(dog_dict)\n#&gt; {'breed': 'lab', 'name': 'fluffy', 'friends': ['buddy', 'spot', 'rufus']}\n</code></pre> <p>\u9a8c\u8bc1 LLM \u8f93\u51fa</p> <p>\u6b64\u529f\u80fd\u5bf9\u4e8e\u9a8c\u8bc1 LLM \u8f93\u51fa\u7279\u522b\u6709\u76ca\u3002 \u6211\u4eec\u64b0\u5199\u4e86\u4e00\u4e9b\u5173\u4e8e\u6b64\u4e3b\u9898\u7684\u535a\u5ba2\u6587\u7ae0\uff0c\u60a8\u53ef\u4ee5\u5728\u6211\u4eec\u7684\u7f51\u7ad9\u4e0a\u627e\u5230\u3002</p> <p>\u5728\u672a\u6765\u7684 Pydantic \u7248\u672c\u4e2d\uff0c\u6211\u4eec\u671f\u671b\u901a\u8fc7 Pydantic \u7684\u5176\u4ed6 JSON \u9a8c\u8bc1\u529f\u80fd (<code>pydantic.main.BaseModel.model_validate_json</code> \u548c <code>pydantic.type_adapter.TypeAdapter.validate_json</code>) \u6216\u6a21\u578b\u914d\u7f6e\u6765\u6269\u5c55\u5bf9\u6b64\u529f\u80fd\u7684\u652f\u6301\u3002\u656c\u8bf7\u671f\u5f85 \ud83d\ude80\uff01</p> <p>\u76ee\u524d\uff0c\u60a8\u53ef\u4ee5\u5c06 <code>pydantic_core.from_json</code> \u4e0e <code>pydantic.main.BaseModel.model_validate</code> \u7ed3\u5408\u4f7f\u7528\u4ee5\u8fbe\u5230\u76f8\u540c\u7684\u7ed3\u679c\u3002\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a</p> <pre><code>from pydantic_core import from_json\n\nfrom pydantic import BaseModel\n\n\nclass Dog(BaseModel):\n    breed: str\n    name: str\n    friends: list\n\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))\nprint(repr(dog))\n#&gt; Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])\n</code></pre> <p>Tip</p> <p>\u4e3a\u4e86\u4f7f\u90e8\u5206 JSON \u89e3\u6790\u53ef\u9760\u5de5\u4f5c\uff0c\u6a21\u578b\u4e0a\u7684\u6240\u6709\u5b57\u6bb5\u90fd\u5e94\u5177\u6709\u9ed8\u8ba4\u503c\u3002</p> <p>\u67e5\u770b\u4ee5\u4e0b\u793a\u4f8b\uff0c\u6df1\u5165\u4e86\u89e3\u5982\u4f55\u5728\u90e8\u5206 JSON \u89e3\u6790\u4e2d\u4f7f\u7528\u9ed8\u8ba4\u503c\uff1a</p> <p>\u5728\u90e8\u5206 JSON \u89e3\u6790\u4e2d\u4f7f\u7528\u9ed8\u8ba4\u503c</p> <pre><code>from typing import Annotated, Any, Optional\n\nimport pydantic_core\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\n\ndef default_on_error(v, handler) -&gt; Any:\n    \"\"\"\n    \u5982\u679c\u503c\u7f3a\u5931\uff0c\u5219\u5f15\u53d1 PydanticUseDefault \u5f02\u5e38\u3002\n\n    \u8fd9\u5bf9\u4e8e\u907f\u514d\u56e0\u90e8\u5206 JSON \u963b\u6b62\u6210\u529f\u9a8c\u8bc1\u800c\u5bfc\u81f4\u7684\u9519\u8bef\u975e\u5e38\u6709\u7528\u3002\n    \"\"\"\n    try:\n        return handler(v)\n    except ValidationError as exc:\n        # \u53ef\u80fd\u5b58\u5728\u5176\u4ed6\u7c7b\u578b\u7684\u9519\u8bef\uff0c\u8fd9\u4e9b\u9519\u8bef\u662f\u7531\u4e8e\u90e8\u5206 JSON \u89e3\u6790\u5bfc\u81f4\u7684\n        # \u60a8\u53ef\u4ee5\u5728\u8fd9\u91cc\u5141\u8bb8\u8fd9\u4e9b\u9519\u8bef\uff0c\u6839\u636e\u9700\u8981\u81ea\u7531\u5b9a\u5236\n        if all(e['type'] == 'missing' for e in exc.errors()):\n            raise pydantic_core.PydanticUseDefault()\n        else:\n            raise\n\n\nclass NestedModel(BaseModel):\n    x: int\n    y: str\n\n\nclass MyModel(BaseModel):\n    foo: Optional[str] = None\n    bar: Annotated[\n        Optional[tuple[str, int]], WrapValidator(default_on_error)\n    ] = None\n    nested: Annotated[\n        Optional[NestedModel], WrapValidator(default_on_error)\n    ] = None\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json('{\"foo\": \"x\", \"bar\": [\"world\",', allow_partial=True)\n)\nprint(repr(m))\n#&gt; MyModel(foo='x', bar=None, nested=None)\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json(\n        '{\"foo\": \"x\", \"bar\": [\"world\", 1], \"nested\": {\"x\":', allow_partial=True\n    )\n)\nprint(repr(m))\n#&gt; MyModel(foo='x', bar=('world', 1), nested=None)\n</code></pre>"},{"location":"concepts/json/#_1","title":"\u5b57\u7b26\u4e32\u7f13\u5b58","text":"<p>\u4ece v2.7.0 \u5f00\u59cb\uff0cPydantic \u7684 JSON \u89e3\u6790\u5668 \u63d0\u4f9b\u4e86\u914d\u7f6e\u5728 JSON \u89e3\u6790\u548c\u9a8c\u8bc1\u671f\u95f4\u5982\u4f55\u7f13\u5b58 Python \u5b57\u7b26\u4e32\u7684\u652f\u6301\uff08\u5f53\u5728 Python \u9a8c\u8bc1\u671f\u95f4\u4ece Rust \u5b57\u7b26\u4e32\u6784\u9020 Python \u5b57\u7b26\u4e32\u65f6\uff0c\u4f8b\u5982\u5728 <code>strip_whitespace=True</code> \u4e4b\u540e\uff09\u3002 <code>cache_strings</code> \u8bbe\u7f6e\u901a\u8fc7 \u6a21\u578b\u914d\u7f6e \u548c <code>pydantic_core.from_json</code> \u66b4\u9732\u3002</p> <p><code>cache_strings</code> \u8bbe\u7f6e\u53ef\u4ee5\u63a5\u53d7\u4ee5\u4e0b\u4efb\u4f55\u503c\uff1a</p> <ul> <li><code>True</code> \u6216 <code>'all'</code>\uff08\u9ed8\u8ba4\u503c\uff09\uff1a\u7f13\u5b58\u6240\u6709\u5b57\u7b26\u4e32</li> <li><code>'keys'</code>\uff1a\u4ec5\u7f13\u5b58\u5b57\u5178\u952e\uff0c\u8fd9\u4ec5\u9002\u7528\u4e8e\u4e0e <code>pydantic_core.from_json</code> \u4e00\u8d77\u4f7f\u7528\u6216\u4f7f\u7528 <code>Json</code> \u89e3\u6790 JSON \u65f6</li> <li><code>False</code> \u6216 <code>'none'</code>\uff1a\u4e0d\u7f13\u5b58</li> </ul> <p>\u4f7f\u7528\u5b57\u7b26\u4e32\u7f13\u5b58\u529f\u80fd\u53ef\u4ee5\u63d0\u9ad8\u6027\u80fd\uff0c\u4f46\u4f1a\u7a0d\u5fae\u589e\u52a0\u5185\u5b58\u4f7f\u7528\u91cf\u3002</p> <p>\u5b57\u7b26\u4e32\u7f13\u5b58\u8be6\u60c5</p> <ol> <li>\u5b57\u7b26\u4e32\u4f7f\u7528\u5927\u5c0f\u4e3a 16,384 \u7684\u5168\u76f8\u8054\u7f13\u5b58\u8fdb\u884c\u7f13\u5b58\u3002</li> <li>\u4ec5\u7f13\u5b58 <code>len(string) &lt; 64</code> \u7684\u5b57\u7b26\u4e32\u3002</li> <li>\u67e5\u627e\u7f13\u5b58\u4f1a\u6709\u4e00\u4e9b\u5f00\u9500\uff0c\u8fd9\u901a\u5e38\u503c\u5f97\u907f\u514d\u6784\u9020\u5b57\u7b26\u4e32\u3002 \u4f46\u662f\uff0c\u5982\u679c\u60a8\u77e5\u9053\u6570\u636e\u4e2d\u91cd\u590d\u5b57\u7b26\u4e32\u5f88\u5c11\uff0c\u901a\u8fc7\u7981\u7528\u6b64\u8bbe\u7f6e <code>cache_strings=False</code> \u53ef\u80fd\u4f1a\u83b7\u5f97\u6027\u80fd\u63d0\u5347\u3002</li> </ol>"},{"location":"concepts/json/#json_3","title":"JSON \u5e8f\u5217\u5316","text":"API \u6587\u6863 <p><code>pydantic.main.BaseModel.model_dump_json</code> <code>pydantic.type_adapter.TypeAdapter.dump_json</code> <code>pydantic_core.to_json</code></p> <p>\u6709\u5173 JSON \u5e8f\u5217\u5316\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u5e8f\u5217\u5316\u6982\u5ff5\u9875\u9762\u3002</p>"},{"location":"concepts/json_schema/","title":"JSON Schema","text":"API \u6587\u6863 <p><code>pydantic.json_schema</code></p> <p>Pydantic \u5141\u8bb8\u4ece\u6a21\u578b\u81ea\u52a8\u521b\u5efa\u548c\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u3002 \u751f\u6210\u7684 JSON \u6a21\u5f0f\u7b26\u5408\u4ee5\u4e0b\u89c4\u8303\uff1a</p> <ul> <li>JSON Schema Draft 2020-12</li> <li>OpenAPI Specification v3.1.0</li> </ul>"},{"location":"concepts/json_schema/#json","title":"\u751f\u6210 JSON \u6a21\u5f0f","text":"<p>\u4f7f\u7528\u4ee5\u4e0b\u51fd\u6570\u751f\u6210 JSON \u6a21\u5f0f\uff1a</p> <ul> <li><code>BaseModel.model_json_schema</code> \u8fd4\u56de\u6a21\u578b\u6a21\u5f0f\u7684\u53ef JSON \u5316\u5b57\u5178</li> <li><code>TypeAdapter.json_schema</code> \u8fd4\u56de\u9002\u914d\u7c7b\u578b\u7684\u53ef JSON \u5316\u5b57\u5178</li> </ul> <p>Note</p> <p>\u8fd9\u4e9b\u65b9\u6cd5\u4e0d\u8981\u4e0e <code>BaseModel.model_dump_json</code> \u548c <code>TypeAdapter.dump_json</code> \u6df7\u6dc6\uff0c\u540e\u8005\u5206\u522b\u5e8f\u5217\u5316\u6a21\u578b\u6216\u9002\u914d\u7c7b\u578b\u7684\u5b9e\u4f8b\u3002 \u8fd9\u4e9b\u65b9\u6cd5\u8fd4\u56de JSON \u5b57\u7b26\u4e32\u3002\u76f8\u6bd4\u4e4b\u4e0b\uff0c <code>BaseModel.model_json_schema</code> \u548c <code>TypeAdapter.json_schema</code> \u8fd4\u56de\u8868\u793a\u6a21\u578b\u6216\u9002\u914d\u7c7b\u578b JSON \u6a21\u5f0f\u7684\u53ef JSON \u5316\u5b57\u5178\u3002</p> <p>\u5173\u4e8e JSON \u6a21\u5f0f\u7684\"\u53ef JSON \u5316\"\u7279\u6027</p> <p>\u5173\u4e8e <code>model_json_schema</code> \u7ed3\u679c\u7684\"\u53ef JSON \u5316\"\u7279\u6027\uff0c \u5728\u67d0\u4e9b <code>BaseModel</code> <code>m</code> \u4e0a\u8c03\u7528 <code>json.dumps(m.model_json_schema())</code> \u4f1a\u8fd4\u56de\u6709\u6548\u7684 JSON \u5b57\u7b26\u4e32\u3002\u7c7b\u4f3c\u5730\uff0c\u5bf9\u4e8e <code>TypeAdapter.json_schema</code>\uff0c\u8c03\u7528 <code>json.dumps(TypeAdapter(&lt;some_type&gt;).json_schema())</code> \u4e5f\u4f1a\u8fd4\u56de\u6709\u6548\u7684 JSON \u5b57\u7b26\u4e32\u3002</p> <p>Tip</p> <p>Pydantic \u63d0\u4f9b\u5bf9\u4ee5\u4e0b\u4e24\u8005\u7684\u652f\u6301\uff1a</p> <ol> <li>\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f</li> <li>\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u751f\u6210\u8fc7\u7a0b</li> </ol> <p>\u7b2c\u4e00\u79cd\u65b9\u6cd5\u901a\u5e38\u8303\u56f4\u8f83\u7a84\uff0c\u5141\u8bb8\u4e3a\u66f4\u5177\u4f53\u7684\u7528\u4f8b\u548c\u7c7b\u578b\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u3002 \u7b2c\u4e8c\u79cd\u65b9\u6cd5\u901a\u5e38\u8303\u56f4\u66f4\u5e7f\uff0c\u5141\u8bb8\u81ea\u5b9a\u4e49\u6574\u4e2a JSON \u6a21\u5f0f\u751f\u6210\u8fc7\u7a0b\u3002 \u4e24\u79cd\u65b9\u6cd5\u90fd\u53ef\u4ee5\u5b9e\u73b0\u76f8\u540c\u7684\u6548\u679c\uff0c\u4f46\u6839\u636e\u60a8\u7684\u7528\u4f8b\uff0c\u4e00\u79cd\u65b9\u6cd5\u53ef\u80fd\u6bd4\u53e6\u4e00\u79cd\u63d0\u4f9b\u66f4\u7b80\u5355\u7684\u89e3\u51b3\u65b9\u6848\u3002</p> <p>\u4ee5\u4e0b\u662f\u4ece <code>BaseModel</code> \u751f\u6210 JSON \u6a21\u5f0f\u7684\u793a\u4f8b\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>import json\nfrom enum import Enum\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.config import ConfigDict\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: Union[float, None] = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    model_config = ConfigDict(title='Main')\n\n    foo_bar: FooBar\n    gender: Annotated[Union[Gender, None], Field(alias='Gender')] = None\n    snap: int = Field(\n        default=42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n\nmain_model_schema = MainModel.model_json_schema()  # (1)!\nprint(json.dumps(main_model_schema, indent=2))  # (2)!\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"$defs\": {\n    \"FooBar\": {\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Size\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ],\n      \"title\": \"FooBar\",\n      \"type\": \"object\"\n    },\n    \"Gender\": {\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"title\": \"Gender\",\n      \"type\": \"string\"\n    }\n  },\n  \"description\": \"This is the description of the main model\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/$defs/FooBar\"\n    },\n    \"Gender\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/Gender\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null\n    },\n    \"snap\": {\n      \"default\": 42,\n      \"description\": \"this is the value of snap\",\n      \"exclusiveMaximum\": 50,\n      \"exclusiveMinimum\": 30,\n      \"title\": \"The Snap\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"title\": \"Main\",\n  \"type\": \"object\"\n}\n</code></pre> <ol> <li>\u8fd9\u4f1a\u751f\u6210 <code>MainModel</code> \u6a21\u5f0f\u7684\"\u53ef JSON \u5316\"\u5b57\u5178\u3002</li> <li>\u5728\u6a21\u5f0f\u5b57\u5178\u4e0a\u8c03\u7528 <code>json.dumps</code> \u4f1a\u751f\u6210 JSON \u5b57\u7b26\u4e32\u3002</li> </ol> <pre><code>import json\nfrom enum import Enum\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.config import ConfigDict\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: float | None = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    model_config = ConfigDict(title='Main')\n\n    foo_bar: FooBar\n    gender: Annotated[Gender | None, Field(alias='Gender')] = None\n    snap: int = Field(\n        default=42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n\nmain_model_schema = MainModel.model_json_schema()  # (1)!\nprint(json.dumps(main_model_schema, indent=2))  # (2)!\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"$defs\": {\n    \"FooBar\": {\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Size\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ],\n      \"title\": \"FooBar\",\n      \"type\": \"object\"\n    },\n    \"Gender\": {\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"title\": \"Gender\",\n      \"type\": \"string\"\n    }\n  },\n  \"description\": \"This is the description of the main model\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/$defs/FooBar\"\n    },\n    \"Gender\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/Gender\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null\n    },\n    \"snap\": {\n      \"default\": 42,\n      \"description\": \"this is the value of snap\",\n      \"exclusiveMaximum\": 50,\n      \"exclusiveMinimum\": 30,\n      \"title\": \"The Snap\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"title\": \"Main\",\n  \"type\": \"object\"\n}\n</code></pre> <ol> <li>\u8fd9\u4f1a\u751f\u6210 <code>MainModel</code> \u6a21\u5f0f\u7684\"\u53ef JSON \u5316\"\u5b57\u5178\u3002</li> <li>\u5728\u6a21\u5f0f\u5b57\u5178\u4e0a\u8c03\u7528 <code>json.dumps</code> \u4f1a\u751f\u6210 JSON \u5b57\u7b26\u4e32\u3002</li> </ol> <p><code>TypeAdapter</code> \u7c7b\u5141\u8bb8\u60a8\u521b\u5efa\u4e00\u4e2a\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u5177\u6709\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u548c\u4e3a\u4efb\u610f\u7c7b\u578b\u751f\u6210 JSON \u6a21\u5f0f\u7684\u65b9\u6cd5\u3002 \u8fd9\u5b8c\u5168\u66ff\u4ee3\u4e86 Pydantic V1 \u4e2d\u7684 <code>schema_of</code>\uff08\u73b0\u5df2\u5f03\u7528\uff09\u3002</p> <p>\u4ee5\u4e0b\u662f\u4ece <code>TypeAdapter</code> \u751f\u6210 JSON \u6a21\u5f0f\u7684\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nprint(adapter.json_schema())\n#&gt; {'items': {'type': 'integer'}, 'type': 'array'}\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u4e3a <code>BaseModel</code>s \u548c <code>TypeAdapter</code>s \u7684\u7ec4\u5408\u751f\u6210 JSON \u6a21\u5f0f\uff0c \u5982\u4ee5\u4e0b\u793a\u4f8b\u6240\u793a\uff1a</p> <pre><code>import json\nfrom typing import Union\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Cat(BaseModel):\n    name: str\n    color: str\n\n\nclass Dog(BaseModel):\n    name: str\n    breed: str\n\n\nta = TypeAdapter(Union[Cat, Dog])\nta_schema = ta.json_schema()\nprint(json.dumps(ta_schema, indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"$defs\": {\n    \"Cat\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"color\": {\n          \"title\": \"Color\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"color\"\n      ],\n      \"title\": \"Cat\",\n      \"type\": \"object\"\n    },\n    \"Dog\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"breed\": {\n          \"title\": \"Breed\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"breed\"\n      ],\n      \"title\": \"Dog\",\n      \"type\": \"object\"\n    }\n  },\n  \"anyOf\": [\n    {\n      \"$ref\": \"#/$defs/Cat\"\n    },\n    {\n      \"$ref\": \"#/$defs/Dog\"\n    }\n  ]\n}\n</code></pre>"},{"location":"concepts/json_schema/#jsonschemamode","title":"\u914d\u7f6e <code>JsonSchemaMode</code>","text":"<p>\u901a\u8fc7 <code>model_json_schema</code> \u548c <code>TypeAdapter.json_schema</code> \u65b9\u6cd5\u4e2d\u7684 <code>mode</code> \u53c2\u6570\u6307\u5b9a JSON \u6a21\u5f0f\u751f\u6210\u6a21\u5f0f\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6a21\u5f0f\u8bbe\u7f6e\u4e3a <code>'validation'</code>\uff0c\u8fd9\u4f1a\u751f\u6210\u4e0e\u6a21\u578b\u9a8c\u8bc1\u6a21\u5f0f\u5bf9\u5e94\u7684 JSON \u6a21\u5f0f\u3002</p> <p><code>JsonSchemaMode</code> \u662f\u4e00\u4e2a\u7c7b\u578b\u522b\u540d\uff0c\u8868\u793a <code>mode</code> \u53c2\u6570\u7684\u53ef\u7528\u9009\u9879\uff1a</p> <ul> <li><code>'validation'</code></li> <li><code>'serialization'</code></li> </ul> <p>\u4ee5\u4e0b\u662f\u5982\u4f55\u6307\u5b9a <code>mode</code> \u53c2\u6570\u4ee5\u53ca\u5b83\u5982\u4f55\u5f71\u54cd\u751f\u6210\u7684 JSON \u6a21\u5f0f\u7684\u793a\u4f8b\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Decimal = Decimal('12.34')\n\n\nprint(Model.model_json_schema(mode='validation'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'anyOf': [\n                {'type': 'number'},\n                {\n                    'pattern': '^(?!^[-+.]*$)[+-]?0*\\\\d*\\\\.?\\\\d*$',\n                    'type': 'string',\n                },\n            ],\n            'default': '12.34',\n            'title': 'A',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n\nprint(Model.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'default': '12.34',\n            'pattern': '^(?!^[-+.]*$)[+-]?0*\\\\d*\\\\.?\\\\d*$',\n            'title': 'A',\n            'type': 'string',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#customizing-json-schema","title":"\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f","text":"<p>\u751f\u6210\u7684 JSON \u6a21\u5f0f\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5728\u5b57\u6bb5\u7ea7\u522b\u548c\u6a21\u578b\u7ea7\u522b\u8fdb\u884c\u81ea\u5b9a\u4e49\uff1a</p> <ol> <li>\u5b57\u6bb5\u7ea7\u522b\u81ea\u5b9a\u4e49 \u4f7f\u7528 <code>Field</code> \u6784\u9020\u51fd\u6570</li> <li>\u6a21\u578b\u7ea7\u522b\u81ea\u5b9a\u4e49 \u4f7f\u7528 <code>model_config</code></li> </ol> <p>\u5728\u5b57\u6bb5\u548c\u6a21\u578b\u7ea7\u522b\uff0c\u60a8\u90fd\u53ef\u4ee5\u4f7f\u7528 <code>json_schema_extra</code> \u9009\u9879\u5411 JSON \u6a21\u5f0f\u6dfb\u52a0\u989d\u5916\u4fe1\u606f\u3002 \u4e0b\u9762\u7684 \u4f7f\u7528 <code>json_schema_extra</code> \u90e8\u5206\u63d0\u4f9b\u4e86\u6709\u5173\u6b64\u9009\u9879\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u3002</p> <p>\u5bf9\u4e8e\u81ea\u5b9a\u4e49\u7c7b\u578b\uff0cPydantic \u63d0\u4f9b\u4e86\u5176\u4ed6\u7528\u4e8e\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u751f\u6210\u7684\u5de5\u5177\uff1a</p> <ol> <li><code>WithJsonSchema</code> \u6ce8\u89e3</li> <li><code>SkipJsonSchema</code> \u6ce8\u89e3</li> <li>\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code></li> <li>\u5b9e\u73b0 <code>__get_pydantic_json_schema__</code></li> </ol>"},{"location":"concepts/json_schema/#field-level-customization","title":"\u5b57\u6bb5\u7ea7\u522b\u81ea\u5b9a\u4e49","text":"<p>\u53ef\u9009\u5730\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>Field</code> \u51fd\u6570\u63d0\u4f9b\u6709\u5173\u5b57\u6bb5\u548c\u9a8c\u8bc1\u7684\u989d\u5916\u4fe1\u606f\u3002</p> <p>\u4e00\u4e9b\u5b57\u6bb5\u53c2\u6570\u4e13\u95e8\u7528\u4e8e\u81ea\u5b9a\u4e49\u751f\u6210\u7684 JSON \u6a21\u5f0f\uff1a</p> <ul> <li><code>title</code>: \u5b57\u6bb5\u7684\u6807\u9898</li> <li><code>description</code>: \u5b57\u6bb5\u7684\u63cf\u8ff0</li> <li><code>examples</code>: \u5b57\u6bb5\u7684\u793a\u4f8b</li> <li><code>json_schema_extra</code>: \u8981\u6dfb\u52a0\u5230\u5b57\u6bb5\u7684\u989d\u5916 JSON \u6a21\u5f0f\u5c5e\u6027</li> <li><code>field_title_generator</code>: \u6839\u636e\u5b57\u6bb5\u540d\u79f0\u548c\u4fe1\u606f\u4ee5\u7f16\u7a0b\u65b9\u5f0f\u8bbe\u7f6e\u5b57\u6bb5\u6807\u9898\u7684\u51fd\u6570</li> </ul> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, EmailStr, Field, SecretStr\n\n\nclass User(BaseModel):\n    age: int = Field(description='Age of the user')\n    email: EmailStr = Field(examples=['marcelo@mail.com'])\n    name: str = Field(title='Username')\n    password: SecretStr = Field(\n        json_schema_extra={\n            'title': 'Password',\n            'description': 'Password of the user',\n            'examples': ['123456'],\n        }\n    )\n\n\nprint(json.dumps(User.model_json_schema(), indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"properties\": {\n    \"age\": {\n      \"description\": \"Age of the user\",\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"examples\": [\n        \"marcelo@mail.com\"\n      ],\n      \"format\": \"email\",\n      \"title\": \"Email\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"title\": \"Username\",\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"description\": \"Password of the user\",\n      \"examples\": [\n        \"123456\"\n      ],\n      \"format\": \"password\",\n      \"title\": \"Password\",\n      \"type\": \"string\",\n      \"writeOnly\": true\n    }\n  },\n  \"required\": [\n    \"age\",\n    \"email\",\n    \"name\",\n    \"password\"\n  ],\n  \"title\": \"User\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#field","title":"\u672a\u5f3a\u5236\u6267\u884c\u7684 <code>Field</code> \u7ea6\u675f","text":"<p>\u5982\u679c Pydantic \u53d1\u73b0\u672a\u5f3a\u5236\u6267\u884c\u7684\u7ea6\u675f\uff0c\u5c06\u5f15\u53d1\u9519\u8bef\u3002\u5982\u679c\u60a8\u5e0c\u671b\u7ea6\u675f\u51fa\u73b0\u5728\u6a21\u5f0f\u4e2d\uff0c\u5373\u4f7f\u89e3\u6790\u65f6\u672a\u68c0\u67e5\uff0c \u53ef\u4ee5\u4f7f\u7528\u5e26\u6709\u539f\u59cb\u6a21\u5f0f\u5c5e\u6027\u540d\u79f0\u7684 <code>Field</code> \u7684\u53ef\u53d8\u53c2\u6570\uff1a</p> <pre><code>from pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # \u8fd9\u4e0d\u4f1a\u8d77\u4f5c\u7528\uff0c\u56e0\u4e3a `PositiveInt` \u4f18\u5148\u4e8e `Field` \u4e2d\u5b9a\u4e49\u7684\u7ea6\u675f\uff0c\u610f\u5473\u7740\u5b83\u4eec\u88ab\u5ffd\u7565\n    class Model(BaseModel):\n        foo: PositiveInt = Field(lt=10)\n\nexcept ValueError as e:\n    print(e)\n\n\n# \u5982\u679c\u60a8\u9700\u8981\u8fd9\u6837\u505a\uff0c\u53e6\u4e00\u79cd\u65b9\u6cd5\u662f\u5728 `Field` \u4e2d\u58f0\u660e\u7ea6\u675f\uff08\u6216\u8005\u53ef\u4ee5\u4f7f\u7528 `conint()`\uff09\n# \u8fd9\u91cc\u4e24\u4e2a\u7ea6\u675f\u90fd\u5c06\u88ab\u5f3a\u5236\u6267\u884c\uff1a\nclass ModelB(BaseModel):\n    # \u8fd9\u91cc\u4e24\u4e2a\u7ea6\u675f\u90fd\u5c06\u88ab\u5e94\u7528\uff0c\u6a21\u5f0f\u5c06\u6b63\u786e\u751f\u6210\n    foo: int = Field(gt=0, lt=10)\n\n\nprint(ModelB.model_json_schema())\n\"\"\"\n{\n    'properties': {\n        'foo': {\n            'exclusiveMaximum': 10,\n            'exclusiveMinimum': 0,\n            'title': 'Foo',\n            'type': 'integer',\n        }\n    },\n    'required': ['foo'],\n    'title': 'ModelB',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <p>\u60a8\u4e5f\u53ef\u4ee5\u901a\u8fc7 <code>typing.Annotated</code> \u4f7f\u7528 <code>Field</code> \u6784\u9020\u51fd\u6570\u6307\u5b9a JSON \u6a21\u5f0f\u4fee\u6539\uff1a</p> <pre><code>import json\nfrom typing import Annotated\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = Field(\n        'Bar', title='CustomName'\n    )\n\n\nprint(json.dumps(Foo.model_json_schema(), indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"properties\": {\n    \"id\": {\n      \"title\": \"Id\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"default\": \"Bar\",\n      \"maxLength\": 256,\n      \"title\": \"CustomName\",\n      \"type\": \"string\"\n    }\n  },\n  \"title\": \"Foo\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#_1","title":"\u7f16\u7a0b\u5f0f\u5b57\u6bb5\u6807\u9898\u751f\u6210","text":"<p><code>field_title_generator</code> \u53c2\u6570\u53ef\u7528\u4e8e\u6839\u636e\u5b57\u6bb5\u540d\u79f0\u548c\u4fe1\u606f\u4ee5\u7f16\u7a0b\u65b9\u5f0f\u751f\u6210\u5b57\u6bb5\u6807\u9898\u3002</p> <p>\u8bf7\u53c2\u9605\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import FieldInfo\n\n\ndef make_title(field_name: str, field_info: FieldInfo) -&gt; str:\n    return field_name.upper()\n\n\nclass Person(BaseModel):\n    name: str = Field(field_title_generator=make_title)\n    age: int = Field(field_title_generator=make_title)\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#model-level-customization","title":"\u6a21\u578b\u7ea7\u81ea\u5b9a\u4e49","text":"<p>\u60a8\u8fd8\u53ef\u4ee5\u4f7f\u7528\u6a21\u578b\u914d\u7f6e\u5728\u6a21\u578b\u7ea7\u522b\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u751f\u6210\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u4ee5\u4e0b\u914d\u7f6e\u9009\u9879\u76f8\u5173\uff1a</p> <ul> <li><code>title</code></li> <li><code>json_schema_extra</code></li> <li><code>json_schema_mode_override</code></li> <li><code>field_title_generator</code></li> <li><code>model_title_generator</code></li> </ul>"},{"location":"concepts/json_schema/#using-json_schema_extra","title":"\u4f7f\u7528 <code>json_schema_extra</code>","text":"<p><code>json_schema_extra</code> \u9009\u9879\u53ef\u7528\u4e8e\u5411 JSON \u6a21\u5f0f\u6dfb\u52a0\u989d\u5916\u4fe1\u606f\uff0c\u53ef\u4ee5\u5728 \u5b57\u6bb5\u7ea7\u522b \u6216 \u6a21\u578b\u7ea7\u522b\u3002 \u60a8\u53ef\u4ee5\u4f20\u9012\u4e00\u4e2a <code>dict</code> \u6216 <code>Callable</code> \u7ed9 <code>json_schema_extra</code>\u3002</p>"},{"location":"concepts/json_schema/#json_schema_extra-dict","title":"\u4f7f\u7528 <code>json_schema_extra</code> \u4e0e <code>dict</code>","text":"<p>\u60a8\u53ef\u4ee5\u4f20\u9012\u4e00\u4e2a <code>dict</code> \u7ed9 <code>json_schema_extra</code> \u6765\u5411 JSON \u6a21\u5f0f\u6dfb\u52a0\u989d\u5916\u4fe1\u606f\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    a: str\n\n    model_config = ConfigDict(json_schema_extra={'examples': [{'a': 'Foo'}]})\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"examples\": [\n    {\n      \"a\": \"Foo\"\n    }\n  ],\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#json_schema_extra-callable","title":"\u4f7f\u7528 <code>json_schema_extra</code> \u4e0e <code>Callable</code>","text":"<p>\u60a8\u53ef\u4ee5\u4f20\u9012\u4e00\u4e2a <code>Callable</code> \u7ed9 <code>json_schema_extra</code>\uff0c\u901a\u8fc7\u51fd\u6570\u4fee\u6539 JSON \u6a21\u5f0f\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, Field\n\n\ndef pop_default(s):\n    s.pop('default')\n\n\nclass Model(BaseModel):\n    a: int = Field(default=1, json_schema_extra=pop_default)\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#merging-json_schema_extra","title":"Merging <code>json_schema_extra</code>","text":"<p>\u81ea v2.9 \u8d77\uff0cPydantic \u4f1a\u5408\u5e76\u6765\u81ea\u6ce8\u89e3\u7c7b\u578b\u7684 <code>json_schema_extra</code> \u5b57\u5178\u3002 \u8fd9\u79cd\u6a21\u5f0f\u63d0\u4f9b\u4e86\u4e00\u79cd\u66f4\u589e\u91cf\u7684\u5408\u5e76\u65b9\u6cd5\uff0c\u800c\u4e0d\u662f\u4e4b\u524d\u7684\u8986\u76d6\u884c\u4e3a\u3002 \u8fd9\u5bf9\u4e8e\u5728\u591a\u4e2a\u7c7b\u578b\u4e2d\u91cd\u7528 JSON \u6a21\u5f0f\u989d\u5916\u4fe1\u606f\u7684\u60c5\u51b5\u975e\u5e38\u6709\u5e2e\u52a9\u3002</p> <p>\u6211\u4eec\u4e3b\u8981\u5c06\u6b64\u66f4\u6539\u89c6\u4e3a\u9519\u8bef\u4fee\u590d\uff0c\u56e0\u4e3a\u5b83\u89e3\u51b3\u4e86 <code>BaseModel</code> \u548c <code>TypeAdapter</code> \u5b9e\u4f8b\u4e4b\u95f4 <code>json_schema_extra</code> \u5408\u5e76\u884c\u4e3a\u7684\u610f\u5916\u5dee\u5f02 - \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6b64\u95ee\u9898\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>import json\nfrom typing import Annotated\n\nfrom typing_extensions import TypeAlias\n\nfrom pydantic import Field, TypeAdapter\n\nExternalType: TypeAlias = Annotated[\n    int, Field(json_schema_extra={'key1': 'value1'})\n]\n\nta = TypeAdapter(\n    Annotated[ExternalType, Field(json_schema_extra={'key2': 'value2'})]\n)\nprint(json.dumps(ta.json_schema(), indent=2))\n\"\"\"\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n  \"type\": \"integer\"\n}\n\"\"\"\n</code></pre> <pre><code>import json\nfrom typing import Annotated\n\nfrom typing import TypeAlias\n\nfrom pydantic import Field, TypeAdapter\n\nExternalType: TypeAlias = Annotated[\n    int, Field(json_schema_extra={'key1': 'value1'})\n]\n\nta = TypeAdapter(\n    Annotated[ExternalType, Field(json_schema_extra={'key2': 'value2'})]\n)\nprint(json.dumps(ta.json_schema(), indent=2))\n\"\"\"\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n  \"type\": \"integer\"\n}\n\"\"\"\n</code></pre> <p>Note</p> <p>\u6211\u4eec\u4e0d\u518d\uff08\u4e5f\u4ece\u672a\u5b8c\u5168\uff09\u652f\u6301\u7ec4\u5408 <code>dict</code> \u548c <code>callable</code> \u7c7b\u578b\u7684 <code>json_schema_extra</code> \u89c4\u8303\u3002 \u5982\u679c\u8fd9\u5bf9\u60a8\u7684\u7528\u4f8b\u662f\u5fc5\u9700\u7684\uff0c\u8bf7\u6253\u5f00\u4e00\u4e2a pydantic issue \u5e76\u89e3\u91ca\u60a8\u7684\u60c5\u51b5 - \u5f53\u6211\u4eec\u770b\u5230\u6709\u8bf4\u670d\u529b\u7684\u6848\u4f8b\u65f6\uff0c\u6211\u4eec\u5f88\u4e50\u610f\u91cd\u65b0\u8003\u8651\u8fd9\u4e2a\u51b3\u5b9a\u3002</p>"},{"location":"concepts/json_schema/#withjsonschema-annotation","title":"<code>WithJsonSchema</code> \u6ce8\u89e3","text":"API \u6587\u6863 <p><code>pydantic.json_schema.WithJsonSchema</code></p> <p>Tip</p> <p>\u5bf9\u4e8e\u81ea\u5b9a\u4e49\u7c7b\u578b\uff0c\u4f7f\u7528 <code>WithJsonSchema</code> \u6bd4 \u5b9e\u73b0 <code>__get_pydantic_json_schema__</code> \u66f4\u53d7\u63a8\u8350\uff0c \u56e0\u4e3a\u5b83\u66f4\u7b80\u5355\u4e14\u66f4\u4e0d\u5bb9\u6613\u51fa\u9519\u3002</p> <p><code>WithJsonSchema</code> \u6ce8\u89e3\u53ef\u7528\u4e8e\u8986\u76d6\u7ed9\u5b9a\u7c7b\u578b\u7684\u751f\u6210\uff08\u57fa\u7840\uff09 JSON \u6a21\u5f0f\uff0c\u800c\u65e0\u9700\u5728\u7c7b\u578b\u672c\u8eab\u4e0a\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code> \u6216 <code>__get_pydantic_json_schema__</code>\u3002\u8bf7\u6ce8\u610f\uff0c\u8fd9\u4f1a\u8986\u76d6\u5b57\u6bb5\u7684\u6574\u4e2a JSON \u6a21\u5f0f\u751f\u6210\u8fc7\u7a0b \uff08\u5728\u4ee5\u4e0b\u793a\u4f8b\u4e2d\uff0c\u8fd8\u9700\u8981\u63d0\u4f9b <code>'type'</code>\uff09\u3002</p> <pre><code>import json\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, WithJsonSchema\n\nMyInt = Annotated[\n    int,\n    WithJsonSchema({'type': 'integer', 'examples': [1, 0, -1]}),\n]\n\n\nclass Model(BaseModel):\n    a: MyInt\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"properties\": {\n    \"a\": {\n      \"examples\": [\n        1,\n        0,\n        -1\n      ],\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n</code></pre> <p>Note</p> <p>\u60a8\u53ef\u80fd\u4f1a\u60f3\u4f7f\u7528 <code>WithJsonSchema</code> \u6ce8\u89e3 \u6765\u5fae\u8c03\u5e26\u6709\u9a8c\u8bc1\u5668\u7684\u5b57\u6bb5\u7684 JSON Schema\u3002\u76f8\u53cd\uff0c \u5efa\u8bae\u4f7f\u7528 <code>json_schema_input_type</code> \u53c2\u6570\u3002</p>"},{"location":"concepts/json_schema/#skipjsonschema-annotation","title":"<code>SkipJsonSchema</code> \u6ce8\u89e3","text":"API \u6587\u6863 <p><code>pydantic.json_schema.SkipJsonSchema</code></p> <p><code>SkipJsonSchema</code> \u6ce8\u89e3\u53ef\u7528\u4e8e\u8df3\u8fc7\u751f\u6210\u5305\u542b\u5b57\u6bb5\uff08\u6216\u5b57\u6bb5\u89c4\u8303\u7684\u4e00\u90e8\u5206\uff09\u7684 JSON \u6a21\u5f0f\u3002 \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 API \u6587\u6863\u3002</p>"},{"location":"concepts/json_schema/#implementing_get_pydantic_core_schema","title":"\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code> \u65b9\u6cd5","text":"<p>\u81ea\u5b9a\u4e49\u7c7b\u578b\uff08\u7528\u4f5c <code>field_name: TheType</code> \u6216 <code>field_name: Annotated[TheType, ...]</code>\uff09\u4ee5\u53ca <code>Annotated</code> \u5143\u6570\u636e \uff08\u7528\u4f5c <code>field_name: Annotated[int, SomeMetadata]</code>\uff09 \u53ef\u4ee5\u901a\u8fc7\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code> \u6765\u4fee\u6539\u6216\u8986\u76d6\u751f\u6210\u7684\u6a21\u5f0f\u3002 \u6b64\u65b9\u6cd5\u63a5\u6536\u4e24\u4e2a\u4f4d\u7f6e\u53c2\u6570\uff1a</p> <ol> <li>\u4e0e\u6b64\u7c7b\u578b\u5bf9\u5e94\u7684\u7c7b\u578b\u6ce8\u89e3\uff08\u4f8b\u5982\uff0c\u5bf9\u4e8e <code>TheType[T][int]</code>\uff0c\u5b83\u5c06\u662f <code>TheType[int]</code>\uff09\u3002</li> <li>\u4e00\u4e2a\u5904\u7406\u7a0b\u5e8f/\u56de\u8c03\u51fd\u6570\uff0c\u7528\u4e8e\u8c03\u7528 <code>__get_pydantic_core_schema__</code> \u7684\u4e0b\u4e00\u4e2a\u5b9e\u73b0\u8005\u3002</li> </ol> <p>\u5904\u7406\u7a0b\u5e8f\u7cfb\u7edf\u7684\u5de5\u4f5c\u65b9\u5f0f\u7c7b\u4f3c\u4e8e wrap \u5b57\u6bb5\u9a8c\u8bc1\u5668\u3002 \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u8f93\u5165\u662f\u7c7b\u578b\uff0c\u8f93\u51fa\u662f\u4e00\u4e2a <code>core_schema</code>\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7c7b\u578b\u7684\u793a\u4f8b\uff0c\u5b83\u8986\u76d6\u4e86\u751f\u6210\u7684 <code>core_schema</code>\uff1a</p> <pre><code>from dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass\nclass CompressedString:\n    dictionary: dict[int, str]\n    text: list[int]\n\n    def build(self) -&gt; str:\n        return ' '.join([self.dictionary[key] for key in self.text])\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        assert source is CompressedString\n        return core_schema.no_info_after_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                cls._serialize,\n                info_arg=False,\n                return_schema=core_schema.str_schema(),\n            ),\n        )\n\n    @staticmethod\n    def _validate(value: str) -&gt; 'CompressedString':\n        inverse_dictionary: dict[str, int] = {}\n        text: list[int] = []\n        for word in value.split(' '):\n            if word not in inverse_dictionary:\n                inverse_dictionary[word] = len(inverse_dictionary)\n            text.append(inverse_dictionary[word])\n        return CompressedString(\n            {v: k for k, v in inverse_dictionary.items()}, text\n        )\n\n    @staticmethod\n    def _serialize(value: 'CompressedString') -&gt; str:\n        return value.build()\n\n\nclass MyModel(BaseModel):\n    value: CompressedString\n\n\nprint(MyModel.model_json_schema())\n\"\"\"\n{\n    'properties': {'value': {'title': 'Value', 'type': 'string'}},\n    'required': ['value'],\n    'title': 'MyModel',\n    'type': 'object',\n}\n\"\"\"\nprint(MyModel(value='fox fox fox dog fox'))\n\"\"\"\nvalue = CompressedString(dictionary={0: 'fox', 1: 'dog'}, text=[0, 0, 0, 1, 0])\n\"\"\"\n\nprint(MyModel(value='fox fox fox dog fox').model_dump(mode='json'))\n#&gt; {'value': 'fox fox fox dog fox'}\n</code></pre> <p>\u7531\u4e8e Pydantic \u4e0d\u77e5\u9053\u5982\u4f55\u4e3a <code>CompressedString</code> \u751f\u6210\u6a21\u5f0f\uff0c\u5982\u679c\u60a8\u5728\u5176 <code>__get_pydantic_core_schema__</code> \u65b9\u6cd5\u4e2d\u8c03\u7528 <code>handler(source)</code>\uff0c\u60a8\u5c06\u5f97\u5230\u4e00\u4e2a <code>pydantic.errors.PydanticSchemaGenerationError</code> \u9519\u8bef\u3002 \u5bf9\u4e8e\u5927\u591a\u6570\u81ea\u5b9a\u4e49\u7c7b\u578b\u6765\u8bf4\u90fd\u662f\u8fd9\u79cd\u60c5\u51b5\uff0c\u56e0\u6b64\u60a8\u51e0\u4e4e\u4ece\u4e0d\u5e0c\u671b\u4e3a\u81ea\u5b9a\u4e49\u7c7b\u578b\u8c03\u7528 <code>handler</code>\u3002</p> <p><code>Annotated</code> \u5143\u6570\u636e\u7684\u8fc7\u7a0b\u5927\u81f4\u76f8\u540c\uff0c\u53ea\u662f\u60a8\u901a\u5e38\u53ef\u4ee5\u8c03\u7528 <code>handler</code> \u8ba9 Pydantic \u5904\u7406\u6a21\u5f0f\u751f\u6210\u3002</p> <pre><code>from collections.abc import Sequence\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationError\n\n\n@dataclass\nclass RestrictCharacters:\n    alphabet: Sequence[str]\n\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        if not self.alphabet:\n            raise ValueError('Alphabet may not be empty')\n        schema = handler(\n            source\n        )  # get the CoreSchema from the type / inner constraints\n        if schema['type'] != 'str':\n            raise TypeError('RestrictCharacters can only be applied to strings')\n        return core_schema.no_info_after_validator_function(\n            self.validate,\n            schema,\n        )\n\n    def validate(self, value: str) -&gt; str:\n        if any(c not in self.alphabet for c in value):\n            raise ValueError(\n                f'{value!r} is not restricted to {self.alphabet!r}'\n            )\n        return value\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, RestrictCharacters('ABC')]\n\n\nprint(MyModel.model_json_schema())\n\"\"\"\n{\n    'properties': {'value': {'title': 'Value', 'type': 'string'}},\n    'required': ['value'],\n    'title': 'MyModel',\n    'type': 'object',\n}\n\"\"\"\nprint(MyModel(value='CBA'))\n#&gt; value='CBA'\n\ntry:\n    MyModel(value='XYZ')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    value\n      Value error, 'XYZ' is not restricted to 'ABC' [type=value_error, input_value='XYZ', input_type=str]\n    \"\"\"\n</code></pre> <p>\u5230\u76ee\u524d\u4e3a\u6b62\uff0c\u6211\u4eec\u4e00\u76f4\u5728\u5305\u88c5\u6a21\u5f0f\uff0c\u4f46\u5982\u679c\u60a8\u53ea\u60f3\u4fee\u6539\u5b83\u6216\u5ffd\u7565\u5b83\uff0c\u4e5f\u53ef\u4ee5\u8fd9\u6837\u505a\u3002</p> <p>\u8981\u4fee\u6539\u6a21\u5f0f\uff0c\u9996\u5148\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\uff0c\u7136\u540e\u4fee\u6539\u7ed3\u679c\uff1a</p> <pre><code>from typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass SmallString:\n    def __get_pydantic_core_schema__(\n        self,\n        source: type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        schema = handler(source)\n        assert schema['type'] == 'str'\n        schema['max_length'] = 10  # \u539f\u5730\u4fee\u6539\n        return schema\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, SmallString()]\n\n\ntry:\n    MyModel(value='too long!!!!!')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    value\n      String should have at most 10 characters [type=string_too_long, input_value='too long!!!!!', input_type=str]\n    \"\"\"\n</code></pre> <p>Tip</p> <p>\u8bf7\u6ce8\u610f\uff0c\u60a8\u5fc5\u987b\u8fd4\u56de\u4e00\u4e2a\u6a21\u5f0f\uff0c\u5373\u4f7f\u60a8\u53ea\u662f\u539f\u5730\u4fee\u6539\u5b83\u3002</p> <p>\u8981\u5b8c\u5168\u8986\u76d6\u6a21\u5f0f\uff0c\u4e0d\u8981\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\uff0c\u800c\u662f\u8fd4\u56de\u60a8\u81ea\u5df1\u7684 <code>CoreSchema</code>\uff1a</p> <pre><code>from typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass AllowAnySubclass:\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        # \u6211\u4eec\u4e0d\u80fd\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\uff0c\u56e0\u4e3a\u5b83\u4f1a\u56e0\u4efb\u610f\u7c7b\u578b\u800c\u5931\u8d25\n        def validate(value: Any) -&gt; Any:\n            if not isinstance(value, source):\n                raise ValueError(\n                    f'Expected an instance of {source}, got an instance of {type(value)}'\n                )\n\n        return core_schema.no_info_plain_validator_function(validate)\n\n\nclass Foo:\n    pass\n\n\nclass Model(BaseModel):\n    f: Annotated[Foo, AllowAnySubclass()]\n\n\nprint(Model(f=Foo()))\n#&gt; f=None\n\n\nclass NotFoo:\n    pass\n\n\ntry:\n    Model(f=NotFoo())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    f\n      Value error, Expected an instance of &lt;class '__main__.Foo'&gt;, got an instance of &lt;class '__main__.NotFoo'&gt; [type=value_error, input_value=&lt;__main__.NotFoo object at 0x0123456789ab&gt;, input_type=NotFoo]\n    \"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#implementing_get_pydantic_json_schema","title":"\u5b9e\u73b0 <code>__get_pydantic_json_schema__</code> \u65b9\u6cd5","text":"<p>\u60a8\u8fd8\u53ef\u4ee5\u5b9e\u73b0 <code>__get_pydantic_json_schema__</code> \u6765\u4fee\u6539\u6216\u8986\u76d6\u751f\u6210\u7684 JSON \u6a21\u5f0f\u3002 \u4fee\u6539\u6b64\u65b9\u6cd5\u4ec5\u5f71\u54cd JSON \u6a21\u5f0f - \u5b83\u4e0d\u5f71\u54cd\u7528\u4e8e\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u7684\u6838\u5fc3\u6a21\u5f0f\u3002</p> <p>\u4ee5\u4e0b\u662f\u4fee\u6539\u751f\u6210\u7684 JSON \u6a21\u5f0f\u7684\u793a\u4f8b\uff1a</p> <pre><code>import json\nfrom typing import Any\n\nfrom pydantic_core import core_schema as cs\n\nfrom pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler, TypeAdapter\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass Person:\n    name: str\n    age: int\n\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; cs.CoreSchema:\n        return cs.typed_dict_schema(\n            {\n                'name': cs.typed_dict_field(cs.str_schema()),\n                'age': cs.typed_dict_field(cs.int_schema()),\n            },\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: cs.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        json_schema = handler(core_schema)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema['examples'] = [\n            {\n                'name': 'John Doe',\n                'age': 25,\n            }\n        ]\n        json_schema['title'] = 'Person'\n        return json_schema\n\n\nprint(json.dumps(TypeAdapter(Person).json_schema(), indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"examples\": [\n    {\n      \"age\": 25,\n      \"name\": \"John Doe\"\n    }\n  ],\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#field_title_generator","title":"\u4f7f\u7528 <code>field_title_generator</code>","text":"<p><code>field_title_generator</code> \u53c2\u6570\u53ef\u7528\u4e8e\u6839\u636e\u5b57\u6bb5\u540d\u79f0\u548c\u4fe1\u606f\u4ee5\u7f16\u7a0b\u65b9\u5f0f\u751f\u6210\u5b57\u6bb5\u6807\u9898\u3002 \u8fd9\u7c7b\u4f3c\u4e8e\u5b57\u6bb5\u7ea7\u522b\u7684 <code>field_title_generator</code>\uff0c\u4f46 <code>ConfigDict</code> \u9009\u9879\u5c06\u5e94\u7528\u4e8e\u7c7b\u7684\u6240\u6709\u5b57\u6bb5\u3002</p> <p>\u8bf7\u53c2\u9605\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(\n        field_title_generator=lambda field_name, field_info: field_name.upper()\n    )\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#model_title_generator","title":"\u4f7f\u7528 <code>model_title_generator</code>","text":"<p><code>model_title_generator</code> \u914d\u7f6e\u9009\u9879\u7c7b\u4f3c\u4e8e <code>field_title_generator</code> \u9009\u9879\uff0c\u4f46\u5b83\u5e94\u7528\u4e8e\u6a21\u578b\u672c\u8eab\u7684\u6807\u9898\uff0c \u5e76\u63a5\u53d7\u6a21\u578b\u7c7b\u4f5c\u4e3a\u8f93\u5165\u3002</p> <p>\u8bf7\u53c2\u9605\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\ndef make_title(model: type) -&gt; str:\n    return f'Title-{model.__name__}'\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(model_title_generator=make_title)\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Title-Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#json-schema","title":"JSON Schema \u7c7b\u578b","text":"<p>\u7c7b\u578b\u3001\u81ea\u5b9a\u4e49\u5b57\u6bb5\u7c7b\u578b\u548c\u7ea6\u675f\uff08\u5982 <code>max_length</code>\uff09\u6309\u7167\u4ee5\u4e0b\u4f18\u5148\u7ea7\u987a\u5e8f\u6620\u5c04\u5230\u76f8\u5e94\u7684\u89c4\u8303\u683c\u5f0f\uff08\u5f53\u6709\u7b49\u6548\u9879\u53ef\u7528\u65f6\uff09\uff1a</p> <ol> <li>JSON Schema Core</li> <li>JSON Schema Validation</li> <li>OpenAPI Data Types</li> <li>\u6807\u51c6\u7684 <code>format</code> JSON \u5b57\u6bb5\u7528\u4e8e\u4e3a\u66f4\u590d\u6742\u7684 <code>string</code> \u5b50\u7c7b\u578b\u5b9a\u4e49 Pydantic \u6269\u5c55\u3002</li> </ol>"},{"location":"concepts/json_schema/#json-schema_1","title":"JSON Schema \u7c7b\u578b\u6620\u5c04\u4f18\u5148\u7ea7","text":"<p>\u751f\u6210 JSON \u6a21\u5f0f\u65f6\uff0cPydantic \u4f7f\u7528\u4ee5\u4e0b\u4f18\u5148\u7ea7\u987a\u5e8f\u6765\u786e\u5b9a\u7c7b\u578b\u6620\u5c04\uff1a</p> <ol> <li>\u5177\u6709 <code>__get_pydantic_json_schema__</code> \u65b9\u6cd5\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b</li> <li>\u5177\u6709 <code>WithJsonSchema</code> \u6ce8\u89e3\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b</li> <li>\u5185\u7f6e\u7c7b\u578b\u548c\u6807\u51c6\u5e93\u7c7b\u578b</li> <li>\u6cdb\u578b\u7c7b\u578b</li> <li>\u8054\u5408\u7c7b\u578b</li> <li>\u53ef\u9009\u7c7b\u578b</li> </ol> <p>\u8fd9\u610f\u5473\u7740\u5982\u679c\u60a8\u6709\u4e00\u4e2a\u5b9e\u73b0 <code>__get_pydantic_json_schema__</code> \u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\uff0c\u5b83\u5c06\u4f18\u5148\u4e8e\u5185\u7f6e\u7c7b\u578b\u6620\u5c04\u3002</p> <p>\u4ece Python \u6216 Pydantic \u5230 JSON \u6a21\u5f0f\u7684\u5b57\u6bb5\u6a21\u5f0f\u6620\u5c04\u5982\u4e0b\uff1a</p> Python type JSON Schema Type Additional JSON Schema Defined in Notes <code>None</code> <code>null</code> JSON Schema Core Same for <code>type(None)</code> or <code>Literal[None]</code> <code>bool</code> <code>boolean</code> JSON Schema Core <code>str</code> <code>string</code> JSON Schema Core <code>float</code> <code>number</code> JSON Schema Core <code>int</code> <code>integer</code> JSON Schema Validation <code>dict</code> <code>object</code> JSON Schema Core <code>list</code> <code>array</code> <code>{\"items\": {}}</code> JSON Schema Core <code>tuple-positional</code> <code>array</code> <code>{\"items\": {}}</code> JSON Schema Core <code>tuple-variable</code> <code>array</code> <code>{\"items\": {}}</code> JSON Schema Core <code>set</code> <code>array</code> <code>{\"uniqueItems\": true, \"items\": {}}</code> JSON Schema Validation <code>frozenset</code> <code>array</code> <code>{\"uniqueItems\": true, \"items\": {}}</code> JSON Schema Validation <code>List[str]</code> <code>array</code> <code>{\"items\": {\"type\": \"string\"}}</code> JSON Schema Validation And equivalently for any other sub type, e.g. <code>List[int]</code>. <code>Tuple[str, ...]</code> <code>array</code> <code>{\"items\": {\"type\": \"string\"}}</code> JSON Schema Validation And equivalently for any other sub type, e.g. <code>Tuple[int, ...]</code>. <code>Tuple[str, int]</code> <code>array</code> <code>{\"minItems\": 2, \"maxItems\": 2, \"items\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]}</code> JSON Schema Validation And equivalently for any other set of subtypes. Note: If using schemas for OpenAPI, you shouldn't use this declaration, as it would not be valid in OpenAPI (although it is valid in JSON Schema). <code>Dict[str, int]</code> <code>object</code> <code>{\"additionalProperties\": {\"type\": \"integer\"}}</code> JSON Schema Validation And equivalently for any other subfields for dicts. Have in mind that although you can use other types as keys for dicts with Pydantic, only strings are valid keys for JSON, and so, only str is valid as JSON Schema key types. <code>Union[str, int]</code> <code>anyOf</code> <code>{\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]}</code> JSON Schema Validation And equivalently for any other subfields for unions. <code>Enum</code> <code>enum</code> <code>{\"enum\": [...]}</code> JSON Schema Validation All the literal values in the enum are included in the definition. <code>SecretStr</code> <code>string</code> <code>{\"writeOnly\": true}</code> JSON Schema Validation <code>SecretBytes</code> <code>string</code> <code>{\"writeOnly\": true}</code> JSON Schema Validation <code>EmailStr</code> <code>string</code> <code>{\"format\": \"email\"}</code> JSON Schema Validation <code>NameEmail</code> <code>string</code> <code>{\"format\": \"name-email\"}</code> Pydantic standard \"format\" extension <code>AnyUrl</code> <code>string</code> <code>{\"format\": \"uri\"}</code> JSON Schema Validation <code>Pattern</code> <code>string</code> <code>{\"format\": \"regex\"}</code> JSON Schema Validation <code>bytes</code> <code>string</code> <code>{\"format\": \"binary\"}</code> OpenAPI <code>Decimal</code> <code>number</code> JSON Schema Core <code>UUID1</code> <code>string</code> <code>{\"format\": \"uuid1\"}</code> Pydantic standard \"format\" extension <code>UUID3</code> <code>string</code> <code>{\"format\": \"uuid3\"}</code> Pydantic standard \"format\" extension <code>UUID4</code> <code>string</code> <code>{\"format\": \"uuid4\"}</code> Pydantic standard \"format\" extension <code>UUID5</code> <code>string</code> <code>{\"format\": \"uuid5\"}</code> Pydantic standard \"format\" extension <code>UUID</code> <code>string</code> <code>{\"format\": \"uuid\"}</code> Pydantic standard \"format\" extension Suggested in OpenAPI. <code>FilePath</code> <code>string</code> <code>{\"format\": \"file-path\"}</code> Pydantic standard \"format\" extension <code>DirectoryPath</code> <code>string</code> <code>{\"format\": \"directory-path\"}</code> Pydantic standard \"format\" extension <code>Path</code> <code>string</code> <code>{\"format\": \"path\"}</code> Pydantic standard \"format\" extension <code>datetime</code> <code>string</code> <code>{\"format\": \"date-time\"}</code> JSON Schema Validation <code>date</code> <code>string</code> <code>{\"format\": \"date\"}</code> JSON Schema Validation <code>time</code> <code>string</code> <code>{\"format\": \"time\"}</code> JSON Schema Validation <code>timedelta</code> <code>number</code> <code>{\"format\": \"time-delta\"}</code> Difference in seconds (a <code>float</code>), with Pydantic standard \"format\" extension Suggested in JSON Schema repository's issues by maintainer. <code>Json</code> <code>string</code> <code>{\"format\": \"json-string\"}</code> Pydantic standard \"format\" extension <code>IPv4Address</code> <code>string</code> <code>{\"format\": \"ipv4\"}</code> JSON Schema Validation <code>IPv6Address</code> <code>string</code> <code>{\"format\": \"ipv6\"}</code> JSON Schema Validation <code>IPvAnyAddress</code> <code>string</code> <code>{\"format\": \"ipvanyaddress\"}</code> Pydantic standard \"format\" extension IPv4 or IPv6 address as used in <code>ipaddress</code> module <code>IPv4Interface</code> <code>string</code> <code>{\"format\": \"ipv4interface\"}</code> Pydantic standard \"format\" extension IPv4 interface as used in <code>ipaddress</code> module <code>IPv6Interface</code> <code>string</code> <code>{\"format\": \"ipv6interface\"}</code> Pydantic standard \"format\" extension IPv6 interface as used in <code>ipaddress</code> module <code>IPvAnyInterface</code> <code>string</code> <code>{\"format\": \"ipvanyinterface\"}</code> Pydantic standard \"format\" extension IPv4 or IPv6 interface as used in <code>ipaddress</code> module <code>IPv4Network</code> <code>string</code> <code>{\"format\": \"ipv4network\"}</code> Pydantic standard \"format\" extension IPv4 network as used in <code>ipaddress</code> module <code>IPv6Network</code> <code>string</code> <code>{\"format\": \"ipv6network\"}</code> Pydantic standard \"format\" extension IPv6 network as used in <code>ipaddress</code> module <code>IPvAnyNetwork</code> <code>string</code> <code>{\"format\": \"ipvanynetwork\"}</code> Pydantic standard \"format\" extension IPv4 or IPv6 network as used in <code>ipaddress</code> module <code>StrictBool</code> <code>boolean</code> JSON Schema Core <code>StrictStr</code> <code>string</code> JSON Schema Core <code>ConstrainedStr</code> <code>string</code> JSON Schema Core If the type has values declared for the constraints, they are included as validations. See the mapping for <code>constr</code> below. <code>constr(pattern='^text$', min_length=2, max_length=10)</code> <code>string</code> JSON Schema Validation Any argument not passed to the function (not defined) will not be included in the schema. <code>|</code> <code>{\"pattern\": \"^text$\", \"minLength\": 2, \"maxLength\": 10}</code> <code>ConstrainedInt</code> <code>integer</code> JSON Schema Core If the type has values declared for the constraints, they are included as validations. See the mapping for <code>conint</code> below. <code>conint(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code> <code>integer</code> <code>{\"maximum\": 5, \"exclusiveMaximum\": 6, \"minimum\": 2, \"exclusiveMinimum\": 1, \"multipleOf\": 2}</code> Any argument not passed to the function (not defined) will not be included in the schema. <code>PositiveInt</code> <code>integer</code> <code>{\"exclusiveMinimum\": 0}</code> JSON Schema Validation <code>NegativeInt</code> <code>integer</code> <code>{\"exclusiveMaximum\": 0}</code> JSON Schema Validation <code>NonNegativeInt</code> <code>integer</code> <code>{\"minimum\": 0}</code> JSON Schema Validation <code>NonPositiveInt</code> <code>integer</code> <code>{\"maximum\": 0}</code> JSON Schema Validation <code>ConstrainedFloat</code> <code>number</code> JSON Schema Core If the type has values declared for the constraints, they are included as validations. See the mapping for <code>confloat</code> below. <code>confloat(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code> <code>number</code> <code>{\"maximum\": 5, \"exclusiveMaximum\": 6, \"minimum\": 2, \"exclusiveMinimum\": 1, \"multipleOf\": 2}</code> JSON Schema Validation Any argument not passed to the function (not defined) will not be included in the schema. <code>PositiveFloat</code> <code>number</code> <code>{\"exclusiveMinimum\": 0}</code> JSON Schema Validation <code>NegativeFloat</code> <code>number</code> <code>{\"exclusiveMaximum\": 0}</code> JSON Schema Validation <code>NonNegativeFloat</code> <code>number</code> <code>{\"minimum\": 0}</code> JSON Schema Validation <code>NonPositiveFloat</code> <code>number</code> <code>{\"maximum\": 0}</code> JSON Schema Validation <code>ConstrainedDecimal</code> <code>number</code> JSON Schema Core If the type has values declared for the constraints, they are included as validations. See the mapping for <code>condecimal</code> below. <code>condecimal(gt=1, ge=2, lt=6, le=5, multiple_of=2)</code> <code>number</code> <code>{\"maximum\": 5, \"exclusiveMaximum\": 6, \"minimum\": 2, \"exclusiveMinimum\": 1, \"multipleOf\": 2}</code> JSON Schema Validation Any argument not passed to the function (not defined) will not be included in the schema. <code>BaseModel</code> <code>object</code> JSON Schema Core All the properties defined will be defined with standard JSON Schema, including submodels. <code>Color</code> <code>string</code> <code>{\"format\": \"color\"}</code> Pydantic standard \"format\" extension"},{"location":"concepts/json_schema/#_2","title":"\u9876\u5c42\u6a21\u5f0f\u751f\u6210","text":"<p>\u60a8\u8fd8\u53ef\u4ee5\u751f\u6210\u4e00\u4e2a\u9876\u5c42 JSON \u6a21\u5f0f\uff0c\u8be5\u6a21\u5f0f\u4ec5\u5728\u5176 <code>$defs</code> \u4e2d\u5305\u542b\u6a21\u578b\u5217\u8868\u548c\u76f8\u5173\u5b50\u6a21\u578b\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import models_json_schema\n\n\nclass Foo(BaseModel):\n    a: str = None\n\n\nclass Model(BaseModel):\n    b: Foo\n\n\nclass Bar(BaseModel):\n    c: int\n\n\n_, top_level_schema = models_json_schema(\n    [(Model, 'validation'), (Bar, 'validation')], title='My Schema'\n)\nprint(json.dumps(top_level_schema, indent=2))\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"$defs\": {\n    \"Bar\": {\n      \"properties\": {\n        \"c\": {\n          \"title\": \"C\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"c\"\n      ],\n      \"title\": \"Bar\",\n      \"type\": \"object\"\n    },\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"default\": null,\n          \"title\": \"A\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    },\n    \"Model\": {\n      \"properties\": {\n        \"b\": {\n          \"$ref\": \"#/$defs/Foo\"\n        }\n      },\n      \"required\": [\n        \"b\"\n      ],\n      \"title\": \"Model\",\n      \"type\": \"object\"\n    }\n  },\n  \"title\": \"My Schema\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#customizing-the-json-schema-generation-process","title":"\u81ea\u5b9a\u4e49 JSON Schema \u751f\u6210\u8fc7\u7a0b","text":"API \u6587\u6863 <p><code>pydantic.json_schema</code></p> <p>\u5982\u679c\u60a8\u9700\u8981\u81ea\u5b9a\u4e49\u6a21\u5f0f\u751f\u6210\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>schema_generator</code>\uff0c\u6839\u636e\u9700\u8981\u4fee\u6539 <code>GenerateJsonSchema</code> \u7c7b\u4ee5\u9002\u5e94\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u3002</p> <p>\u5404\u79cd\u53ef\u7528\u4e8e\u751f\u6210 JSON \u6a21\u5f0f\u7684\u65b9\u6cd5\u90fd\u63a5\u53d7\u5173\u952e\u5b57\u53c2\u6570 <code>schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema</code>\uff0c\u60a8\u53ef\u4ee5\u5c06\u81ea\u5b9a\u4e49\u5b50\u7c7b\u4f20\u9012\u7ed9\u8fd9\u4e9b\u65b9\u6cd5\uff0c\u4ee5\u4f7f\u7528\u60a8\u81ea\u5df1\u7684 JSON \u6a21\u5f0f\u751f\u6210\u65b9\u6cd5\u3002</p> <p><code>GenerateJsonSchema</code> \u5b9e\u73b0\u4e86\u5c06\u7c7b\u578b\u7684 <code>pydantic-core</code> \u6a21\u5f0f\u8f6c\u6362\u4e3a JSON \u6a21\u5f0f\u7684\u529f\u80fd\u3002 \u901a\u8fc7\u8bbe\u8ba1\uff0c\u8be5\u7c7b\u5c06 JSON \u6a21\u5f0f\u751f\u6210\u8fc7\u7a0b\u5206\u89e3\u4e3a\u66f4\u5c0f\u7684\u65b9\u6cd5\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u53ef\u4ee5\u5728\u5b50\u7c7b\u4e2d\u8f7b\u677e\u91cd\u5199\uff0c\u4ee5\u4fee\u6539\u751f\u6210 JSON \u6a21\u5f0f\u7684\"\u5168\u5c40\"\u65b9\u6cd5\u3002</p> <pre><code>from pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def generate(self, schema, mode='validation'):\n        json_schema = super().generate(schema, mode=mode)\n        json_schema['title'] = 'Customize title'\n        json_schema['$schema'] = self.schema_dialect\n        return json_schema\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_json_schema(schema_generator=MyGenerateJsonSchema))\n\"\"\"\n{\n    'properties': {'x': {'title': 'X', 'type': 'integer'}},\n    'required': ['x'],\n    'title': 'Customize title',\n    'type': 'object',\n    '$schema': 'https://json-schema.org/draft/2020-12/schema',\n}\n\"\"\"\n</code></pre> <p>Below is an approach you can use to exclude any fields from the schema that don't have valid json schemas:</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -&gt; JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <pre><code>from collections.abc import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -&gt; JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#json-schema_2","title":"JSON Schema \u6392\u5e8f","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u901a\u8fc7\u6309\u5b57\u6bcd\u987a\u5e8f\u6392\u5e8f\u952e\u6765\u9012\u5f52\u6392\u5e8f JSON \u6a21\u5f0f\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0cPydantic \u8df3\u8fc7\u5bf9 <code>properties</code> \u952e\u503c\u7684\u6392\u5e8f\uff0c \u4ee5\u4fdd\u7559\u5b57\u6bb5\u5728\u6a21\u578b\u4e2d\u5b9a\u4e49\u7684\u987a\u5e8f\u3002</p> <p>\u5982\u679c\u60a8\u60f3\u81ea\u5b9a\u4e49\u6b64\u884c\u4e3a\uff0c\u53ef\u4ee5\u5728\u81ea\u5b9a\u4e49\u7684 <code>GenerateJsonSchema</code> \u5b50\u7c7b\u4e2d\u91cd\u5199 <code>sort</code> \u65b9\u6cd5\u3002\u4ee5\u4e0b\u793a\u4f8b \u4f7f\u7528\u65e0\u64cd\u4f5c\u7684 <code>sort</code> \u65b9\u6cd5\u5b8c\u5168\u7981\u7528\u6392\u5e8f\uff0c\u8fd9\u53cd\u6620\u5728\u6a21\u578b\u5b57\u6bb5\u548c <code>json_schema_extra</code> \u952e\u7684\u4fdd\u7559\u987a\u5e8f\u4e2d\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>import json\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def sort(\n        self, value: JsonSchemaValue, parent_key: Optional[str] = None\n    ) -&gt; JsonSchemaValue:\n        \"\"\"No-op, we don't want to sort schema values at all.\"\"\"\n        return value\n\n\nclass Bar(BaseModel):\n    c: str\n    b: str\n    a: str = Field(json_schema_extra={'c': 'hi', 'b': 'hello', 'a': 'world'})\n\n\njson_schema = Bar.model_json_schema(schema_generator=MyGenerateJsonSchema)\nprint(json.dumps(json_schema, indent=2))\n\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"c\": {\n      \"type\": \"string\",\n      \"title\": \"C\"\n    },\n    \"b\": {\n      \"type\": \"string\",\n      \"title\": \"B\"\n    },\n    \"a\": {\n      \"type\": \"string\",\n      \"c\": \"hi\",\n      \"b\": \"hello\",\n      \"a\": \"world\",\n      \"title\": \"A\"\n    }\n  },\n  \"required\": [\n    \"c\",\n    \"b\",\n    \"a\"\n  ],\n  \"title\": \"Bar\"\n}\n\"\"\"\n</code></pre> <pre><code>import json\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def sort(\n        self, value: JsonSchemaValue, parent_key: str | None = None\n    ) -&gt; JsonSchemaValue:\n        \"\"\"No-op, we don't want to sort schema values at all.\"\"\"\n        return value\n\n\nclass Bar(BaseModel):\n    c: str\n    b: str\n    a: str = Field(json_schema_extra={'c': 'hi', 'b': 'hello', 'a': 'world'})\n\n\njson_schema = Bar.model_json_schema(schema_generator=MyGenerateJsonSchema)\nprint(json.dumps(json_schema, indent=2))\n\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"c\": {\n      \"type\": \"string\",\n      \"title\": \"C\"\n    },\n    \"b\": {\n      \"type\": \"string\",\n      \"title\": \"B\"\n    },\n    \"a\": {\n      \"type\": \"string\",\n      \"c\": \"hi\",\n      \"b\": \"hello\",\n      \"a\": \"world\",\n      \"title\": \"A\"\n    }\n  },\n  \"required\": [\n    \"c\",\n    \"b\",\n    \"a\"\n  ],\n  \"title\": \"Bar\"\n}\n\"\"\"\n</code></pre>"},{"location":"concepts/json_schema/#json-schema-ref","title":"\u81ea\u5b9a\u4e49 JSON Schema \u4e2d\u7684 <code>$ref</code>","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 <code>model_json_schema()</code> \u6216 <code>model_dump_json()</code> \u5e76\u4f20\u5165 <code>ref_template</code> \u5173\u952e\u5b57\u53c2\u6570\u6765\u66f4\u6539 <code>$ref</code> \u7684\u683c\u5f0f\u3002 \u5b9a\u4e49\u59cb\u7ec8\u5b58\u50a8\u5728\u952e <code>$defs</code> \u4e0b\uff0c\u4f46\u53ef\u4ee5\u4e3a\u5f15\u7528\u4f7f\u7528\u6307\u5b9a\u7684\u524d\u7f00\u3002</p> <p>\u5982\u679c\u60a8\u9700\u8981\u6269\u5c55\u6216\u4fee\u6539 JSON \u6a21\u5f0f\u9ed8\u8ba4\u5b9a\u4e49\u4f4d\u7f6e\uff0c\u8fd9\u5f88\u6709\u7528\u3002\u4f8b\u5982\uff0c\u5bf9\u4e8e OpenAPI\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel\nfrom pydantic.type_adapter import TypeAdapter\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\nadapter = TypeAdapter(Model)\n\nprint(\n    json.dumps(\n        adapter.json_schema(ref_template='#/components/schemas/{model}'),\n        indent=2,\n    )\n)\n</code></pre> <p>JSON output:</p> <pre><code>{\n  \"$defs\": {\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ],\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"a\": {\n      \"$ref\": \"#/components/schemas/Foo\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n</code></pre>"},{"location":"concepts/json_schema/#json-schema_3","title":"JSON Schema \u751f\u6210\u7684\u6742\u9879\u8bf4\u660e","text":"<ul> <li><code>Optional</code> \u5b57\u6bb5\u7684 JSON \u6a21\u5f0f\u8868\u660e\u5141\u8bb8\u503c <code>null</code>\u3002</li> <li><code>Decimal</code> \u7c7b\u578b\u5728 JSON \u6a21\u5f0f\u4e2d\uff08\u4ee5\u53ca\u5e8f\u5217\u5316\u65f6\uff09\u4ee5\u5b57\u7b26\u4e32\u5f62\u5f0f\u66b4\u9732\u3002</li> <li>\u7531\u4e8e JSON \u4e2d\u4e0d\u5b58\u5728 <code>namedtuple</code> \u7c7b\u578b\uff0c\u6a21\u578b\u7684 JSON \u6a21\u5f0f\u4e0d\u4f1a\u5c06 <code>namedtuple</code> \u4fdd\u7559\u4e3a <code>namedtuple</code>\u3002</li> <li>\u4f7f\u7528\u7684\u5b50\u6a21\u578b\u6309\u7167\u89c4\u8303\u6dfb\u52a0\u5230 <code>$defs</code> JSON \u5c5e\u6027\u4e2d\u5e76\u88ab\u5f15\u7528\u3002</li> <li>\u5177\u6709\u4fee\u6539\uff08\u901a\u8fc7 <code>Field</code> \u7c7b\uff09\u7684\u5b50\u6a21\u578b\uff0c\u5982\u81ea\u5b9a\u4e49\u6807\u9898\u3001\u63cf\u8ff0\u6216\u9ed8\u8ba4\u503c\uff0c     \u4f1a\u88ab\u9012\u5f52\u5305\u542b\u800c\u4e0d\u662f\u88ab\u5f15\u7528\u3002</li> <li>\u6a21\u578b\u7684 <code>description</code> \u53d6\u81ea\u7c7b\u7684\u6587\u6863\u5b57\u7b26\u4e32\u6216 <code>Field</code> \u7c7b\u7684 <code>description</code> \u53c2\u6570\u3002</li> <li>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6a21\u5f0f\u4f7f\u7528\u522b\u540d\u4f5c\u4e3a\u952e\u751f\u6210\uff0c\u4f46\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 <code>model_json_schema()</code> \u6216     <code>model_dump_json()</code> \u5e76\u4f20\u5165 <code>by_alias=False</code> \u5173\u952e\u5b57\u53c2\u6570\uff0c\u4f7f\u7528\u6a21\u578b\u5c5e\u6027\u540d\u79f0\u751f\u6210\u6a21\u5f0f\u3002</li> </ul>"},{"location":"concepts/models/","title":"Models","text":"API \u6587\u6863 <p><code>pydantic.main.BaseModel</code></p> <p>\u5728 Pydantic \u4e2d\u5b9a\u4e49\u6a21\u5f0f\u7684\u4e3b\u8981\u65b9\u5f0f\u4e4b\u4e00\u662f\u901a\u8fc7\u6a21\u578b\u3002\u6a21\u578b\u662f\u7ee7\u627f\u81ea <code>BaseModel</code> \u7684\u7b80\u5355\u7c7b\uff0c\u5e76\u5c06\u5b57\u6bb5\u5b9a\u4e49\u4e3a\u5e26\u6ce8\u89e3\u7684\u5c5e\u6027\u3002</p> <p>\u60a8\u53ef\u4ee5\u5c06\u6a21\u578b\u89c6\u4e3a\u7c7b\u4f3c\u4e8e C \u7b49\u8bed\u8a00\u4e2d\u7684\u7ed3\u6784\u4f53\uff0c\u6216\u8005\u4f5c\u4e3a API \u4e2d\u5355\u4e2a\u7aef\u70b9\u7684\u8981\u6c42\u3002</p> <p>\u6a21\u578b\u4e0e Python \u7684 dataclasses \u6709\u8bb8\u591a\u76f8\u4f3c\u4e4b\u5904\uff0c\u4f46\u8bbe\u8ba1\u4e0a\u5b58\u5728\u4e00\u4e9b\u5fae\u5999\u4f46\u91cd\u8981\u7684\u5dee\u5f02\uff0c\u8fd9\u4e9b\u5dee\u5f02\u7b80\u5316\u4e86\u4e0e\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u548c JSON \u6a21\u5f0f\u751f\u6210\u76f8\u5173\u7684\u67d0\u4e9b\u5de5\u4f5c\u6d41\u7a0b\u3002 \u60a8\u53ef\u4ee5\u5728\u6587\u6863\u7684 Dataclasses \u90e8\u5206\u627e\u5230\u66f4\u591a\u5173\u4e8e\u6b64\u7684\u8ba8\u8bba\u3002</p> <p>\u4e0d\u53d7\u4fe1\u4efb\u7684\u6570\u636e\u53ef\u4ee5\u4f20\u9012\u7ed9\u6a21\u578b\uff0c\u5728\u89e3\u6790\u548c\u9a8c\u8bc1\u4e4b\u540e\uff0cPydantic \u4fdd\u8bc1\u7ed3\u679c\u6a21\u578b\u5b9e\u4f8b\u7684\u5b57\u6bb5\u5c06\u7b26\u5408\u6a21\u578b\u4e0a\u5b9a\u4e49\u7684\u5b57\u6bb5\u7c7b\u578b\u3002</p> <p>\u9a8c\u8bc1 \u2014 \u4e00\u4e2a\u6545\u610f\u7684\u8bef\u79f0</p> <p>\u7b80\u8981\u8bf4\u660e</p> <p>\u6211\u4eec\u4f7f\u7528\u672f\u8bed\"\u9a8c\u8bc1\"\u6765\u6307\u4ee3\u5b9e\u4f8b\u5316\u7b26\u5408\u6307\u5b9a\u7c7b\u578b\u548c\u7ea6\u675f\u7684\u6a21\u578b\uff08\u6216\u5176\u4ed6\u7c7b\u578b\uff09\u7684\u8fc7\u7a0b\u3002Pydantic \u4ee5\u6b64\u95fb\u540d\uff0c\u5728\u53e3\u8bed\u4e2d\u8fd9\u4e2a\u4efb\u52a1\u6700\u5e7f\u6cdb\u5730\u88ab\u8ba4\u4e3a\u662f\"\u9a8c\u8bc1\"\uff0c \u5c3d\u7ba1\u5728\u5176\u4ed6\u4e0a\u4e0b\u6587\u4e2d\u672f\u8bed\"\u9a8c\u8bc1\"\u53ef\u80fd\u66f4\u5177\u9650\u5236\u6027\u3002</p> <p>\u8be6\u7ec6\u8bf4\u660e</p> <p>\u56f4\u7ed5\u672f\u8bed\"\u9a8c\u8bc1\"\u7684\u6f5c\u5728\u6df7\u6dc6\u6e90\u4e8e\u8fd9\u6837\u4e00\u4e2a\u4e8b\u5b9e\uff1a\u4e25\u683c\u6765\u8bf4\uff0cPydantic \u7684\u4e3b\u8981\u5173\u6ce8\u70b9\u5e76\u4e0d\u5b8c\u5168\u7b26\u5408\"\u9a8c\u8bc1\"\u7684\u5b57\u5178\u5b9a\u4e49\uff1a</p> <p>\u9a8c\u8bc1 \u540d\u8bcd \u68c0\u67e5\u6216\u8bc1\u660e\u67d0\u7269\u6709\u6548\u6027\u6216\u51c6\u786e\u6027\u7684\u884c\u4e3a\u3002</p> <p>\u5728 Pydantic \u4e2d\uff0c\u672f\u8bed\"\u9a8c\u8bc1\"\u6307\u7684\u662f\u5b9e\u4f8b\u5316\u7b26\u5408\u6307\u5b9a\u7c7b\u578b\u548c\u7ea6\u675f\u7684\u6a21\u578b\uff08\u6216\u5176\u4ed6\u7c7b\u578b\uff09\u7684\u8fc7\u7a0b\u3002Pydantic \u4fdd\u8bc1\u8f93\u51fa\u7684\u7c7b\u578b\u548c\u7ea6\u675f\uff0c\u800c\u4e0d\u662f\u8f93\u5165\u6570\u636e\u3002 \u5f53\u8003\u8651\u5230 Pydantic \u7684 <code>ValidationError</code> \u5728\u6570\u636e\u65e0\u6cd5\u6210\u529f\u89e3\u6790\u4e3a\u6a21\u578b\u5b9e\u4f8b\u65f6\u88ab\u5f15\u53d1\u65f6\uff0c\u8fd9\u79cd\u533a\u522b\u53d8\u5f97\u660e\u663e\u3002</p> <p>\u867d\u7136\u8fd9\u79cd\u533a\u522b\u6700\u521d\u53ef\u80fd\u770b\u8d77\u6765\u5f88\u5fae\u5999\uff0c\u4f46\u5b83\u5177\u6709\u5b9e\u9645\u610f\u4e49\u3002 \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\"\u9a8c\u8bc1\"\u8d85\u51fa\u4e86\u6a21\u578b\u521b\u5efa\u7684\u8303\u56f4\uff0c\u53ef\u80fd\u5305\u62ec\u6570\u636e\u7684\u590d\u5236\u548c\u5f3a\u5236\u8f6c\u6362\u3002 \u8fd9\u53ef\u80fd\u6d89\u53ca\u590d\u5236\u4f20\u9012\u7ed9\u6784\u9020\u51fd\u6570\u7684\u53c2\u6570\uff0c\u4ee5\u4fbf\u5728\u4e0d\u6539\u53d8\u539f\u59cb\u8f93\u5165\u6570\u636e\u7684\u60c5\u51b5\u4e0b\u6267\u884c\u5230\u65b0\u7c7b\u578b\u7684\u5f3a\u5236\u8f6c\u6362\u3002 \u8981\u66f4\u6df1\u5165\u5730\u4e86\u89e3\u5bf9\u60a8\u4f7f\u7528\u7684\u5f71\u54cd\uff0c\u8bf7\u53c2\u8003\u4e0b\u9762\u7684 \u6570\u636e\u8f6c\u6362 \u548c \u5c5e\u6027\u590d\u5236 \u90e8\u5206\u3002</p> <p>\u672c\u8d28\u4e0a\uff0cPydantic \u7684\u4e3b\u8981\u76ee\u6807\u662f\u786e\u4fdd\u540e\u5904\u7406\uff08\u79f0\u4e3a\"\u9a8c\u8bc1\"\uff09\u7684\u7ed3\u679c\u7ed3\u6784\u7cbe\u786e\u7b26\u5408\u5e94\u7528\u7684\u7c7b\u578b\u63d0\u793a\u3002 \u9274\u4e8e\"\u9a8c\u8bc1\"\u4f5c\u4e3a\u6b64\u8fc7\u7a0b\u7684\u901a\u7528\u672f\u8bed\u88ab\u5e7f\u6cdb\u91c7\u7528\uff0c\u6211\u4eec\u5c06\u5728\u6587\u6863\u4e2d\u4e00\u81f4\u4f7f\u7528\u5b83\u3002</p> <p>\u867d\u7136\u672f\u8bed\"\u89e3\u6790\"\u548c\"\u9a8c\u8bc1\"\u4ee5\u524d\u53ef\u4ee5\u4e92\u6362\u4f7f\u7528\uff0c\u4f46\u4eca\u540e\u6211\u4eec\u65e8\u5728\u4e13\u95e8\u4f7f\u7528\"\u9a8c\u8bc1\"\uff0c \u800c\"\u89e3\u6790\"\u4e13\u95e8\u4fdd\u7559\u7528\u4e8e\u4e0e JSON \u89e3\u6790 \u76f8\u5173\u7684\u8ba8\u8bba\u3002</p>"},{"location":"concepts/models/#_1","title":"\u57fa\u672c\u6a21\u578b\u7528\u6cd5","text":"<p>Note</p> <p>Pydantic \u4e25\u91cd\u4f9d\u8d56\u73b0\u6709\u7684 Python \u7c7b\u578b\u6784\u9020\u6765\u5b9a\u4e49\u6a21\u578b\u3002\u5982\u679c\u60a8\u4e0d\u719f\u6089\u8fd9\u4e9b\uff0c\u4ee5\u4e0b\u8d44\u6e90\u53ef\u80fd\u4f1a\u6709\u7528\uff1a</p> <ul> <li>\u7c7b\u578b\u7cfb\u7edf\u6307\u5357</li> <li>mypy \u6587\u6863</li> </ul> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'Jane Doe'\n\n    model_config = ConfigDict(str_max_length=10)  # (1)!\n</code></pre> <ol> <li>Pydantic \u6a21\u578b\u652f\u6301\u5404\u79cd \u914d\u7f6e\u503c    \uff08\u8bf7\u53c2\u9605 \u6b64\u5904 \u4e86\u89e3\u53ef\u7528\u7684\u914d\u7f6e\u503c\uff09\u3002</li> </ol> <p>\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c<code>User</code> \u662f\u4e00\u4e2a\u6709\u4e24\u4e2a\u5b57\u6bb5\u7684\u6a21\u578b\uff1a</p> <ul> <li><code>id</code>\uff0c\u662f\u4e00\u4e2a\u6574\u6570\uff08\u4f7f\u7528 <code>int</code> \u7c7b\u578b\u5b9a\u4e49\uff09\u5e76\u4e14\u662f\u5fc5\u9700\u7684</li> <li><code>name</code>\uff0c\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff08\u4f7f\u7528 <code>str</code> \u7c7b\u578b\u5b9a\u4e49\uff09\u5e76\u4e14\u4e0d\u662f\u5fc5\u9700\u7684\uff08\u5b83\u6709\u9ed8\u8ba4\u503c\uff09\u3002</li> </ul> <p>\u5173\u4e8e \u7c7b\u578b \u7684\u6587\u6863\u6269\u5c55\u4e86\u652f\u6301\u7684\u7c7b\u578b\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528 <code>Field()</code> \u51fd\u6570\u4ee5\u591a\u79cd\u65b9\u5f0f\u81ea\u5b9a\u4e49\u5b57\u6bb5\u3002 \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u5b57\u6bb5\u6587\u6863\u3002</p> <p>\u7136\u540e\u53ef\u4ee5\u5b9e\u4f8b\u5316\u6a21\u578b\uff1a</p> <pre><code>user = User(id='123')\n</code></pre> <p><code>user</code> \u662f <code>User</code> \u7684\u4e00\u4e2a\u5b9e\u4f8b\u3002\u5bf9\u8c61\u7684\u521d\u59cb\u5316\u5c06\u6267\u884c\u6240\u6709\u89e3\u6790\u548c\u9a8c\u8bc1\u3002 \u5982\u679c\u6ca1\u6709\u5f15\u53d1 <code>ValidationError</code> \u5f02\u5e38\uff0c \u60a8\u5c31\u77e5\u9053\u7ed3\u679c\u6a21\u578b\u5b9e\u4f8b\u662f\u6709\u6548\u7684\u3002</p> <p>\u6a21\u578b\u7684\u5b57\u6bb5\u53ef\u4ee5\u4f5c\u4e3a <code>user</code> \u5bf9\u8c61\u7684\u666e\u901a\u5c5e\u6027\u8bbf\u95ee\uff1a</p> <pre><code>assert user.name == 'Jane Doe'  # (1)!\nassert user.id == 123  # (2)!\nassert isinstance(user.id, int)\n</code></pre> <ol> <li><code>name</code> \u5728\u521d\u59cb\u5316 <code>user</code> \u65f6\u6ca1\u6709\u8bbe\u7f6e\uff0c\u6240\u4ee5\u4f7f\u7528\u4e86\u9ed8\u8ba4\u503c\u3002    \u53ef\u4ee5\u68c0\u67e5 <code>model_fields_set</code> \u5c5e\u6027    \u6765\u67e5\u770b\u5728\u5b9e\u4f8b\u5316\u671f\u95f4\u663e\u5f0f\u8bbe\u7f6e\u7684\u5b57\u6bb5\u540d\u79f0\u3002</li> <li>\u6ce8\u610f\u5b57\u7b26\u4e32 <code>'123'</code> \u88ab\u5f3a\u5236\u8f6c\u6362\u4e3a\u6574\u6570\uff0c\u5176\u503c\u4e3a <code>123</code>\u3002    \u6709\u5173 Pydantic \u5f3a\u5236\u8f6c\u6362\u903b\u8f91\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\u53ef\u4ee5\u5728 \u6570\u636e\u8f6c\u6362 \u90e8\u5206\u627e\u5230\u3002</li> </ol> <p>\u53ef\u4ee5\u4f7f\u7528 <code>model_dump()</code> \u65b9\u6cd5\u5e8f\u5217\u5316\u6a21\u578b\u5b9e\u4f8b\uff1a</p> <pre><code>assert user.model_dump() == {'id': 123, 'name': 'Jane Doe'}\n</code></pre> <p>\u5728\u5b9e\u4f8b\u4e0a\u8c03\u7528 dict \u4e5f\u4f1a\u63d0\u4f9b\u4e00\u4e2a\u5b57\u5178\uff0c\u4f46\u5d4c\u5957\u5b57\u6bb5\u4e0d\u4f1a \u9012\u5f52\u8f6c\u6362\u4e3a\u5b57\u5178\u3002 <code>model_dump()</code> \u8fd8 \u63d0\u4f9b\u4e86\u8bb8\u591a\u53c2\u6570\u6765\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u7ed3\u679c\u3002</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u6a21\u578b\u662f\u53ef\u53d8\u7684\uff0c\u53ef\u4ee5\u901a\u8fc7\u5c5e\u6027\u8d4b\u503c\u66f4\u6539\u5b57\u6bb5\u503c\uff1a</p> <pre><code>user.id = 321\nassert user.id == 321\n</code></pre> <p>Warning</p> <p>\u5728\u5b9a\u4e49\u6a21\u578b\u65f6\uff0c\u8bf7\u6ce8\u610f\u5b57\u6bb5\u540d\u79f0\u4e0e\u5176\u7c7b\u578b\u6ce8\u89e3\u4e4b\u95f4\u7684\u547d\u540d\u51b2\u7a81\u3002</p> <p>\u4f8b\u5982\uff0c\u4ee5\u4e0b\u5185\u5bb9\u4e0d\u4f1a\u6309\u9884\u671f\u884c\u4e3a\uff0c\u5e76\u4f1a\u4ea7\u751f\u9a8c\u8bc1\u9519\u8bef\uff1a</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Boo(BaseModel):\n    int: Optional[int] = None\n\n\nm = Boo(int=123)  # \u9a8c\u8bc1\u5c06\u5931\u8d25\u3002\n</code></pre> <p>\u7531\u4e8e Python \u8bc4\u4f30 \u5e26\u6ce8\u89e3\u7684\u8d4b\u503c\u8bed\u53e5 \u7684\u65b9\u5f0f\uff0c\u8be5\u8bed\u53e5\u7b49\u540c\u4e8e <code>int: None = None</code>\uff0c\u56e0\u6b64 \u5bfc\u81f4\u9a8c\u8bc1\u9519\u8bef\u3002</p>"},{"location":"concepts/models/#model-methods-and-properties","title":"\u6a21\u578b\u65b9\u6cd5\u548c\u5c5e\u6027","text":"<p>\u4e0a\u9762\u7684\u4f8b\u5b50\u53ea\u5c55\u793a\u4e86\u6a21\u578b\u529f\u80fd\u7684\u51b0\u5c71\u4e00\u89d2\u3002 \u6a21\u578b\u5177\u6709\u4ee5\u4e0b\u65b9\u6cd5\u548c\u5c5e\u6027\uff1a</p> <ul> <li><code>model_validate()</code>: \u6839\u636e Pydantic \u6a21\u578b\u9a8c\u8bc1\u7ed9\u5b9a\u5bf9\u8c61\u3002\u8bf7\u53c2\u9605 \u9a8c\u8bc1\u6570\u636e\u3002</li> <li><code>model_validate_json()</code>: \u6839\u636e Pydantic \u6a21\u578b\u9a8c\u8bc1\u7ed9\u5b9a\u7684 JSON \u6570\u636e\u3002\u8bf7\u53c2\u9605     \u9a8c\u8bc1\u6570\u636e\u3002</li> <li><code>model_construct()</code>: \u5728\u4e0d\u8fd0\u884c\u9a8c\u8bc1\u7684\u60c5\u51b5\u4e0b\u521b\u5efa\u6a21\u578b\u3002\u8bf7\u53c2\u9605     \u521b\u5efa\u4e0d\u9a8c\u8bc1\u7684\u6a21\u578b\u3002</li> <li><code>model_dump()</code>: \u8fd4\u56de\u6a21\u578b\u5b57\u6bb5\u548c\u503c\u7684\u5b57\u5178\u3002\u8bf7\u53c2\u9605     \u5e8f\u5217\u5316\u3002</li> <li><code>model_dump_json()</code>: \u8fd4\u56de <code>model_dump()</code> \u7684 JSON \u5b57\u7b26\u4e32\u8868\u793a\u3002\u8bf7\u53c2\u9605 \u5e8f\u5217\u5316\u3002</li> <li><code>model_copy()</code>: \u8fd4\u56de\u6a21\u578b\u7684\u526f\u672c\uff08\u9ed8\u8ba4\u60c5\u51b5\u4e0b\u662f\u6d45\u62f7\u8d1d\uff09\u3002\u8bf7\u53c2\u9605     \u6a21\u578b\u590d\u5236\u3002</li> <li><code>model_json_schema()</code>: \u8fd4\u56de\u8868\u793a\u6a21\u578b JSON \u6a21\u5f0f\u7684 JSON \u53ef\u5e8f\u5217\u5316\u5b57\u5178\u3002\u8bf7\u53c2\u9605 JSON \u6a21\u5f0f\u3002</li> <li><code>model_fields</code>: \u5b57\u6bb5\u540d\u79f0\u4e0e\u5176\u5b9a\u4e49\uff08<code>FieldInfo</code> \u5b9e\u4f8b\uff09\u4e4b\u95f4\u7684\u6620\u5c04\u3002</li> <li><code>model_computed_fields</code>: \u8ba1\u7b97\u5b57\u6bb5\u540d\u79f0\u4e0e\u5176\u5b9a\u4e49\uff08<code>ComputedFieldInfo</code> \u5b9e\u4f8b\uff09\u4e4b\u95f4\u7684\u6620\u5c04\u3002</li> <li><code>model_extra</code>: \u5728\u9a8c\u8bc1\u671f\u95f4\u8bbe\u7f6e\u7684\u989d\u5916\u5b57\u6bb5\u3002</li> <li><code>model_fields_set</code>: \u5728\u6a21\u578b\u521d\u59cb\u5316\u65f6\u663e\u5f0f\u63d0\u4f9b\u7684\u5b57\u6bb5\u96c6\u5408\u3002</li> <li><code>model_parametrized_name()</code>: \u8ba1\u7b97\u6cdb\u578b\u7c7b\u53c2\u6570\u5316\u7684\u7c7b\u540d\u3002</li> <li><code>model_post_init()</code>: \u5728\u6a21\u578b\u5b9e\u4f8b\u5316\u540e\u4e14\u6240\u6709\u5b57\u6bb5\u9a8c\u8bc1\u5668\u5e94\u7528\u540e\u6267\u884c\u5176\u4ed6\u64cd\u4f5c\u3002</li> <li><code>model_rebuild()</code>: \u91cd\u5efa\u6a21\u578b\u6a21\u5f0f\uff0c\u8fd9\u4e5f\u652f\u6301\u6784\u5efa\u9012\u5f52\u6cdb\u578b\u6a21\u578b\u3002     \u8bf7\u53c2\u9605 \u91cd\u5efa\u6a21\u578b\u6a21\u5f0f\u3002</li> </ul> <p>Note</p> <p>\u8bf7\u53c2\u9605 <code>BaseModel</code> \u7684 API \u6587\u6863\uff0c\u4e86\u89e3\u5305\u62ec\u5b8c\u6574\u65b9\u6cd5\u548c\u5c5e\u6027\u5217\u8868\u7684\u7c7b\u5b9a\u4e49\u3002</p> <p>Tip</p> <p>\u8bf7\u53c2\u9605 \u8fc1\u79fb\u6307\u5357 \u4e2d\u7684 \u5bf9 <code>pydantic.BaseModel</code> \u7684\u66f4\u6539\uff0c \u4e86\u89e3 Pydantic V1 \u7684\u66f4\u6539\u8be6\u60c5\u3002</p>"},{"location":"concepts/models/#data-conversion","title":"\u6570\u636e\u8f6c\u6362","text":"<p>Pydantic \u53ef\u80fd\u4f1a\u5f3a\u5236\u8f6c\u6362\u8f93\u5165\u6570\u636e\u4ee5\u4f7f\u5176\u7b26\u5408\u6a21\u578b\u5b57\u6bb5\u7c7b\u578b\uff0c \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u8fd9\u53ef\u80fd\u5bfc\u81f4\u4fe1\u606f\u4e22\u5931\u3002 \u4f8b\u5982\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.000, b='2.72', c=b'binary data').model_dump())\n#&gt; {'a': 3, 'b': 2.72, 'c': 'binary data'}\n</code></pre> <p>\u8fd9\u662f Pydantic \u7684\u4e00\u4e2a\u6709\u610f\u51b3\u5b9a\uff0c\u901a\u5e38\u662f\u6700\u6709\u7528\u7684\u65b9\u6cd5\u3002\u8bf7\u53c2\u9605 \u6b64\u95ee\u9898 \u4e86\u89e3\u5173\u4e8e\u8be5\u4e3b\u9898\u7684\u8be6\u7ec6\u8ba8\u8bba\u3002</p> <p>\u5c3d\u7ba1\u5982\u6b64\uff0cPydantic \u63d0\u4f9b\u4e86 \u4e25\u683c\u6a21\u5f0f\uff0c\u5728\u8be5\u6a21\u5f0f\u4e0b\u4e0d\u6267\u884c\u6570\u636e\u8f6c\u6362\u3002 \u503c\u5fc5\u987b\u4e0e\u58f0\u660e\u7684\u5b57\u6bb5\u7c7b\u578b\u76f8\u540c\u3002</p> <p>\u5bf9\u4e8e\u96c6\u5408\u4e5f\u662f\u5982\u6b64\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u60a8\u4e0d\u5e94\u8be5\u4f7f\u7528\u62bd\u8c61\u5bb9\u5668\u7c7b\uff0c \u800c\u5e94\u8be5\u4f7f\u7528\u5177\u4f53\u7c7b\u578b\uff0c\u4f8b\u5982 <code>list</code>\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    items: list[int]  # (1)!\n\n\nprint(Model(items=(1, 2, 3)))\n#&gt; items=[1, 2, 3]\n</code></pre> <ol> <li>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u80fd\u4f1a\u60f3\u4f7f\u7528\u62bd\u8c61\u7684 <code>Sequence</code> \u7c7b\u578b    \u6765\u5141\u8bb8\u5217\u8868\u548c\u5143\u7ec4\u3002\u4f46 Pydantic \u4f1a\u8d1f\u8d23\u5c06\u5143\u7ec4\u8f93\u5165\u8f6c\u6362\u4e3a\u5217\u8868\uff0c\u56e0\u6b64    \u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u8fd9\u662f\u4e0d\u5fc5\u8981\u7684\u3002</li> </ol> <p>\u6b64\u5916\uff0c\u4f7f\u7528\u8fd9\u4e9b\u62bd\u8c61\u7c7b\u578b\u8fd8\u53ef\u80fd\u5bfc\u81f4 \u9a8c\u8bc1\u6027\u80fd\u8f83\u5dee\uff0c\u901a\u5e38\u4f7f\u7528\u5177\u4f53\u5bb9\u5668\u7c7b\u578b \u53ef\u4ee5\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u68c0\u67e5\u3002</p> <p></p>"},{"location":"concepts/models/#extra-data","title":"\u989d\u5916\u6570\u636e","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u6a21\u578b\u5728\u60a8\u63d0\u4f9b\u989d\u5916\u6570\u636e\u65f6\u4e0d\u4f1a\u62a5\u9519\uff0c\u8fd9\u4e9b\u503c\u5c06\u88ab\u7b80\u5355\u5730\u5ffd\u7565\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int\n\n\nm = Model(x=1, y='a')\nassert m.model_dump() == {'x': 1}\n</code></pre> <p>\u53ef\u4ee5\u4f7f\u7528 <code>extra</code> \u914d\u7f6e\u503c\u6765\u63a7\u5236\u6b64\u884c\u4e3a\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\nm = Model(x=1, y='a')  # (1)!\nassert m.model_dump() == {'x': 1, 'y': 'a'}\nassert m.__pydantic_extra__ == {'y': 'a'}\n</code></pre> <ol> <li>\u5982\u679c <code>extra</code> \u8bbe\u7f6e\u4e3a <code>'forbid'</code>\uff0c\u8fd9\u5c06\u5931\u8d25\u3002</li> </ol> <p>\u914d\u7f6e\u53ef\u4ee5\u53d6\u4e09\u4e2a\u503c\uff1a</p> <ul> <li><code>'ignore'</code>: \u5ffd\u7565\u63d0\u4f9b\u7684\u989d\u5916\u6570\u636e\uff08\u9ed8\u8ba4\u503c\uff09\u3002</li> <li><code>'forbid'</code>: \u4e0d\u5141\u8bb8\u63d0\u4f9b\u989d\u5916\u6570\u636e\u3002</li> <li><code>'allow'</code>: \u5141\u8bb8\u63d0\u4f9b\u989d\u5916\u6570\u636e\u5e76\u5b58\u50a8\u5728 <code>__pydantic_extra__</code> \u5b57\u5178\u5c5e\u6027\u4e2d\u3002   <code>__pydantic_extra__</code> \u53ef\u4ee5\u663e\u5f0f\u6ce8\u89e3\u4ee5\u63d0\u4f9b\u5bf9\u989d\u5916\u5b57\u6bb5\u7684\u9a8c\u8bc1\u3002</li> </ul> <p>\u9a8c\u8bc1\u65b9\u6cd5\uff08\u4f8b\u5982 <code>model_validate()</code>\uff09\u6709\u4e00\u4e2a\u53ef\u9009\u7684 <code>extra</code> \u53c2\u6570\uff0c \u8be5\u53c2\u6570\u5c06\u8986\u76d6\u8be5\u9a8c\u8bc1\u8c03\u7528\u7684\u6a21\u578b\u7684 <code>extra</code> \u914d\u7f6e\u503c\u3002</p> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 <code>extra</code> API \u6587\u6863\u3002</p> <p>Pydantic \u6570\u636e\u7c7b\u4e5f\u652f\u6301\u989d\u5916\u6570\u636e\uff08\u8bf7\u53c2\u9605 \u6570\u636e\u7c7b\u914d\u7f6e \u90e8\u5206\uff09\u3002</p>"},{"location":"concepts/models/#nested-models","title":"\u5d4c\u5957\u6a21\u578b","text":"<p>\u53ef\u4ee5\u4f7f\u7528\u6a21\u578b\u672c\u8eab\u4f5c\u4e3a\u6ce8\u89e3\u4e2d\u7684\u7c7b\u578b\u6765\u5b9a\u4e49\u66f4\u590d\u6742\u7684\u5c42\u6b21\u6570\u636e\u7ed3\u6784\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n\"\"\"\nfoo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'), Bar(apple='x2', banana='y')]\n\"\"\"\nprint(m.model_dump())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}],\n}\n\"\"\"\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: float | None = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n\"\"\"\nfoo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'), Bar(apple='x2', banana='y')]\n\"\"\"\nprint(m.model_dump())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}],\n}\n\"\"\"\n</code></pre> <p>\u652f\u6301\u81ea\u5f15\u7528\u6a21\u578b\u3002\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u76f8\u5173\u7684 \u524d\u5411\u6ce8\u89e3 \u6587\u6863\u3002</p>"},{"location":"concepts/models/#rebuilding-model-schema","title":"\u91cd\u5efa\u6a21\u578b\u6a21\u5f0f","text":"<p>\u5f53\u60a8\u5728\u4ee3\u7801\u4e2d\u5b9a\u4e49\u6a21\u578b\u7c7b\u65f6\uff0cPydantic \u5c06\u5206\u6790\u7c7b\u7684\u4e3b\u4f53\u4ee5\u6536\u96c6\u6267\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u6240\u9700\u7684\u5404\u79cd\u4fe1\u606f\uff0c \u8fd9\u4e9b\u4fe1\u606f\u6536\u96c6\u5728\u4e00\u4e2a\u6838\u5fc3\u6a21\u5f0f\u4e2d\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u6a21\u578b\u7c7b\u578b\u6ce8\u89e3\u4f1a\u88ab\u8bc4\u4f30\u4ee5 \u4e86\u89e3\u6bcf\u4e2a\u5b57\u6bb5\u7684\u6709\u6548\u7c7b\u578b\uff08\u66f4\u591a\u4fe1\u606f\u53ef\u4ee5\u5728 \u67b6\u6784 \u6587\u6863\u4e2d\u627e\u5230\uff09\u3002 \u4f46\u662f\uff0c\u6ce8\u89e3\u53ef\u80fd\u5f15\u7528\u5728\u6a21\u578b\u7c7b\u521b\u5efa\u65f6\u672a\u5b9a\u4e49\u7684\u7b26\u53f7\u3002 \u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>model_rebuild()</code> \u65b9\u6cd5\uff1a</p> <pre><code>from pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    x: 'Bar'  # (1)!\n\n\ntry:\n    Foo.model_json_schema()\nexcept PydanticUserError as e:\n    print(e)\n    \"\"\"\n    `Foo` is not fully defined; you should define `Bar`, then call `Foo.model_rebuild()`.\n\n    For further information visit https://errors.pydantic.dev/2/u/class-not-fully-defined\n    \"\"\"\n\n\nclass Bar(BaseModel):\n    pass\n\n\nFoo.model_rebuild()\nprint(Foo.model_json_schema())\n\"\"\"\n{\n    '$defs': {'Bar': {'properties': {}, 'title': 'Bar', 'type': 'object'}},\n    'properties': {'x': {'$ref': '#/$defs/Bar'}},\n    'required': ['x'],\n    'title': 'Foo',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <ol> <li>\u5728\u521b\u5efa <code>Foo</code> \u7c7b\u65f6\uff0c<code>Bar</code> \u5c1a\u672a\u5b9a\u4e49\u3002\u56e0\u6b64\uff0c     \u4f7f\u7528\u4e86 \u524d\u5411\u6ce8\u89e3\u3002</li> </ol> <p>Pydantic \u4f1a\u5c1d\u8bd5\u81ea\u52a8\u786e\u5b9a\u4f55\u65f6\u9700\u8981\u8fd9\u6837\u505a\uff0c\u5982\u679c\u672a\u5b8c\u6210\u5219\u4f1a\u62a5\u9519\uff0c\u4f46\u60a8\u53ef\u80fd\u5e0c\u671b\u5728\u5904\u7406\u9012\u5f52\u6a21\u578b\u6216\u6cdb\u578b\u65f6 \u4e3b\u52a8\u8c03\u7528 <code>model_rebuild()</code>\u3002</p> <p>\u5728 V2 \u4e2d\uff0c<code>model_rebuild()</code> \u53d6\u4ee3\u4e86 V1 \u4e2d\u7684 <code>update_forward_refs()</code>\u3002\u65b0\u884c\u4e3a\u6709\u4e00\u4e9b\u7ec6\u5fae\u5dee\u5f02\u3002 \u6700\u5927\u7684\u53d8\u5316\u662f\uff0c\u5f53\u5728\u6700\u5916\u5c42\u6a21\u578b\u4e0a\u8c03\u7528 <code>model_rebuild()</code> \u65f6\uff0c\u5b83\u4f1a\u6784\u5efa\u4e00\u4e2a\u7528\u4e8e\u9a8c\u8bc1\u6574\u4e2a\u6a21\u578b \uff08\u5305\u62ec\u5d4c\u5957\u6a21\u578b\uff09\u7684\u6838\u5fc3\u6a21\u5f0f\uff0c\u56e0\u6b64\u5728\u8c03\u7528 <code>model_rebuild()</code> \u4e4b\u524d\uff0c\u6240\u6709\u7ea7\u522b\u7684\u6240\u6709\u7c7b\u578b\u90fd\u9700\u8981\u51c6\u5907\u5c31\u7eea\u3002</p>"},{"location":"concepts/models/#_2","title":"\u4efb\u610f\u7c7b\u5b9e\u4f8b","text":"<p>\uff08\u4ee5\u524d\u79f0\u4e3a\"ORM \u6a21\u5f0f\"/<code>from_orm</code>\uff09\u3002</p> <p>Pydantic \u6a21\u578b\u4e5f\u53ef\u4ee5\u901a\u8fc7\u8bfb\u53d6\u4e0e\u6a21\u578b\u5b57\u6bb5\u540d\u79f0\u5bf9\u5e94\u7684\u5b9e\u4f8b\u5c5e\u6027\u6765\u4ece\u4efb\u610f\u7c7b\u5b9e\u4f8b\u521b\u5efa\u3002 \u6b64\u529f\u80fd\u7684\u4e00\u4e2a\u5e38\u89c1\u5e94\u7528\u662f\u4e0e\u5bf9\u8c61\u5173\u7cfb\u6620\u5c04\uff08ORMs\uff09\u96c6\u6210\u3002</p> <p>\u4e3a\u6b64\uff0c\u5c06 <code>from_attributes</code> \u914d\u7f6e\u503c\u8bbe\u7f6e\u4e3a <code>True</code> \uff08\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u914d\u7f6e \u6587\u6863\uff09\u3002</p> <p>\u6b64\u5904\u7684\u793a\u4f8b\u4f7f\u7528 SQLAlchemy\uff0c\u4f46\u76f8\u540c\u7684\u65b9\u6cd5\u5e94\u9002\u7528\u4e8e\u4efb\u4f55 ORM\u3002</p> <pre><code>from typing import Annotated\n\nfrom sqlalchemy import ARRAY, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nfrom pydantic import BaseModel, ConfigDict, StringConstraints\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n\n    id: Mapped[int] = mapped_column(primary_key=True, nullable=False)\n    public_key: Mapped[str] = mapped_column(\n        String(20), index=True, nullable=False, unique=True\n    )\n    domains: Mapped[list[str]] = mapped_column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    public_key: Annotated[str, StringConstraints(max_length=20)]\n    domains: list[Annotated[str, StringConstraints(max_length=255)]]\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n#&gt; &lt;__main__.CompanyOrm object at 0x0123456789ab&gt;\nco_model = CompanyModel.model_validate(co_orm)\nprint(co_model)\n#&gt; id=123 public_key='foobar' domains=['example.com', 'foobar.com']\n</code></pre>"},{"location":"concepts/models/#_3","title":"\u5d4c\u5957\u5c5e\u6027","text":"<p>\u5f53\u4f7f\u7528\u5c5e\u6027\u89e3\u6790\u6a21\u578b\u65f6\uff0c\u6a21\u578b\u5b9e\u4f8b\u5c06\u4ece\u9876\u7ea7\u5c5e\u6027\u548c\u66f4\u6df1\u5c42\u6b21\u7684\u5d4c\u5957\u5c5e\u6027\uff08\u5982\u9002\u7528\uff09\u521b\u5efa\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u6f14\u793a\u8be5\u539f\u7406\u7684\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: list[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    species: str\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    age: float = None\n    pets: list[Pet]\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.model_validate(anna)\nprint(anna_model)\n\"\"\"\nname='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'), Pet(name='Orion', species='cat')]\n\"\"\"\n</code></pre>"},{"location":"concepts/models/#error-handling","title":"\u9519\u8bef\u5904\u7406","text":"<p>\u6bcf\u5f53 Pydantic \u5728\u9a8c\u8bc1\u7684\u6570\u636e\u4e2d\u53d1\u73b0\u9519\u8bef\u65f6\uff0c\u5b83\u5c06\u5f15\u53d1 <code>ValidationError</code> \u5f02\u5e38\u3002</p> <p>\u65e0\u8bba\u53d1\u73b0\u591a\u5c11\u9519\u8bef\uff0c\u90fd\u4f1a\u5f15\u53d1\u5355\u4e2a\u5f02\u5e38\uff0c\u5e76\u4e14\u8be5\u9a8c\u8bc1\u9519\u8bef \u5c06\u5305\u542b\u6240\u6709\u9519\u8bef\u7684\u4fe1\u606f\u4ee5\u53ca\u5b83\u4eec\u662f\u5982\u4f55\u53d1\u751f\u7684\u3002</p> <p>\u6709\u5173\u6807\u51c6\u548c\u81ea\u5b9a\u4e49\u9519\u8bef\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u9519\u8bef\u5904\u7406\u3002</p> <p>\u4f5c\u4e3a\u6f14\u793a\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    list_of_ints: list[int]\n    a_float: float\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='not a float', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"concepts/models/#validating-data","title":"\u9a8c\u8bc1\u6570\u636e","text":"<p>Pydantic \u5728\u6a21\u578b\u7c7b\u4e0a\u63d0\u4f9b\u4e86\u4e09\u79cd\u89e3\u6790\u6570\u636e\u7684\u65b9\u6cd5\uff1a</p> <ul> <li><code>model_validate()</code>: \u8fd9\u4e0e\u6a21\u578b\u7684 <code>__init__</code> \u65b9\u6cd5\u975e\u5e38\u76f8\u4f3c\uff0c   \u4e0d\u540c\u4e4b\u5904\u5728\u4e8e\u5b83\u63a5\u53d7\u5b57\u5178\u6216\u5bf9\u8c61\u800c\u4e0d\u662f\u5173\u952e\u5b57\u53c2\u6570\u3002\u5982\u679c\u4f20\u9012\u7684\u5bf9\u8c61\u65e0\u6cd5\u9a8c\u8bc1\uff0c   \u6216\u8005\u5b83\u4e0d\u662f\u5b57\u5178\u6216\u76f8\u5173\u6a21\u578b\u7684\u5b9e\u4f8b\uff0c\u5c06\u5f15\u53d1 <code>ValidationError</code>\u3002</li> <li><code>model_validate_json()</code>: \u8fd9\u5c06\u63d0\u4f9b\u7684\u6570\u636e\u4f5c\u4e3a JSON \u5b57\u7b26\u4e32\u6216 <code>bytes</code> \u5bf9\u8c61\u8fdb\u884c\u9a8c\u8bc1\u3002   \u5982\u679c\u60a8\u7684\u4f20\u5165\u6570\u636e\u662f JSON \u8d1f\u8f7d\uff0c\u8fd9\u901a\u5e38\u88ab\u8ba4\u4e3a\u66f4\u5feb\uff08\u800c\u4e0d\u662f\u624b\u52a8\u5c06\u6570\u636e\u89e3\u6790\u4e3a\u5b57\u5178\uff09\u3002   \u5728\u6587\u6863\u7684 JSON \u90e8\u5206\u4e86\u89e3\u66f4\u591a\u5173\u4e8e JSON \u89e3\u6790\u7684\u4fe1\u606f\u3002</li> <li><code>model_validate_strings()</code>: \u8fd9\u63a5\u53d7\u4e00\u4e2a\u5177\u6709\u5b57\u7b26\u4e32\u952e\u548c\u503c\u7684\u5b57\u5178\uff08\u53ef\u4ee5\u662f\u5d4c\u5957\u7684\uff09\uff0c\u5e76\u5728 JSON \u6a21\u5f0f\u4e0b\u9a8c\u8bc1\u6570\u636e\uff0c\u4ee5\u4fbf\u5c06\u6240\u8ff0\u5b57\u7b26\u4e32\u5f3a\u5236\u8f6c\u6362\u4e3a\u6b63\u786e\u7684\u7c7b\u578b\u3002</li> </ul> Python 3.9 and abovePython 3.10 and above <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#&gt; id=123 name='James' signup_ts=None\n\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#&gt; id=123 name='James' signup_ts=None\n\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#&gt; id=123 name='James' signup_ts=None\n\nm = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#&gt; id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n</code></pre> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None = None\n\n\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#&gt; id=123 name='James' signup_ts=None\n\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#&gt; id=123 name='James' signup_ts=None\n\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#&gt; id=123 name='James' signup_ts=None\n\nm = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#&gt; id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n</code></pre> <p>\u5982\u679c\u60a8\u60f3\u8981\u9a8c\u8bc1\u975e JSON \u683c\u5f0f\u7684\u5e8f\u5217\u5316\u6570\u636e\uff0c\u60a8\u5e94\u8be5\u81ea\u5df1\u5c06\u6570\u636e\u52a0\u8f7d\u5230\u5b57\u5178\u4e2d\uff0c \u7136\u540e\u5c06\u5176\u4f20\u9012\u7ed9 <code>model_validate</code>\u3002</p> <p>Note</p> <p>\u6839\u636e\u6240\u6d89\u53ca\u7684\u7c7b\u578b\u548c\u6a21\u578b\u914d\u7f6e\uff0c<code>model_validate</code> \u548c <code>model_validate_json</code> \u53ef\u80fd\u5177\u6709\u4e0d\u540c\u7684\u9a8c\u8bc1\u884c\u4e3a\u3002 \u5982\u679c\u60a8\u6709\u6765\u81ea\u975e JSON \u6e90\u7684\u6570\u636e\uff0c\u4f46\u60f3\u8981\u83b7\u5f97\u4e0e <code>model_validate_json</code> \u76f8\u540c\u7684\u9a8c\u8bc1 \u884c\u4e3a\u548c\u9519\u8bef\uff0c\u6211\u4eec\u76ee\u524d\u7684\u5efa\u8bae\u662f\u4f7f\u7528 <code>model_validate_json(json.dumps(data))</code>\uff0c\u6216\u8005\u5982\u679c\u6570\u636e\u91c7\u7528\u5177\u6709\u5b57\u7b26\u4e32\u952e\u548c\u503c\u7684\uff08\u53ef\u80fd\u662f\u5d4c\u5957\u7684\uff09\u5b57\u5178\u5f62\u5f0f\uff0c\u5219\u4f7f\u7528 <code>model_validate_strings</code>\u3002</p> <p>Note</p> <p>\u5982\u679c\u60a8\u5c06\u6a21\u578b\u5b9e\u4f8b\u4f20\u9012\u7ed9 <code>model_validate</code>\uff0c\u60a8\u9700\u8981\u8003\u8651\u5728\u6a21\u578b\u914d\u7f6e\u4e2d\u8bbe\u7f6e <code>revalidate_instances</code>\u3002 \u5982\u679c\u60a8\u4e0d\u8bbe\u7f6e\u6b64\u503c\uff0c\u5219\u5c06\u5728\u6a21\u578b\u5b9e\u4f8b\u4e0a\u8df3\u8fc7\u9a8c\u8bc1\u3002\u8bf7\u53c2\u9605\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <code>revalidate_instances='never'</code> <code>revalidate_instances='always'</code> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nm = Model(a=0)\n# note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\nm.a = 'not an int'\n\n# doesn't raise a validation error even though m is invalid\nm2 = Model.model_validate(m)\n</code></pre> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n\n    model_config = ConfigDict(revalidate_instances='always')\n\n\nm = Model(a=0)\n# note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\nm.a = 'not an int'\n\ntry:\n    m2 = Model.model_validate(m)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    a\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='not an int', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"concepts/models/#creating-models-without-validation","title":"\u521b\u5efa\u6a21\u578b\u800c\u4e0d\u8fdb\u884c\u9a8c\u8bc1","text":"<p>Pydantic \u8fd8\u63d0\u4f9b\u4e86 <code>model_construct()</code> \u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u5141\u8bb8\u4e0d\u8fdb\u884c\u9a8c\u8bc1\u521b\u5efa\u6a21\u578b\u3002 \u8fd9\u5728\u81f3\u5c11\u4ee5\u4e0b\u51e0\u79cd\u60c5\u51b5\u4e0b\u5f88\u6709\u7528\uff1a</p> <ul> <li>\u5f53\u5904\u7406\u5df2\u77e5\u6709\u6548\u7684\u590d\u6742\u6570\u636e\u65f6\uff08\u51fa\u4e8e\u6027\u80fd\u539f\u56e0\uff09</li> <li>\u5f53\u4e00\u4e2a\u6216\u591a\u4e2a\u9a8c\u8bc1\u5668\u51fd\u6570\u4e0d\u662f\u5e42\u7b49\u65f6</li> <li>\u5f53\u4e00\u4e2a\u6216\u591a\u4e2a\u9a8c\u8bc1\u5668\u51fd\u6570\u5177\u6709\u60a8\u4e0d\u5e0c\u671b\u89e6\u53d1\u7684\u526f\u4f5c\u7528\u65f6</li> </ul> <p>Warning</p> <p><code>model_construct()</code> \u4e0d\u8fdb\u884c\u4efb\u4f55\u9a8c\u8bc1\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u53ef\u4ee5\u521b\u5efa \u65e0\u6548\u7684\u6a21\u578b\u3002\u60a8\u5e94\u8be5\u53ea\u5bf9\u5df2\u7ecf\u9a8c\u8bc1\u8fc7\u7684\u6570\u636e\u6216\u60a8\u7edd\u5bf9\u4fe1\u4efb\u7684\u6570\u636e\u4f7f\u7528 <code>model_construct()</code> \u65b9\u6cd5\u3002</p> <p>Note</p> <p>\u5728 Pydantic V2 \u4e2d\uff0c\u9a8c\u8bc1\uff08\u65e0\u8bba\u662f\u76f4\u63a5\u5b9e\u4f8b\u5316\u8fd8\u662f\u4f7f\u7528 <code>model_validate*</code> \u65b9\u6cd5\uff09\u4e0e <code>model_construct()</code> \u4e4b\u95f4\u7684\u6027\u80fd\u5dee\u8ddd\u5df2\u7ecf\u5927\u5927\u7f29\u5c0f\u3002 \u5bf9\u4e8e\u7b80\u5355\u6a21\u578b\uff0c\u4f7f\u7528\u9a8c\u8bc1\u751a\u81f3\u53ef\u80fd\u66f4\u5feb\u3002\u5982\u679c\u60a8\u51fa\u4e8e\u6027\u80fd\u539f\u56e0\u4f7f\u7528 <code>model_construct()</code>\uff0c \u60a8\u53ef\u80fd\u9700\u8981\u5728\u5047\u8bbe\u5b83\u5b9e\u9645\u4e0a\u66f4\u5feb\u4e4b\u524d\u5bf9\u60a8\u7684\u7528\u4f8b\u8fdb\u884c\u5206\u6790\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0c\u5bf9\u4e8e\u6839\u6a21\u578b\uff0c\u6839\u503c\u53ef\u4ee5\u4f4d\u7f6e\u4f20\u9012\u7ed9 <code>model_construct()</code>\uff0c\u800c\u4e0d\u662f\u4f7f\u7528\u5173\u952e\u5b57\u53c2\u6570\u3002</p> <p>\u4ee5\u4e0b\u662f\u5173\u4e8e <code>model_construct()</code> \u884c\u4e3a\u7684\u4e00\u4e9b\u989d\u5916\u8bf4\u660e\uff1a</p> <ul> <li>\u5f53\u6211\u4eec\u8bf4\"\u4e0d\u6267\u884c\u9a8c\u8bc1\"\u65f6\u2014\u2014\u8fd9\u5305\u62ec\u5c06\u5b57\u5178\u8f6c\u6362\u4e3a\u6a21\u578b\u5b9e\u4f8b\u3002\u56e0\u6b64\uff0c\u5982\u679c\u60a8\u6709\u4e00\u4e2a\u5b57\u6bb5   \u5f15\u7528\u6a21\u578b\u7c7b\u578b\uff0c\u60a8\u9700\u8981\u81ea\u5df1\u5c06\u5185\u90e8\u5b57\u5178\u8f6c\u6362\u4e3a\u6a21\u578b\u3002</li> <li>\u5982\u679c\u60a8\u4e0d\u4e3a\u5177\u6709\u9ed8\u8ba4\u503c\u7684\u5b57\u6bb5\u4f20\u9012\u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ecd\u5c06\u4f7f\u7528\u9ed8\u8ba4\u503c\u3002</li> <li>\u5bf9\u4e8e\u5177\u6709\u79c1\u6709\u5c5e\u6027\u7684\u6a21\u578b\uff0c<code>__pydantic_private__</code> \u5b57\u5178\u5c06\u4ee5\u4e0e\u521b\u5efa\u6a21\u578b\u65f6\u76f8\u540c\u7684\u65b9\u5f0f\u586b\u5145   \u9a8c\u8bc1\u3002</li> <li>\u4e0d\u4f1a\u8c03\u7528\u6a21\u578b\u6216\u5176\u4efb\u4f55\u7236\u7c7b\u7684 <code>__init__</code> \u65b9\u6cd5\uff0c\u5373\u4f7f\u5b9a\u4e49\u4e86\u81ea\u5b9a\u4e49 <code>__init__</code> \u65b9\u6cd5\u3002</li> </ul> <p>\u5173\u4e8e <code>model_construct()</code> \u7684\u989d\u5916\u6570\u636e\u884c\u4e3a</p> <ul> <li>\u5bf9\u4e8e\u5c06 <code>extra</code> \u8bbe\u7f6e\u4e3a <code>'allow'</code> \u7684\u6a21\u578b\uff0c\u4e0d\u5bf9\u5e94\u4e8e\u5b57\u6bb5\u7684\u6570\u636e\u5c06\u6b63\u786e\u5b58\u50a8\u5728 <code>__pydantic_extra__</code> \u5b57\u5178\u4e2d\u5e76\u4fdd\u5b58\u5230\u6a21\u578b\u7684 <code>__dict__</code> \u5c5e\u6027\u4e2d\u3002</li> <li>\u5bf9\u4e8e\u5c06 <code>extra</code> \u8bbe\u7f6e\u4e3a <code>'ignore'</code> \u7684\u6a21\u578b\uff0c\u4e0d\u5bf9\u5e94\u4e8e\u5b57\u6bb5\u7684\u6570\u636e\u5c06\u88ab\u5ffd\u7565\u2014\u2014\u4e5f\u5c31\u662f\u8bf4\uff0c \u4e0d\u4f1a\u5b58\u50a8\u5728\u5b9e\u4f8b\u7684 <code>__pydantic_extra__</code> \u6216 <code>__dict__</code> \u4e2d\u3002</li> <li>\u4e0e\u901a\u8fc7\u9a8c\u8bc1\u5b9e\u4f8b\u5316\u6a21\u578b\u4e0d\u540c\uff0c\u5f53 <code>extra</code> \u8bbe\u7f6e\u4e3a <code>'forbid'</code> \u65f6\u8c03\u7528 <code>model_construct()</code> \u4e0d\u4f1a\u5728\u5b58\u5728\u4e0d\u5bf9\u5e94\u4e8e\u5b57\u6bb5\u7684\u6570\u636e\u65f6\u5f15\u53d1\u9519\u8bef\u3002\u76f8\u53cd\uff0c\u6240\u8ff0\u8f93\u5165\u6570\u636e\u5c06\u88ab\u7b80\u5355\u5730\u5ffd\u7565\u3002</li> </ul>"},{"location":"concepts/models/#model-copy","title":"\u6a21\u578b\u590d\u5236","text":"API \u6587\u6863 <p><code>pydantic.main.BaseModel.model_copy</code></p> <p><code>model_copy()</code> \u65b9\u6cd5\u5141\u8bb8\u590d\u5236\u6a21\u578b\uff08\u5e26\u6709\u53ef\u9009\u66f4\u65b0\uff09\uff0c \u8fd9\u5728\u5904\u7406\u51bb\u7ed3\u6a21\u578b\u65f6\u7279\u522b\u6709\u7528\u3002</p> <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.model_copy(update={'banana': 0}))\n#&gt; banana=0 foo='hello' bar=BarModel(whatever=123)\n\n# \u6b63\u5e38\u590d\u5236\u4e3a bar \u63d0\u4f9b\u76f8\u540c\u7684\u5bf9\u8c61\u5f15\u7528\uff1a\nprint(id(m.bar) == id(m.model_copy().bar))\n#&gt; True\n# \u6df1\u5ea6\u590d\u5236\u4e3a `bar` \u63d0\u4f9b\u65b0\u7684\u5bf9\u8c61\u5f15\u7528\uff1a\nprint(id(m.bar) == id(m.model_copy(deep=True).bar))\n#&gt; False\n</code></pre>"},{"location":"concepts/models/#generic-models","title":"\u6cdb\u578b\u6a21\u578b","text":"<p>Pydantic \u652f\u6301\u521b\u5efa\u6cdb\u578b\u6a21\u578b\uff0c\u4ee5\u4fbf\u66f4\u8f7b\u677e\u5730\u91cd\u7528\u901a\u7528\u6a21\u578b\u7ed3\u6784\u3002\u65b0\u7684 \u7c7b\u578b\u53c2\u6570\u8bed\u6cd5\uff08\u7531 Python 3.12 \u4e2d\u7684 PEP 695 \u5f15\u5165\uff09 \u548c\u65e7\u8bed\u6cd5\u90fd\u53d7\u652f\u6301\uff08\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Python \u6587\u6863\uff09\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528\u6cdb\u578b Pydantic \u6a21\u578b\u521b\u5efa\u6613\u4e8e\u91cd\u7528\u7684 HTTP \u54cd\u5e94\u8d1f\u8f7d\u5305\u88c5\u5668\u7684\u793a\u4f8b\uff1a</p> Python 3.9 \u53ca\u4ee5\u4e0a\u7248\u672cPython 3.12 \u53ca\u4ee5\u4e0a\u7248\u672c\uff08\u65b0\u8bed\u6cd5\uff09 <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nDataT = TypeVar('DataT')  # (1)!\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response(BaseModel, Generic[DataT]):  # (2)!\n    data: DataT  # (3)!\n\n\nprint(Response[int](data=1))\n#&gt; data=1\nprint(Response[str](data='value'))\n#&gt; data='value'\nprint(Response[str](data='value').model_dump())\n#&gt; {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#&gt; {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u58f0\u660e\u4e00\u4e2a\u6216\u591a\u4e2a\u7c7b\u578b\u53d8\u91cf\u4ee5\u7528\u4e8e\u53c2\u6570\u5316\u60a8\u7684\u6a21\u578b\u3002</li> <li>\u58f0\u660e\u4e00\u4e2a\u7ee7\u627f\u81ea <code>BaseModel</code> \u548c <code>typing.Generic</code>    \uff08\u6309\u6b64\u7279\u5b9a\u987a\u5e8f\uff09\u7684 Pydantic \u6a21\u578b\uff0c\u5e76\u5c06\u60a8\u4e4b\u524d\u58f0\u660e\u7684\u7c7b\u578b\u53d8\u91cf\u5217\u8868\u4f5c\u4e3a\u53c2\u6570\u6dfb\u52a0\u5230    <code>Generic</code> \u7236\u7c7b\u3002</li> <li>\u5728\u60a8\u5e0c\u671b\u7528\u5176\u4ed6\u7c7b\u578b\u66ff\u6362\u7684\u5730\u65b9\u4f7f\u7528\u7c7b\u578b\u53d8\u91cf\u4f5c\u4e3a\u6ce8\u89e3\u3002</li> </ol> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response[DataT](BaseModel):  # (1)!\n    data: DataT  # (2)!\n\n\nprint(Response[int](data=1))\n#&gt; data=1\nprint(Response[str](data='value'))\n#&gt; data='value'\nprint(Response[str](data='value').model_dump())\n#&gt; {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#&gt; {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u58f0\u660e\u4e00\u4e2a Pydantic \u6a21\u578b\u5e76\u5c06\u7c7b\u578b\u53d8\u91cf\u5217\u8868\u6dfb\u52a0\u4e3a\u7c7b\u578b\u53c2\u6570\u3002</li> <li>\u5728\u60a8\u5e0c\u671b\u7528\u5176\u4ed6\u7c7b\u578b\u66ff\u6362\u7684\u5730\u65b9\u4f7f\u7528\u7c7b\u578b\u53d8\u91cf\u4f5c\u4e3a\u6ce8\u89e3\u3002</li> </ol> <p>Warning</p> <p>\u5f53\u4f7f\u7528\u5177\u4f53\u7c7b\u578b\u53c2\u6570\u5316\u6a21\u578b\u65f6\uff0c\u5982\u679c\u7c7b\u578b\u53d8\u91cf\u6709\u4e0a\u754c\uff0cPydantic \u4e0d\u4f1a\u9a8c\u8bc1\u63d0\u4f9b\u7684\u7c7b\u578b \u662f\u5426\u53ef\u5206\u914d\u7ed9\u7c7b\u578b\u53d8\u91cf\u3002</p> <p>\u5728\u6cdb\u578b\u6a21\u578b\u4e0a\u8bbe\u7f6e\u7684\u4efb\u4f55\u914d\u7f6e\u3001\u9a8c\u8bc1\u6216\u5e8f\u5217\u5316\u903b\u8f91 \u4e5f\u5c06\u5e94\u7528\u4e8e\u53c2\u6570\u5316\u7c7b\uff0c\u5c31\u50cf\u4ece\u6a21\u578b\u7c7b\u7ee7\u627f\u65f6\u4e00\u6837\u3002\u4efb\u4f55\u81ea\u5b9a\u4e49\u65b9\u6cd5\u6216\u5c5e\u6027\u4e5f\u5c06\u88ab\u7ee7\u627f\u3002</p> <p>\u6cdb\u578b\u6a21\u578b\u8fd8\u4e0e\u7c7b\u578b\u68c0\u67e5\u5668\u6b63\u786e\u96c6\u6210\uff0c\u56e0\u6b64\u60a8\u5c06\u83b7\u5f97\u6240\u6709\u7c7b\u578b\u68c0\u67e5 \u5c31\u50cf\u60a8\u4e3a\u6bcf\u4e2a\u53c2\u6570\u5316\u58f0\u660e\u4e00\u4e2a\u4e0d\u540c\u7684\u7c7b\u578b\u4e00\u6837\u3002</p> <p>Note</p> <p>\u5728\u5185\u90e8\uff0c\u5f53\u6cdb\u578b\u6a21\u578b\u7c7b\u88ab\u53c2\u6570\u5316\u65f6\uff0cPydantic \u5728\u8fd0\u884c\u65f6\u521b\u5efa\u6cdb\u578b\u6a21\u578b\u7684\u5b50\u7c7b\u3002 \u8fd9\u4e9b\u7c7b\u88ab\u7f13\u5b58\uff0c\u56e0\u6b64\u4f7f\u7528\u6cdb\u578b\u6a21\u578b\u5f15\u5165\u7684\u5f00\u9500\u5e94\u8be5\u662f\u6700\u5c0f\u7684\u3002</p> <p>\u8981\u4ece\u6cdb\u578b\u6a21\u578b\u7ee7\u627f\u5e76\u4fdd\u6301\u5176\u6cdb\u578b\u7279\u6027\uff0c\u5b50\u7c7b\u8fd8\u5fc5\u987b\u7ee7\u627f\u81ea <code>Generic</code>\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\n\n\nclass BaseClass(BaseModel, Generic[TypeX]):\n    X: TypeX\n\n\nclass ChildClass(BaseClass[TypeX], Generic[TypeX]):\n    pass\n\n\n# Parametrize `TypeX` with `int`:\nprint(ChildClass[int](X=1))\n#&gt; X=1\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u6cdb\u578b\u5b50\u7c7b\uff0c\u90e8\u5206\u6216\u5b8c\u5168\u66ff\u6362\u8d85\u7c7b\u4e2d\u7684\u7c7b\u578b\u53d8\u91cf\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(BaseModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ\n\n\n# Parametrize `TypeY` with `str`:\nprint(ChildClass[str, int](x='1', y='y', z='3'))\n#&gt; x=1 y='y' z=3\n</code></pre> <p>\u5982\u679c\u5177\u4f53\u5b50\u7c7b\u7684\u540d\u79f0\u5f88\u91cd\u8981\uff0c\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u91cd\u5199<code>model_parametrized_name()</code>\u65b9\u6cd5\u6765\u8986\u76d6\u9ed8\u8ba4\u7684\u540d\u79f0\u751f\u6210\uff1a</p> <pre><code>from typing import Any, Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nDataT = TypeVar('DataT')\n\n\nclass Response(BaseModel, Generic[DataT]):\n    data: DataT\n\n    @classmethod\n    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -&gt; str:\n        return f'{params[0].__name__.title()}Response'\n\n\nprint(repr(Response[int](data=1)))\n#&gt; IntResponse(data=1)\nprint(repr(Response[str](data='a')))\n#&gt; StrResponse(data='a')\n</code></pre> <p>\u60a8\u53ef\u4ee5\u5728\u5176\u4ed6\u6a21\u578b\u4e2d\u4f7f\u7528\u53c2\u6570\u5316\u6cdb\u578b\u6a21\u578b\u4f5c\u4e3a\u7c7b\u578b\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass ResponseModel(BaseModel, Generic[T]):\n    content: T\n\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\n\nclass Order(BaseModel):\n    id: int\n    product: ResponseModel[Product]\n\n\nproduct = Product(name='Apple', price=0.5)\nresponse = ResponseModel[Product](content=product)\norder = Order(id=1, product=response)\nprint(repr(order))\n\"\"\"\nOrder(id=1, product=ResponseModel[Product](content=Product(name='Apple', price=0.5)))\n\"\"\"\n</code></pre> <p>\u5728\u5d4c\u5957\u6a21\u578b\u4e2d\u4f7f\u7528\u76f8\u540c\u7684\u7c7b\u578b\u53d8\u91cf\u5141\u8bb8\u60a8\u5728\u6a21\u578b\u7684\u4e0d\u540c\u70b9\u5f3a\u5236\u6267\u884c\u7c7b\u578b\u5173\u7cfb\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\n\n\nclass InnerT(BaseModel, Generic[T]):\n    inner: T\n\n\nclass OuterT(BaseModel, Generic[T]):\n    outer: T\n    nested: InnerT[T]\n\n\nnested = InnerT[int](inner=1)\nprint(OuterT[int](outer=1, nested=nested))\n#&gt; outer=1 nested=InnerT[int](inner=1)\ntry:\n    print(OuterT[int](outer='a', nested=InnerT(inner='a')))  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for OuterT[int]\n    outer\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    nested.inner\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li><code>OuterT</code> \u6a21\u578b\u4f7f\u7528 <code>int</code> \u53c2\u6570\u5316\uff0c\u4f46\u5728\u9a8c\u8bc1\u671f\u95f4\u4e0e <code>T</code> \u6ce8\u89e3\u5173\u8054\u7684\u6570\u636e\u7c7b\u578b\u4e3a <code>str</code>\uff0c\u5bfc\u81f4\u9a8c\u8bc1\u9519\u8bef\u3002</li> </ol> <p>Warning</p> <p>\u867d\u7136\u53ef\u80fd\u4e0d\u4f1a\u5f15\u53d1\u9519\u8bef\uff0c\u4f46\u6211\u4eec\u5f3a\u70c8\u5efa\u8bae\u4e0d\u8981\u5728 <code>isinstance()</code> \u68c0\u67e5\u4e2d\u4f7f\u7528\u53c2\u6570\u5316\u6cdb\u578b\u3002</p> <p>\u4f8b\u5982\uff0c\u60a8\u4e0d\u5e94\u8be5\u6267\u884c <code>isinstance(my_model, MyGenericModel[int])</code>\u3002\u4f46\u662f\uff0c\u6267\u884c <code>isinstance(my_model, MyGenericModel)</code> \u662f\u53ef\u4ee5\u7684\uff08\u8bf7\u6ce8\u610f\uff0c\u5bf9\u4e8e\u6807\u51c6\u6cdb\u578b\uff0c\u4f7f\u7528\u53c2\u6570\u5316\u6cdb\u578b\u7c7b\u8fdb\u884c\u5b50\u7c7b\u68c0\u67e5\u4f1a\u5f15\u53d1\u9519\u8bef\uff09\u3002</p> <p>\u5982\u679c\u60a8\u9700\u8981\u5bf9\u53c2\u6570\u5316\u6cdb\u578b\u6267\u884c <code>isinstance()</code> \u68c0\u67e5\uff0c\u53ef\u4ee5\u901a\u8fc7\u5b50\u7c7b\u5316\u53c2\u6570\u5316\u6cdb\u578b\u7c7b\u6765\u5b9e\u73b0\uff1a</p> <pre><code>class MyIntModel(MyGenericModel[int]): ...\n\nisinstance(my_model, MyIntModel)\n</code></pre> \u5b9e\u73b0\u7ec6\u8282 <p>\u5f53\u4f7f\u7528\u5d4c\u5957\u6cdb\u578b\u6a21\u578b\u65f6\uff0cPydantic\u6709\u65f6\u4f1a\u6267\u884c\u91cd\u65b0\u9a8c\u8bc1\uff0c\u4ee5\u4ea7\u751f\u6700\u76f4\u89c2\u7684\u9a8c\u8bc1\u7ed3\u679c\u3002 \u5177\u4f53\u6765\u8bf4\uff0c\u5982\u679c\u60a8\u6709\u4e00\u4e2a\u7c7b\u578b\u4e3a <code>GenericModel[SomeType]</code> \u7684\u5b57\u6bb5\uff0c\u5e76\u4e14\u60a8\u9488\u5bf9\u6b64\u5b57\u6bb5\u9a8c\u8bc1\u50cf <code>GenericModel[SomeCompatibleType]</code> \u8fd9\u6837\u7684\u6570\u636e\uff0c \u6211\u4eec\u5c06\u68c0\u67e5\u6570\u636e\uff0c\u8bc6\u522b\u8f93\u5165\u6570\u636e\u662f <code>GenericModel</code> \u7684\u4e00\u79cd\"\u677e\u6563\"\u5b50\u7c7b\uff0c\u5e76\u91cd\u65b0\u9a8c\u8bc1\u5305\u542b\u7684 <code>SomeCompatibleType</code> \u6570\u636e\u3002</p> <p>\u8fd9\u4f1a\u589e\u52a0\u4e00\u4e9b\u9a8c\u8bc1\u5f00\u9500\uff0c\u4f46\u5bf9\u4e8e\u5982\u4e0b\u6240\u793a\u7684\u60c5\u51b5\uff0c\u5b83\u4f7f\u4e8b\u60c5\u66f4\u52a0\u76f4\u89c2\u3002</p> <pre><code>from typing import Any, Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nT = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nprint(repr(Model.model_validate(Model(inner=GenericModel[int](a=1)))))\n#&gt; Model(inner=GenericModel[Any](a=1))\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u60a8\u9488\u5bf9 <code>GenericModel[int]</code> \u8fdb\u884c\u9a8c\u8bc1\u5e76\u4f20\u5165\u4e00\u4e2a <code>GenericModel[str](a='not an int')</code> \u5b9e\u4f8b\uff0c\u9a8c\u8bc1\u4ecd\u7136\u4f1a\u5931\u8d25\u3002</p> <p>\u8fd8\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u8fd9\u79cd\u6a21\u5f0f\u4e5f\u4f1a\u91cd\u65b0\u89e6\u53d1\u4efb\u4f55\u81ea\u5b9a\u4e49\u9a8c\u8bc1\uff0c\u6bd4\u5982\u989d\u5916\u7684\u6a21\u578b\u9a8c\u8bc1\u5668\u7b49\u3002 \u9a8c\u8bc1\u5668\u5c06\u5728\u7b2c\u4e00\u6b21\u4f20\u9012\u65f6\u88ab\u8c03\u7528\u4e00\u6b21\uff0c\u76f4\u63a5\u9488\u5bf9 <code>GenericModel[Any]</code> \u8fdb\u884c\u9a8c\u8bc1\u3002\u8be5\u9a8c\u8bc1\u5931\u8d25\uff0c\u56e0\u4e3a <code>GenericModel[int]</code> \u4e0d\u662f <code>GenericModel[Any]</code> \u7684\u5b50\u7c7b\u3002\u8fd9\u4e0e\u4e0a\u9762\u5173\u4e8e\u5728 <code>isinstance()</code> \u548c <code>issubclass()</code> \u68c0\u67e5\u4e2d\u4f7f\u7528\u53c2\u6570\u5316\u6cdb\u578b\u7684\u590d\u6742\u6027\u7684\u8b66\u544a\u6709\u5173\u3002 \u7136\u540e\uff0c\u9a8c\u8bc1\u5668\u5c06\u5728\u7b2c\u4e8c\u6b21\u4f20\u9012\u65f6\u518d\u6b21\u88ab\u8c03\u7528\uff0c\u5728\u66f4\u5bbd\u677e\u7684\u5f3a\u5236\u91cd\u65b0\u9a8c\u8bc1\u9636\u6bb5\uff0c\u8fd9\u4f1a\u6210\u529f\u3002 \u4e3a\u4e86\u66f4\u597d\u5730\u7406\u89e3\u8fd9\u4e2a\u540e\u679c\uff0c\u8bf7\u53c2\u89c1\u4e0b\u9762\uff1a</p> <pre><code>from typing import Any, Generic, Self, TypeVar\n\nfrom pydantic import BaseModel, model_validator\n\nT = TypeVar('T')\n\n\nclass GenericModel(BaseModel, Generic[T]):\n    a: T\n\n    @model_validator(mode='after')\n    def validate_after(self: Self) -&gt; Self:\n        print('after validator running custom validation...')\n        return self\n\n\nclass Model(BaseModel):\n    inner: GenericModel[Any]\n\n\nm = Model.model_validate(Model(inner=GenericModel[int](a=1)))\n#&gt; after validator running custom validation...\n#&gt; after validator running custom validation...\nprint(repr(m))\n#&gt; Model(inner=GenericModel[Any](a=1))\n</code></pre>"},{"location":"concepts/models/#_4","title":"\u672a\u53c2\u6570\u5316\u7c7b\u578b\u53d8\u91cf\u7684\u9a8c\u8bc1","text":"<p>\u5f53\u7c7b\u578b\u53d8\u91cf\u672a\u88ab\u53c2\u6570\u5316\u65f6\uff0cPydantic \u5904\u7406\u6cdb\u578b\u6a21\u578b\u7684\u65b9\u5f0f\u7c7b\u4f3c\u4e8e\u5904\u7406\u5185\u7f6e\u6cdb\u578b\u7c7b\u578b\u5982 <code>list</code> \u548c <code>dict</code>\uff1a</p> <ul> <li>\u5982\u679c\u7c7b\u578b\u53d8\u91cf\u7ed1\u5b9a   \u6216\u7ea6\u675f\u5230\u7279\u5b9a\u7c7b\u578b\uff0c   \u5c06\u4f7f\u7528\u8be5\u7c7b\u578b\u3002</li> <li>\u5982\u679c\u7c7b\u578b\u53d8\u91cf\u6709\u9ed8\u8ba4\u7c7b\u578b\uff08\u6839\u636e PEP 696 \u6307\u5b9a\uff09\uff0c\u5c06\u4f7f\u7528\u8be5\u9ed8\u8ba4\u7c7b\u578b\u3002</li> <li>\u5bf9\u4e8e\u672a\u7ed1\u5b9a\u6216\u672a\u7ea6\u675f\u7684\u7c7b\u578b\u53d8\u91cf\uff0cPydantic \u5c06\u56de\u9000\u5230 <code>Any</code>\u3002</li> </ul> <pre><code>from typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nT = TypeVar('T')\nU = TypeVar('U', bound=int)\nV = TypeVar('V', default=str)\n\n\nclass Model(BaseModel, Generic[T, U, V]):\n    t: T\n    u: U\n    v: V\n\n\nprint(Model(t='t', u=1, v='v'))\n#&gt; t='t' u=1 v='v'\n\ntry:\n    Model(t='t', u='u', v=1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    u\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='u', input_type=str]\n    v\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    \"\"\"\n</code></pre> <p>Warning</p> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u9488\u5bf9\u672a\u53c2\u6570\u5316\u6cdb\u578b\u6a21\u578b\u7684\u9a8c\u8bc1\u53ef\u80fd\u5bfc\u81f4\u6570\u636e\u4e22\u5931\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5982\u679c\u4f7f\u7528\u4e86\u7c7b\u578b\u53d8\u91cf\u4e0a\u754c\u3001\u7ea6\u675f\u6216\u9ed8\u8ba4\u503c\u7684\u5b50\u7c7b\u578b\uff0c\u5e76\u4e14\u6a21\u578b\u6ca1\u6709\u663e\u5f0f\u53c2\u6570\u5316\uff0c\u7ed3\u679c\u7c7b\u578b\u5c06\u4e0d\u662f\u63d0\u4f9b\u7684\u7c7b\u578b\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nItemT = TypeVar('ItemT', bound='ItemBase')\n\n\nclass ItemBase(BaseModel): ...\n\n\nclass IntItem(ItemBase):\n    value: int\n\n\nclass ItemHolder(BaseModel, Generic[ItemT]):\n    item: ItemT\n\n\nloaded_data = {'item': {'value': 1}}\n\n\nprint(ItemHolder(**loaded_data))  # (1)!\n#&gt; item=ItemBase()\n\nprint(ItemHolder[IntItem](**loaded_data))  # (2)!\n#&gt; item=IntItem(value=1)\n</code></pre> <ol> <li>\u5f53\u6cdb\u578b\u672a\u88ab\u53c2\u6570\u5316\u65f6\uff0c\u8f93\u5165\u6570\u636e\u9488\u5bf9 <code>ItemT</code> \u4e0a\u754c\u8fdb\u884c\u9a8c\u8bc1\u3002    \u7531\u4e8e <code>ItemBase</code> \u6ca1\u6709\u5b57\u6bb5\uff0c<code>item</code> \u5b57\u6bb5\u4fe1\u606f\u4e22\u5931\u3002</li> <li>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u7c7b\u578b\u53d8\u91cf\u88ab\u663e\u5f0f\u53c2\u6570\u5316\uff0c\u56e0\u6b64\u8f93\u5165\u6570\u636e\u9488\u5bf9 <code>IntItem</code> \u7c7b\u8fdb\u884c\u9a8c\u8bc1\u3002</li> </ol>"},{"location":"concepts/models/#_5","title":"\u672a\u53c2\u6570\u5316\u7c7b\u578b\u53d8\u91cf\u7684\u5e8f\u5217\u5316","text":"<p>\u5f53\u4f7f\u7528\u5e26\u6709\u4e0a\u754c\u3001\u7ea6\u675f\u6216\u9ed8\u8ba4\u503c\u7684\u7c7b\u578b\u53d8\u91cf\u65f6\uff0c\u5e8f\u5217\u5316\u884c\u4e3a\u4f1a\u6709\u6240\u4e0d\u540c\uff1a</p> <p>\u5982\u679cPydantic\u6a21\u578b\u88ab\u7528\u4f5c\u7c7b\u578b\u53d8\u91cf\u7684\u4e0a\u754c\uff0c\u5e76\u4e14\u8be5\u7c7b\u578b\u53d8\u91cf\u4ece\u672a\u88ab\u53c2\u6570\u5316\uff0c\u90a3\u4e48Pydantic\u5c06\u4f7f\u7528\u4e0a\u754c\u8fdb\u884c\u9a8c\u8bc1\uff0c\u4f46\u5728\u5e8f\u5217\u5316\u65b9\u9762\u5c06\u8be5\u503c\u89c6\u4e3a<code>Any</code>\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', bound=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized as Any\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'var2',\n    },\n}\n\n# serialized using the concrete parametrization\n# note that `'bar': 'var2'` is missing\nerror = Error[ErrorDetails](\n    message='We just had an error',\n    details=ErrorDetails(foo='var'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n</code></pre> <p>\u8fd9\u662f\u4e0a\u8ff0\u884c\u4e3a\u7684\u53e6\u4e00\u4e2a\u793a\u4f8b\uff0c\u679a\u4e3e\u4e86\u5173\u4e8e\u7ed1\u5b9a\u89c4\u8303\u548c\u6cdb\u578b\u7c7b\u578b\u53c2\u6570\u5316\u7684\u6240\u6709\u6392\u5217\uff1a</p> <pre><code>from typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTBound = TypeVar('TBound', bound=BaseModel)\nTNoBound = TypeVar('TNoBound')\n\n\nclass IntValue(BaseModel):\n    value: int\n\n\nclass ItemBound(BaseModel, Generic[TBound]):\n    item: TBound\n\n\nclass ItemNoBound(BaseModel, Generic[TNoBound]):\n    item: TNoBound\n\n\nitem_bound_inferred = ItemBound(item=IntValue(value=3))\nitem_bound_explicit = ItemBound[IntValue](item=IntValue(value=3))\nitem_no_bound_inferred = ItemNoBound(item=IntValue(value=3))\nitem_no_bound_explicit = ItemNoBound[IntValue](item=IntValue(value=3))\n\n# calling `print(x.model_dump())` on any of the above instances results in the following:\n#&gt; {'item': {'value': 3}}\n</code></pre> <p>\u4f46\u662f\uff0c\u5982\u679c\u4f7f\u7528\u4e86\u7ea6\u675f \u6216\u9ed8\u8ba4\u503c\uff08\u6839\u636ePEP 696\uff09\uff0c\u90a3\u4e48\u5982\u679c\u7c7b\u578b\u53d8\u91cf\u672a\u88ab\u53c2\u6570\u5316\uff0c\u5c06\u4f7f\u7528\u9ed8\u8ba4\u7c7b\u578b\u6216\u7ea6\u675f \u8fdb\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u3002\u60a8\u53ef\u4ee5\u4f7f\u7528<code>SerializeAsAny</code>\u6765\u8986\u76d6\u6b64\u884c\u4e3a\uff1a</p> Python 3.9 and abovePython 3.13 and above <pre><code>from typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', default=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized using the default's serializer\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n# If `ErrorDataT` was using an upper bound, `bar` would be present in `details`.\n\n\nclass SerializeAsAnyError(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: SerializeAsAny[ErrorDataT]\n\n\n# serialized as Any\nerror = SerializeAsAnyError(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='baz'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'baz',\n    },\n}\n</code></pre> <pre><code>from typing import Generic\n\nfrom typing import TypeVar\n\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', default=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized using the default's serializer\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n# If `ErrorDataT` was using an upper bound, `bar` would be present in `details`.\n\n\nclass SerializeAsAnyError(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: SerializeAsAny[ErrorDataT]\n\n\n# serialized as Any\nerror = SerializeAsAnyError(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='baz'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'baz',\n    },\n}\n</code></pre>"},{"location":"concepts/models/#dynamic-model-creation","title":"\u52a8\u6001\u6a21\u578b\u521b\u5efa","text":"API \u6587\u6863 <p><code>pydantic.main.create_model</code></p> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u9700\u8981\u4f7f\u7528\u8fd0\u884c\u65f6\u4fe1\u606f\u6765\u6307\u5b9a\u5b57\u6bb5\u521b\u5efa\u6a21\u578b\u3002 Pydantic\u63d0\u4f9b\u4e86<code>create_model()</code>\u51fd\u6570\u6765\u5141\u8bb8\u52a8\u6001\u521b\u5efa\u6a21\u578b\uff1a</p> <pre><code>from pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=str, bar=(int, 123))\n\n# Equivalent to:\n\n\nclass StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n</code></pre> <p>\u5b57\u6bb5\u5b9a\u4e49\u88ab\u6307\u5b9a\u4e3a\u5173\u952e\u5b57\u53c2\u6570\uff0c\u5e94\u8be5\u662f\u4ee5\u4e0b\u4e4b\u4e00\uff1a</p> <ul> <li>\u5355\u4e2a\u5143\u7d20\uff0c\u8868\u793a\u5b57\u6bb5\u7684\u7c7b\u578b\u6ce8\u89e3\u3002</li> <li>\u4e00\u4e2a\u4e8c\u5143\u7ec4\uff0c\u7b2c\u4e00\u4e2a\u5143\u7d20\u662f\u7c7b\u578b\uff0c\u7b2c\u4e8c\u4e2a\u5143\u7d20\u662f\u5206\u914d\u7684\u503c   \uff08\u53ef\u4ee5\u662f\u9ed8\u8ba4\u503c\u6216<code>Field()</code>\u51fd\u6570\uff09\u3002</li> </ul> <p>\u8fd9\u662f\u4e00\u4e2a\u66f4\u9ad8\u7ea7\u7684\u793a\u4f8b\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field, PrivateAttr, create_model\n\nDynamicModel = create_model(\n    'DynamicModel',\n    foo=(str, Field(alias='FOO')),\n    bar=Annotated[str, Field(description='Bar field')],\n    _private=(int, PrivateAttr(default=1)),\n)\n\n\nclass StaticModel(BaseModel):\n    foo: str = Field(alias='FOO')\n    bar: Annotated[str, Field(description='Bar field')]\n    _private: int = PrivateAttr(default=1)\n</code></pre> <p>\u7279\u6b8a\u7684\u5173\u952e\u5b57\u53c2\u6570<code>__config__</code>\u548c<code>__base__</code>\u53ef\u7528\u4e8e\u81ea\u5b9a\u4e49\u65b0\u6a21\u578b\u3002 \u8fd9\u5305\u62ec\u4f7f\u7528\u989d\u5916\u5b57\u6bb5\u6269\u5c55\u57fa\u7840\u6a21\u578b\u3002</p> <pre><code>from pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple=(str, 'russet'),\n    banana=(str, 'yellow'),\n    __base__=FooModel,\n)\nprint(BarModel)\n#&gt; &lt;class '__main__.BarModel'&gt;\nprint(BarModel.model_fields.keys())\n#&gt; dict_keys(['foo', 'bar', 'apple', 'banana'])\n</code></pre> <p>\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5411<code>__validators__</code>\u53c2\u6570\u4f20\u9012\u5b57\u5178\u6765\u6dfb\u52a0\u9a8c\u8bc1\u5668\u3002</p> <pre><code>from pydantic import ValidationError, create_model, field_validator\n\n\ndef alphanum(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator': field_validator('username')(alphanum)  # (1)!\n}\n\nUserModel = create_model(\n    'UserModel', username=(str, ...), __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n#&gt; username='scolvin'\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    username\n      Assertion failed, must be alphanumeric [type=assertion_error, input_value='scolvi%n', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u786e\u4fdd\u9a8c\u8bc1\u5668\u540d\u79f0\u4e0d\u4e0e\u4efb\u4f55\u5b57\u6bb5\u540d\u79f0\u51b2\u7a81\uff0c\u56e0\u4e3a    \u5728\u5185\u90e8\uff0cPydantic\u5c06\u6240\u6709\u6210\u5458\u6536\u96c6\u5230\u4e00\u4e2a\u547d\u540d\u7a7a\u95f4\u4e2d\uff0c\u5e76\u6a21\u62df\u4f7f\u7528    <code>types</code>\u6a21\u5757\u5de5\u5177\u6b63\u5e38\u521b\u5efa\u7c7b\u7684\u8fc7\u7a0b\u3002</li> </ol> <p>\u6ce8\u610f</p> <p>\u8981pickle\u4e00\u4e2a\u52a8\u6001\u521b\u5efa\u7684\u6a21\u578b\uff1a</p> <ul> <li>\u6a21\u578b\u5fc5\u987b\u5728\u5168\u5c40\u8303\u56f4\u5185\u5b9a\u4e49</li> <li>\u5fc5\u987b\u63d0\u4f9b<code>__module__</code>\u53c2\u6570</li> </ul>"},{"location":"concepts/models/#rootmodel-and-custom-root-types","title":"<code>RootModel</code> \u548c\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b","text":"API \u6587\u6863 <p><code>pydantic.root_model.RootModel</code></p> <p>Pydantic\u6a21\u578b\u53ef\u4ee5\u901a\u8fc7\u5b50\u7c7b\u5316<code>pydantic.RootModel</code>\u6765\u5b9a\u4e49\"\u81ea\u5b9a\u4e49\u6839\u7c7b\u578b\"\u3002</p> <p>\u6839\u7c7b\u578b\u53ef\u4ee5\u662fPydantic\u652f\u6301\u7684\u4efb\u4f55\u7c7b\u578b\uff0c\u5e76\u901a\u8fc7<code>RootModel</code>\u7684\u6cdb\u578b\u53c2\u6570\u6307\u5b9a\u3002 \u6839\u503c\u53ef\u4ee5\u901a\u8fc7\u7b2c\u4e00\u4e2a\u4e5f\u662f\u552f\u4e00\u7684\u53c2\u6570\u4f20\u9012\u7ed9\u6a21\u578b\u7684<code>__init__</code>\u6216<code>model_validate</code>\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\uff0c\u8bf4\u660e\u8fd9\u662f\u5982\u4f55\u5de5\u4f5c\u7684\uff1a</p> <pre><code>from pydantic import RootModel\n\nPets = RootModel[list[str]]\nPetsByName = RootModel[dict[str, str]]\n\n\nprint(Pets(['dog', 'cat']))\n#&gt; root=['dog', 'cat']\nprint(Pets(['dog', 'cat']).model_dump_json())\n#&gt; [\"dog\",\"cat\"]\nprint(Pets.model_validate(['dog', 'cat']))\n#&gt; root=['dog', 'cat']\nprint(Pets.model_json_schema())\n\"\"\"\n{'items': {'type': 'string'}, 'title': 'RootModel[list[str]]', 'type': 'array'}\n\"\"\"\n\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}))\n#&gt; root={'Otis': 'dog', 'Milo': 'cat'}\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}).model_dump_json())\n#&gt; {\"Otis\":\"dog\",\"Milo\":\"cat\"}\nprint(PetsByName.model_validate({'Otis': 'dog', 'Milo': 'cat'}))\n#&gt; root={'Otis': 'dog', 'Milo': 'cat'}\n</code></pre> <p>\u5982\u679c\u60a8\u60f3\u76f4\u63a5\u8bbf\u95ee<code>root</code>\u5b57\u6bb5\u4e2d\u7684\u9879\u76ee\u6216\u8fed\u4ee3\u8fd9\u4e9b\u9879\u76ee\uff0c\u60a8\u53ef\u4ee5\u5b9e\u73b0 \u81ea\u5b9a\u4e49\u7684<code>__iter__</code>\u548c<code>__getitem__</code>\u51fd\u6570\uff0c\u5982\u4e0b\u4f8b\u6240\u793a\u3002</p> <pre><code>from pydantic import RootModel\n\n\nclass Pets(RootModel):\n    root: list[str]\n\n    def __iter__(self):\n        return iter(self.root)\n\n    def __getitem__(self, item):\n        return self.root[item]\n\n\npets = Pets.model_validate(['dog', 'cat'])\nprint(pets[0])\n#&gt; dog\nprint([pet for pet in pets])\n#&gt; ['dog', 'cat']\n</code></pre> <p>\u60a8\u4e5f\u53ef\u4ee5\u76f4\u63a5\u521b\u5efa\u53c2\u6570\u5316\u6839\u6a21\u578b\u7684\u5b50\u7c7b\uff1a</p> <pre><code>from pydantic import RootModel\n\n\nclass Pets(RootModel[list[str]]):\n    def describe(self) -&gt; str:\n        return f'Pets: {\", \".join(self.root)}'\n\n\nmy_pets = Pets.model_validate(['dog', 'cat'])\n\nprint(my_pets.describe())\n#&gt; Pets: dog, cat\n</code></pre>"},{"location":"concepts/models/#faux-immutability","title":"\u4f2a\u4e0d\u53ef\u53d8\u6027","text":"<p>\u53ef\u4ee5\u901a\u8fc7<code>model_config['frozen'] = True</code>\u5c06\u6a21\u578b\u914d\u7f6e\u4e3a\u4e0d\u53ef\u53d8\u3002\u8bbe\u7f6e\u6b64\u9009\u9879\u540e\uff0c\u5c1d\u8bd5\u66f4\u6539 \u5b9e\u4f8b\u5c5e\u6027\u7684\u503c\u5c06\u5f15\u53d1\u9519\u8bef\u3002\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605API\u53c2\u8003\u3002</p> <p>\u6ce8\u610f</p> <p>\u5728Pydantic V1\u4e2d\uff0c\u6b64\u884c\u4e3a\u901a\u8fc7\u914d\u7f6e\u8bbe\u7f6e<code>allow_mutation = False</code>\u5b9e\u73b0\u3002 \u6b64\u914d\u7f6e\u6807\u5fd7\u5728Pydantic V2\u4e2d\u5df2\u5f03\u7528\uff0c\u5e76\u5df2\u88ab<code>frozen</code>\u66ff\u6362\u3002</p> <p>\u8b66\u544a</p> <p>\u5728Python\u4e2d\uff0c\u4e0d\u53ef\u53d8\u6027\u4e0d\u662f\u5f3a\u5236\u6267\u884c\u7684\u3002\u5f00\u53d1\u4eba\u5458\u6709\u80fd\u529b\u4fee\u6539 \u901a\u5e38\u88ab\u8ba4\u4e3a\u662f\"\u4e0d\u53ef\u53d8\"\u7684\u5bf9\u8c61\uff0c\u5982\u679c\u4ed6\u4eec\u9009\u62e9\u8fd9\u6837\u505a\u7684\u8bdd\u3002</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass FooBarModel(BaseModel):\n    model_config = ConfigDict(frozen=True)\n\n    a: str\n    b: dict\n\n\nfoobar = FooBarModel(a='hello', b={'apple': 'pear'})\n\ntry:\n    foobar.a = 'different'\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for FooBarModel\n    a\n      Instance is frozen [type=frozen_instance, input_value='different', input_type=str]\n    \"\"\"\n\nprint(foobar.a)\n#&gt; hello\nprint(foobar.b)\n#&gt; {'apple': 'pear'}\nfoobar.b['apple'] = 'grape'\nprint(foobar.b)\n#&gt; {'apple': 'grape'}\n</code></pre> <p>\u5c1d\u8bd5\u66f4\u6539<code>a</code>\u5bfc\u81f4\u9519\u8bef\uff0c<code>a</code>\u4fdd\u6301\u4e0d\u53d8\u3002\u7136\u800c\uff0c\u5b57\u5178<code>b</code>\u662f\u53ef\u53d8\u7684\uff0c<code>foobar</code>\u7684 \u4e0d\u53ef\u53d8\u6027\u4e0d\u4f1a\u963b\u6b62<code>b</code>\u88ab\u66f4\u6539\u3002</p>"},{"location":"concepts/models/#_6","title":"\u62bd\u8c61\u57fa\u7c7b","text":"<p>Pydantic\u6a21\u578b\u53ef\u4ee5\u4e0ePython\u7684 \u62bd\u8c61\u57fa\u7c7b (ABCs)\u4e00\u8d77\u4f7f\u7528\u3002</p> <pre><code>import abc\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n</code></pre>"},{"location":"concepts/models/#field-ordering","title":"\u5b57\u6bb5\u6392\u5e8f","text":"<p>\u5b57\u6bb5\u987a\u5e8f\u5728\u4ee5\u4e0b\u65b9\u9762\u5f71\u54cd\u6a21\u578b\uff1a</p> <ul> <li>\u5b57\u6bb5\u987a\u5e8f\u5728\u6a21\u578b\u7684JSON Schema\u4e2d\u4fdd\u6301\u4e0d\u53d8</li> <li>\u5b57\u6bb5\u987a\u5e8f\u5728\u9a8c\u8bc1\u9519\u8bef\u4e2d\u4fdd\u6301\u4e0d\u53d8</li> <li>\u5b57\u6bb5\u987a\u5e8f\u5728\u5e8f\u5217\u5316\u6570\u636e\u65f6\u4fdd\u6301\u4e0d\u53d8</li> </ul> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = 2\n    c: int = 1\n    d: int = 0\n    e: float\n\n\nprint(Model.model_fields.keys())\n#&gt; dict_keys(['a', 'b', 'c', 'd', 'e'])\nm = Model(e=2, a=1)\nprint(m.model_dump())\n#&gt; {'a': 1, 'b': 2, 'c': 1, 'd': 0, 'e': 2.0}\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as err:\n    error_locations = [e['loc'] for e in err.errors()]\n\nprint(error_locations)\n#&gt; [('a',), ('b',), ('c',), ('d',), ('e',)]\n</code></pre>"},{"location":"concepts/models/#_7","title":"\u81ea\u52a8\u6392\u9664\u7684\u5c5e\u6027","text":""},{"location":"concepts/models/#_8","title":"\u7c7b\u53d8\u91cf","text":"<p>\u7528<code>ClassVar</code>\u6ce8\u89e3\u7684\u5c5e\u6027\u88abPydantic\u6b63\u786e\u89c6\u4e3a\u7c7b\u53d8\u91cf\uff0c\u5e76\u4e14\u4e0d\u4f1a \u6210\u4e3a\u6a21\u578b\u5b9e\u4f8b\u7684\u5b57\u6bb5\uff1a</p> <pre><code>from typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: ClassVar[int] = 1\n\n    y: int = 2\n\n\nm = Model()\nprint(m)\n#&gt; y=2\nprint(Model.x)\n#&gt; 1\n</code></pre>"},{"location":"concepts/models/#_9","title":"\u79c1\u6709\u6a21\u578b\u5c5e\u6027","text":"API \u6587\u6863 <p><code>pydantic.fields.PrivateAttr</code></p> <p>\u540d\u79f0\u5e26\u6709\u524d\u5bfc\u4e0b\u5212\u7ebf\u7684\u5c5e\u6027\u4e0d\u88abPydantic\u89c6\u4e3a\u5b57\u6bb5\uff0c\u5e76\u4e14\u4e0d\u5305\u542b\u5728 \u6a21\u578b\u6a21\u5f0f\u4e2d\u3002\u76f8\u53cd\uff0c\u8fd9\u4e9b\u5c5e\u6027\u88ab\u8f6c\u6362\u4e3a\"\u79c1\u6709\u5c5e\u6027\"\uff0c\u5728\u8c03\u7528 <code>__init__</code>\u3001<code>model_validate</code>\u7b49\u671f\u95f4\u4e0d\u4f1a\u88ab\u9a8c\u8bc1\u751a\u81f3\u8bbe\u7f6e\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code>from datetime import datetime\nfrom random import randint\nfrom typing import Any\n\nfrom pydantic import BaseModel, PrivateAttr\n\n\nclass TimeAwareModel(BaseModel):\n    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)\n    _secret_value: str\n\n    def model_post_init(self, context: Any) -&gt; None:\n        # this could also be done with `default_factory`:\n        self._secret_value = randint(1, 5)\n\n\nm = TimeAwareModel()\nprint(m._processed_at)\n#&gt; 2032-01-02 03:04:05.000006\nprint(m._secret_value)\n#&gt; 3\n</code></pre> <p>\u79c1\u6709\u5c5e\u6027\u540d\u79f0\u5fc5\u987b\u4ee5\u4e0b\u5212\u7ebf\u5f00\u5934\uff0c\u4ee5\u9632\u6b62\u4e0e\u6a21\u578b\u5b57\u6bb5\u51b2\u7a81\u3002\u4f46\u662f\uff0c\u53cc\u4e0b\u5212\u7ebf\u540d\u79f0 \uff08\u5982<code>__attr__</code>\uff09\u4e0d\u53d7\u652f\u6301\uff0c\u5e76\u4e14\u4f1a\u4ece\u6a21\u578b\u5b9a\u4e49\u4e2d\u5b8c\u5168\u5ffd\u7565\u3002</p>"},{"location":"concepts/models/#_10","title":"\u6a21\u578b\u7b7e\u540d","text":"<p>\u6240\u6709Pydantic\u6a21\u578b\u90fd\u5c06\u57fa\u4e8e\u5176\u5b57\u6bb5\u751f\u6210\u7b7e\u540d\uff1a</p> <pre><code>import inspect\n\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(alias='pear')\n\n\nprint(inspect.signature(FooModel))\n#&gt; (*, id: int, name: str = None, description: str = 'Foo', pear: int) -&gt; None\n</code></pre> <p>\u51c6\u786e\u7684\u7b7e\u540d\u5bf9\u4e8e\u5185\u7701\u76ee\u7684\u548c\u50cf<code>FastAPI</code>\u6216<code>hypothesis</code>\u8fd9\u6837\u7684\u5e93\u5f88\u6709\u7528\u3002</p> <p>\u751f\u6210\u7684\u7b7e\u540d\u4e5f\u4f1a\u5c0a\u91cd\u81ea\u5b9a\u4e49\u7684<code>__init__</code>\u51fd\u6570\uff1a</p> <pre><code>import inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -&gt; None:\n        \"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n#&gt; (id: int = 1, *, bar: str, info: str = 'Foo') -&gt; None\n</code></pre> <p>\u8981\u5305\u542b\u5728\u7b7e\u540d\u4e2d\uff0c\u5b57\u6bb5\u7684\u522b\u540d\u6216\u540d\u79f0\u5fc5\u987b\u662f\u6709\u6548\u7684Python\u6807\u8bc6\u7b26\u3002 Pydantic\u5728\u751f\u6210\u7b7e\u540d\u65f6\u4f1a\u4f18\u5148\u4f7f\u7528\u5b57\u6bb5\u7684\u522b\u540d\u800c\u4e0d\u662f\u5176\u540d\u79f0\uff0c\u4f46\u5982\u679c\u522b\u540d \u4e0d\u662f\u6709\u6548\u7684Python\u6807\u8bc6\u7b26\uff0c\u5219\u53ef\u80fd\u4f7f\u7528\u5b57\u6bb5\u540d\u79f0\u3002</p> <p>\u5982\u679c\u5b57\u6bb5\u7684\u522b\u540d\u548c\u540d\u79f0\u90fd\u4e0d\u662f\u6709\u6548\u7684\u6807\u8bc6\u7b26\uff08\u8fd9\u53ef\u80fd\u662f\u901a\u8fc7<code>create_model</code>\u7684\u5f02\u4e4e\u5bfb\u5e38\u4f7f\u7528\u5b9e\u73b0\u7684\uff09\uff0c \u5219\u4f1a\u6dfb\u52a0\u4e00\u4e2a<code>**data</code>\u53c2\u6570\u3002\u6b64\u5916\uff0c\u5982\u679c<code>model_config['extra'] == 'allow'</code>\uff0c <code>**data</code>\u53c2\u6570\u5c06\u59cb\u7ec8\u51fa\u73b0\u5728\u7b7e\u540d\u4e2d\u3002</p>"},{"location":"concepts/models/#_11","title":"\u7ed3\u6784\u5316\u6a21\u5f0f\u5339\u914d","text":"<p>Pydantic\u652f\u6301\u6a21\u578b\u7684\u7ed3\u6784\u5316\u6a21\u5f0f\u5339\u914d\uff0c\u8fd9\u662fPython 3.10\u4e2d\u7531PEP 636\u5f15\u5165\u7684\u3002</p> <pre><code>from pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n#&gt; Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n</code></pre> <p>\u6ce8\u610f</p> <p>match-case\u8bed\u53e5\u53ef\u80fd\u770b\u8d77\u6765\u50cf\u662f\u521b\u5efa\u4e86\u4e00\u4e2a\u65b0\u6a21\u578b\uff0c\u4f46\u4e0d\u8981\u88ab\u8bef\u5bfc\uff1b \u5b83\u53ea\u662f\u83b7\u53d6\u5c5e\u6027\u5e76\u6bd4\u8f83\u5b83\u6216\u58f0\u660e\u548c\u521d\u59cb\u5316\u5b83\u7684\u8bed\u6cd5\u7cd6\u3002</p>"},{"location":"concepts/models/#attribute-copies","title":"\u5c5e\u6027\u590d\u5236","text":"<p>\u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u4f20\u9012\u7ed9\u6784\u9020\u51fd\u6570\u7684\u53c2\u6570\u5c06\u88ab\u590d\u5236\u4ee5\u6267\u884c\u9a8c\u8bc1\uff0c\u5e76\u5728\u5fc5\u8981\u65f6\u8fdb\u884c\u5f3a\u5236\u7c7b\u578b\u8f6c\u6362\u3002</p> <p>\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0c\u8bf7\u6ce8\u610f\u5217\u8868\u7684ID\u5728\u7c7b\u6784\u9020\u540e\u53d1\u751f\u4e86\u53d8\u5316\uff0c\u56e0\u4e3a\u5b83\u5728\u9a8c\u8bc1\u8fc7\u7a0b\u4e2d\u88ab\u590d\u5236\u4e86\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass C1:\n    arr = []\n\n    def __init__(self, in_arr):\n        self.arr = in_arr\n\n\nclass C2(BaseModel):\n    arr: list[int]\n\n\narr_orig = [1, 9, 10, 3]\n\n\nc1 = C1(arr_orig)\nc2 = C2(arr=arr_orig)\nprint(f'{id(c1.arr) == id(c2.arr)=}')\n#&gt; id(c1.arr) == id(c2.arr)=False\n</code></pre> <p>\u6ce8\u610f</p> <p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0cPydantic\u4e0d\u4f1a\u590d\u5236\u5c5e\u6027\uff0c\u4f8b\u5982\u4f20\u9012\u6a21\u578b\u65f6\u2014\u2014\u6211\u4eec\u6309\u539f\u6837\u4f7f\u7528 \u6a21\u578b\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e <code>model_config['revalidate_instances'] = 'always'</code>\u6765\u8986\u76d6\u6b64\u884c\u4e3a\u3002</p>"},{"location":"concepts/performance/","title":"\u6027\u80fd\u63d0\u793a","text":"<p>\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0cPydantic \u4e0d\u4f1a\u6210\u4e3a\u4f60\u7684\u6027\u80fd\u74f6\u9888\uff0c\u53ea\u6709\u5728\u786e\u5b9a\u6709\u5fc5\u8981\u65f6\u624d\u9075\u5faa\u8fd9\u4e9b\u5efa\u8bae\u3002</p>"},{"location":"concepts/performance/#model_validate_json-model_validatejsonloads","title":"\u4e00\u822c\u60c5\u51b5\u4e0b\uff0c\u4f7f\u7528 <code>model_validate_json()</code> \u800c\u4e0d\u662f <code>model_validate(json.loads(...))</code>","text":"<p>\u5728 <code>model_validate(json.loads(...))</code> \u4e2d\uff0cJSON \u9996\u5148\u5728 Python \u4e2d\u88ab\u89e3\u6790\uff0c\u7136\u540e\u8f6c\u6362\u4e3a\u5b57\u5178\uff0c\u6700\u540e\u5728\u5185\u90e8\u8fdb\u884c\u9a8c\u8bc1\u3002 \u53e6\u4e00\u65b9\u9762\uff0c<code>model_validate_json()</code> \u5df2\u7ecf\u5728\u5185\u90e8\u6267\u884c\u4e86\u9a8c\u8bc1\u3002</p> <p>\u6709\u5c11\u6570\u60c5\u51b5\u4e0b <code>model_validate(json.loads(...))</code> \u53ef\u80fd\u66f4\u5feb\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5f53\u5728\u6a21\u578b\u4e0a\u4f7f\u7528 <code>'before'</code> \u6216 <code>'wrap'</code> \u9a8c\u8bc1\u5668\u65f6\uff0c \u4e24\u6b65\u9a8c\u8bc1\u65b9\u6cd5\u53ef\u80fd\u66f4\u5feb\u3002\u4f60\u53ef\u4ee5\u5728\u8fd9\u4e2a\u8ba8\u8bba\u4e2d\u4e86\u89e3\u66f4\u591a\u5173\u4e8e\u8fd9\u4e9b\u7279\u6b8a\u60c5\u51b5\u7684\u4fe1\u606f\u3002</p> <p>\u76ee\u524d <code>pydantic-core</code> \u6b63\u5728\u8fdb\u884c\u8bb8\u591a\u6027\u80fd\u6539\u8fdb\uff0c\u8bf7\u53c2\u9605 \u8fd9\u4e2a\u8ba8\u8bba\u3002 \u4e00\u65e6\u8fd9\u4e9b\u66f4\u6539\u5408\u5e76\uff0c\u6211\u4eec\u5e94\u8be5\u8fbe\u5230 <code>model_validate_json()</code> \u603b\u662f\u6bd4 <code>model_validate(json.loads(...))</code> \u66f4\u5feb\u7684\u7a0b\u5ea6\u3002</p>"},{"location":"concepts/performance/#typeadapter","title":"<code>TypeAdapter</code> \u53ea\u5b9e\u4f8b\u5316\u4e00\u6b21","text":"<p>\u8fd9\u91cc\u7684\u60f3\u6cd5\u662f\u907f\u514d\u4e0d\u5fc5\u8981\u5730\u591a\u6b21\u6784\u9020\u9a8c\u8bc1\u5668\u548c\u5e8f\u5217\u5316\u5668\u3002\u6bcf\u6b21\u5b9e\u4f8b\u5316 <code>TypeAdapter</code> \u65f6\uff0c \u5b83\u90fd\u4f1a\u6784\u9020\u4e00\u4e2a\u65b0\u7684\u9a8c\u8bc1\u5668\u548c\u5e8f\u5217\u5316\u5668\u3002\u5982\u679c\u4f60\u5728\u51fd\u6570\u4e2d\u4f7f\u7528 <code>TypeAdapter</code>\uff0c\u5b83\u4f1a\u5728\u6bcf\u6b21 \u51fd\u6570\u8c03\u7528\u65f6\u88ab\u5b9e\u4f8b\u5316\u3002\u76f8\u53cd\uff0c\u5e94\u8be5\u53ea\u5b9e\u4f8b\u5316\u4e00\u6b21\uff0c\u7136\u540e\u91cd\u590d\u4f7f\u7528\u5b83\u3002</p>  \u9519\u8bef\u505a\u6cd5 \u6b63\u786e\u505a\u6cd5 <pre><code>from pydantic import TypeAdapter\n\n\ndef my_func():\n    adapter = TypeAdapter(list[int])\n    # \u4f7f\u7528 adapter \u505a\u4e00\u4e9b\u4e8b\u60c5\n</code></pre> <pre><code>from pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\n\ndef my_func():\n    ...\n    # \u4f7f\u7528 adapter \u505a\u4e00\u4e9b\u4e8b\u60c5\n</code></pre>"},{"location":"concepts/performance/#sequence-vs-list-or-tuple-with-mapping-vs-dict","title":"<code>Sequence</code> vs <code>list</code> \u6216 <code>tuple</code> \u4ee5\u53ca <code>Mapping</code> vs <code>dict</code>","text":"<p>\u5f53\u4f7f\u7528 <code>Sequence</code> \u65f6\uff0cPydantic \u4f1a\u8c03\u7528 <code>isinstance(value, Sequence)</code> \u6765\u68c0\u67e5\u8be5\u503c\u662f\u5426\u662f\u4e00\u4e2a\u5e8f\u5217\u3002 \u6b64\u5916\uff0cPydantic \u4f1a\u5c1d\u8bd5\u9488\u5bf9\u4e0d\u540c\u7c7b\u578b\u7684\u5e8f\u5217\u8fdb\u884c\u9a8c\u8bc1\uff0c\u6bd4\u5982 <code>list</code> \u548c <code>tuple</code>\u3002 \u5982\u679c\u4f60\u77e5\u9053\u8be5\u503c\u662f <code>list</code> \u6216 <code>tuple</code>\uff0c\u8bf7\u4f7f\u7528 <code>list</code> \u6216 <code>tuple</code> \u800c\u4e0d\u662f <code>Sequence</code>\u3002</p> <p>\u540c\u6837\u7684\u89c4\u5219\u9002\u7528\u4e8e <code>Mapping</code> \u548c <code>dict</code>\u3002 \u5982\u679c\u4f60\u77e5\u9053\u8be5\u503c\u662f <code>dict</code>\uff0c\u8bf7\u4f7f\u7528 <code>dict</code> \u800c\u4e0d\u662f <code>Mapping</code>\u3002</p>"},{"location":"concepts/performance/#any","title":"\u4e0d\u9700\u8981\u9a8c\u8bc1\u65f6\u4e0d\u8981\u9a8c\u8bc1\uff0c\u4f7f\u7528 <code>Any</code> \u4fdd\u6301\u503c\u4e0d\u53d8","text":"<p>\u5982\u679c\u4f60\u4e0d\u9700\u8981\u9a8c\u8bc1\u67d0\u4e2a\u503c\uff0c\u8bf7\u4f7f\u7528 <code>Any</code> \u6765\u4fdd\u6301\u8be5\u503c\u4e0d\u53d8\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Any\n\n\nmodel = Model(a=1)\n</code></pre>"},{"location":"concepts/performance/#_2","title":"\u907f\u514d\u901a\u8fc7\u57fa\u672c\u7c7b\u578b\u7684\u5b50\u7c7b\u6dfb\u52a0\u989d\u5916\u4fe1\u606f","text":"\u4e0d\u8981\u8fd9\u6837\u505a\u5e94\u8be5\u8fd9\u6837\u505a <pre><code>class CompletedStr(str):\n    def __init__(self, s: str):\n        self.s = s\n        self.done = False\n</code></pre> <pre><code>from pydantic import BaseModel\n\n\nclass CompletedModel(BaseModel):\n    s: str\n    done: bool = False\n</code></pre>"},{"location":"concepts/performance/#tagged-union","title":"\u4f7f\u7528\u6807\u8bb0\u8054\u5408\uff08tagged union\uff09\uff0c\u800c\u4e0d\u662f\u666e\u901a\u8054\u5408","text":"<p>\u6807\u8bb0\u8054\u5408\uff08\u6216\u79f0\u4e3a\u53ef\u533a\u5206\u8054\u5408\uff09\u662f\u4e00\u79cd\u5e26\u6709\u6307\u793a\u5176\u7c7b\u578b\u7684\u5b57\u6bb5\u7684\u8054\u5408\u7c7b\u578b\u3002</p> <pre><code>from typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass DivModel(BaseModel):\n    el_type: Literal['div'] = 'div'\n    class_name: str | None = None\n    children: list[Any] | None = None\n\n\nclass SpanModel(BaseModel):\n    el_type: Literal['span'] = 'span'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass ButtonModel(BaseModel):\n    el_type: Literal['button'] = 'button'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass InputModel(BaseModel):\n    el_type: Literal['input'] = 'input'\n    class_name: str | None = None\n    value: str | None = None\n\n\nclass Html(BaseModel):\n    contents: DivModel | SpanModel | ButtonModel | InputModel = Field(\n        discriminator='el_type'\n    )\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u53ef\u533a\u5206\u8054\u5408\u3002</p>"},{"location":"concepts/performance/#typeddict","title":"\u4f7f\u7528 <code>TypedDict</code> \u800c\u4e0d\u662f\u5d4c\u5957\u6a21\u578b","text":"<p>\u4e0d\u8981\u4f7f\u7528\u5d4c\u5957\u6a21\u578b\uff0c\u800c\u662f\u4f7f\u7528 <code>TypedDict</code> \u6765\u5b9a\u4e49\u6570\u636e\u7684\u7ed3\u6784\u3002</p> \u6027\u80fd\u6bd4\u8f83 <p>\u901a\u8fc7\u7b80\u5355\u7684\u57fa\u51c6\u6d4b\u8bd5\uff0c<code>TypedDict</code> \u6bd4\u5d4c\u5957\u6a21\u578b\u5feb\u7ea6 2.5 \u500d\uff1a</p> <pre><code>from timeit import timeit\n\nfrom typing_extensions import TypedDict\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass A(TypedDict):\n    a: str\n    b: int\n\n\nclass TypedModel(TypedDict):\n    a: A\n\n\nclass B(BaseModel):\n    a: str\n    b: int\n\n\nclass Model(BaseModel):\n    b: B\n\n\nta = TypeAdapter(TypedModel)\nresult1 = timeit(\n    lambda: ta.validate_python({'a': {'a': 'a', 'b': 2}}), number=10000\n)\nresult2 = timeit(\n    lambda: Model.model_validate({'b': {'a': 'a', 'b': 2}}), number=10000\n)\nprint(result2 / result1)\n</code></pre>"},{"location":"concepts/performance/#_3","title":"\u5982\u679c\u771f\u6b63\u5173\u5fc3\u6027\u80fd\uff0c\u8bf7\u907f\u514d\u4f7f\u7528\u5305\u88c5\u9a8c\u8bc1\u5668","text":"<p>\u5305\u88c5\u9a8c\u8bc1\u5668\u901a\u5e38\u6bd4\u5176\u4ed6\u9a8c\u8bc1\u5668\u6162\u3002\u8fd9\u662f\u56e0\u4e3a\u5b83\u4eec\u5728\u9a8c\u8bc1\u8fc7\u7a0b\u4e2d\u9700\u8981\u5c06\u6570\u636e\u5177\u4f53\u5316\u5230 Python \u4e2d\u3002 \u5305\u88c5\u9a8c\u8bc1\u5668\u5bf9\u4e8e\u590d\u6742\u7684\u9a8c\u8bc1\u903b\u8f91\u975e\u5e38\u6709\u7528\uff0c\u4f46\u5982\u679c\u4f60\u8ffd\u6c42\u6700\u4f73\u6027\u80fd\uff0c\u5e94\u8be5\u907f\u514d\u4f7f\u7528\u5b83\u4eec\u3002</p>"},{"location":"concepts/performance/#failfast","title":"\u4f7f\u7528 <code>FailFast</code> \u63d0\u524d\u5931\u8d25","text":"<p>\u4ece v2.8+ \u5f00\u59cb\uff0c\u4f60\u53ef\u4ee5\u5c06 <code>FailFast</code> \u6ce8\u89e3\u5e94\u7528\u4e8e\u5e8f\u5217\u7c7b\u578b\uff0c\u4ee5\u4fbf\u5728\u5e8f\u5217\u4e2d\u7684\u4efb\u4f55\u9879\u9a8c\u8bc1\u5931\u8d25\u65f6\u63d0\u524d\u5931\u8d25\u3002 \u5982\u679c\u4f60\u4f7f\u7528\u6b64\u6ce8\u89e3\uff0c\u5f53\u5e8f\u5217\u4e2d\u7684\u4e00\u4e2a\u9879\u5931\u8d25\u65f6\uff0c\u4f60\u5c06\u4e0d\u4f1a\u83b7\u5f97\u5e8f\u5217\u4e2d\u5176\u4f59\u9879\u7684\u9a8c\u8bc1\u9519\u8bef\uff0c\u56e0\u6b64\u4f60\u5b9e\u9645\u4e0a\u662f\u5728\u7528\u53ef\u89c1\u6027\u6362\u53d6\u6027\u80fd\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import FailFast, TypeAdapter, ValidationError\n\nta = TypeAdapter(Annotated[list[bool], FailFast()])\ntry:\n    ta.validate_python([True, 'invalid', False, 'also invalid'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[bool]\n    1\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='invalid', input_type=str]\n    \"\"\"\n</code></pre> <p>\u6709\u5173 <code>FailFast</code> \u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u6b64\u5904\u3002</p>"},{"location":"concepts/pydantic_settings/","title":"\u8bbe\u7f6e\u7ba1\u7406","text":"<p>Pydantic Settings \u63d0\u4f9b\u4e86\u53ef\u9009\u7684 Pydantic \u529f\u80fd\uff0c\u7528\u4e8e\u4ece\u73af\u5883\u53d8\u91cf\u6216\u5bc6\u94a5\u6587\u4ef6\u52a0\u8f7d\u8bbe\u7f6e\u6216\u914d\u7f6e\u7c7b\u3002</p>"},{"location":"concepts/pydantic_settings/#_2","title":"\u5b89\u88c5","text":"<p>\u5b89\u88c5\u975e\u5e38\u7b80\u5355\uff1a</p> <pre><code>pip install pydantic-settings\n</code></pre>"},{"location":"concepts/pydantic_settings/#_3","title":"\u4f7f\u7528","text":"<p>\u5982\u679c\u4f60\u521b\u5efa\u4e00\u4e2a\u7ee7\u627f\u81ea <code>BaseSettings</code> \u7684\u6a21\u578b\uff0c\u6a21\u578b\u521d\u59cb\u5316\u5668\u5c06\u5c1d\u8bd5\u901a\u8fc7\u4ece\u73af\u5883\u4e2d\u8bfb\u53d6\u6765\u786e\u5b9a\u4efb\u4f55\u672a\u4f5c\u4e3a\u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u7684\u5b57\u6bb5\u7684\u503c\u3002\uff08\u5982\u679c\u672a\u8bbe\u7f6e\u5339\u914d\u7684\u73af\u5883\u53d8\u91cf\uff0c\u4ecd\u5c06\u4f7f\u7528\u9ed8\u8ba4\u503c\u3002\uff09</p> <p>\u8fd9\u4f7f\u5f97\u4ee5\u4e0b\u64cd\u4f5c\u53d8\u5f97\u5bb9\u6613\uff1a</p> <ul> <li>\u521b\u5efa\u4e00\u4e2a\u660e\u786e\u5b9a\u4e49\u3001\u7c7b\u578b\u63d0\u793a\u7684\u5e94\u7528\u7a0b\u5e8f\u914d\u7f6e\u7c7b</li> <li>\u81ea\u52a8\u4ece\u73af\u5883\u53d8\u91cf\u4e2d\u8bfb\u53d6\u914d\u7f6e\u7684\u4fee\u6539</li> <li>\u5728\u9700\u8981\u65f6\u624b\u52a8\u8986\u76d6\u521d\u59cb\u5316\u5668\u4e2d\u7684\u7279\u5b9a\u8bbe\u7f6e\uff08\u4f8b\u5982\u5728\u5355\u5143\u6d4b\u8bd5\u4e2d\uff09</li> </ul> <p>\u4f8b\u5982\uff1a</p> <pre><code>from collections.abc import Callable\nfrom typing import Any\n\nfrom pydantic import (\n    AliasChoices,\n    AmqpDsn,\n    BaseModel,\n    Field,\n    ImportString,\n    PostgresDsn,\n    RedisDsn,\n)\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass SubModel(BaseModel):\n    foo: str = 'bar'\n    apple: int = 1\n\n\nclass Settings(BaseSettings):\n    auth_key: str = Field(validation_alias='my_auth_key')  # (1)!\n\n    api_key: str = Field(alias='my_api_key')  # (2)!\n\n    redis_dsn: RedisDsn = Field(\n        'redis://user:pass@localhost:6379/1',\n        validation_alias=AliasChoices('service_redis_dsn', 'redis_url'),  # (3)!\n    )\n    pg_dsn: PostgresDsn = 'postgres://user:pass@localhost:5432/foobar'\n    amqp_dsn: AmqpDsn = 'amqp://user:pass@localhost:5672/'\n\n    special_function: ImportString[Callable[[Any], Any]] = 'math.cos'  # (4)!\n\n    # to override domains:\n    # export my_prefix_domains='[\"foo.com\", \"bar.com\"]'\n    domains: set[str] = set()\n\n    # to override more_settings:\n    # export my_prefix_more_settings='{\"foo\": \"x\", \"apple\": 1}'\n    more_settings: SubModel = SubModel()\n\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')  # (5)!\n\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'auth_key': 'xxx',\n    'api_key': 'xxx',\n    'redis_dsn': RedisDsn('redis://user:pass@localhost:6379/1'),\n    'pg_dsn': PostgresDsn('postgres://user:pass@localhost:5432/foobar'),\n    'amqp_dsn': AmqpDsn('amqp://user:pass@localhost:5672/'),\n    'special_function': math.cos,\n    'domains': set(),\n    'more_settings': {'foo': 'bar', 'apple': 1},\n}\n\"\"\"\n</code></pre> <ol> <li> <p>\u4f7f\u7528 <code>validation_alias</code> \u8986\u76d6\u73af\u5883\u53d8\u91cf\u540d\u79f0\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c06\u8bfb\u53d6\u73af\u5883\u53d8\u91cf <code>my_auth_key</code> \u800c\u4e0d\u662f <code>auth_key</code>\u3002</p> <p>\u67e5\u770b <code>Field</code> \u6587\u6863 \u83b7\u53d6\u66f4\u591a\u4fe1\u606f\u3002</p> </li> <li> <p>\u4f7f\u7528 <code>alias</code> \u8986\u76d6\u73af\u5883\u53d8\u91cf\u540d\u79f0\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u73af\u5883\u53d8\u91cf <code>my_api_key</code> \u5c06\u7528\u4e8e\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\uff0c\u800c\u4e0d\u662f <code>api_key</code>\u3002</p> <p>\u67e5\u770b <code>Field</code> \u6587\u6863 \u83b7\u53d6\u66f4\u591a\u4fe1\u606f\u3002</p> </li> <li> <p><code>AliasChoices</code> \u7c7b\u5141\u8bb8\u4e3a\u5355\u4e2a\u5b57\u6bb5\u8bbe\u7f6e\u591a\u4e2a\u73af\u5883\u53d8\u91cf\u540d\u79f0\u3002\u5c06\u4f7f\u7528\u627e\u5230\u7684\u7b2c\u4e00\u4e2a\u73af\u5883\u53d8\u91cf\u3002</p> <p>\u67e5\u770b \u522b\u540d\u9009\u62e9\u6587\u6863 \u83b7\u53d6\u66f4\u591a\u4fe1\u606f\u3002</p> </li> <li> <p><code>ImportString</code> \u7c7b\u5141\u8bb8\u4ece\u5b57\u7b26\u4e32\u5bfc\u5165\u5bf9\u8c61\u3002    \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5c06\u8bfb\u53d6\u73af\u5883\u53d8\u91cf <code>special_function</code> \u5e76\u5bfc\u5165\u51fd\u6570 <code>math.cos</code>\u3002</p> </li> <li> <p><code>env_prefix</code> \u914d\u7f6e\u8bbe\u7f6e\u5141\u8bb8\u4e3a\u6240\u6709\u73af\u5883\u53d8\u91cf\u8bbe\u7f6e\u524d\u7f00\u3002</p> <p>\u67e5\u770b \u73af\u5883\u53d8\u91cf\u540d\u79f0\u6587\u6863 \u83b7\u53d6\u66f4\u591a\u4fe1\u606f\u3002</p> </li> </ol>"},{"location":"concepts/pydantic_settings/#_4","title":"\u9ed8\u8ba4\u503c\u9a8c\u8bc1","text":"<p>\u4e0e pydantic <code>BaseModel</code> \u4e0d\u540c\uff0c<code>BaseSettings</code> \u5b57\u6bb5\u7684\u9ed8\u8ba4\u503c\u9ed8\u8ba4\u4f1a\u88ab\u9a8c\u8bc1\u3002 \u4f60\u53ef\u4ee5\u901a\u8fc7\u5728 <code>model_config</code> \u4e2d\u8bbe\u7f6e <code>validate_default=False</code> \u6216\u5728\u5b57\u6bb5\u7ea7\u522b\u901a\u8fc7 <code>Field(validate_default=False)</code> \u6765\u7981\u7528\u6b64\u884c\u4e3a\uff1a</p> <pre><code>from pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(validate_default=False)\n\n    # \u9ed8\u8ba4\u503c\u4e0d\u4f1a\u88ab\u9a8c\u8bc1\n    foo: int = 'test'\n\n\nprint(Settings())\n#&gt; foo='test'\n\n\nclass Settings1(BaseSettings):\n    # \u9ed8\u8ba4\u503c\u4e0d\u4f1a\u88ab\u9a8c\u8bc1\n    foo: int = Field('test', validate_default=False)\n\n\nprint(Settings1())\n#&gt; foo='test'\n</code></pre> <p>\u67e5\u770b \u9ed8\u8ba4\u503c\u9a8c\u8bc1 \u83b7\u53d6\u66f4\u591a\u4fe1\u606f\u3002</p>"},{"location":"concepts/pydantic_settings/#environment-variable-names","title":"\u73af\u5883\u53d8\u91cf\u540d\u79f0","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u73af\u5883\u53d8\u91cf\u540d\u79f0\u4e0e\u5b57\u6bb5\u540d\u79f0\u76f8\u540c\u3002</p> <p>\u4f60\u53ef\u4ee5\u901a\u8fc7\u8bbe\u7f6e <code>env_prefix</code> \u914d\u7f6e\u8bbe\u7f6e\u6216\u5728\u5b9e\u4f8b\u5316\u65f6\u901a\u8fc7 <code>_env_prefix</code> \u5173\u952e\u5b57\u53c2\u6570\u6765\u66f4\u6539\u6240\u6709\u73af\u5883\u53d8\u91cf\u7684\u524d\u7f00\uff1a</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')\n\n    auth_key: str = 'xxx'  # \u5c06\u4ece `my_prefix_auth_key` \u8bfb\u53d6\n</code></pre> <p>Note</p> <p>\u9ed8\u8ba4\u7684 <code>env_prefix</code> \u662f <code>''</code>\uff08\u7a7a\u5b57\u7b26\u4e32\uff09\u3002<code>env_prefix</code> \u4e0d\u4ec5\u9002\u7528\u4e8e\u73af\u5883\u8bbe\u7f6e\uff0c\u8fd8\u9002\u7528\u4e8e dotenv \u6587\u4ef6\u3001\u5bc6\u94a5\u548c\u5176\u4ed6\u6e90\u3002</p> <p>\u5982\u679c\u4f60\u60f3\u66f4\u6539\u5355\u4e2a\u5b57\u6bb5\u7684\u73af\u5883\u53d8\u91cf\u540d\u79f0\uff0c\u53ef\u4ee5\u4f7f\u7528\u522b\u540d\u3002</p> <p>\u6709\u4e24\u79cd\u65b9\u6cd5\u53ef\u4ee5\u505a\u5230\u8fd9\u4e00\u70b9\uff1a</p> <ul> <li>\u4f7f\u7528 <code>Field(alias=...)</code>\uff08\u53c2\u89c1\u4e0a\u9762\u7684 <code>api_key</code>\uff09</li> <li>\u4f7f\u7528 <code>Field(validation_alias=...)</code>\uff08\u53c2\u89c1\u4e0a\u9762\u7684 <code>auth_key</code>\uff09</li> </ul> <p>\u67e5\u770b <code>Field</code> \u522b\u540d\u6587\u6863 \u83b7\u53d6\u6709\u5173\u522b\u540d\u7684\u66f4\u591a\u4fe1\u606f\u3002</p> <p><code>env_prefix</code> \u4e0d\u9002\u7528\u4e8e\u5e26\u6709\u522b\u540d\u7684\u5b57\u6bb5\u3002\u8fd9\u610f\u5473\u7740\u73af\u5883\u53d8\u91cf\u540d\u79f0\u4e0e\u5b57\u6bb5\u522b\u540d\u76f8\u540c\uff1a</p> <pre><code>from pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_prefix='my_prefix_')\n\n    foo: str = Field('xxx', alias='FooAlias')  # (1)!\n</code></pre> <ol> <li><code>env_prefix</code> \u5c06\u88ab\u5ffd\u7565\uff0c\u503c\u5c06\u4ece <code>FooAlias</code> \u73af\u5883\u53d8\u91cf\u4e2d\u8bfb\u53d6\u3002</li> </ol>"},{"location":"concepts/pydantic_settings/#_5","title":"\u5927\u5c0f\u5199\u654f\u611f\u6027","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u73af\u5883\u53d8\u91cf\u540d\u79f0\u662f\u5927\u5c0f\u5199\u4e0d\u654f\u611f\u7684\u3002</p> <p>\u5982\u679c\u4f60\u60f3\u4f7f\u73af\u5883\u53d8\u91cf\u540d\u79f0\u5927\u5c0f\u5199\u654f\u611f\uff0c\u53ef\u4ee5\u8bbe\u7f6e <code>case_sensitive</code> \u914d\u7f6e\u8bbe\u7f6e\uff1a</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(case_sensitive=True)\n\n    redis_host: str = 'localhost'\n</code></pre> <p>\u5f53 <code>case_sensitive</code> \u4e3a <code>True</code> \u65f6\uff0c\u73af\u5883\u53d8\u91cf\u540d\u79f0\u5fc5\u987b\u4e0e\u5b57\u6bb5\u540d\u79f0\u5339\u914d\uff08\u53ef\u9009\u5730\u5e26\u6709\u524d\u7f00\uff09\uff0c \u56e0\u6b64\u5728\u6b64\u793a\u4f8b\u4e2d\uff0c<code>redis_host</code> \u53ea\u80fd\u901a\u8fc7 <code>export redis_host</code> \u8fdb\u884c\u4fee\u6539\u3002\u5982\u679c\u4f60\u60f3\u5c06\u73af\u5883\u53d8\u91cf\u547d\u540d\u4e3a\u5168\u5927\u5199\uff0c \u4f60\u4e5f\u5e94\u8be5\u5c06\u5c5e\u6027\u547d\u540d\u4e3a\u5168\u5927\u5199\u3002\u4f60\u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7 <code>Field(validation_alias=...)</code> \u5c06\u73af\u5883\u53d8\u91cf\u547d\u540d\u4e3a\u4efb\u4f55\u4f60\u559c\u6b22\u7684\u540d\u79f0\u3002</p> <p>\u5927\u5c0f\u5199\u654f\u611f\u6027\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5b9e\u4f8b\u5316\u65f6\u7684 <code>_case_sensitive</code> \u5173\u952e\u5b57\u53c2\u6570\u8bbe\u7f6e\u3002</p> <p>\u5bf9\u4e8e\u5d4c\u5957\u6a21\u578b\uff0c<code>case_sensitive</code> \u8bbe\u7f6e\u5c06\u5e94\u7528\u4e8e\u6240\u6709\u5d4c\u5957\u6a21\u578b\u3002</p> <pre><code>import os\n\nfrom pydantic import BaseModel, ValidationError\n\nfrom pydantic_settings import BaseSettings\n\n\nclass RedisSettings(BaseModel):\n    host: str\n    port: int\n\n\nclass Settings(BaseSettings, case_sensitive=True):\n    redis: RedisSettings\n\n\nos.environ['redis'] = '{\"host\": \"localhost\", \"port\": 6379}'\nprint(Settings().model_dump())\n#&gt; {'redis': {'host': 'localhost', 'port': 6379}}\nos.environ['redis'] = '{\"HOST\": \"localhost\", \"port\": 6379}'  # (1)!\ntry:\n    Settings()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Settings\n    redis.host\n      Field required [type=missing, input_value={'HOST': 'localhost', 'port': 6379}, input_type=dict]\n        \u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u8bbf\u95ee https://errors.pydantic.dev/2/v/missing\n    \"\"\"\n</code></pre> <ol> <li>\u6ce8\u610f <code>host</code> \u5b57\u6bb5\u672a\u627e\u5230\uff0c\u56e0\u4e3a\u73af\u5883\u53d8\u91cf\u540d\u79f0\u662f <code>HOST</code>\uff08\u5168\u5927\u5199\uff09\u3002</li> </ol> <p>Note</p> <p>\u5728 Windows \u4e0a\uff0cPython \u7684 <code>os</code> \u6a21\u5757\u59cb\u7ec8\u5c06\u73af\u5883\u53d8\u91cf\u89c6\u4e3a\u5927\u5c0f\u5199\u4e0d\u654f\u611f\uff0c\u56e0\u6b64 <code>case_sensitive</code> \u914d\u7f6e\u8bbe\u7f6e\u5c06\u65e0\u6548 - \u8bbe\u7f6e\u5c06\u59cb\u7ec8\u5ffd\u7565\u5927\u5c0f\u5199\u8fdb\u884c\u66f4\u65b0\u3002</p>"},{"location":"concepts/pydantic_settings/#parsing-environment-variable-values","title":"\u89e3\u6790\u73af\u5883\u53d8\u91cf\u503c","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u73af\u5883\u53d8\u91cf\u6309\u5b57\u9762\u89e3\u6790\uff0c\u5305\u62ec\u503c\u4e3a\u7a7a\u7684\u60c5\u51b5\u3002\u4f60\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>env_ignore_empty</code> \u914d\u7f6e\u8bbe\u7f6e\u8bbe\u7f6e\u4e3a <code>True</code> \u6765\u9009\u62e9\u5ffd\u7565\u7a7a\u73af\u5883\u53d8\u91cf\u3002 \u5982\u679c\u4f60\u66f4\u613f\u610f\u4f7f\u7528\u5b57\u6bb5\u7684\u9ed8\u8ba4\u503c\u800c\u4e0d\u662f\u6765\u81ea\u73af\u5883\u7684\u7a7a\u503c\uff0c\u8fd9\u4f1a\u5f88\u6709\u7528\u3002</p> <p>\u5bf9\u4e8e\u5927\u591a\u6570\u7b80\u5355\u5b57\u6bb5\u7c7b\u578b\uff08\u5982 <code>int</code>\u3001<code>float</code>\u3001<code>str</code> \u7b49\uff09\uff0c\u73af\u5883\u53d8\u91cf\u503c\u7684\u89e3\u6790\u65b9\u5f0f\u4e0e\u76f4\u63a5\u4f20\u9012\u7ed9\u521d\u59cb\u5316\u5668\uff08\u4f5c\u4e3a\u5b57\u7b26\u4e32\uff09\u76f8\u540c\u3002</p> <p>\u590d\u6742\u7c7b\u578b\u5982 <code>list</code>\u3001<code>set</code>\u3001<code>dict</code> \u548c\u5b50\u6a21\u578b\u901a\u8fc7\u5c06\u73af\u5883\u53d8\u91cf\u7684\u503c\u89c6\u4e3a JSON \u7f16\u7801\u7684\u5b57\u7b26\u4e32\u6765\u4ece\u73af\u5883\u4e2d\u586b\u5145\u3002</p> <p>\u586b\u5145\u5d4c\u5957\u590d\u6742\u53d8\u91cf\u7684\u53e6\u4e00\u79cd\u65b9\u6cd5\u662f\u914d\u7f6e\u6a21\u578b\u7684 <code>env_nested_delimiter</code> \u914d\u7f6e\u8bbe\u7f6e\uff0c\u7136\u540e\u4f7f\u7528\u6307\u5411\u5d4c\u5957\u6a21\u5757\u5b57\u6bb5\u540d\u79f0\u7684\u73af\u5883\u53d8\u91cf\u3002 \u5b83\u7684\u4f5c\u7528\u53ea\u662f\u5c06\u4f60\u7684\u53d8\u91cf\u5206\u89e3\u4e3a\u5d4c\u5957\u6a21\u578b\u6216\u5b57\u5178\u3002 \u56e0\u6b64\uff0c\u5982\u679c\u4f60\u5b9a\u4e49\u4e00\u4e2a\u53d8\u91cf <code>FOO__BAR__BAZ=123</code>\uff0c\u5b83\u5c06\u8f6c\u6362\u4e3a <code>FOO={'BAR': {'BAZ': 123}}</code> \u5982\u679c\u4f60\u6709\u591a\u4e2a\u5177\u6709\u76f8\u540c\u7ed3\u6784\u7684\u53d8\u91cf\uff0c\u5b83\u4eec\u5c06\u88ab\u5408\u5e76\u3002</p> <p>Note</p> <p>\u5b50\u6a21\u578b\u5fc5\u987b\u7ee7\u627f\u81ea <code>pydantic.BaseModel</code>\uff0c\u5426\u5219 <code>pydantic-settings</code> \u5c06\u521d\u59cb\u5316\u5b50\u6a21\u578b\uff0c \u5355\u72ec\u6536\u96c6\u5b50\u6a21\u578b\u5b57\u6bb5\u7684\u503c\uff0c\u4f60\u53ef\u80fd\u4f1a\u5f97\u5230\u610f\u5916\u7684\u7ed3\u679c\u3002</p> <p>\u4f8b\u5982\uff0c\u7ed9\u5b9a\u4ee5\u4e0b\u73af\u5883\u53d8\u91cf\uff1a <pre><code># your environment\nexport V0=0\nexport SUB_MODEL='{\"v1\": \"json-1\", \"v2\": \"json-2\"}'\nexport SUB_MODEL__V2=nested-2\nexport SUB_MODEL__V3=3\nexport SUB_MODEL__DEEP__V4=v4\n</code></pre></p> <p>\u4f60\u53ef\u4ee5\u5c06\u5b83\u4eec\u52a0\u8f7d\u5230\u4ee5\u4e0b\u8bbe\u7f6e\u6a21\u578b\u4e2d\uff1a</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):  # (1)!\n    v4: str\n\n\nclass SubModel(BaseModel):  # (2)!\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_nested_delimiter='__')\n\n    v0: str\n    sub_model: SubModel\n\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'v0': '0',\n    'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},\n}\n\"\"\"\n</code></pre> <ol> <li> <p>\u5b50\u6a21\u578b\u5fc5\u987b\u7ee7\u627f\u81ea <code>pydantic.BaseModel</code>\u3002</p> </li> <li> <p>\u5b50\u6a21\u578b\u5fc5\u987b\u7ee7\u627f\u81ea <code>pydantic.BaseModel</code>\u3002</p> </li> </ol> <p><code>env_nested_delimiter</code> \u53ef\u4ee5\u901a\u8fc7 <code>model_config</code> \u914d\u7f6e\uff0c\u5982\u4e0a\u6240\u793a\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5b9e\u4f8b\u5316\u65f6\u7684 <code>_env_nested_delimiter</code> \u5173\u952e\u5b57\u53c2\u6570\u914d\u7f6e\u3002</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u73af\u5883\u53d8\u91cf\u6309 <code>env_nested_delimiter</code> \u5206\u5272\u4e3a\u4efb\u610f\u6df1\u5ea6\u7684\u5d4c\u5957\u5b57\u6bb5\u3002\u4f60\u53ef\u4ee5\u4f7f\u7528 <code>env_nested_max_split</code> \u914d\u7f6e\u8bbe\u7f6e\u9650\u5236\u5d4c\u5957\u5b57\u6bb5\u7684\u6df1\u5ea6\u3002\u8fd9\u5728\u4e24\u7ea7\u6df1\u5ea6\u8bbe\u7f6e\u4e2d\u7279\u522b\u6709\u7528\uff0c\u5176\u4e2d <code>env_nested_delimiter</code>\uff08\u901a\u5e38\u662f\u5355\u4e2a <code>_</code>\uff09\u53ef\u80fd\u662f\u6a21\u578b\u5b57\u6bb5\u540d\u79f0\u7684\u5b50\u5b57\u7b26\u4e32\u3002\u4f8b\u5982\uff1a</p> <pre><code># your environment\nexport GENERATION_LLM_PROVIDER='anthropic'\nexport GENERATION_LLM_API_KEY='your-api-key'\nexport GENERATION_LLM_API_VERSION='2024-03-15'\n</code></pre> <p>\u4f60\u53ef\u4ee5\u5c06\u5b83\u4eec\u52a0\u8f7d\u5230\u4ee5\u4e0b\u8bbe\u7f6e\u6a21\u578b\u4e2d\uff1a</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass LLMConfig(BaseModel):\n    provider: str = 'openai'\n    api_key: str\n    api_type: str = 'azure'\n    api_version: str = '2023-03-15-preview'\n\n\nclass GenerationConfig(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='_', env_nested_max_split=1, env_prefix='GENERATION_'\n    )\n\n    llm: LLMConfig\n    ...\n\n\nprint(GenerationConfig().model_dump())\n\"\"\"\n{\n    'llm': {\n        'provider': 'anthropic',\n        'api_key': 'your-api-key',\n        'api_type': 'azure',\n        'api_version': '2024-03-15',\n    }\n}\n\"\"\"\n</code></pre> <p>\u5982\u679c\u6ca1\u6709\u8bbe\u7f6e <code>env_nested_max_split=1</code>\uff0c<code>GENERATION_LLM_API_KEY</code> \u5c06\u88ab\u89e3\u6790\u4e3a <code>llm.api.key</code> \u800c\u4e0d\u662f <code>llm.api_key</code>\uff0c\u5e76\u4e14\u4f1a\u5f15\u53d1 <code>ValidationError</code>\u3002</p> <p>\u5d4c\u5957\u73af\u5883\u53d8\u91cf\u4f18\u5148\u4e8e\u9876\u7ea7\u73af\u5883\u53d8\u91cf JSON\uff08\u4f8b\u5982\uff0c\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c<code>SUB_MODEL__V2</code> \u4f18\u5148\u4e8e <code>SUB_MODEL</code>\uff09\u3002</p> <p>\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u63d0\u4f9b\u81ea\u5df1\u7684\u6e90\u7c7b\u6765\u586b\u5145\u590d\u6742\u7c7b\u578b\u3002</p> <pre><code>import json\nimport os\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import (\n    BaseSettings,\n    EnvSettingsSource,\n    PydanticBaseSettingsSource,\n)\n\n\nclass MyCustomSource(EnvSettingsSource):\n    def prepare_field_value(\n        self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n    ) -&gt; Any:\n        if field_name == 'numbers':\n            return [int(x) for x in value.split(',')]\n        return json.loads(value)\n\n\nclass Settings(BaseSettings):\n    numbers: list[int]\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (MyCustomSource(settings_cls),)\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#&gt; {'numbers': [1, 2, 3]}\n</code></pre>"},{"location":"concepts/pydantic_settings/#json","title":"\u7981\u7528 JSON \u89e3\u6790","text":"<p>pydantic-settings \u9ed8\u8ba4\u5c06\u73af\u5883\u53d8\u91cf\u4e2d\u7684\u590d\u6742\u7c7b\u578b\u89e3\u6790\u4e3a JSON \u5b57\u7b26\u4e32\u3002\u5982\u679c\u4f60\u60f3\u7981\u7528 \u6b64\u884c\u4e3a\u5e76\u5728\u81ea\u5df1\u7684\u9a8c\u8bc1\u5668\u4e2d\u89e3\u6790\u503c\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>NoDecode</code> \u6ce8\u89e3\u5b57\u6bb5\uff1a</p> <pre><code>import os\nfrom typing import Annotated\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, NoDecode\n\n\nclass Settings(BaseSettings):\n    numbers: Annotated[list[int], NoDecode]  # (1)!\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def decode_numbers(cls, v: str) -&gt; list[int]:\n        return [int(x) for x in v.split(',')]\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#&gt; {'numbers': [1, 2, 3]}\n</code></pre> <ol> <li><code>NoDecode</code> \u6ce8\u89e3\u7981\u7528 <code>numbers</code> \u5b57\u6bb5\u7684 JSON \u89e3\u6790\u3002<code>decode_numbers</code> \u5b57\u6bb5\u9a8c\u8bc1\u5668\u5c06\u88ab\u8c03\u7528\u6765\u89e3\u6790\u503c\u3002</li> </ol> <p>\u4f60\u4e5f\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>enable_decoding</code> \u914d\u7f6e\u8bbe\u7f6e\u8bbe\u7f6e\u4e3a <code>False</code> \u6765\u7981\u7528\u6240\u6709\u5b57\u6bb5\u7684 JSON \u89e3\u6790\uff1a</p> <pre><code>import os\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(enable_decoding=False)\n\n    numbers: list[int]\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def decode_numbers(cls, v: str) -&gt; list[int]:\n        return [int(x) for x in v.split(',')]\n\n\nos.environ['numbers'] = '1,2,3'\nprint(Settings().model_dump())\n#&gt; {'numbers': [1, 2, 3]}\n</code></pre> <p>\u4f60\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>ForceDecode</code> \u6ce8\u89e3\u5b57\u6bb5\u6765\u5f3a\u5236\u8fdb\u884c JSON \u89e3\u6790\u3002 \u8fd9\u5c06\u7ed5\u8fc7 <code>enable_decoding</code> \u914d\u7f6e\u8bbe\u7f6e\uff1a</p> <pre><code>import os\nfrom typing import Annotated\n\nfrom pydantic import field_validator\n\nfrom pydantic_settings import BaseSettings, ForceDecode, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(enable_decoding=False)\n\n    numbers: Annotated[list[int], ForceDecode]\n    numbers1: list[int]  # (1)!\n\n    @field_validator('numbers1', mode='before')\n    @classmethod\n    def decode_numbers1(cls, v: str) -&gt; list[int]:\n        return [int(x) for x in v.split(',')]\n\n\nos.environ['numbers'] = '[\"1\",\"2\",\"3\"]'\nos.environ['numbers1'] = '1,2,3'\nprint(Settings().model_dump())\n#&gt; {'numbers': [1, 2, 3], 'numbers1': [1, 2, 3]}\n</code></pre> <ol> <li><code>numbers1</code> \u5b57\u6bb5\u6ca1\u6709\u7528 <code>ForceDecode</code> \u6ce8\u89e3\uff0c\u56e0\u6b64\u4e0d\u4f1a\u88ab\u89e3\u6790\u4e3a JSON\uff0c\u6211\u4eec\u9700\u8981\u63d0\u4f9b\u4e00\u4e2a\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u6765\u89e3\u6790\u503c\u3002</li> </ol>"},{"location":"concepts/pydantic_settings/#_6","title":"\u5d4c\u5957\u6a21\u578b\u9ed8\u8ba4\u90e8\u5206\u66f4\u65b0","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic settings \u4e0d\u5141\u8bb8\u5bf9\u5d4c\u5957\u6a21\u578b\u9ed8\u8ba4\u5bf9\u8c61\u8fdb\u884c\u90e8\u5206\u66f4\u65b0\u3002\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>nested_model_default_partial_update</code> \u6807\u5fd7\u8bbe\u7f6e\u4e3a <code>True</code> \u6765\u8986\u76d6\u6b64\u884c\u4e3a\uff0c\u8fd9\u5c06\u5141\u8bb8\u5bf9\u5d4c\u5957\u6a21\u578b\u9ed8\u8ba4\u5bf9\u8c61\u5b57\u6bb5\u8fdb\u884c\u90e8\u5206\u66f4\u65b0\u3002</p> <pre><code>import os\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass SubModel(BaseModel):\n    val: int = 0\n    flag: bool = False\n\n\nclass SettingsPartialUpdate(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='__', nested_model_default_partial_update=True\n    )\n\n    nested_model: SubModel = SubModel(val=1)\n\n\nclass SettingsNoPartialUpdate(BaseSettings):\n    model_config = SettingsConfigDict(\n        env_nested_delimiter='__', nested_model_default_partial_update=False\n    )\n\n    nested_model: SubModel = SubModel(val=1)\n\n\n# Apply a partial update to the default object using environment variables\nos.environ['NESTED_MODEL__FLAG'] = 'True'\n\n# When partial update is enabled, the existing SubModel instance is updated\n# with nested_model.flag=True change\nassert SettingsPartialUpdate().model_dump() == {\n    'nested_model': {'val': 1, 'flag': True}\n}\n\n# When partial update is disabled, a new SubModel instance is instantiated\n# with nested_model.flag=True change\nassert SettingsNoPartialUpdate().model_dump() == {\n    'nested_model': {'val': 0, 'flag': True}\n}\n</code></pre>"},{"location":"concepts/pydantic_settings/#dotenv-env","title":"Dotenv (.env) \u652f\u6301","text":"<p>Dotenv \u6587\u4ef6\uff08\u901a\u5e38\u547d\u540d\u4e3a <code>.env</code>\uff09\u662f\u4e00\u79cd\u5e38\u89c1\u6a21\u5f0f\uff0c\u53ef\u4ee5\u8f7b\u677e\u5730\u4ee5\u5e73\u53f0\u65e0\u5173\u7684\u65b9\u5f0f\u4f7f\u7528\u73af\u5883\u53d8\u91cf\u3002</p> <p>Dotenv \u6587\u4ef6\u9075\u5faa\u6240\u6709\u73af\u5883\u53d8\u91cf\u7684\u76f8\u540c\u4e00\u822c\u539f\u5219\uff0c\u5b83\u770b\u8d77\u6765\u50cf\u8fd9\u6837\uff1a</p> .env<pre><code># \u5ffd\u7565\u6ce8\u91ca\nENVIRONMENT=\"production\"\nREDIS_ADDRESS=localhost:6379\nMEANING_OF_LIFE=42\nMY_VAR='Hello world'\n</code></pre> <p>\u4e00\u65e6\u4f60\u586b\u5145\u4e86 <code>.env</code> \u6587\u4ef6\uff0cpydantic \u652f\u6301\u4ee5\u4e24\u79cd\u65b9\u5f0f\u52a0\u8f7d\u5b83\uff1a</p> <ol> <li>\u5728 <code>BaseSettings</code> \u7c7b\u7684 <code>model_config</code> \u4e0a\u8bbe\u7f6e <code>env_file</code>\uff08\u5982\u679c\u4e0d\u60f3\u4f7f\u7528\u64cd\u4f5c\u7cfb\u7edf\u7684\u9ed8\u8ba4\u7f16\u7801\uff0c\u8fd8\u53ef\u4ee5\u8bbe\u7f6e <code>env_file_encoding</code>\uff09\uff1a    <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n</code></pre></li> <li>\u4f7f\u7528 <code>_env_file</code> \u5173\u952e\u5b57\u53c2\u6570\uff08\u5982\u679c\u9700\u8981\uff0c\u8fd8\u53ef\u4ee5\u4f7f\u7528 <code>_env_file_encoding</code>\uff09\u5b9e\u4f8b\u5316 <code>BaseSettings</code> \u6d3e\u751f\u7c7b\uff1a    <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', env_file_encoding='utf-8')\n\n\nsettings = Settings(_env_file='prod.env', _env_file_encoding='utf-8')\n</code></pre> \u65e0\u8bba\u54ea\u79cd\u60c5\u51b5\uff0c\u4f20\u9012\u7684\u53c2\u6570\u503c\u53ef\u4ee5\u662f\u4efb\u4f55\u6709\u6548\u7684\u8def\u5f84\u6216\u6587\u4ef6\u540d\uff0c\u53ef\u4ee5\u662f\u7edd\u5bf9\u8def\u5f84\uff0c\u4e5f\u53ef\u4ee5\u662f\u76f8\u5bf9\u4e8e\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u7684\u8def\u5f84\u3002 \u4ece\u90a3\u91cc\uff0cpydantic \u5c06\u901a\u8fc7\u52a0\u8f7d\u4f60\u7684\u53d8\u91cf\u5e76\u9a8c\u8bc1\u5b83\u4eec\u6765\u5904\u7406\u6240\u6709\u4e8b\u60c5\u3002</li> </ol> <p>Note</p> <p>\u5982\u679c\u4e3a <code>env_file</code> \u6307\u5b9a\u4e86\u6587\u4ef6\u540d\uff0cPydantic \u5c06\u4ec5\u68c0\u67e5\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\uff0c \u4e0d\u4f1a\u68c0\u67e5\u4efb\u4f55\u7236\u76ee\u5f55\u4e2d\u7684 <code>.env</code> \u6587\u4ef6\u3002</p> <p>\u5373\u4f7f\u4f7f\u7528 dotenv \u6587\u4ef6\uff0cpydantic \u4ecd\u4f1a\u8bfb\u53d6\u73af\u5883\u53d8\u91cf\u4ee5\u53ca dotenv \u6587\u4ef6\uff0c \u73af\u5883\u53d8\u91cf\u59cb\u7ec8\u4f18\u5148\u4e8e\u4ece dotenv \u6587\u4ef6\u52a0\u8f7d\u7684\u503c\u3002</p> <p>\u901a\u8fc7\u5b9e\u4f8b\u5316\u65f6\u7684 <code>_env_file</code> \u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u6587\u4ef6\u8def\u5f84\uff08\u65b9\u6cd5 2\uff09\u5c06\u8986\u76d6 <code>model_config</code> \u7c7b\u4e0a\u8bbe\u7f6e\u7684\u4efb\u4f55\u503c\u3002\u5982\u679c\u4e0a\u8ff0\u4ee3\u7801\u7247\u6bb5\u4e00\u8d77\u4f7f\u7528\uff0c\u5c06\u52a0\u8f7d <code>prod.env</code> \u800c\u5ffd\u7565 <code>.env</code>\u3002</p> <p>\u5982\u679c\u9700\u8981\u52a0\u8f7d\u591a\u4e2a dotenv \u6587\u4ef6\uff0c\u53ef\u4ee5\u5c06\u591a\u4e2a\u6587\u4ef6\u8def\u5f84\u4f5c\u4e3a\u5143\u7ec4\u6216\u5217\u8868\u4f20\u9012\u3002\u6587\u4ef6\u5c06 \u6309\u987a\u5e8f\u52a0\u8f7d\uff0c\u6bcf\u4e2a\u6587\u4ef6\u8986\u76d6\u524d\u4e00\u4e2a\u6587\u4ef6\u3002</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(\n        # `.env.prod` \u4f18\u5148\u4e8e `.env`\n        env_file=('.env', '.env.prod')\n    )\n</code></pre> <p>\u4f60\u4e5f\u53ef\u4ee5\u4f7f\u7528\u5173\u952e\u5b57\u53c2\u6570\u8986\u76d6\u6765\u544a\u8bc9 Pydantic \u6839\u672c\u4e0d\u52a0\u8f7d\u4efb\u4f55\u6587\u4ef6\uff08\u5373\u4f7f\u5728 <code>model_config</code> \u7c7b\u4e2d\u8bbe\u7f6e\u4e86\u6587\u4ef6\uff09\uff0c\u901a\u8fc7\u4f20\u9012 <code>None</code> \u4f5c\u4e3a\u5b9e\u4f8b\u5316\u5173\u952e\u5b57\u53c2\u6570\uff0c\u4f8b\u5982 <code>settings = Settings(_env_file=None)</code>\u3002</p> <p>\u7531\u4e8e\u4f7f\u7528 python-dotenv \u6765\u89e3\u6790\u6587\u4ef6\uff0c\u53ef\u4ee5\u4f7f\u7528\u7c7b\u4f3c bash \u7684\u8bed\u4e49\uff0c\u5982 <code>export</code>\uff0c \uff08\u53d6\u51b3\u4e8e\u4f60\u7684\u64cd\u4f5c\u7cfb\u7edf\u548c\u73af\u5883\uff09\u53ef\u80fd\u5141\u8bb8\u4f60\u7684 dotenv \u6587\u4ef6\u4e5f\u4e0e <code>source</code> \u4e00\u8d77\u4f7f\u7528\uff0c \u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 python-dotenv \u7684\u6587\u6863\u3002</p> <p>Pydantic settings \u5728 dotenv \u6587\u4ef6\u7684\u60c5\u51b5\u4e0b\u4f1a\u8003\u8651 <code>extra</code> \u914d\u7f6e\u3002\u8fd9\u610f\u5473\u7740\u5982\u679c\u4f60\u5728 <code>model_config</code> \u4e0a\u8bbe\u7f6e <code>extra=forbid</code>\uff08\u9ed8\u8ba4\uff09 \u5e76\u4e14\u4f60\u7684 dotenv \u6587\u4ef6\u5305\u542b\u672a\u5728\u8bbe\u7f6e\u6a21\u578b\u4e2d\u5b9a\u4e49\u7684\u5b57\u6bb5\u7684\u6761\u76ee\uff0c \u5b83\u5c06\u5728\u8bbe\u7f6e\u6784\u9020\u65f6\u5f15\u53d1 <code>ValidationError</code>\u3002</p> <p>\u4e3a\u4e86\u4e0e pydantic 1.x BaseSettings \u517c\u5bb9\uff0c\u4f60\u5e94\u8be5\u4f7f\u7528 <code>extra=ignore</code>\uff1a <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file='.env', extra='ignore')\n</code></pre></p> <p>Note</p> <p>Pydantic settings \u4ece dotenv \u6587\u4ef6\u52a0\u8f7d\u6240\u6709\u503c\u5e76\u5c06\u5176\u4f20\u9012\u7ed9\u6a21\u578b\uff0c\u65e0\u8bba\u6a21\u578b\u7684 <code>env_prefix</code> \u5982\u4f55\u3002 \u56e0\u6b64\uff0c\u5982\u679c\u4f60\u5728 dotenv \u6587\u4ef6\u4e2d\u63d0\u4f9b\u989d\u5916\u503c\uff0c\u65e0\u8bba\u5b83\u4eec\u662f\u5426\u4ee5 <code>env_prefix</code> \u5f00\u5934\uff0c \u90fd\u4f1a\u5f15\u53d1 <code>ValidationError</code>\u3002</p>"},{"location":"concepts/pydantic_settings/#command-line-support","title":"\u547d\u4ee4\u884c\u652f\u6301","text":"<p>Pydantic settings \u63d0\u4f9b\u96c6\u6210\u7684 CLI \u652f\u6301\uff0c\u4f7f\u5f97\u4f7f\u7528 Pydantic \u6a21\u578b\u5feb\u901f\u5b9a\u4e49 CLI \u5e94\u7528\u7a0b\u5e8f\u53d8\u5f97\u5bb9\u6613\u3002 Pydantic settings CLI \u6709\u4e24\u4e2a\u4e3b\u8981\u7528\u4f8b\uff1a</p> <ol> <li>\u4f7f\u7528 CLI \u8986\u76d6 Pydantic \u6a21\u578b\u4e2d\u7684\u5b57\u6bb5\u3002</li> <li>\u4f7f\u7528 Pydantic \u6a21\u578b\u5b9a\u4e49 CLI\u3002</li> </ol> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u4f53\u9a8c\u662f\u9488\u5bf9\u7528\u4f8b #1 \u91cf\u8eab\u5b9a\u5236\u7684\uff0c\u5e76\u5efa\u7acb\u5728 \u89e3\u6790\u73af\u5883\u53d8\u91cf \u4e2d\u5efa\u7acb\u7684\u57fa\u7840\u4e0a\u3002 \u5982\u679c\u4f60\u7684\u7528\u4f8b\u4e3b\u8981\u5c5e\u4e8e #2\uff0c\u4f60\u53ef\u80fd\u5e0c\u671b\u542f\u7528 \u521b\u5efa CLI \u5e94\u7528\u7a0b\u5e8f \u672b\u5c3e\u6982\u8ff0\u7684\u5927\u591a\u6570\u9ed8\u8ba4\u8bbe\u7f6e\u3002</p>"},{"location":"concepts/pydantic_settings/#_7","title":"\u57fa\u7840","text":"<p>\u5f00\u59cb\u4e4b\u524d\uff0c\u8ba9\u6211\u4eec\u91cd\u65b0\u5ba1\u89c6 \u89e3\u6790\u73af\u5883\u53d8\u91cf \u4e2d\u63d0\u4f9b\u7684\u793a\u4f8b\uff0c\u4f46\u4f7f\u7528 Pydantic settings CLI\uff1a</p> <pre><code>import sys\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass DeepSubModel(BaseModel):\n    v4: str\n\n\nclass SubModel(BaseModel):\n    v1: str\n    v2: bytes\n    v3: int\n    deep: DeepSubModel\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(cli_parse_args=True)\n\n    v0: str\n    sub_model: SubModel\n\n\nsys.argv = [\n    'example.py',\n    '--v0=0',\n    '--sub_model={\"v1\": \"json-1\", \"v2\": \"json-2\"}',\n    '--sub_model.v2=nested-2',\n    '--sub_model.v3=3',\n    '--sub_model.deep.v4=v4',\n]\n\nprint(Settings().model_dump())\n\"\"\"\n{\n    'v0': '0',\n    'sub_model': {'v1': 'json-1', 'v2': b'nested-2', 'v3': 3, 'deep': {'v4': 'v4'}},\n}\n\"\"\"\n</code></pre> <p>\u8981\u542f\u7528 CLI \u89e3\u6790\uff0c\u6211\u4eec\u53ea\u9700\u5c06 <code>cli_parse_args</code> \u6807\u5fd7\u8bbe\u7f6e\u4e3a\u6709\u6548\u503c\uff0c\u8fd9\u4fdd\u7559\u4e86\u4e0e <code>argparse</code> \u4e2d\u5b9a\u4e49\u7684\u517c\u5bb9\u6027\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0cCLI \u8bbe\u7f6e\u6e90\u9ed8\u8ba4\u662f \u6700\u9ad8\u4f18\u5148\u7ea7\u7684\u6e90\uff0c\u9664\u975e\u5176 \u4f18\u5148\u7ea7\u503c\u88ab\u81ea\u5b9a\u4e49\uff1a</p> <pre><code>import os\nimport sys\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliSettingsSource,\n    PydanticBaseSettingsSource,\n)\n\n\nclass Settings(BaseSettings):\n    my_foo: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return env_settings, CliSettingsSource(settings_cls, cli_parse_args=True)\n\n\nos.environ['MY_FOO'] = 'from environment'\n\nsys.argv = ['example.py', '--my_foo=from cli']\n\nprint(Settings().model_dump())\n#&gt; {'my_foo': 'from environment'}\n</code></pre>"},{"location":"concepts/pydantic_settings/#_8","title":"\u5217\u8868","text":"<p>CLI \u53c2\u6570\u89e3\u6790\u5217\u8868\u652f\u6301\u6df7\u5408\u4f7f\u7528\u4ee5\u4e0b\u4e09\u79cd\u6837\u5f0f\u4e2d\u7684\u4efb\u4f55\u4e00\u79cd\uff1a</p> <ul> <li>JSON \u6837\u5f0f <code>--field='[1,2]'</code></li> <li>Argparse \u6837\u5f0f <code>--field 1 --field 2</code></li> <li>\u61d2\u4eba\u6837\u5f0f <code>--field=1,2</code></li> </ul> <pre><code>import sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    my_list: list[int]\n\n\nsys.argv = ['example.py', '--my_list', '[1,2]']\nprint(Settings().model_dump())\n#&gt; {'my_list': [1, 2]}\n\nsys.argv = ['example.py', '--my_list', '1', '--my_list', '2']\nprint(Settings().model_dump())\n#&gt; {'my_list': [1, 2]}\n\nsys.argv = ['example.py', '--my_list', '1,2']\nprint(Settings().model_dump())\n#&gt; {'my_list': [1, 2]}\n</code></pre>"},{"location":"concepts/pydantic_settings/#_9","title":"\u5b57\u5178","text":"<p>CLI \u53c2\u6570\u89e3\u6790\u5b57\u5178\u652f\u6301\u6df7\u5408\u4f7f\u7528\u4ee5\u4e0b\u4e24\u79cd\u6837\u5f0f\u4e2d\u7684\u4efb\u4f55\u4e00\u79cd\uff1a</p> <ul> <li>JSON \u6837\u5f0f <code>--field='{\"k1\": 1, \"k2\": 2}'</code></li> <li>\u73af\u5883\u53d8\u91cf\u6837\u5f0f <code>--field k1=1 --field k2=2</code></li> </ul> <p>\u8fd9\u4e9b\u4e5f\u53ef\u4ee5\u4e0e\u5217\u8868\u5f62\u5f0f\u7ed3\u5408\u4f7f\u7528\uff0c\u4f8b\u5982\uff1a</p> <ul> <li><code>--field k1=1,k2=2 --field k3=3 --field '{\"k4\": 4}'</code> \u7b49</li> </ul> <pre><code>import sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    my_dict: dict[str, int]\n\n\nsys.argv = ['example.py', '--my_dict', '{\"k1\":1,\"k2\":2}']\nprint(Settings().model_dump())\n#&gt; {'my_dict': {'k1': 1, 'k2': 2}}\n\nsys.argv = ['example.py', '--my_dict', 'k1=1', '--my_dict', 'k2=2']\nprint(Settings().model_dump())\n#&gt; {'my_dict': {'k1': 1, 'k2': 2}}\n</code></pre>"},{"location":"concepts/pydantic_settings/#_10","title":"\u5b57\u9762\u91cf\u548c\u679a\u4e3e","text":"<p>CLI \u53c2\u6570\u89e3\u6790\u5b57\u9762\u91cf\u548c\u679a\u4e3e\u4f1a\u88ab\u8f6c\u6362\u4e3a CLI \u9009\u9879\u3002</p> <pre><code>import sys\nfrom enum import IntEnum\nfrom typing import Literal\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Fruit(IntEnum):\n    pear = 0\n    kiwi = 1\n    lime = 2\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    fruit: Fruit\n    pet: Literal['dog', 'cat', 'bird']\n\n\nsys.argv = ['example.py', '--fruit', 'lime', '--pet', 'cat']\nprint(Settings().model_dump())\n#&gt; {'fruit': &lt;Fruit.lime: 2&gt;, 'pet': 'cat'}\n</code></pre>"},{"location":"concepts/pydantic_settings/#_11","title":"\u522b\u540d","text":"<p>Pydantic \u5b57\u6bb5\u522b\u540d\u4f1a\u4f5c\u4e3a CLI \u53c2\u6570\u522b\u540d\u6dfb\u52a0\u3002\u957f\u5ea6\u4e3a1\u7684\u522b\u540d\u4f1a\u88ab\u8f6c\u6362\u4e3a\u77ed\u9009\u9879\u3002</p> <pre><code>import sys\n\nfrom pydantic import AliasChoices, AliasPath, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass User(BaseSettings, cli_parse_args=True):\n    first_name: str = Field(\n        validation_alias=AliasChoices('f', 'fname', AliasPath('name', 0))\n    )\n    last_name: str = Field(\n        validation_alias=AliasChoices('l', 'lname', AliasPath('name', 1))\n    )\n\n\nsys.argv = ['example.py', '--fname', 'John', '--lname', 'Doe']\nprint(User().model_dump())\n#&gt; {'first_name': 'John', 'last_name': 'Doe'}\n\nsys.argv = ['example.py', '-f', 'John', '-l', 'Doe']\nprint(User().model_dump())\n#&gt; {'first_name': 'John', 'last_name': 'Doe'}\n\nsys.argv = ['example.py', '--name', 'John,Doe']\nprint(User().model_dump())\n#&gt; {'first_name': 'John', 'last_name': 'Doe'}\n\nsys.argv = ['example.py', '--name', 'John', '--lname', 'Doe']\nprint(User().model_dump())\n#&gt; {'first_name': 'John', 'last_name': 'Doe'}\n</code></pre>"},{"location":"concepts/pydantic_settings/#_12","title":"\u5b50\u547d\u4ee4\u548c\u4f4d\u7f6e\u53c2\u6570","text":"<p>\u5b50\u547d\u4ee4\u548c\u4f4d\u7f6e\u53c2\u6570\u4f7f\u7528 <code>CliSubCommand</code> \u548c <code>CliPositionalArg</code> \u6ce8\u89e3\u6765\u8868\u793a\u3002 \u5b50\u547d\u4ee4\u6ce8\u89e3\u53ea\u80fd\u5e94\u7528\u4e8e\u5fc5\u9700\u5b57\u6bb5\uff08\u5373\u6ca1\u6709\u9ed8\u8ba4\u503c\u7684\u5b57\u6bb5\uff09\u3002 \u6b64\u5916\uff0c\u5b50\u547d\u4ee4\u5fc5\u987b\u662f\u6d3e\u751f\u81ea pydantic <code>BaseModel</code> \u6216 pydantic.dataclasses <code>dataclass</code> \u7684\u6709\u6548\u7c7b\u578b\u3002</p> <p>\u89e3\u6790\u540e\u7684\u5b50\u547d\u4ee4\u53ef\u4ee5\u4f7f\u7528 <code>get_subcommand</code> \u5b9e\u7528\u51fd\u6570\u4ece\u6a21\u578b\u5b9e\u4f8b\u4e2d\u68c0\u7d22\u3002\u5982\u679c\u5b50\u547d\u4ee4\u4e0d\u662f\u5fc5\u9700\u7684\uff0c\u5c06 <code>is_required</code> \u6807\u5fd7\u8bbe\u7f6e\u4e3a <code>False</code> \u4ee5\u5728\u672a\u627e\u5230\u5b50\u547d\u4ee4\u65f6\u7981\u7528\u9519\u8bef\u629b\u51fa\u3002</p> <p>Note</p> <p>CLI \u8bbe\u7f6e\u5b50\u547d\u4ee4\u6bcf\u4e2a\u6a21\u578b\u4ec5\u9650\u4e8e\u5355\u4e2a\u5b50\u89e3\u6790\u5668\u3002\u6362\u53e5\u8bdd\u8bf4\uff0c\u6a21\u578b\u7684\u6240\u6709\u5b50\u547d\u4ee4\u90fd\u5206\u7ec4\u5728\u5355\u4e2a\u5b50\u89e3\u6790\u5668\u4e0b\uff1b\u5b83\u4e0d\u5141\u8bb8\u6bcf\u4e2a\u5b50\u89e3\u6790\u5668\u62e5\u6709\u81ea\u5df1\u7684\u5b50\u547d\u4ee4\u96c6\u7684\u591a\u4e2a\u5b50\u89e3\u6790\u5668\u3002\u6709\u5173\u5b50\u89e3\u6790\u5668\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 argparse \u5b50\u547d\u4ee4\u3002</p> <p>Note</p> <p><code>CliSubCommand</code> \u548c <code>CliPositionalArg</code> \u59cb\u7ec8\u533a\u5206\u5927\u5c0f\u5199\u3002</p> <pre><code>import sys\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliPositionalArg,\n    CliSubCommand,\n    SettingsError,\n    get_subcommand,\n)\n\n\nclass Init(BaseModel):\n    directory: CliPositionalArg[str]\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n\nclass Git(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n    clone: CliSubCommand[Clone]\n    init: CliSubCommand[Init]\n\n\n# Run without subcommands\nsys.argv = ['example.py']\ncmd = Git()\nassert cmd.model_dump() == {'clone': None, 'init': None}\n\ntry:\n    # Will raise an error since no subcommand was provided\n    get_subcommand(cmd).model_dump()\nexcept SettingsError as err:\n    assert str(err) == 'Error: CLI subcommand is required {clone, init}'\n\n# Will not raise an error since subcommand is not required\nassert get_subcommand(cmd, is_required=False) is None\n\n\n# Run the clone subcommand\nsys.argv = ['example.py', 'clone', 'repo', 'dest']\ncmd = Git()\nassert cmd.model_dump() == {\n    'clone': {'repository': 'repo', 'directory': 'dest'},\n    'init': None,\n}\n\n# Returns the subcommand model instance (in this case, 'clone')\nassert get_subcommand(cmd).model_dump() == {\n    'directory': 'dest',\n    'repository': 'repo',\n}\n</code></pre> <p><code>CliSubCommand</code> \u548c <code>CliPositionalArg</code> \u6ce8\u89e3\u4e5f\u652f\u6301\u8054\u5408\u64cd\u4f5c\u548c\u522b\u540d\u3002\u5bf9\u4e8e Pydantic \u6a21\u578b\u7684\u8054\u5408\uff0c\u91cd\u8981\u7684\u662f\u8981\u8bb0\u4f4f\u9a8c\u8bc1\u8fc7\u7a0b\u4e2d\u53ef\u80fd\u51fa\u73b0\u7684 \u7ec6\u5fae\u5dee\u522b\u3002\u5177\u4f53\u6765\u8bf4\uff0c\u5bf9\u4e8e\u5185\u5bb9\u76f8\u540c\u7684\u5b50\u547d\u4ee4\u8054\u5408\uff0c\u5efa\u8bae\u5c06\u5b83\u4eec\u5206\u89e3\u4e3a\u5355\u72ec\u7684 <code>CliSubCommand</code> \u5b57\u6bb5\u4ee5\u907f\u514d\u4efb\u4f55\u590d\u6742\u6027\u3002\u6700\u540e\uff0c\u4ece\u8054\u5408\u6d3e\u751f\u7684\u5b50\u547d\u4ee4\u540d\u79f0\u5c06\u662f Pydantic \u6a21\u578b\u7c7b\u672c\u8eab\u7684\u540d\u79f0\u3002</p> <p>\u5f53\u4e3a <code>CliSubCommand</code> \u6216 <code>CliPositionalArg</code> \u5b57\u6bb5\u5206\u914d\u522b\u540d\u65f6\uff0c\u53ea\u80fd\u5206\u914d\u5355\u4e2a\u522b\u540d\u3002\u5bf9\u4e8e\u975e\u8054\u5408\u5b50\u547d\u4ee4\uff0c\u522b\u540d\u5c06\u66f4\u6539\u663e\u793a\u7684\u5e2e\u52a9\u6587\u672c\u548c\u5b50\u547d\u4ee4\u540d\u79f0\u3002\u76f8\u53cd\uff0c\u5bf9\u4e8e\u8054\u5408\u5b50\u547d\u4ee4\uff0c\u4ece CLI \u8bbe\u7f6e\u6e90\u7684\u89d2\u5ea6\u6765\u770b\uff0c\u522b\u540d\u4e0d\u4f1a\u6709\u5b9e\u9645\u6548\u679c\u3002\u6700\u540e\uff0c\u5bf9\u4e8e\u4f4d\u7f6e\u53c2\u6570\uff0c\u522b\u540d\u5c06\u66f4\u6539\u5b57\u6bb5\u663e\u793a\u7684 CLI \u5e2e\u52a9\u6587\u672c\u3002</p> <pre><code>import sys\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliPositionalArg,\n    CliSubCommand,\n    get_subcommand,\n)\n\n\nclass Alpha(BaseModel):\n    \"\"\"Apha Help\"\"\"\n\n    cmd_alpha: CliPositionalArg[str] = Field(alias='alpha-cmd')\n\n\nclass Beta(BaseModel):\n    \"\"\"Beta Help\"\"\"\n\n    opt_beta: str = Field(alias='opt-beta')\n\n\nclass Gamma(BaseModel):\n    \"\"\"Gamma Help\"\"\"\n\n    opt_gamma: str = Field(alias='opt-gamma')\n\n\nclass Root(BaseSettings, cli_parse_args=True, cli_exit_on_error=False):\n    alpha_or_beta: CliSubCommand[Union[Alpha, Beta]] = Field(alias='alpha-or-beta-cmd')\n    gamma: CliSubCommand[Gamma] = Field(alias='gamma-cmd')\n\n\nsys.argv = ['example.py', 'Alpha', 'hello']\nassert get_subcommand(Root()).model_dump() == {'cmd_alpha': 'hello'}\n\nsys.argv = ['example.py', 'Beta', '--opt-beta=hey']\nassert get_subcommand(Root()).model_dump() == {'opt_beta': 'hey'}\n\nsys.argv = ['example.py', 'gamma-cmd', '--opt-gamma=hi']\nassert get_subcommand(Root()).model_dump() == {'opt_gamma': 'hi'}\n</code></pre>"},{"location":"concepts/pydantic_settings/#creating-cli-applications","title":"\u521b\u5efa CLI \u5e94\u7528\u7a0b\u5e8f","text":"<p><code>CliApp</code> \u7c7b\u63d0\u4f9b\u4e86\u4e24\u4e2a\u5b9e\u7528\u65b9\u6cd5\uff0c<code>CliApp.run</code> \u548c <code>CliApp.run_subcommand</code>\uff0c\u53ef\u7528\u4e8e\u5c06 Pydantic <code>BaseSettings</code>\u3001<code>BaseModel</code> \u6216 <code>pydantic.dataclasses.dataclass</code> \u4f5c\u4e3a CLI \u5e94\u7528\u7a0b\u5e8f\u8fd0\u884c\u3002\u8fd9\u4e9b\u65b9\u6cd5\u4e3b\u8981\u4e3a\u8fd0\u884c\u4e0e\u6a21\u578b\u5173\u8054\u7684 <code>cli_cmd</code> \u65b9\u6cd5\u63d0\u4f9b\u7ed3\u6784\u3002</p> <p><code>CliApp.run</code> \u53ef\u7528\u4e8e\u76f4\u63a5\u63d0\u4f9b\u8981\u89e3\u6790\u7684 <code>cli_args</code>\uff0c\u5e76\u5728\u5b9e\u4f8b\u5316\u540e\u8fd0\u884c\u6a21\u578b\u7684 <code>cli_cmd</code> \u65b9\u6cd5\uff08\u5982\u679c\u5df2\u5b9a\u4e49\uff09\uff1a</p> <pre><code>from pydantic_settings import BaseSettings, CliApp\n\n\nclass Settings(BaseSettings):\n    this_foo: str\n\n    def cli_cmd(self) -&gt; None:\n        # Print the parsed data\n        print(self.model_dump())\n        #&gt; {'this_foo': 'is such a foo'}\n\n        # Update the parsed data showing cli_cmd ran\n        self.this_foo = 'ran the foo cli cmd'\n\n\ns = CliApp.run(Settings, cli_args=['--this_foo', 'is such a foo'])\nprint(s.model_dump())\n#&gt; {'this_foo': 'ran the foo cli cmd'}\n</code></pre> <p>\u7c7b\u4f3c\u5730\uff0c<code>CliApp.run_subcommand</code> \u53ef\u4ee5\u4ee5\u9012\u5f52\u65b9\u5f0f\u7528\u4e8e\u8fd0\u884c\u5b50\u547d\u4ee4\u7684 <code>cli_cmd</code> \u65b9\u6cd5\uff1a</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import CliApp, CliPositionalArg, CliSubCommand\n\n\nclass Init(BaseModel):\n    directory: CliPositionalArg[str]\n\n    def cli_cmd(self) -&gt; None:\n        print(f'git init \"{self.directory}\"')\n        #&gt; git init \"dir\"\n        self.directory = 'ran the git init cli cmd'\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n    def cli_cmd(self) -&gt; None:\n        print(f'git clone from \"{self.repository}\" into \"{self.directory}\"')\n        self.directory = 'ran the clone cli cmd'\n\n\nclass Git(BaseModel):\n    clone: CliSubCommand[Clone]\n    init: CliSubCommand[Init]\n\n    def cli_cmd(self) -&gt; None:\n        CliApp.run_subcommand(self)\n\n\ncmd = CliApp.run(Git, cli_args=['init', 'dir'])\nassert cmd.model_dump() == {\n    'clone': None,\n    'init': {'directory': 'ran the git init cli cmd'},\n}\n</code></pre> <p>Note</p> <p>\u4e0e <code>CliApp.run</code> \u4e0d\u540c\uff0c<code>CliApp.run_subcommand</code> \u8981\u6c42\u5b50\u547d\u4ee4\u6a21\u578b\u5177\u6709\u5df2\u5b9a\u4e49\u7684 <code>cli_cmd</code> \u65b9\u6cd5\u3002</p> <p>\u5bf9\u4e8e <code>BaseModel</code> \u548c <code>pydantic.dataclasses.dataclass</code> \u7c7b\u578b\uff0c<code>CliApp.run</code> \u5c06\u5728\u5185\u90e8\u4f7f\u7528\u4ee5\u4e0b <code>BaseSettings</code> \u914d\u7f6e\u9ed8\u8ba4\u503c\uff1a</p> <ul> <li><code>nested_model_default_partial_update=True</code></li> <li><code>case_sensitive=True</code></li> <li><code>cli_hide_none_type=True</code></li> <li><code>cli_avoid_json=True</code></li> <li><code>cli_enforce_required=True</code></li> <li><code>cli_implicit_flags=True</code></li> <li><code>cli_kebab_case=True</code></li> </ul>"},{"location":"concepts/pydantic_settings/#cli","title":"\u5f02\u6b65 CLI \u547d\u4ee4","text":"<p>Pydantic settings \u652f\u6301\u901a\u8fc7 <code>CliApp.run</code> \u548c <code>CliApp.run_subcommand</code> \u8fd0\u884c\u5f02\u6b65 CLI \u547d\u4ee4\u3002\u901a\u8fc7\u6b64\u529f\u80fd\uff0c\u4f60\u53ef\u4ee5\u5728 Pydantic \u6a21\u578b\uff08\u5305\u62ec\u5b50\u547d\u4ee4\uff09\u4e2d\u5b9a\u4e49 async def \u65b9\u6cd5\uff0c\u5e76\u8ba9\u5b83\u4eec\u50cf\u540c\u6b65\u5bf9\u5e94\u9879\u4e00\u6837\u6267\u884c\u3002\u5177\u4f53\u6765\u8bf4\uff1a</p> <ol> <li>\u652f\u6301\u5f02\u6b65\u65b9\u6cd5\uff1a\u4f60\u73b0\u5728\u53ef\u4ee5\u5c06 cli_cmd \u6216\u7c7b\u4f3c\u7684 CLI \u5165\u53e3\u70b9\u65b9\u6cd5\u6807\u8bb0\u4e3a async def\uff0c\u5e76\u8ba9 CliApp \u6267\u884c\u5b83\u4eec\u3002</li> <li>\u5b50\u547d\u4ee4\u4e5f\u53ef\u4ee5\u662f\u5f02\u6b65\u7684\uff1a\u5982\u679c\u4f60\u6709\u5d4c\u5957\u7684 CLI \u5b50\u547d\u4ee4\uff0c\u6700\u7ec8\uff08\u6700\u4f4e\u7ea7\u522b\uff09\u7684\u5b50\u547d\u4ee4\u65b9\u6cd5\u540c\u6837\u53ef\u4ee5\u662f\u5f02\u6b65\u7684\u3002</li> <li>\u5c06\u5f02\u6b65\u65b9\u6cd5\u9650\u5236\u5728\u6700\u7ec8\u5b50\u547d\u4ee4\uff1a\u4e0d\u5efa\u8bae\u5c06\u7236\u547d\u4ee4\u5b9a\u4e49\u4e3a\u5f02\u6b65\uff0c\u56e0\u4e3a\u8fd9\u53ef\u80fd\u5bfc\u81f4\u521b\u5efa\u989d\u5916\u7684\u7ebf\u7a0b\u548c\u4e8b\u4ef6\u5faa\u73af\u3002\u4e3a\u4e86\u83b7\u5f97\u6700\u4f73\u6027\u80fd\u5e76\u907f\u514d\u4e0d\u5fc5\u8981\u7684\u8d44\u6e90\u4f7f\u7528\uff0c\u53ea\u5b9e\u73b0\u6700\u6df1\u5c42\u7684\uff08\u5b50\uff09\u5b50\u547d\u4ee4\u4e3a async def\u3002</li> </ol> <p>\u4e0b\u9762\u662f\u4e00\u4e2a\u6f14\u793a\u5f02\u6b65\u9876\u7ea7\u547d\u4ee4\u7684\u7b80\u5355\u793a\u4f8b\uff1a</p> <pre><code>from pydantic_settings import BaseSettings, CliApp\n\n\nclass AsyncSettings(BaseSettings):\n    async def cli_cmd(self) -&gt; None:\n        print('Hello from an async CLI method!')\n        #&gt; Hello from an async CLI method!\n\n\n# If an event loop is already running, a new thread will be used;\n# otherwise, asyncio.run() is used to execute this async method.\nassert CliApp.run(AsyncSettings, cli_args=[]).model_dump() == {}\n</code></pre>"},{"location":"concepts/pydantic_settings/#_13","title":"\u5f02\u6b65\u5b50\u547d\u4ee4","text":"<p>\u5982\u4e0a\u6240\u8ff0\uff0c\u4f60\u4e5f\u53ef\u4ee5\u5c06\u5b50\u547d\u4ee4\u5b9a\u4e49\u4e3a\u5f02\u6b65\u3002\u4f46\u662f\uff0c\u4ec5\u5728\u53f6\u5b50\uff08\u6700\u4f4e\u7ea7\u522b\uff09\u5b50\u547d\u4ee4\u4e2d\u8fd9\u6837\u505a\uff0c\u4ee5\u907f\u514d\u5728\u7236\u547d\u4ee4\u4e2d\u4e0d\u5fc5\u8981\u5730\u751f\u6210\u65b0\u7ebf\u7a0b\u548c\u4e8b\u4ef6\u5faa\u73af\uff1a</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    CliApp,\n    CliPositionalArg,\n    CliSubCommand,\n)\n\n\nclass Clone(BaseModel):\n    repository: CliPositionalArg[str]\n    directory: CliPositionalArg[str]\n\n    async def cli_cmd(self) -&gt; None:\n        # Perform async tasks here, e.g. network or I/O operations\n        print(f'Cloning async from \"{self.repository}\" into \"{self.directory}\"')\n        #&gt; Cloning async from \"repo\" into \"dir\"\n\n\nclass Git(BaseSettings):\n    clone: CliSubCommand[Clone]\n\n    def cli_cmd(self) -&gt; None:\n        # Run the final subcommand (clone/init). It is recommended to define async methods only at the deepest level.\n        CliApp.run_subcommand(self)\n\n\nCliApp.run(Git, cli_args=['clone', 'repo', 'dir']).model_dump() == {\n    'repository': 'repo',\n    'directory': 'dir',\n}\n</code></pre> <p>\u5f53\u6267\u884c\u5177\u6709\u5f02\u6b65 cli_cmd \u7684\u5b50\u547d\u4ee4\u65f6\uff0cPydantic settings \u4f1a\u81ea\u52a8\u68c0\u6d4b\u5f53\u524d\u7ebf\u7a0b\u662f\u5426\u5df2\u6709\u6d3b\u52a8\u7684\u4e8b\u4ef6\u5faa\u73af\u3002\u5982\u679c\u6709\uff0c\u5f02\u6b65\u547d\u4ee4\u5c06\u5728\u65b0\u7ebf\u7a0b\u4e2d\u8fd0\u884c\u4ee5\u907f\u514d\u51b2\u7a81\u3002\u5426\u5219\uff0c\u5b83\u5c06\u5728\u5f53\u524d\u7ebf\u7a0b\u4e2d\u4f7f\u7528 asyncio.run()\u3002\u8fd9\u79cd\u5904\u7406\u786e\u4fdd\u4f60\u7684\u5f02\u6b65\u5b50\u547d\u4ee4\"\u6b63\u5e38\u5de5\u4f5c\"\uff0c\u65e0\u9700\u989d\u5916\u7684\u624b\u52a8\u8bbe\u7f6e\u3002</p>"},{"location":"concepts/pydantic_settings/#cli_1","title":"\u5e8f\u5217\u5316 CLI \u53c2\u6570","text":"<p>\u53ef\u4ee5\u4f7f\u7528 <code>CliApp.serialize</code> \u65b9\u6cd5\u5c06\u5b9e\u4f8b\u5316\u7684 Pydantic \u6a21\u578b\u5e8f\u5217\u5316\u4e3a\u5176 CLI \u53c2\u6570\u3002</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import CliApp\n\n\nclass Nested(BaseModel):\n    that: int\n\n\nclass Settings(BaseModel):\n    this: str\n    nested: Nested\n\n\nprint(CliApp.serialize(Settings(this='hello', nested=Nested(that=123))))\n#&gt; ['--this', 'hello', '--nested.that', '123']\n</code></pre>"},{"location":"concepts/pydantic_settings/#_14","title":"\u4e92\u65a5\u7ec4","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u7ee7\u627f <code>CliMutuallyExclusiveGroup</code> \u7c7b\u6765\u521b\u5efa CLI \u4e92\u65a5\u7ec4\u3002</p> <p>Note</p> <p><code>CliMutuallyExclusiveGroup</code> \u4e0d\u80fd\u5728\u8054\u5408\u4e2d\u4f7f\u7528\uff0c\u4e5f\u4e0d\u80fd\u5305\u542b\u5d4c\u5957\u6a21\u578b\u3002</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import CliApp, CliMutuallyExclusiveGroup, SettingsError\n\n\nclass Circle(CliMutuallyExclusiveGroup):\n    radius: Optional[float] = None\n    diameter: Optional[float] = None\n    perimeter: Optional[float] = None\n\n\nclass Settings(BaseModel):\n    circle: Circle\n\n\ntry:\n    CliApp.run(\n        Settings,\n        cli_args=['--circle.radius=1', '--circle.diameter=2'],\n        cli_exit_on_error=False,\n    )\nexcept SettingsError as e:\n    print(e)\n    \"\"\"\n    error parsing CLI: argument --circle.diameter: not allowed with argument --circle.radius\n    \"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_2","title":"\u81ea\u5b9a\u4e49 CLI \u4f53\u9a8c","text":"<p>\u4ee5\u4e0b\u6807\u5fd7\u53ef\u7528\u4e8e\u6839\u636e\u4f60\u7684\u9700\u6c42\u81ea\u5b9a\u4e49 CLI \u4f53\u9a8c\u3002</p>"},{"location":"concepts/pydantic_settings/#_15","title":"\u66f4\u6539\u663e\u793a\u7684\u7a0b\u5e8f\u540d\u79f0","text":"<p>\u901a\u8fc7\u8bbe\u7f6e <code>cli_prog_name</code> \u6765\u66f4\u6539\u5e2e\u52a9\u6587\u672c\u4f7f\u7528\u4e2d\u663e\u793a\u7684\u9ed8\u8ba4\u7a0b\u5e8f\u540d\u79f0\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5b83\u5c06\u4ece <code>sys.argv[0]</code> \u6d3e\u751f\u5f53\u524d\u6b63\u5728\u6267\u884c\u7684\u7a0b\u5e8f\u7684\u540d\u79f0\uff0c\u5c31\u50cf argparse \u4e00\u6837\u3002</p> <pre><code>import sys\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_prog_name='appdantic'):\n    pass\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #&gt; 0\n\"\"\"\nusage: appdantic [-h]\n\noptions:\n  -h, --help  \u663e\u793a\u6b64\u5e2e\u52a9\u4fe1\u606f\u5e76\u9000\u51fa\n\"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_3","title":"CLI \u5e03\u5c14\u6807\u5fd7","text":"<p>\u4f7f\u7528 <code>cli_implicit_flags</code> \u8bbe\u7f6e\u6765\u66f4\u6539\u5e03\u5c14\u5b57\u6bb5\u9ed8\u8ba4\u5e94\u8be5\u662f\u663e\u5f0f\u8fd8\u662f\u9690\u5f0f\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5e03\u5c14\u5b57\u6bb5\u662f\"\u663e\u5f0f\"\u7684\uff0c\u610f\u5473\u7740\u5fc5\u987b\u5728 CLI \u4e0a\u663e\u5f0f\u63d0\u4f9b\u5e03\u5c14\u503c\uff0c\u4f8b\u5982 <code>--flag=True</code>\u3002\u76f8\u53cd\uff0c\"\u9690\u5f0f\"\u7684\u5e03\u5c14\u5b57\u6bb5\u4ece\u6807\u5fd7\u672c\u8eab\u6d3e\u751f\u503c\uff0c\u4f8b\u5982 <code>--flag,--no-flag</code>\uff0c\u8fd9\u6d88\u9664\u4e86\u4f20\u9012\u663e\u5f0f\u503c\u7684\u9700\u8981\u3002</p> <p>\u6b64\u5916\uff0c\u63d0\u4f9b\u7684 <code>CliImplicitFlag</code> \u548c <code>CliExplicitFlag</code> \u6ce8\u89e3\u53ef\u4ee5\u5728\u9700\u8981\u65f6\u7528\u4e8e\u66f4\u7ec6\u7c92\u5ea6\u7684\u63a7\u5236\u3002</p> <pre><code>from pydantic_settings import BaseSettings, CliExplicitFlag, CliImplicitFlag\n\n\nclass ExplicitSettings(BaseSettings, cli_parse_args=True):\n    \"\"\"Boolean fields are explicit by default.\"\"\"\n\n    explicit_req: bool\n    \"\"\"\n    --explicit_req bool   (required)\n    \"\"\"\n\n    explicit_opt: bool = False\n    \"\"\"\n    --explicit_opt bool   (default: False)\n    \"\"\"\n\n    # Booleans are explicit by default, so must override implicit flags with annotation\n    implicit_req: CliImplicitFlag[bool]\n    \"\"\"\n    --implicit_req, --no-implicit_req (required)\n    \"\"\"\n\n    implicit_opt: CliImplicitFlag[bool] = False\n    \"\"\"\n    --implicit_opt, --no-implicit_opt (default: False)\n    \"\"\"\n\n\nclass ImplicitSettings(BaseSettings, cli_parse_args=True, cli_implicit_flags=True):\n    \"\"\"With cli_implicit_flags=True, boolean fields are implicit by default.\"\"\"\n\n    # Booleans are implicit by default, so must override explicit flags with annotation\n    explicit_req: CliExplicitFlag[bool]\n    \"\"\"\n    --explicit_req bool   (required)\n    \"\"\"\n\n    explicit_opt: CliExplicitFlag[bool] = False\n    \"\"\"\n    --explicit_opt bool   (default: False)\n    \"\"\"\n\n    implicit_req: bool\n    \"\"\"\n    --implicit_req, --no-implicit_req (required)\n    \"\"\"\n\n    implicit_opt: bool = False\n    \"\"\"\n    --implicit_opt, --no-implicit_opt (default: False)\n    \"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#_16","title":"\u5ffd\u7565\u548c\u68c0\u7d22\u672a\u77e5\u53c2\u6570","text":"<p>\u4f7f\u7528 <code>cli_ignore_unknown_args</code> \u6765\u66f4\u6539\u662f\u5426\u5ffd\u7565\u672a\u77e5\u7684 CLI \u53c2\u6570\u5e76\u4ec5\u89e3\u6790\u5df2\u77e5\u7684\u53c2\u6570\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cCLI \u4e0d\u4f1a\u5ffd\u7565\u4efb\u4f55\u53c2\u6570\u3002\u7136\u540e\u53ef\u4ee5\u4f7f\u7528 <code>CliUnknownArgs</code> \u6ce8\u89e3\u68c0\u7d22\u88ab\u5ffd\u7565\u7684\u53c2\u6570\u3002</p> <pre><code>import sys\n\nfrom pydantic_settings import BaseSettings, CliUnknownArgs\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_ignore_unknown_args=True):\n    good_arg: str\n    ignored_args: CliUnknownArgs\n\n\nsys.argv = ['example.py', '--bad-arg=bad', 'ANOTHER_BAD_ARG', '--good_arg=hello world']\nprint(Settings().model_dump())\n#&gt; {'good_arg': 'hello world', 'ignored_args': ['--bad-arg=bad', 'ANOTHER_BAD_ARG']}\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli-kebab-case","title":"CLI \u53c2\u6570\u7684 Kebab Case","text":"<p>\u901a\u8fc7\u542f\u7528 <code>cli_kebab_case</code> \u6765\u66f4\u6539 CLI \u53c2\u6570\u662f\u5426\u5e94\u4f7f\u7528 kebab case\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>cli_kebab_case=True</code> \u5c06\u5ffd\u7565\u679a\u4e3e\u5b57\u6bb5\uff0c\u76f8\u5f53\u4e8e <code>cli_kebab_case='no_enums'</code>\u3002\u8981\u5c06 kebab case \u5e94\u7528\u4e8e\u6240\u6709\u5185\u5bb9\uff0c\u5305\u62ec\u679a\u4e3e\uff0c\u8bf7\u4f7f\u7528 <code>cli_kebab_case='all'</code>\u3002</p> <pre><code>import sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_kebab_case=True):\n    my_option: str = Field(description='will show as kebab case on CLI')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #&gt; 0\n\"\"\"\nusage: example.py [-h] [--my-option str]\n\noptions:\n  -h, --help       \u663e\u793a\u6b64\u5e2e\u52a9\u4fe1\u606f\u5e76\u9000\u51fa\n  --my-option str  will show as kebab case on CLI (required)\n\"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_4","title":"\u66f4\u6539 CLI \u662f\u5426\u5e94\u5728\u51fa\u9519\u65f6\u9000\u51fa","text":"<p>\u4f7f\u7528 <code>cli_exit_on_error</code> \u6765\u66f4\u6539 CLI \u5185\u90e8\u89e3\u6790\u5668\u662f\u5728\u51fa\u9519\u65f6\u9000\u51fa\u8fd8\u662f\u5f15\u53d1 <code>SettingsError</code> \u5f02\u5e38\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cCLI \u5185\u90e8\u89e3\u6790\u5668\u4f1a\u5728\u51fa\u9519\u65f6\u9000\u51fa\u3002</p> <pre><code>import sys\n\nfrom pydantic_settings import BaseSettings, SettingsError\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_exit_on_error=False): ...\n\n\ntry:\n    sys.argv = ['example.py', '--bad-arg']\n    Settings()\nexcept SettingsError as e:\n    print(e)\n    #&gt; error parsing CLI: unrecognized arguments: --bad-arg\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_5","title":"\u5728 CLI \u4e2d\u5f3a\u5236\u6267\u884c\u5fc5\u9700\u53c2\u6570","text":"<p>Pydantic settings \u8bbe\u8ba1\u7528\u4e8e\u5728\u5b9e\u4f8b\u5316\u6a21\u578b\u65f6\u4ece\u5404\u79cd\u6765\u6e90\u62c9\u53d6\u503c\u3002\u8fd9\u610f\u5473\u7740\u5fc5\u9700\u7684\u5b57\u6bb5\u5e76\u4e0d\u4e25\u683c\u8981\u6c42\u6765\u81ea\u4efb\u4f55\u5355\u4e2a\u6765\u6e90\uff08\u4f8b\u5982 CLI\uff09\u3002\u76f8\u53cd\uff0c\u91cd\u8981\u7684\u662f\u5176\u4e2d\u4e00\u4e2a\u6765\u6e90\u63d0\u4f9b\u6240\u9700\u7684\u503c\u3002</p> <p>\u4f46\u662f\uff0c\u5982\u679c\u4f60\u7684\u7528\u4f8b\u66f4\u7b26\u5408 #2\uff0c\u5373\u4f7f\u7528 Pydantic \u6a21\u578b\u5b9a\u4e49 CLI\uff0c\u4f60\u53ef\u80fd\u5e0c\u671b\u5fc5\u9700\u5b57\u6bb5\u5728 CLI \u4e2d\u4e25\u683c\u5fc5\u9700\u3002\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>cli_enforce_required</code> \u6765\u542f\u7528\u6b64\u884c\u4e3a\u3002</p> <p>Note</p> <p>\u5fc5\u9700\u7684 <code>CliPositionalArg</code> \u5b57\u6bb5\u5728 CLI \u4e2d\u59cb\u7ec8\u662f\u4e25\u683c\u5fc5\u9700\u7684\uff08\u5f3a\u5236\u6267\u884c\u7684\uff09\u3002</p> <pre><code>import os\nimport sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsError\n\n\nclass Settings(\n    BaseSettings,\n    cli_parse_args=True,\n    cli_enforce_required=True,\n    cli_exit_on_error=False,\n):\n    my_required_field: str = Field(description='a top level required field')\n\n\nos.environ['MY_REQUIRED_FIELD'] = 'hello from environment'\n\ntry:\n    sys.argv = ['example.py']\n    Settings()\nexcept SettingsError as e:\n    print(e)\n    #&gt; error parsing CLI: the following arguments are required: --my_required_field\n</code></pre>"},{"location":"concepts/pydantic_settings/#none","title":"\u66f4\u6539 None \u7c7b\u578b\u89e3\u6790\u5b57\u7b26\u4e32","text":"<p>\u901a\u8fc7\u8bbe\u7f6e <code>cli_parse_none_str</code> \u6765\u66f4\u6539\u5c06\u88ab\u89e3\u6790\u4e3a <code>None</code> \u7684 CLI \u5b57\u7b26\u4e32\u503c\uff08\u4f8b\u5982 \"null\"\u3001\"void\"\u3001\"None\" \u7b49\uff09\u3002\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86 <code>env_parse_none_str</code> \u503c\uff0c\u5b83\u5c06\u4f7f\u7528\u8be5\u503c\u3002\u5426\u5219\uff0c\u5982\u679c <code>cli_avoid_json</code> \u4e3a <code>False</code>\uff0c\u5219\u9ed8\u8ba4\u4e3a \"null\"\uff0c\u5982\u679c <code>cli_avoid_json</code> \u4e3a <code>True</code>\uff0c\u5219\u9ed8\u8ba4\u4e3a \"None\"\u3002</p> <pre><code>import sys\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_parse_none_str='void'):\n    v1: Optional[int] = Field(description='the top level v0 option')\n\n\nsys.argv = ['example.py', '--v1', 'void']\nprint(Settings().model_dump())\n#&gt; {'v1': None}\n</code></pre>"},{"location":"concepts/pydantic_settings/#none_1","title":"\u9690\u85cf None \u7c7b\u578b\u503c","text":"<p>\u901a\u8fc7\u542f\u7528 <code>cli_hide_none_type</code> \u4ece CLI \u5e2e\u52a9\u6587\u672c\u4e2d\u9690\u85cf <code>None</code> \u503c\u3002</p> <pre><code>import sys\nfrom typing import Optional\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_hide_none_type=True):\n    v0: Optional[str] = Field(description='the top level v0 option')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #&gt; 0\n\"\"\"\nusage: example.py [-h] [--v0 str]\n\noptions:\n  -h, --help  show this help message and exit\n  --v0 str    the top level v0 option (required)\n\"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#json-cli","title":"\u907f\u514d\u6dfb\u52a0 JSON CLI \u9009\u9879","text":"<p>\u901a\u8fc7\u542f\u7528 <code>cli_avoid_json</code> \u6765\u907f\u514d\u5728 CLI \u4e2d\u6dfb\u52a0\u5bfc\u81f4 JSON \u5b57\u7b26\u4e32\u7684\u590d\u6742\u5b57\u6bb5\u3002</p> <pre><code>import sys\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass SubModel(BaseModel):\n    v1: int = Field(description='the sub model v1 option')\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_avoid_json=True):\n    sub_model: SubModel = Field(\n        description='The help summary for SubModel related options'\n    )\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #&gt; 0\n\"\"\"\nusage: example.py [-h] [--sub_model.v1 int]\n\noptions:\n  -h, --help          show this help message and exit\n\nsub_model options:\n  The help summary for SubModel related options\n\n  --sub_model.v1 int  the sub model v1 option (required)\n\"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#_17","title":"\u4f7f\u7528\u7c7b\u6587\u6863\u5b57\u7b26\u4e32\u4f5c\u4e3a\u7ec4\u5e2e\u52a9\u6587\u672c","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5728\u586b\u5145\u5d4c\u5957\u6a21\u578b\u7684\u7ec4\u5e2e\u52a9\u6587\u672c\u65f6\uff0c\u5b83\u5c06\u4ece\u5b57\u6bb5\u63cf\u8ff0\u4e2d\u63d0\u53d6\u3002\u6216\u8005\uff0c\u6211\u4eec\u4e5f\u53ef\u4ee5\u914d\u7f6e CLI \u8bbe\u7f6e\u4ee5\u4ece\u7c7b\u6587\u6863\u5b57\u7b26\u4e32\u4e2d\u63d0\u53d6\u3002</p> <p>Note</p> <p>\u5982\u679c\u5b57\u6bb5\u662f\u5d4c\u5957\u6a21\u578b\u7684\u8054\u5408\uff0c\u7ec4\u5e2e\u52a9\u6587\u672c\u5c06\u59cb\u7ec8\u4ece\u5b57\u6bb5\u63cf\u8ff0\u4e2d\u63d0\u53d6\uff1b\u5373\u4f7f <code>cli_use_class_docs_for_groups</code> \u8bbe\u7f6e\u4e3a <code>True</code>\u3002</p> <pre><code>import sys\n\nfrom pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass SubModel(BaseModel):\n    \"\"\"The help text from the class docstring.\"\"\"\n\n    v1: int = Field(description='the sub model v1 option')\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_use_class_docs_for_groups=True):\n    \"\"\"My application help text.\"\"\"\n\n    sub_model: SubModel = Field(description='The help text from the field description')\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #&gt; 0\n\"\"\"\nusage: example.py [-h] [--sub_model JSON] [--sub_model.v1 int]\n\n\u6211\u7684\u5e94\u7528\u7a0b\u5e8f\u5e2e\u52a9\u6587\u672c\u3002\n\noptions:\n  -h, --help          \u663e\u793a\u6b64\u5e2e\u52a9\u4fe1\u606f\u5e76\u9000\u51fa\n\nsub_model options:\n  The help text from the class docstring.\n\n  --sub_model JSON    set sub_model from JSON string\n  --sub_model.v1 int  the sub model v1 option (required)\n\"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_6","title":"\u66f4\u6539 CLI \u6807\u5fd7\u524d\u7f00\u5b57\u7b26","text":"<p>\u901a\u8fc7\u8bbe\u7f6e <code>cli_flag_prefix_char</code> \u6765\u66f4\u6539 CLI \u53ef\u9009\u53c2\u6570\u4e2d\u4f7f\u7528\u7684 CLI \u6807\u5fd7\u524d\u7f00\u5b57\u7b26\u3002</p> <pre><code>import sys\n\nfrom pydantic import AliasChoices, Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings, cli_parse_args=True, cli_flag_prefix_char='+'):\n    my_arg: str = Field(validation_alias=AliasChoices('m', 'my-arg'))\n\n\nsys.argv = ['example.py', '++my-arg', 'hi']\nprint(Settings().model_dump())\n#&gt; {'my_arg': 'hi'}\n\nsys.argv = ['example.py', '+m', 'hi']\nprint(Settings().model_dump())\n#&gt; {'my_arg': 'hi'}\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_7","title":"\u4ece CLI \u5e2e\u52a9\u6587\u672c\u4e2d\u6291\u5236\u5b57\u6bb5","text":"<p>\u8981\u4ece CLI \u5e2e\u52a9\u6587\u672c\u4e2d\u6291\u5236\u5b57\u6bb5\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>CliSuppress</code> \u6ce8\u89e3\u7528\u4e8e\u5b57\u6bb5\u7c7b\u578b\uff0c\u6216\u8005\u4f7f\u7528 <code>CLI_SUPPRESS</code> \u5b57\u7b26\u4e32\u5e38\u91cf\u7528\u4e8e\u5b57\u6bb5\u63cf\u8ff0\u3002</p> <pre><code>import sys\n\nfrom pydantic import Field\n\nfrom pydantic_settings import CLI_SUPPRESS, BaseSettings, CliSuppress\n\n\nclass Settings(BaseSettings, cli_parse_args=True):\n    \"\"\"\u4ece CLI \u5e2e\u52a9\u6587\u672c\u4e2d\u6291\u5236\u5b57\u6bb5\u3002\"\"\"\n\n    field_a: CliSuppress[int] = 0\n    field_b: str = Field(default=1, description=CLI_SUPPRESS)\n\n\ntry:\n    sys.argv = ['example.py', '--help']\n    Settings()\nexcept SystemExit as e:\n    print(e)\n    #&gt; 0\n\"\"\"\nusage: example.py [-h]\n\n\u4ece CLI \u5e2e\u52a9\u6587\u672c\u4e2d\u6291\u5236\u5b57\u6bb5\u3002\n\noptions:\n  -h, --help          \u663e\u793a\u6b64\u5e2e\u52a9\u4fe1\u606f\u5e76\u9000\u51fa\n\"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#cli_8","title":"CLI \u53c2\u6570\u5feb\u6377\u65b9\u5f0f","text":"<p>\u4f7f\u7528 <code>SettingsConfigDict</code> \u4e2d\u7684 <code>cli_shortcuts</code> \u9009\u9879\u4e3a\u5b57\u6bb5\u6dfb\u52a0\u66ff\u4ee3\u7684 CLI \u53c2\u6570\u540d\u79f0\uff08\u5feb\u6377\u65b9\u5f0f\uff09\u3002\u8fd9\u5141\u8bb8\u4f60\u4e3a CLI \u53c2\u6570\u5b9a\u4e49\u989d\u5916\u7684\u540d\u79f0\uff0c\u8fd9\u5bf9\u4e8e\u4e3a\u6df1\u5ea6\u5d4c\u5957\u6216\u5197\u957f\u7684\u5b57\u6bb5\u540d\u79f0\u63d0\u4f9b\u66f4\u7528\u6237\u53cb\u597d\u6216\u66f4\u77ed\u7684\u522b\u540d\u7279\u522b\u6709\u7528\u3002</p> <p><code>cli_shortcuts</code> \u9009\u9879\u63a5\u53d7\u4e00\u4e2a\u5b57\u5178\uff0c\u5c06\u76ee\u6807\u5b57\u6bb5\u540d\u79f0\uff08\u5bf9\u5d4c\u5957\u5b57\u6bb5\u4f7f\u7528\u70b9\u8868\u793a\u6cd5\uff09\u6620\u5c04\u5230\u4e00\u4e2a\u6216\u591a\u4e2a\u5feb\u6377\u65b9\u5f0f\u540d\u79f0\u3002\u5982\u679c\u591a\u4e2a\u5b57\u6bb5\u5171\u4eab\u76f8\u540c\u7684\u5feb\u6377\u65b9\u5f0f\uff0c\u7b2c\u4e00\u4e2a\u5339\u914d\u7684\u5b57\u6bb5\u5c06\u4f18\u5148\u3002</p> <p>Flat Example:</p> <pre><code>from pydantic import Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    option: str = Field(default='foo')\n    list_option: str = Field(default='fizz')\n\n    model_config = SettingsConfigDict(\n        cli_shortcuts={'option': 'option2', 'list_option': ['list_option2']}\n    )\n\n\n# Now you can use the shortcuts on the CLI:\n# --option2 sets 'option', --list_option2 sets 'list_option'\n</code></pre> <p>Nested Example:</p> <pre><code>from pydantic import BaseModel, Field\n\nfrom pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass TwiceNested(BaseModel):\n    option: str = Field(default='foo')\n\n\nclass Nested(BaseModel):\n    twice_nested_option: TwiceNested = TwiceNested()\n    option: str = Field(default='foo')\n\n\nclass Settings(BaseSettings):\n    nested: Nested = Nested()\n    model_config = SettingsConfigDict(\n        cli_shortcuts={\n            'nested.option': 'option2',\n            'nested.twice_nested_option.option': 'twice_nested_option',\n        }\n    )\n\n\n# Now you can use --option2 to set nested.option and --twice_nested_option to set nested.twice_nested_option.option\n</code></pre> <p>\u5982\u679c\u5feb\u6377\u65b9\u5f0f\u53d1\u751f\u51b2\u7a81\uff08\u6620\u5c04\u5230\u591a\u4e2a\u5b57\u6bb5\uff09\uff0c\u5b83\u5c06\u5e94\u7528\u4e8e\u6a21\u578b\u4e2d\u7b2c\u4e00\u4e2a\u5339\u914d\u7684\u5b57\u6bb5\u3002</p>"},{"location":"concepts/pydantic_settings/#_18","title":"\u4e0e\u73b0\u6709\u89e3\u6790\u5668\u96c6\u6210","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u7528\u7528\u6237\u5b9a\u4e49\u7684\u6307\u5b9a <code>root_parser</code> \u5bf9\u8c61\u7684 CLI \u8bbe\u7f6e\u6e90\u8986\u76d6\u9ed8\u8ba4\u7684 CLI \u8bbe\u7f6e\u6e90\u6765\u4e0e\u73b0\u6709\u89e3\u6790\u5668\u96c6\u6210\u3002</p> <pre><code>import sys\nfrom argparse import ArgumentParser\n\nfrom pydantic_settings import BaseSettings, CliApp, CliSettingsSource\n\nparser = ArgumentParser()\nparser.add_argument('--food', choices=['pear', 'kiwi', 'lime'])\n\n\nclass Settings(BaseSettings):\n    name: str = 'Bob'\n\n\n# Set existing `parser` as the `root_parser` object for the user defined settings source\ncli_settings = CliSettingsSource(Settings, root_parser=parser)\n\n# Parse and load CLI settings from the command line into the settings source.\nsys.argv = ['example.py', '--food', 'kiwi', '--name', 'waldo']\ns = CliApp.run(Settings, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#&gt; {'name': 'waldo'}\n\n# Load CLI settings from pre-parsed arguments. i.e., the parsing occurs elsewhere and we\n# just need to load the pre-parsed args into the settings source.\nparsed_args = parser.parse_args(['--food', 'kiwi', '--name', 'ralph'])\ns = CliApp.run(Settings, cli_args=parsed_args, cli_settings_source=cli_settings)\nprint(s.model_dump())\n#&gt; {'name': 'ralph'}\n</code></pre> <p><code>CliSettingsSource</code> \u901a\u8fc7\u4f7f\u7528\u89e3\u6790\u5668\u65b9\u6cd5\u5c06 <code>settings_cls</code> \u5b57\u6bb5\u6dfb\u52a0\u4e3a\u547d\u4ee4\u884c\u53c2\u6570\u6765\u4e0e <code>root_parser</code> \u5bf9\u8c61\u8fde\u63a5\u3002<code>CliSettingsSource</code> \u5185\u90e8\u89e3\u6790\u5668\u8868\u793a\u57fa\u4e8e <code>argparse</code> \u5e93\uff0c\u56e0\u6b64\u9700\u8981\u652f\u6301\u4e0e\u5176 <code>argparse</code> \u5bf9\u5e94\u9879\u76f8\u540c\u5c5e\u6027\u7684\u89e3\u6790\u5668\u65b9\u6cd5\u3002\u53ef\u4ee5\u81ea\u5b9a\u4e49\u7684\u53ef\u7528\u89e3\u6790\u5668\u65b9\u6cd5\u53ca\u5176 argparse \u5bf9\u5e94\u9879\uff08\u9ed8\u8ba4\u503c\uff09\u5982\u4e0b\uff1a</p> <ul> <li><code>parse_args_method</code> - (<code>argparse.ArgumentParser.parse_args</code>)</li> <li><code>add_argument_method</code> - (<code>argparse.ArgumentParser.add_argument</code>)</li> <li><code>add_argument_group_method</code> - (<code>argparse.ArgumentParser.add_argument_group</code>)</li> <li><code>add_parser_method</code> - (<code>argparse._SubParsersAction.add_parser</code>)</li> <li><code>add_subparsers_method</code> - (<code>argparse.ArgumentParser.add_subparsers</code>)</li> <li><code>formatter_class</code> - (<code>argparse.RawDescriptionHelpFormatter</code>)</li> </ul> <p>\u5bf9\u4e8e\u975e argparse \u89e3\u6790\u5668\uff0c\u5982\u679c\u4e0d\u652f\u6301\uff0c\u89e3\u6790\u5668\u65b9\u6cd5\u53ef\u4ee5\u8bbe\u7f6e\u4e3a <code>None</code>\u3002\u53ea\u6709\u5f53\u89e3\u6790\u5668\u65b9\u6cd5\u5fc5\u8981\u4f46\u8bbe\u7f6e\u4e3a <code>None</code> \u65f6\uff0cCLI \u8bbe\u7f6e\u624d\u4f1a\u5728\u8fde\u63a5\u5230\u6839\u89e3\u6790\u5668\u65f6\u5f15\u53d1\u9519\u8bef\u3002</p> <p>Note</p> <p><code>formatter_class</code> \u4ec5\u5e94\u7528\u4e8e\u5b50\u547d\u4ee4\u3002<code>CliSettingsSource</code> \u4ece\u4e0d\u63a5\u89e6\u6216\u4fee\u6539\u4efb\u4f55\u5916\u90e8\u89e3\u6790\u5668\u8bbe\u7f6e\u4ee5\u907f\u514d\u7834\u574f\u6027\u66f4\u6539\u3002\u7531\u4e8e\u5b50\u547d\u4ee4\u9a7b\u7559\u5728\u5b83\u4eec\u81ea\u5df1\u7684\u5185\u90e8\u89e3\u6790\u5668\u6811\u4e0a\uff0c\u6211\u4eec\u53ef\u4ee5\u5b89\u5168\u5730\u5e94\u7528 <code>formatter_class</code> \u8bbe\u7f6e\u800c\u4e0d\u4f1a\u7834\u574f\u5916\u90e8\u89e3\u6790\u5668\u903b\u8f91\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets","title":"Secrets","text":"<p>\u5c06\u5bc6\u94a5\u503c\u653e\u5728\u6587\u4ef6\u4e2d\u662f\u4e3a\u5e94\u7528\u7a0b\u5e8f\u63d0\u4f9b\u654f\u611f\u914d\u7f6e\u7684\u5e38\u89c1\u6a21\u5f0f\u3002</p> <p>\u5bc6\u94a5\u6587\u4ef6\u9075\u5faa\u4e0e dotenv \u6587\u4ef6\u76f8\u540c\u7684\u539f\u5219\uff0c\u53ea\u662f\u5b83\u53ea\u5305\u542b\u5355\u4e2a\u503c\uff0c\u5e76\u4e14\u6587\u4ef6\u540d\u7528\u4f5c\u952e\u3002\u5bc6\u94a5\u6587\u4ef6\u5c06\u5982\u4e0b\u6240\u793a\uff1a</p> /var/run/database_password<pre><code>super_secret_database_password\n</code></pre> <p>\u4e00\u65e6\u60a8\u6709\u4e86\u5bc6\u94a5\u6587\u4ef6\uff0cpydantic \u652f\u6301\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u52a0\u8f7d\u5b83\uff1a</p> <ol> <li>\u5728 <code>BaseSettings</code> \u7c7b\u7684 <code>model_config</code> \u4e0a\u8bbe\u7f6e <code>secrets_dir</code> \u5230\u5b58\u50a8\u5bc6\u94a5\u6587\u4ef6\u7684\u76ee\u5f55\u3002    <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(secrets_dir='/var/run')\n\n    database_password: str\n</code></pre></li> <li>\u4f7f\u7528 <code>_secrets_dir</code> \u5173\u952e\u5b57\u53c2\u6570\u5b9e\u4f8b\u5316 <code>BaseSettings</code> \u6d3e\u751f\u7c7b\uff1a    <pre><code>settings = Settings(_secrets_dir='/var/run')\n</code></pre></li> </ol> <p>\u65e0\u8bba\u54ea\u79cd\u60c5\u51b5\uff0c\u4f20\u9012\u7684\u53c2\u6570\u503c\u53ef\u4ee5\u662f\u4efb\u4f55\u6709\u6548\u76ee\u5f55\uff0c\u7edd\u5bf9\u8def\u5f84\u6216\u76f8\u5bf9\u4e8e\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u3002\u8bf7\u6ce8\u610f\uff0c\u4e0d\u5b58\u5728\u7684\u76ee\u5f55\u53ea\u4f1a\u751f\u6210\u8b66\u544a\u3002 \u4ece\u90a3\u91cc\uff0cpydantic \u5c06\u901a\u8fc7\u52a0\u8f7d\u53d8\u91cf\u5e76\u9a8c\u8bc1\u5b83\u4eec\u6765\u5904\u7406\u6240\u6709\u4e8b\u60c5\u3002</p> <p>\u5373\u4f7f\u4f7f\u7528\u5bc6\u94a5\u76ee\u5f55\uff0cpydantic \u4ecd\u5c06\u4ece dotenv \u6587\u4ef6\u6216\u73af\u5883\u4e2d\u8bfb\u53d6\u73af\u5883\u53d8\u91cf\uff0cdotenv \u6587\u4ef6\u548c\u73af\u5883\u53d8\u91cf\u59cb\u7ec8\u4f18\u5148\u4e8e\u4ece\u5bc6\u94a5\u76ee\u5f55\u52a0\u8f7d\u7684\u503c\u3002</p> <p>\u5728\u5b9e\u4f8b\u5316\u65f6\u901a\u8fc7 <code>_secrets_dir</code> \u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u6587\u4ef6\u8def\u5f84\uff08\u65b9\u6cd5 2\uff09\u5c06\u8986\u76d6\u5728 <code>model_config</code> \u7c7b\u4e0a\u8bbe\u7f6e\u7684\u4efb\u4f55\u503c\u3002</p> <p>\u5982\u679c\u9700\u8981\u4ece\u591a\u4e2a\u5bc6\u94a5\u76ee\u5f55\u52a0\u8f7d\u8bbe\u7f6e\uff0c\u53ef\u4ee5\u5c06\u591a\u4e2a\u8def\u5f84\u4f5c\u4e3a\u5143\u7ec4\u6216\u5217\u8868\u4f20\u9012\u3002\u5c31\u50cf <code>env_file</code> \u4e00\u6837\uff0c\u540e\u7eed\u8def\u5f84\u7684\u503c\u4f1a\u8986\u76d6\u5148\u524d\u7684\u503c\u3002</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    # '/run/secrets' \u4e2d\u7684\u6587\u4ef6\u4f18\u5148\u4e8e '/var/run'\n    model_config = SettingsConfigDict(secrets_dir=('/var/run', '/run/secrets'))\n\n    database_password: str\n</code></pre> <p>\u5982\u679c\u4efb\u4f55 <code>secrets_dir</code> \u7f3a\u5931\uff0c\u5b83\u5c06\u88ab\u5ffd\u7565\uff0c\u5e76\u663e\u793a\u8b66\u544a\u3002\u5982\u679c\u4efb\u4f55 <code>secrets_dir</code> \u662f\u6587\u4ef6\uff0c\u5c06\u5f15\u53d1\u9519\u8bef\u3002</p>"},{"location":"concepts/pydantic_settings/#docker-secrets","title":"\u7528\u4f8b\uff1aDocker Secrets","text":"<p>Docker Secrets \u53ef\u7528\u4e8e\u4e3a\u5728 Docker \u5bb9\u5668\u4e2d\u8fd0\u884c\u7684\u5e94\u7528\u7a0b\u5e8f\u63d0\u4f9b\u654f\u611f\u914d\u7f6e\u3002 \u8981\u5728 pydantic \u5e94\u7528\u7a0b\u5e8f\u4e2d\u4f7f\u7528\u8fd9\u4e9b\u5bc6\u94a5\uff0c\u8fc7\u7a0b\u5f88\u7b80\u5355\u3002\u6709\u5173\u5728 Docker \u4e2d\u521b\u5efa\u3001\u7ba1\u7406\u548c\u4f7f\u7528\u5bc6\u94a5\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u5b98\u65b9 Docker \u6587\u6863\u3002</p> <p>\u9996\u5148\uff0c\u4f7f\u7528\u6307\u5b9a\u5bc6\u94a5\u76ee\u5f55\u7684 <code>SettingsConfigDict</code> \u5b9a\u4e49\u60a8\u7684 <code>Settings</code> \u7c7b\u3002</p> <pre><code>from pydantic_settings import BaseSettings, SettingsConfigDict\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(secrets_dir='/run/secrets')\n\n    my_secret_data: str\n</code></pre> <p>Note</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b Docker \u4f7f\u7528 <code>/run/secrets</code> \u4f5c\u4e3a\u76ee\u6807\u6302\u8f7d\u70b9\u3002\u5982\u679c\u60a8\u60f3\u4f7f\u7528\u4e0d\u540c\u7684\u4f4d\u7f6e\uff0c\u8bf7\u76f8\u5e94\u5730\u66f4\u6539 <code>Config.secrets_dir</code>\u3002</p> <p>\u7136\u540e\uff0c\u901a\u8fc7 Docker CLI \u521b\u5efa\u60a8\u7684\u5bc6\u94a5 <pre><code>printf \"This is a secret\" | docker secret create my_secret_data -\n</code></pre></p> <p>\u6700\u540e\uff0c\u5728 Docker \u5bb9\u5668\u5185\u8fd0\u884c\u60a8\u7684\u5e94\u7528\u7a0b\u5e8f\u5e76\u63d0\u4f9b\u65b0\u521b\u5efa\u7684\u5bc6\u94a5 <pre><code>docker service create --name pydantic-with-secrets --secret my_secret_data pydantic-app:latest\n</code></pre></p>"},{"location":"concepts/pydantic_settings/#_19","title":"\u5d4c\u5957\u5bc6\u94a5","text":"<p>\u9ed8\u8ba4\u7684\u5bc6\u94a5\u5b9e\u73b0 <code>SecretsSettingsSource</code> \u7684\u884c\u4e3a\u5e76\u4e0d\u603b\u662f\u7406\u60f3\u6216\u8db3\u591f\u7684\u3002 \u4f8b\u5982\uff0c\u9ed8\u8ba4\u5b9e\u73b0\u4e0d\u652f\u6301\u5d4c\u5957\u5b50\u6a21\u578b\u4e2d\u7684\u5bc6\u94a5\u5b57\u6bb5\u3002</p> <p><code>NestedSecretsSettingsSource</code> \u53ef\u4ee5\u7528\u4f5c <code>SecretsSettingsSource</code> \u7684\u76f4\u63a5\u66ff\u4ee3\u54c1\u6765\u8c03\u6574\u9ed8\u8ba4\u884c\u4e3a\u3002 \u6240\u6709\u5dee\u5f02\u603b\u7ed3\u5728\u4e0b\u8868\u4e2d\u3002</p> <code>SecretsSettingsSource</code> <code>NestedSecretsSettingsSourcee</code> \u5bc6\u94a5\u5b57\u6bb5\u5fc5\u987b\u5c5e\u4e8e\u9876\u7ea7\u6a21\u578b\u3002 \u5bc6\u94a5\u53ef\u4ee5\u662f\u5d4c\u5957\u6a21\u578b\u7684\u5b57\u6bb5\u3002 \u5bc6\u94a5\u6587\u4ef6\u53ea\u80fd\u653e\u5728 <code>secrets_dir</code> \u4e2d\u3002 \u5bc6\u94a5\u6587\u4ef6\u53ef\u4ee5\u653e\u5728\u5d4c\u5957\u6a21\u578b\u7684\u5b50\u76ee\u5f55\u4e2d\u3002 \u5bc6\u94a5\u6587\u4ef6\u53d1\u73b0\u57fa\u4e8e\u4e0e <code>EnvSettingsSource</code> \u76f8\u540c\u7684\u914d\u7f6e\u9009\u9879\uff1a<code>case_sensitive</code>\u3001<code>env_nested_delimiter</code>\u3001<code>env_prefix</code>\u3002 \u9ed8\u8ba4\u9009\u9879\u88ab\u5c0a\u91cd\uff0c\u4f46\u53ef\u4ee5\u7528 <code>secrets_case_sensitive</code>\u3001<code>secrets_nested_delimiter</code>\u3001<code>secrets_prefix</code> \u8986\u76d6\u3002 \u5f53 <code>secrets_dir</code> \u5728\u6587\u4ef6\u7cfb\u7edf\u4e2d\u7f3a\u5931\u65f6\uff0c\u4f1a\u751f\u6210\u8b66\u544a\u3002 \u4f7f\u7528 <code>secrets_dir_missing</code> \u9009\u9879\u9009\u62e9\u662f\u53d1\u51fa\u8b66\u544a\u3001\u5f15\u53d1\u9519\u8bef\u8fd8\u662f\u9759\u9ed8\u5ffd\u7565\u3002"},{"location":"concepts/pydantic_settings/#_20","title":"\u7528\u4f8b\uff1a\u666e\u901a\u76ee\u5f55\u5e03\u5c40","text":"<pre><code>\ud83d\udcc2 secrets\n\u251c\u2500\u2500 \ud83d\udcc4 app_key\n\u2514\u2500\u2500 \ud83d\udcc4 db_passwd\n</code></pre> <p>\u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u5bc6\u94a5\u5d4c\u5957\u5206\u9694\u7b26 <code>'_'</code> \u4e0e\u73af\u5883\u5d4c\u5957\u5206\u9694\u7b26 <code>'__'</code> \u4e0d\u540c\u3002 <code>Settings.db.user</code> \u7684\u503c\u53ef\u4ee5\u901a\u8fc7\u73af\u5883\u53d8\u91cf <code>MY_DB__USER</code> \u4f20\u9012\u3002</p> <pre><code>from pydantic import BaseModel, SecretStr\n\nfrom pydantic_settings import (\n    BaseSettings,\n    NestedSecretsSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass AppSettings(BaseModel):\n    key: SecretStr\n\n\nclass DbSettings(BaseModel):\n    user: str\n    passwd: SecretStr\n\n\nclass Settings(BaseSettings):\n    app: AppSettings\n    db: DbSettings\n\n    model_config = SettingsConfigDict(\n        env_prefix='MY_',\n        env_nested_delimiter='__',\n        secrets_dir='secrets',\n        secrets_nested_delimiter='_',\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls,\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            NestedSecretsSettingsSource(file_secret_settings),\n        )\n</code></pre>"},{"location":"concepts/pydantic_settings/#_21","title":"\u7528\u4f8b\uff1a\u5d4c\u5957\u76ee\u5f55\u5e03\u5c40","text":"<p><pre><code>\ud83d\udcc2 secrets\n\u251c\u2500\u2500 \ud83d\udcc2 app\n\u2502   \u2514\u2500\u2500 \ud83d\udcc4 key\n\u2514\u2500\u2500 \ud83d\udcc2 db\n    \u2514\u2500\u2500 \ud83d\udcc4 passwd\n</code></pre> <pre><code>from pydantic import BaseModel, SecretStr\n\nfrom pydantic_settings import (\n    BaseSettings,\n    NestedSecretsSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass AppSettings(BaseModel):\n    key: SecretStr\n\n\nclass DbSettings(BaseModel):\n    user: str\n    passwd: SecretStr\n\n\nclass Settings(BaseSettings):\n    app: AppSettings\n    db: DbSettings\n\n    model_config = SettingsConfigDict(\n        env_prefix='MY_',\n        env_nested_delimiter='__',\n        secrets_dir='secrets',\n        secrets_nested_subdir=True,\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls,\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            NestedSecretsSettingsSource(file_secret_settings),\n        )\n</code></pre></p>"},{"location":"concepts/pydantic_settings/#_22","title":"\u7528\u4f8b\uff1a\u591a\u4e2a\u5d4c\u5957\u76ee\u5f55","text":"<p><pre><code>\ud83d\udcc2 secrets\n\u251c\u2500\u2500 \ud83d\udcc2 default\n\u2502   \u251c\u2500\u2500 \ud83d\udcc2 app\n\u2502   \u2502   \u2514\u2500\u2500 \ud83d\udcc4 key\n\u2502   \u2514\u2500\u2500 \ud83d\udcc2 db\n\u2502       \u2514\u2500\u2500 \ud83d\udcc4 passwd\n\u2514\u2500\u2500 \ud83d\udcc2 override\n    \u251c\u2500\u2500 \ud83d\udcc2 app\n    \u2502   \u2514\u2500\u2500 \ud83d\udcc4 key\n    \u2514\u2500\u2500 \ud83d\udcc2 db\n        \u2514\u2500\u2500 \ud83d\udcc4 passwd\n</code></pre> <pre><code>from pydantic import BaseModel, SecretStr\n\nfrom pydantic_settings import (\n    BaseSettings,\n    NestedSecretsSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass AppSettings(BaseModel):\n    key: SecretStr\n\n\nclass DbSettings(BaseModel):\n    user: str\n    passwd: SecretStr\n\n\nclass Settings(BaseSettings):\n    app: AppSettings\n    db: DbSettings\n\n    model_config = SettingsConfigDict(\n        env_prefix='MY_',\n        env_nested_delimiter='__',\n        secrets_dir=['secrets/default', 'secrets/override'],\n        secrets_nested_subdir=True,\n    )\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls,\n        init_settings,\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    ):\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            NestedSecretsSettingsSource(file_secret_settings),\n        )\n</code></pre></p>"},{"location":"concepts/pydantic_settings/#_23","title":"\u914d\u7f6e\u9009\u9879","text":""},{"location":"concepts/pydantic_settings/#secrets_dir","title":"secrets_dir","text":"<p>\u5bc6\u94a5\u76ee\u5f55\u7684\u8def\u5f84\uff0c\u4e0e <code>SecretsSettingsSource.secrets_dir</code> \u76f8\u540c\u3002\u5982\u679c\u662f <code>list</code>\uff0c\u6700\u540e\u4e00\u4e2a\u5339\u914d\u9879\u83b7\u80dc\u3002 \u5982\u679c\u540c\u65f6\u5728\u6e90\u6784\u9020\u51fd\u6570\u548c\u6a21\u578b\u914d\u7f6e\u4e2d\u4f20\u9012 <code>secrets_dir</code>\uff0c\u503c\u4e0d\u4f1a\u5408\u5e76\uff08\u6784\u9020\u51fd\u6570\u83b7\u80dc\uff09\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets_dir_missing","title":"secrets_dir_missing","text":"<p>\u5982\u679c <code>secrets_dir</code> \u4e0d\u5b58\u5728\uff0c\u539f\u59cb\u7684 <code>SecretsSettingsSource</code> \u4f1a\u53d1\u51fa\u8b66\u544a\u3002 \u7136\u800c\uff0c\u8fd9\u53ef\u80fd\u662f\u4e0d\u5e0c\u671b\u7684\uff0c\u4f8b\u5982\uff0c\u5982\u679c\u6211\u4eec\u5728\u5f00\u53d1\u73af\u5883\u4e2d\u6ca1\u6709\u6302\u8f7d Docker Secrets\u3002 \u4f7f\u7528 <code>secrets_dir_missing</code> \u6765\u9009\u62e9\uff1a</p> <ul> <li><code>'ok'</code> \u2014 \u5982\u679c <code>secrets_dir</code> \u4e0d\u5b58\u5728\uff0c\u4ec0\u4e48\u4e5f\u4e0d\u505a</li> <li><code>'warn'</code>\uff08\u9ed8\u8ba4\uff09\u2014 \u6253\u5370\u8b66\u544a\uff0c\u4e0e <code>SecretsSettingsSource</code> \u76f8\u540c</li> <li><code>'error'</code> \u2014 \u5f15\u53d1 <code>SettingsError</code></li> </ul> <p>\u5982\u679c\u4f20\u9012\u4e86\u591a\u4e2a <code>secrets_dir</code>\uff0c\u76f8\u540c\u7684 <code>secrets_dir_missing</code> \u64cd\u4f5c\u9002\u7528\u4e8e\u6bcf\u4e2a\u76ee\u5f55\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets_dir_max_size","title":"secrets_dir_max_size","text":"<p>\u51fa\u4e8e\u5b89\u5168\u539f\u56e0\u9650\u5236 <code>secrets_dir</code> \u7684\u5927\u5c0f\uff0c\u9ed8\u8ba4\u4e3a <code>SECRETS_DIR_MAX_SIZE</code> \u7b49\u4e8e 16 MiB\u3002</p> <p><code>NestedSecretsSettingsSource</code> \u662f\u56f4\u7ed5 <code>EnvSettingsSource</code> \u7684\u8584\u5305\u88c5\u5668\uff0c \u5b83\u5728\u521d\u59cb\u5316\u65f6\u52a0\u8f7d\u6240\u6709\u6f5c\u5728\u7684\u5bc6\u94a5\u3002\u5982\u679c\u6211\u4eec\u5728 <code>secrets_dir</code> \u4e0b\u6302\u8f7d\u4e00\u4e2a\u5927\u6587\u4ef6\uff0c\u8fd9\u53ef\u80fd\u5bfc\u81f4 <code>MemoryError</code>\u3002</p> <p>\u5982\u679c\u4f20\u9012\u4e86\u591a\u4e2a <code>secrets_dir</code>\uff0c\u9650\u5236\u72ec\u7acb\u5e94\u7528\u4e8e\u6bcf\u4e2a\u76ee\u5f55\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets_case_sensitive","title":"secrets_case_sensitive","text":"<p>\u4e0e <code>case_sensitive</code> \u76f8\u540c\uff0c\u4f46\u4ec5\u9002\u7528\u4e8e\u5bc6\u94a5\u3002\u5982\u679c\u672a\u6307\u5b9a\uff0c\u9ed8\u8ba4\u4e3a <code>case_sensitive</code>\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets_nested_delimiter","title":"secrets_nested_delimiter","text":"<p>\u4e0e <code>env_nested_delimiter</code> \u76f8\u540c\uff0c\u4f46\u4ec5\u9002\u7528\u4e8e\u5bc6\u94a5\u3002\u5982\u679c\u672a\u6307\u5b9a\uff0c\u9ed8\u8ba4\u4e3a <code>env_nested_delimiter</code>\u3002 \u6b64\u9009\u9879\u7528\u4e8e\u5b9e\u73b0_\u5d4c\u5957\u5bc6\u94a5\u76ee\u5f55_\u5e03\u5c40\uff0c\u5e76\u5141\u8bb8\u6267\u884c\u751a\u81f3\u50cf <code>/run/secrets/model/delim/nested1/delim/nested2</code> \u8fd9\u6837\u7684\u590d\u6742\u64cd\u4f5c\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets_nested_subdir","title":"secrets_nested_subdir","text":"<p>\u5e03\u5c14\u6807\u5fd7\uff0c\u7528\u4e8e\u6253\u5f00_\u5d4c\u5957\u5bc6\u94a5\u76ee\u5f55_\u6a21\u5f0f\uff0c\u9ed8\u8ba4\u4e3a <code>False</code>\u3002\u5982\u679c\u4e3a <code>True</code>\uff0c\u5c06 <code>secrets_nested_delimiter</code> \u8bbe\u7f6e\u4e3a <code>os.sep</code>\u3002\u5982\u679c\u5df2\u7ecf\u6307\u5b9a\u4e86 <code>secrets_nested_delimiter</code>\uff0c\u5219\u5f15\u53d1 <code>SettingsError</code>\u3002</p>"},{"location":"concepts/pydantic_settings/#secrets_prefix","title":"secrets_prefix","text":"<p>\u5bc6\u94a5\u8def\u5f84\u524d\u7f00\uff0c\u7c7b\u4f3c\u4e8e <code>env_prefix</code>\uff0c\u4f46\u4ec5\u9002\u7528\u4e8e\u5bc6\u94a5\u3002\u5982\u679c\u672a\u6307\u5b9a\uff0c\u9ed8\u8ba4\u4e3a <code>env_prefix</code>\u3002 \u5728\u666e\u901a\u548c\u5d4c\u5957\u76ee\u5f55\u6a21\u5f0f\u4e0b\u90fd\u6709\u6548\uff0c\u5982 <code>'/run/secrets/prefix_model__nested'</code> \u548c <code>'/run/secrets/prefix_model/nested'</code>\u3002</p>"},{"location":"concepts/pydantic_settings/#aws-secrets-manager","title":"AWS Secrets Manager","text":"<p>\u60a8\u5fc5\u987b\u8bbe\u7f6e\u4e00\u4e2a\u53c2\u6570\uff1a</p> <ul> <li><code>secret_id</code>\uff1aAWS \u5bc6\u94a5 ID</li> </ul> <p>\u60a8\u5fc5\u987b\u5728\u5bc6\u94a5\u4e2d\u7684\u952e\u503c\u4e0e\u5b57\u6bb5\u540d\u79f0\u4e2d\u4f7f\u7528\u76f8\u540c\u7684\u547d\u540d\u7ea6\u5b9a\u3002\u4f8b\u5982\uff0c\u5982\u679c\u5bc6\u94a5\u4e2d\u7684\u952e\u540d\u4e3a <code>SqlServerPassword</code>\uff0c\u5b57\u6bb5\u540d\u79f0\u5fc5\u987b\u76f8\u540c\u3002\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528\u522b\u540d\u3002</p> <p>\u5728 AWS Secrets Manager \u4e2d\uff0c\u5d4c\u5957\u6a21\u578b\u652f\u6301\u5728\u952e\u540d\u4e2d\u4f7f\u7528 <code>--</code> \u5206\u9694\u7b26\u3002\u4f8b\u5982\uff0c<code>SqlServer--Password</code>\u3002</p> <p>\u4e0d\u652f\u6301\u6570\u7ec4\uff08\u4f8b\u5982 <code>MySecret--0</code>\u3001<code>MySecret--1</code>\uff09\u3002</p> <pre><code>import os\n\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    AWSSecretsManagerSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass SubModel(BaseModel):\n    a: str\n\n\nclass AWSSecretsManagerSettings(BaseSettings):\n    foo: str\n    bar: int\n    sub: SubModel\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        aws_secrets_manager_settings = AWSSecretsManagerSettingsSource(\n            settings_cls,\n            os.environ['AWS_SECRETS_MANAGER_SECRET_ID'],\n        )\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            aws_secrets_manager_settings,\n        )\n</code></pre>"},{"location":"concepts/pydantic_settings/#azure-key-vault","title":"Azure Key Vault","text":"<p>\u60a8\u5fc5\u987b\u8bbe\u7f6e\u4e24\u4e2a\u53c2\u6570\uff1a</p> <ul> <li><code>url</code>\uff1a\u4f8b\u5982\uff0c<code>https://my-resource.vault.azure.net/</code>\u3002</li> <li><code>credential</code>\uff1a\u5982\u679c\u60a8\u4f7f\u7528 <code>DefaultAzureCredential</code>\uff0c\u5728\u672c\u5730\u53ef\u4ee5\u6267\u884c <code>az login</code> \u6765\u83b7\u53d6\u60a8\u7684\u8eab\u4efd\u51ed\u636e\u3002\u8eab\u4efd\u5fc5\u987b\u5177\u6709\u89d2\u8272\u5206\u914d\uff08\u63a8\u8350\u7684\u662f <code>Key Vault Secrets User</code>\uff09\uff0c\u4ee5\u4fbf\u60a8\u53ef\u4ee5\u8bbf\u95ee\u5bc6\u94a5\u3002</li> </ul> <p>\u60a8\u5fc5\u987b\u5728\u5b57\u6bb5\u540d\u79f0\u4e0e Key Vault \u5bc6\u94a5\u540d\u79f0\u4e2d\u4f7f\u7528\u76f8\u540c\u7684\u547d\u540d\u7ea6\u5b9a\u3002\u4f8b\u5982\uff0c\u5982\u679c\u5bc6\u94a5\u540d\u4e3a <code>SqlServerPassword</code>\uff0c\u5b57\u6bb5\u540d\u79f0\u5fc5\u987b\u76f8\u540c\u3002\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528\u522b\u540d\u3002</p> <p>\u5728 Key Vault \u4e2d\uff0c\u5d4c\u5957\u6a21\u578b\u652f\u6301\u4f7f\u7528 <code>--</code> \u5206\u9694\u7b26\u3002\u4f8b\u5982\uff0c<code>SqlServer--Password</code>\u3002</p> <p>\u4e0d\u652f\u6301 Key Vault \u6570\u7ec4\uff08\u4f8b\u5982 <code>MySecret--0</code>\u3001<code>MySecret--1</code>\uff09\u3002</p> <pre><code>import os\n\nfrom azure.identity import DefaultAzureCredential\nfrom pydantic import BaseModel\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass SubModel(BaseModel):\n    a: str\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    foo: str\n    bar: int\n    sub: SubModel\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n        )\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            az_key_vault_settings,\n        )\n</code></pre>"},{"location":"concepts/pydantic_settings/#snake-case","title":"Snake case \u8f6c\u6362","text":"<p>Azure Key Vault \u6e90\u63a5\u53d7\u4e00\u4e2a <code>snake_case_convertion</code> \u9009\u9879\uff0c\u9ed8\u8ba4\u7981\u7528\uff0c\u7528\u4e8e\u901a\u8fc7\u5c06 Key Vault \u5bc6\u94a5\u540d\u79f0\u6620\u5c04\u5230 Python \u7684 snake_case \u5b57\u6bb5\u540d\u79f0\u6765\u8f6c\u6362\u5b83\u4eec\uff0c\u65e0\u9700\u4f7f\u7528\u522b\u540d\u3002</p> <pre><code>import os\n\nfrom azure.identity import DefaultAzureCredential\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    my_setting: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n            snake_case_conversion=True,\n        )\n        return (az_key_vault_settings,)\n</code></pre> <p>\u6b64\u8bbe\u7f6e\u5c06\u52a0\u8f7d Azure Key Vault \u5bc6\u94a5\uff08\u4f8b\u5982\uff0c<code>MySetting</code>\u3001<code>mySetting</code>\u3001<code>my-secret</code> \u6216 <code>MY-SECRET</code>\uff09\uff0c\u5c06\u5b83\u4eec\u6620\u5c04\u5230 snake case \u7248\u672c\uff08\u672c\u4f8b\u4e2d\u4e3a <code>my_setting</code>\uff09\u3002</p>"},{"location":"concepts/pydantic_settings/#_24","title":"\u7834\u6298\u53f7\u5230\u4e0b\u5212\u7ebf\u6620\u5c04","text":"<p>Azure Key Vault \u6e90\u63a5\u53d7\u4e00\u4e2a <code>dash_to_underscore</code> \u9009\u9879\uff0c\u9ed8\u8ba4\u7981\u7528\uff0c\u7528\u4e8e\u901a\u8fc7\u5c06 Key Vault kebab-case \u5bc6\u94a5\u540d\u79f0\u6620\u5c04\u5230 Python \u7684 snake_case \u5b57\u6bb5\u540d\u79f0\u6765\u652f\u6301\u5b83\u4eec\u3002\u542f\u7528\u540e\uff0c\u5728\u9a8c\u8bc1\u671f\u95f4\uff0c\u5bc6\u94a5\u540d\u79f0\u4e2d\u7684\u7834\u6298\u53f7\uff08<code>-</code>\uff09\u5c06\u6620\u5c04\u5230\u5b57\u6bb5\u540d\u79f0\u4e2d\u7684\u4e0b\u5212\u7ebf\uff08<code>_</code>\uff09\u3002</p> <p>\u6b64\u6620\u5c04\u4ec5\u9002\u7528\u4e8e\u5b57\u6bb5\u540d\u79f0\uff0c\u4e0d\u9002\u7528\u4e8e\u522b\u540d\u3002</p> <pre><code>import os\n\nfrom azure.identity import DefaultAzureCredential\nfrom pydantic import Field\n\nfrom pydantic_settings import (\n    AzureKeyVaultSettingsSource,\n    BaseSettings,\n    PydanticBaseSettingsSource,\n)\n\n\nclass AzureKeyVaultSettings(BaseSettings):\n    field_with_underscore: str\n    field_with_alias: str = Field(..., alias='Alias-With-Dashes')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        az_key_vault_settings = AzureKeyVaultSettingsSource(\n            settings_cls,\n            os.environ['AZURE_KEY_VAULT_URL'],\n            DefaultAzureCredential(),\n            dash_to_underscore=True,\n        )\n        return (az_key_vault_settings,)\n</code></pre> <p>\u6b64\u8bbe\u7f6e\u5c06\u52a0\u8f7d\u540d\u4e3a <code>field-with-underscore</code> \u548c <code>Alias-With-Dashes</code> \u7684 Azure Key Vault \u5bc6\u94a5\uff0c\u5206\u522b\u5c06\u5b83\u4eec\u6620\u5c04\u5230 <code>field_with_underscore</code> \u548c <code>field_with_alias</code> \u5b57\u6bb5\u3002</p> <p>Tip</p> <p>\u6216\u8005\uff0c\u60a8\u53ef\u4ee5\u914d\u7f6e alias_generator \u6765\u6620\u5c04 PascalCase \u5bc6\u94a5\u3002</p>"},{"location":"concepts/pydantic_settings/#google-cloud-secret-manager","title":"Google Cloud Secret Manager","text":"<p>Google Cloud Secret Manager \u5141\u8bb8\u60a8\u5728 Google Cloud Platform \u4e2d\u5b58\u50a8\u3001\u7ba1\u7406\u548c\u8bbf\u95ee\u654f\u611f\u4fe1\u606f\u4f5c\u4e3a\u5bc6\u94a5\u3002\u6b64\u96c6\u6210\u4f7f\u60a8\u53ef\u4ee5\u76f4\u63a5\u4ece GCP Secret Manager \u68c0\u7d22\u5bc6\u94a5\u4ee5\u7528\u4e8e\u60a8\u7684 Pydantic \u8bbe\u7f6e\u3002</p>"},{"location":"concepts/pydantic_settings/#_25","title":"\u5b89\u88c5","text":"<p>Google Cloud Secret Manager \u96c6\u6210\u9700\u8981\u989d\u5916\u7684\u4f9d\u8d56\u9879\uff1a</p> <pre><code>pip install \"pydantic-settings[gcp-secret-manager]\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#_26","title":"\u57fa\u672c\u7528\u6cd5","text":"<p>\u8981\u4f7f\u7528 Google Cloud Secret Manager\uff0c\u60a8\u9700\u8981\uff1a</p> <ol> <li>\u521b\u5efa\u4e00\u4e2a <code>GoogleSecretManagerSettingsSource</code>\u3002\uff08\u6709\u5173\u8eab\u4efd\u9a8c\u8bc1\u9009\u9879\uff0c\u8bf7\u53c2\u9605 GCP Authentication\u3002\uff09</li> <li>\u5c06\u6b64\u6e90\u6dfb\u52a0\u5230\u60a8\u7684\u8bbe\u7f6e\u81ea\u5b9a\u4e49\u7ba1\u9053\u4e2d</li> </ol> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    GoogleSecretManagerSettingsSource,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass Database(BaseModel):\n    password: str\n    user: str\n\n\nclass Settings(BaseSettings):\n    database: Database\n\n    model_config = SettingsConfigDict(env_nested_delimiter='__')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        # Create the GCP Secret Manager settings source\n        gcp_settings = GoogleSecretManagerSettingsSource(\n            settings_cls,\n            # If not provided, will use google.auth.default()\n            # to get credentials from the environemnt\n            # credentials=your_credentials,\n            # If not provided, will use google.auth.default()\n            # to get project_id from the environemnt\n            project_id='your-gcp-project-id',\n        )\n\n        return (\n            init_settings,\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n            gcp_settings,\n        )\n</code></pre>"},{"location":"concepts/pydantic_settings/#gcp-authentication","title":"GCP Authentication","text":"<p><code>GoogleSecretManagerSettingsSource</code> \u652f\u6301\u591a\u79cd\u8eab\u4efd\u9a8c\u8bc1\u65b9\u6cd5\uff1a</p> <ol> <li> <p>\u9ed8\u8ba4\u51ed\u636e - \u5982\u679c\u60a8\u4e0d\u63d0\u4f9b\u51ed\u636e\u6216\u9879\u76ee ID\uff0c\u5b83\u5c06\u4f7f\u7528 <code>google.auth.default()</code> \u6765\u83b7\u53d6\u5b83\u4eec\u3002\u8fd9\u9002\u7528\u4e8e\uff1a</p> </li> <li> <p>\u6765\u81ea <code>GOOGLE_APPLICATION_CREDENTIALS</code> \u73af\u5883\u53d8\u91cf\u7684\u670d\u52a1\u8d26\u6237\u51ed\u636e</p> </li> <li>\u6765\u81ea <code>gcloud auth application-default login</code> \u7684\u7528\u6237\u51ed\u636e</li> <li> <p>Compute Engine\u3001GKE\u3001Cloud Run \u6216 Cloud Functions \u7684\u9ed8\u8ba4\u670d\u52a1\u8d26\u6237</p> </li> <li> <p>\u663e\u5f0f\u51ed\u636e - \u60a8\u4e5f\u53ef\u4ee5\u76f4\u63a5\u63d0\u4f9b <code>credentials</code>\u3002\u4f8b\u5982 <code>sa_credentials = google.oauth2.service_account.Credentials.from_service_account_file('path/to/service-account.json')</code>\uff0c\u7136\u540e\u4f7f\u7528 <code>GoogleSecretManagerSettingsSource(credentials=sa_credentials)</code></p> </li> </ol>"},{"location":"concepts/pydantic_settings/#_27","title":"\u5d4c\u5957\u6a21\u578b","text":"<p>\u5bf9\u4e8e\u5d4c\u5957\u6a21\u578b\uff0c\u53ea\u8981\u7b26\u5408\u547d\u540d\u89c4\u5219\uff0cSecret Manager \u652f\u6301 <code>env_nested_delimiter</code> \u8bbe\u7f6e\u3002\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u60a8\u9700\u8981\u5728 Secret Manager \u4e2d\u521b\u5efa\u540d\u4e3a <code>database__password</code> \u548c <code>database__user</code> \u7684\u5bc6\u94a5\u3002</p>"},{"location":"concepts/pydantic_settings/#_28","title":"\u91cd\u8981\u6ce8\u610f\u4e8b\u9879","text":"<ol> <li>\u5927\u5c0f\u5199\u654f\u611f\u6027\uff1a\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5bc6\u94a5\u540d\u79f0\u662f\u533a\u5206\u5927\u5c0f\u5199\u7684\u3002</li> <li>\u5bc6\u94a5\u547d\u540d\uff1a\u5728 Google Secret Manager \u4e2d\u521b\u5efa\u5bc6\u94a5\u65f6\uff0c\u540d\u79f0\u5e94\u4e0e\u60a8\u7684\u5b57\u6bb5\u540d\u79f0\u5339\u914d\uff08\u5305\u62ec\u4efb\u4f55\u524d\u7f00\uff09\u3002\u6839\u636e Secret Manager \u6587\u6863\uff0c\u5bc6\u94a5\u540d\u79f0\u53ef\u4ee5\u5305\u542b\u5927\u5199\u548c\u5c0f\u5199\u5b57\u6bcd\u3001\u6570\u5b57\u3001\u8fde\u5b57\u7b26\u548c\u4e0b\u5212\u7ebf\u3002\u540d\u79f0\u7684\u6700\u5927\u5141\u8bb8\u957f\u5ea6\u4e3a 255 \u4e2a\u5b57\u7b26\u3002</li> <li>\u5bc6\u94a5\u7248\u672c\uff1a<code>GoogleSecretManagerSettingsSource</code> \u4f7f\u7528\u5bc6\u94a5\u7684\"\u6700\u65b0\"\u7248\u672c\u3002</li> </ol> <p>\u6709\u5173\u5728 Google Cloud Secret Manager \u4e2d\u521b\u5efa\u548c\u7ba1\u7406\u5bc6\u94a5\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u5b98\u65b9 Google Cloud \u6587\u6863\u3002</p>"},{"location":"concepts/pydantic_settings/#_29","title":"\u5176\u4ed6\u8bbe\u7f6e\u6e90","text":"<p>\u5176\u4ed6\u8bbe\u7f6e\u6e90\u53ef\u7528\u4e8e\u5e38\u89c1\u7684\u914d\u7f6e\u6587\u4ef6\uff1a</p> <ul> <li><code>JsonConfigSettingsSource</code> \u4f7f\u7528 <code>json_file</code> \u548c <code>json_file_encoding</code> \u53c2\u6570</li> <li><code>PyprojectTomlConfigSettingsSource</code> \u4f7f\u7528 (\u53ef\u9009) <code>pyproject_toml_depth</code> \u548c (\u53ef\u9009) <code>pyproject_toml_table_header</code> \u53c2\u6570</li> <li><code>TomlConfigSettingsSource</code> \u4f7f\u7528 <code>toml_file</code> \u53c2\u6570</li> <li><code>YamlConfigSettingsSource</code> \u4f7f\u7528 <code>yaml_file</code> \u548c yaml_file_encoding \u53c2\u6570</li> </ul> <p>\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u63d0\u4f9b\u8def\u5f84\u5217\u8868\u6765\u63d0\u4f9b\u591a\u4e2a\u6587\u4ef6\uff1a <pre><code>toml_file = ['config.default.toml', 'config.custom.toml']\n</code></pre> \u8981\u4f7f\u7528\u5b83\u4eec\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u6b64\u5904\u63cf\u8ff0\u7684\u76f8\u540c\u673a\u5236</p> <pre><code>from pydantic import BaseModel\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n    TomlConfigSettingsSource,\n)\n\n\nclass Nested(BaseModel):\n    nested_field: str\n\n\nclass Settings(BaseSettings):\n    foobar: str\n    nested: Nested\n    model_config = SettingsConfigDict(toml_file='config.toml')\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (TomlConfigSettingsSource(settings_cls),)\n</code></pre> <p>\u8fd9\u5c06\u80fd\u591f\u8bfb\u53d6\u4f4d\u4e8e\u5de5\u4f5c\u76ee\u5f55\u4e2d\u7684\u4ee5\u4e0b \"config.toml\" \u6587\u4ef6\uff1a</p> <pre><code>foobar = \"Hello\"\n[nested]\nnested_field = \"world!\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#pyprojecttoml","title":"pyproject.toml","text":"<p>\"pyproject.toml\" \u662f\u4e00\u4e2a\u6807\u51c6\u5316\u7684\u6587\u4ef6\uff0c\u7528\u4e8e\u5728 Python \u9879\u76ee\u4e2d\u63d0\u4f9b\u914d\u7f6e\u503c\u3002 PEP 518 \u5b9a\u4e49\u4e86\u4e00\u4e2a <code>[tool]</code> \u8868\uff0c\u53ef\u7528\u4e8e\u63d0\u4f9b\u4efb\u610f\u5de5\u5177\u914d\u7f6e\u3002 \u867d\u7136\u9f13\u52b1\u4f7f\u7528 <code>[tool]</code> \u8868\uff0c\u4f46 <code>PyprojectTomlConfigSettingsSource</code> \u53ef\u7528\u4e8e\u4ece \"pyproject.toml\" \u6587\u4ef6\u4e2d\u7684\u4efb\u4f55\u4f4d\u7f6e\u52a0\u8f7d\u53d8\u91cf\u3002</p> <p>\u8fd9\u901a\u8fc7\u63d0\u4f9b <code>SettingsConfigDict(pyproject_toml_table_header=tuple[str, ...])</code> \u6765\u63a7\u5236\uff0c\u5176\u4e2d\u503c\u662f\u4e00\u4e2a\u5934\u90e8\u90e8\u5206\u7684\u5143\u7ec4\u3002 \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>pyproject_toml_table_header=('tool', 'pydantic-settings')</code>\uff0c\u8fd9\u5c06\u4ece <code>[tool.pydantic-settings]</code> \u8868\u52a0\u8f7d\u53d8\u91cf\u3002</p> <pre><code>from pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    PyprojectTomlConfigSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass Settings(BaseSettings):\n    \"\"\"Example loading values from the table used by default.\"\"\"\n\n    field: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\n\nclass SomeTableSettings(Settings):\n    \"\"\"Example loading values from a user defined table.\"\"\"\n\n    model_config = SettingsConfigDict(\n        pyproject_toml_table_header=('tool', 'some-table')\n    )\n\n\nclass RootSettings(Settings):\n    \"\"\"Example loading values from the root of a pyproject.toml file.\"\"\"\n\n    model_config = SettingsConfigDict(extra='ignore', pyproject_toml_table_header=())\n</code></pre> <p>\u8fd9\u5c06\u80fd\u591f\u8bfb\u53d6\u4f4d\u4e8e\u5de5\u4f5c\u76ee\u5f55\u4e2d\u7684\u4ee5\u4e0b \"pyproject.toml\" \u6587\u4ef6\uff0c\u7ed3\u679c\u4e3a <code>Settings(field='default-table')</code>\u3001<code>SomeTableSettings(field='some-table')</code> \u548c <code>RootSettings(field='root')</code>\uff1a</p> <pre><code>field = \"root\"\n\n[tool.pydantic-settings]\nfield = \"default-table\"\n\n[tool.some-table]\nfield = \"some-table\"\n</code></pre> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>PyprojectTomlConfigSettingsSource</code> \u53ea\u4f1a\u5728\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u4e2d\u67e5\u627e \"pyproject.toml\"\u3002 \u4f46\u662f\uff0c\u6709\u4e24\u4e2a\u9009\u9879\u53ef\u4ee5\u6539\u53d8\u8fd9\u79cd\u884c\u4e3a\u3002</p> <ul> <li>\u53ef\u4ee5\u63d0\u4f9b <code>SettingsConfigDict(pyproject_toml_depth=&lt;int&gt;)</code> \u6765\u68c0\u67e5\u76ee\u5f55\u6811\u4e2d \u5411\u4e0a <code>&lt;int&gt;</code> \u4e2a\u76ee\u5f55\u4ee5\u67e5\u627e \"pyproject.toml\"\uff0c\u5982\u679c\u5728\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\u4e2d\u672a\u627e\u5230\u3002   \u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u4e0d\u68c0\u67e5\u7236\u76ee\u5f55\u3002</li> <li>\u53ef\u4ee5\u5728\u5b9e\u4f8b\u5316\u6e90\u65f6\u63d0\u4f9b\u663e\u5f0f\u6587\u4ef6\u8def\u5f84\uff08\u4f8b\u5982 <code>PyprojectTomlConfigSettingsSource(settings_cls, Path('~/.config').resolve() / 'pyproject.toml')</code>\uff09\u3002   \u5982\u679c\u4ee5\u8fd9\u79cd\u65b9\u5f0f\u63d0\u4f9b\u6587\u4ef6\u8def\u5f84\uff0c\u5b83\u5c06\u88ab\u89c6\u4e3a\u7edd\u5bf9\u8def\u5f84\uff08\u4e0d\u68c0\u67e5\u5176\u4ed6\u4f4d\u7f6e\uff09\u3002</li> </ul> <pre><code>from pathlib import Path\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    PyprojectTomlConfigSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass DiscoverSettings(BaseSettings):\n    \"\"\"Example of discovering a pyproject.toml in parent directories in not in `Path.cwd()`.\"\"\"\n\n    model_config = SettingsConfigDict(pyproject_toml_depth=2)\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (PyprojectTomlConfigSettingsSource(settings_cls),)\n\n\nclass ExplicitFilePathSettings(BaseSettings):\n    \"\"\"Example of explicitly providing the path to the file to load.\"\"\"\n\n    field: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            PyprojectTomlConfigSettingsSource(\n                settings_cls, Path('~/.config').resolve() / 'pyproject.toml'\n            ),\n        )\n</code></pre>"},{"location":"concepts/pydantic_settings/#field-value-priority","title":"\u5b57\u6bb5\u503c\u4f18\u5148\u7ea7","text":"<p>\u5f53\u4ee5\u591a\u79cd\u65b9\u5f0f\u4e3a\u540c\u4e00\u4e2a <code>Settings</code> \u5b57\u6bb5\u6307\u5b9a\u503c\u65f6\uff0c\u6240\u9009\u503c\u6309\u4ee5\u4e0b\u4f18\u5148\u7ea7\u786e\u5b9a\uff08\u6309\u4f18\u5148\u7ea7\u964d\u5e8f\u6392\u5217\uff09\uff1a</p> <ol> <li>\u5982\u679c\u542f\u7528\u4e86 <code>cli_parse_args</code>\uff0c\u5219\u5728 CLI \u4f20\u9012\u7684\u53c2\u6570\u3002</li> <li>\u4f20\u9012\u7ed9 <code>Settings</code> \u7c7b\u521d\u59cb\u5316\u5668\u7684\u53c2\u6570\u3002</li> <li>\u73af\u5883\u53d8\u91cf\uff0c\u4f8b\u5982\u4e0a\u9762\u63cf\u8ff0\u7684 <code>my_prefix_special_function</code>\u3002</li> <li>\u4ece dotenv (<code>.env</code>) \u6587\u4ef6\u52a0\u8f7d\u7684\u53d8\u91cf\u3002</li> <li>\u4ece secrets \u76ee\u5f55\u52a0\u8f7d\u7684\u53d8\u91cf\u3002</li> <li><code>Settings</code> \u6a21\u578b\u7684\u9ed8\u8ba4\u5b57\u6bb5\u503c\u3002</li> </ol>"},{"location":"concepts/pydantic_settings/#customise-settings-sources","title":"\u81ea\u5b9a\u4e49\u8bbe\u7f6e\u6e90","text":"<p>\u5982\u679c\u9ed8\u8ba4\u7684\u4f18\u5148\u7ea7\u987a\u5e8f\u4e0d\u7b26\u5408\u4f60\u7684\u9700\u6c42\uff0c\u53ef\u4ee5\u901a\u8fc7\u91cd\u5199 <code>Settings</code> \u7684 <code>settings_customise_sources</code> \u65b9\u6cd5\u6765\u66f4\u6539\u5b83\u3002</p> <p><code>settings_customise_sources</code> \u63a5\u53d7\u56db\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4efb\u610f\u6570\u91cf\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u4f5c\u4e3a\u5143\u7ec4\u3002 \u8fd9\u4e9b\u53ef\u8c03\u7528\u5bf9\u8c61\u4f9d\u6b21\u88ab\u8c03\u7528\u6765\u6784\u5efa\u8bbe\u7f6e\u7c7b\u5b57\u6bb5\u7684\u8f93\u5165\u3002</p> <p>\u6bcf\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\u5e94\u5c06\u8bbe\u7f6e\u7c7b\u7684\u5b9e\u4f8b\u4f5c\u4e3a\u5176\u552f\u4e00\u53c2\u6570\u5e76\u8fd4\u56de\u4e00\u4e2a <code>dict</code>\u3002</p>"},{"location":"concepts/pydantic_settings/#_30","title":"\u66f4\u6539\u4f18\u5148\u7ea7","text":"<p>\u8fd4\u56de\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u7684\u987a\u5e8f\u51b3\u5b9a\u4e86\u8f93\u5165\u7684\u4f18\u5148\u7ea7\uff1b\u7b2c\u4e00\u9879\u5177\u6709\u6700\u9ad8\u4f18\u5148\u7ea7\u3002</p> <pre><code>from pydantic import PostgresDsn\n\nfrom pydantic_settings import BaseSettings, PydanticBaseSettingsSource\n\n\nclass Settings(BaseSettings):\n    database_dsn: PostgresDsn\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return env_settings, init_settings, file_secret_settings\n\n\nprint(Settings(database_dsn='postgres://postgres@localhost:5432/kwargs_db'))\n#&gt; database_dsn=PostgresDsn('postgres://postgres@localhost:5432/kwargs_db')\n</code></pre> <p>\u901a\u8fc7\u4ea4\u6362 <code>env_settings</code> \u548c <code>init_settings</code>\uff0c\u73af\u5883\u53d8\u91cf\u73b0\u5728\u4f18\u5148\u4e8e <code>__init__</code> \u5173\u952e\u5b57\u53c2\u6570\u3002</p>"},{"location":"concepts/pydantic_settings/#_31","title":"\u6dfb\u52a0\u6e90","text":"<p>\u5982\u524d\u6240\u8ff0\uff0cpydantic \u9644\u5e26\u591a\u4e2a\u5185\u7f6e\u8bbe\u7f6e\u6e90\u3002\u4f46\u662f\uff0c\u4f60\u53ef\u80fd\u5076\u5c14\u9700\u8981\u6dfb\u52a0\u81ea\u5df1\u7684\u81ea\u5b9a\u4e49\u6e90\uff0c<code>settings_customise_sources</code> \u4f7f\u8fd9\u53d8\u5f97\u975e\u5e38\u5bb9\u6613\uff1a</p> <pre><code>import json\nfrom pathlib import Path\nfrom typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    SettingsConfigDict,\n)\n\n\nclass JsonConfigSettingsSource(PydanticBaseSettingsSource):\n    \"\"\"\n    A simple settings source class that loads variables from a JSON file\n    at the project's root.\n\n    Here we happen to choose to use the `env_file_encoding` from Config\n    when reading `config.json`\n    \"\"\"\n\n    def get_field_value(\n        self, field: FieldInfo, field_name: str\n    ) -&gt; tuple[Any, str, bool]:\n        encoding = self.config.get('env_file_encoding')\n        file_content_json = json.loads(\n            Path('tests/example_test_config.json').read_text(encoding)\n        )\n        field_value = file_content_json.get(field_name)\n        return field_value, field_name, False\n\n    def prepare_field_value(\n        self, field_name: str, field: FieldInfo, value: Any, value_is_complex: bool\n    ) -&gt; Any:\n        return value\n\n    def __call__(self) -&gt; dict[str, Any]:\n        d: dict[str, Any] = {}\n\n        for field_name, field in self.settings_cls.model_fields.items():\n            field_value, field_key, value_is_complex = self.get_field_value(\n                field, field_name\n            )\n            field_value = self.prepare_field_value(\n                field_name, field, field_value, value_is_complex\n            )\n            if field_value is not None:\n                d[field_key] = field_value\n\n        return d\n\n\nclass Settings(BaseSettings):\n    model_config = SettingsConfigDict(env_file_encoding='utf-8')\n\n    foobar: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            init_settings,\n            JsonConfigSettingsSource(settings_cls),\n            env_settings,\n            file_secret_settings,\n        )\n\n\nprint(Settings())\n#&gt; foobar='test'\n</code></pre>"},{"location":"concepts/pydantic_settings/#_32","title":"\u8bbf\u95ee\u5148\u524d\u6e90\u7684\u7ed3\u679c","text":"<p>\u6bcf\u4e2a\u8bbe\u7f6e\u6e90\u90fd\u53ef\u4ee5\u8bbf\u95ee\u5148\u524d\u6e90\u7684\u7ed3\u679c\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic.fields import FieldInfo\n\nfrom pydantic_settings import PydanticBaseSettingsSource\n\n\nclass MyCustomSource(PydanticBaseSettingsSource):\n    def get_field_value(\n        self, field: FieldInfo, field_name: str\n    ) -&gt; tuple[Any, str, bool]: ...\n\n    def __call__(self) -&gt; dict[str, Any]:\n        # Retrieve the aggregated settings from previous sources\n        current_state = self.current_state\n        current_state.get('some_setting')\n\n        # Retrive settings from all sources individually\n        # self.settings_sources_data[\"SettingsSourceName\"]: dict[str, Any]\n        settings_sources_data = self.settings_sources_data\n        settings_sources_data['SomeSettingsSource'].get('some_setting')\n\n        # Your code here...\n</code></pre>"},{"location":"concepts/pydantic_settings/#_33","title":"\u79fb\u9664\u6e90","text":"<p>\u4f60\u53ef\u80fd\u4e5f\u60f3\u7981\u7528\u67d0\u4e2a\u6e90\uff1a</p> <pre><code>from pydantic import ValidationError\n\nfrom pydantic_settings import BaseSettings, PydanticBaseSettingsSource\n\n\nclass Settings(BaseSettings):\n    my_api_key: str\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -&gt; tuple[PydanticBaseSettingsSource, ...]:\n        # here we choose to ignore arguments from init_settings\n        return env_settings, file_secret_settings\n\n\ntry:\n    Settings(my_api_key='this is ignored')\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    1 validation error for Settings\n    my_api_key\n      Field required [type=missing, input_value={}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2/v/missing\n    \"\"\"\n</code></pre>"},{"location":"concepts/pydantic_settings/#_34","title":"\u5c31\u5730\u91cd\u8f7d","text":"<p>\u5982\u679c\u4f60\u60f3\u5c31\u5730\u91cd\u8f7d\u73b0\u6709\u8bbe\u7f6e\uff0c\u53ef\u4ee5\u4f7f\u7528\u5176 <code>__init__</code> \u65b9\u6cd5\uff1a</p> <pre><code>import os\n\nfrom pydantic import Field\n\nfrom pydantic_settings import BaseSettings\n\n\nclass Settings(BaseSettings):\n    foo: str = Field('foo')\n\n\nmutable_settings = Settings()\n\nprint(mutable_settings.foo)\n#&gt; foo\n\nos.environ['foo'] = 'bar'\nprint(mutable_settings.foo)\n#&gt; foo\n\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#&gt; bar\n\nos.environ.pop('foo')\nmutable_settings.__init__()\nprint(mutable_settings.foo)\n#&gt; foo\n</code></pre>"},{"location":"concepts/serialization/","title":"Serialization","text":"<p>\u9664\u4e86\u901a\u8fc7\u5b57\u6bb5\u540d\u76f4\u63a5\u8bbf\u95ee\u6a21\u578b\u5c5e\u6027\uff08\u4f8b\u5982 <code>model.foobar</code>\uff09\u4e4b\u5916\uff0c\u6a21\u578b\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u8fdb\u884c\u8f6c\u6362\u3001\u8f6c\u50a8\u3001\u5e8f\u5217\u5316\u548c\u5bfc\u51fa\u3002\u5e8f\u5217\u5316\u53ef\u4ee5\u9488\u5bf9\u6574\u4e2a\u6a21\u578b\u8fdb\u884c\u81ea\u5b9a\u4e49\uff0c\u4e5f\u53ef\u4ee5\u57fa\u4e8e\u6bcf\u4e2a\u5b57\u6bb5\u6216\u6bcf\u79cd\u7c7b\u578b\u8fdb\u884c\u5b9a\u5236\u3002</p> \u5e8f\u5217\u5316\u4e0e\u8f6c\u50a8 <p>Pydantic \u4f7f\u7528\u672f\u8bed\"\u5e8f\u5217\u5316\"\u548c\"\u8f6c\u50a8\"\u53ef\u4ee5\u4e92\u6362\u4f7f\u7528\u3002\u4e24\u8005\u90fd\u6307\u5c06\u6a21\u578b\u8f6c\u6362\u4e3a\u5b57\u5178\u6216JSON\u7f16\u7801\u5b57\u7b26\u4e32\u7684\u8fc7\u7a0b\u3002</p> <p>\u5728 Pydantic \u4e4b\u5916\uff0c\u5355\u8bcd\"\u5e8f\u5217\u5316\"\u901a\u5e38\u6307\u5c06\u5185\u5b58\u4e2d\u7684\u6570\u636e\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u6216\u5b57\u8282\u3002\u7136\u800c\uff0c\u5728 Pydantic \u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u5c06\u5bf9\u8c61\u4ece\u66f4\u7ed3\u6784\u5316\u7684\u5f62\u5f0f\uff08\u5982 Pydantic \u6a21\u578b\u3001\u6570\u636e\u7c7b\u7b49\uff09\u8f6c\u6362\u4e3a\u7531 Python \u5185\u7f6e\u7c7b\u578b\uff08\u5982 dict\uff09\u7ec4\u6210\u7684\u8f83\u4e0d\u7ed3\u6784\u5316\u5f62\u5f0f\u4e4b\u95f4\u5b58\u5728\u975e\u5e38\u5bc6\u5207\u7684\u5173\u7cfb\u3002</p> <p>\u867d\u7136\u6211\u4eec\u53ef\u4ee5\uff08\u5e76\u4e14\u6709\u65f6\u786e\u5b9e\uff09\u901a\u8fc7\u4f7f\u7528\u5355\u8bcd\"\u8f6c\u50a8\"\u6765\u533a\u5206\u8fd9\u4e9b\u573a\u666f\uff08\u5f53\u8f6c\u6362\u4e3a\u57fa\u672c\u7c7b\u578b\u65f6\uff09\u548c\u4f7f\u7528\"\u5e8f\u5217\u5316\"\uff08\u5f53\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u65f6\uff09\uff0c\u4f46\u51fa\u4e8e\u5b9e\u9645\u76ee\u7684\uff0c\u6211\u4eec\u7ecf\u5e38\u4f7f\u7528\u5355\u8bcd\"\u5e8f\u5217\u5316\"\u6765\u6307\u4ee3\u8fd9\u4e24\u79cd\u60c5\u51b5\uff0c\u5373\u4f7f\u5b83\u5e76\u4e0d\u603b\u662f\u610f\u5473\u7740\u8f6c\u6362\u4e3a\u5b57\u7b26\u4e32\u6216\u5b57\u8282\u3002</p> <p>Tip</p> <p>\u60f3\u8981\u5feb\u901f\u8df3\u8f6c\u5230\u76f8\u5173\u7684\u5e8f\u5217\u5316\u5668\u90e8\u5206\uff1f</p> <ul> <li> <p>\u5b57\u6bb5\u5e8f\u5217\u5316\u5668</p> <ul> <li>\u5b57\u6bb5 plain \u5e8f\u5217\u5316\u5668</li> <li>\u5b57\u6bb5 wrap \u5e8f\u5217\u5316\u5668</li> </ul> </li> <li> <p>\u6a21\u578b\u5e8f\u5217\u5316\u5668</p> <ul> <li>\u6a21\u578b plain \u5e8f\u5217\u5316\u5668</li> <li>\u6a21\u578b wrap \u5e8f\u5217\u5316\u5668</li> </ul> </li> </ul>"},{"location":"concepts/serialization/#serializing-data","title":"\u5e8f\u5217\u5316\u6570\u636e","text":"<p>Pydantic \u5141\u8bb8\u6a21\u578b\uff08\u4ee5\u53ca\u4f7f\u7528\u7c7b\u578b\u9002\u914d\u5668\u7684\u4efb\u4f55\u5176\u4ed6\u7c7b\u578b\uff09\u4ee5\u4e24\u79cd\u6a21\u5f0f\u8fdb\u884c\u5e8f\u5217\u5316\uff1aPython\u6a21\u5f0f\u548cJSON\u6a21\u5f0f\u3002Python\u8f93\u51fa\u53ef\u80fd\u5305\u542b\u4e0d\u53efJSON\u5e8f\u5217\u5316\u7684\u6570\u636e\uff08\u5c3d\u7ba1\u8fd9\u53ef\u4ee5\u6a21\u62df\uff09\u3002</p> <p></p>"},{"location":"concepts/serialization/#python-mode","title":"Python \u6a21\u5f0f","text":"<p>\u5f53\u4f7f\u7528 Python \u6a21\u5f0f\u65f6\uff0cPydantic \u6a21\u578b\uff08\u4ee5\u53ca\u7c7b\u4f3c\u6a21\u578b\u7684\u7c7b\u578b\uff0c\u5982 dataclasses\uff09\uff081\uff09\u5c06\u88ab\uff08\u9012\u5f52\u5730\uff09\u8f6c\u6362\u4e3a\u5b57\u5178\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528<code>model_dump()</code>\u65b9\u6cd5\u5b9e\u73b0\uff1a</p> <ol> <li>\u9664\u4e86\u6839\u6a21\u578b\uff0c\u5176\u4e2d\u6839\u503c\u76f4\u63a5\u8f6c\u50a8\u3002</li> </ol> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    banana: Optional[float] = 1.1\n    foo: str = Field(serialization_alias='foo_alias')\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': (1, 2)})\n\n# returns a dictionary:\nprint(m.model_dump())\n#&gt; {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(by_alias=True))\n#&gt; {'banana': 3.14, 'foo_alias': 'hello', 'bar': {'whatever': (1, 2)}}\n</code></pre> <pre><code>from pydantic import BaseModel, Field\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    banana: float | None = 1.1\n    foo: str = Field(serialization_alias='foo_alias')\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': (1, 2)})\n\n# returns a dictionary:\nprint(m.model_dump())\n#&gt; {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': (1, 2)}}\n\nprint(m.model_dump(by_alias=True))\n#&gt; {'banana': 3.14, 'foo_alias': 'hello', 'bar': {'whatever': (1, 2)}}\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c<code>whatever</code> \u7684\u503c\u88ab\u8f6c\u50a8\u4e3a\u5143\u7ec4\uff0c\u8fd9\u4e0d\u662f\u5df2\u77e5\u7684 JSON \u7c7b\u578b\u3002\u53ef\u4ee5\u5c06 <code>mode</code> \u53c2\u6570\u8bbe\u7f6e\u4e3a <code>'json'</code> \u4ee5\u786e\u4fdd\u4f7f\u7528JSON\u517c\u5bb9\u7684\u7c7b\u578b\uff1a</p> <pre><code>print(m.model_dump(mode='json'))\n#&gt; {'banana': 3.14, 'foo': 'hello', 'bar': {'whatever': [1, 2]}}\n</code></pre> <p>\u53e6\u8bf7\u53c2\u9605</p> <p>\u5f53\u4e0d\u5904\u7406 Pydantic \u6a21\u578b\u65f6\uff0c<code>TypeAdapter.dump_python()</code>\u65b9\u6cd5\u5f88\u6709\u7528\u3002</p> <p></p>"},{"location":"concepts/serialization/#json-mode","title":"JSON \u6a21\u5f0f","text":"<p>Pydantic \u5141\u8bb8\u6570\u636e\u76f4\u63a5\u5e8f\u5217\u5316\u4e3a JSON \u7f16\u7801\u7684\u5b57\u7b26\u4e32\uff0c\u901a\u8fc7\u5c3d\u529b\u5c06 Python \u503c\u8f6c\u6362\u4e3a\u6709\u6548\u7684 JSON \u6570\u636e\u3002\u8fd9\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>model_dump_json()</code> \u65b9\u6cd5\u5b9e\u73b0\uff1a</p> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: tuple[int, ...]\n\n\nclass FooBarModel(BaseModel):\n    foo: datetime\n    bar: BarModel\n\n\nm = FooBarModel(foo=datetime(2032, 6, 1, 12, 13, 14), bar={'whatever': (1, 2)})\n\nprint(m.model_dump_json(indent=2))\n\"\"\"\n{\n  \"foo\": \"2032-06-01T12:13:14\",\n  \"bar\": {\n    \"whatever\": [\n      1,\n      2\n    ]\n  }\n}\n\"\"\"\n</code></pre> <p>\u9664\u4e86\u6807\u51c6\u5e93 <code>json</code> \u6a21\u5757\u652f\u6301\u7684\u7c7b\u578b\u4e4b\u5916\uff0cPydantic\u8fd8\u652f\u6301\u591a\u79cd\u7c7b\u578b\uff08\u65e5\u671f\u548c\u65f6\u95f4\u7c7b\u578b\u3001<code>UUID</code> \u5bf9\u8c61\u3001\u96c6\u5408\u7b49\uff09\u3002\u5982\u679c\u4f7f\u7528\u4e86\u4e0d\u652f\u6301\u7684\u7c7b\u578b\u4e14\u65e0\u6cd5\u5e8f\u5217\u5316\u4e3a JSON\uff0c\u5219\u4f1a\u5f15\u53d1 <code>PydanticSerializationError</code> \u5f02\u5e38\u3002</p> <p>\u53e6\u8bf7\u53c2\u9605</p> <p>\u5f53\u4e0d\u5904\u7406 Pydantic \u6a21\u578b\u65f6\uff0c<code>TypeAdapter.dump_json()</code> \u65b9\u6cd5\u5f88\u6709\u7528\u3002</p> <p></p>"},{"location":"concepts/serialization/#_1","title":"\u8fed\u4ee3\u6a21\u578b","text":"<p>Pydantic \u6a21\u578b\u4e5f\u53ef\u4ee5\u88ab\u8fed\u4ee3\uff0c\u4ea7\u751f <code>(\u5b57\u6bb5\u540d, \u5b57\u6bb5\u503c)</code> \u5bf9\u3002\u8bf7\u6ce8\u610f\uff0c\u5b57\u6bb5\u503c\u4fdd\u6301\u539f\u6837\uff0c\u56e0\u6b64\u5b50\u6a21\u578b\u4e0d\u4f1a\u88ab\u8f6c\u6362\u4e3a\u5b57\u5178\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nfor name, value in m:\n    print(f'{name}: {value}')\n    #&gt; banana: 3.14\n    #&gt; foo: hello\n    #&gt; bar: whatever=123\n</code></pre> <p>\u8fd9\u610f\u5473\u7740\u5728\u6a21\u578b\u4e0a\u8c03\u7528 <code>dict()</code> \u53ef\u4ee5\u7528\u4e8e\u6784\u9020\u6a21\u578b\u7684\u5b57\u5178\uff1a</p> <pre><code>print(dict(m))\n#&gt; {'banana': 3.14, 'foo': 'hello', 'bar': BarModel(whatever=123)}\n</code></pre> <p>Note</p> <p>\u6839\u6a21\u578b\u786e\u5b9e\u4f1a\u88ab\u8f6c\u6362\u4e3a\u5e26\u6709\u952e <code>'root'</code> \u7684\u5b57\u5178\u3002</p> <p></p>"},{"location":"concepts/serialization/#pickling","title":"Pickling \u652f\u6301","text":"<p>Pydantic \u6a21\u578b\u652f\u6301\u9ad8\u6548\u7684 pickling \u548c unpickling \u3002</p> <pre><code>import pickle\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\n#&gt; a='hello' b=123\ndata = pickle.dumps(m)\nprint(data[:20])\n#&gt; b'\\x80\\x04\\x95\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main_'\nm2 = pickle.loads(data)\nprint(m2)\n#&gt; a='hello' b=123\n</code></pre> <p></p>"},{"location":"concepts/serialization/#serializers","title":"\u5e8f\u5217\u5316\u5668","text":"<p>\u7c7b\u4f3c\u4e8e\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\uff0c\u60a8\u53ef\u4ee5\u5728\u5b57\u6bb5\u548c\u6a21\u578b\u7ea7\u522b\u5229\u7528\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u5668\u6765\u8fdb\u4e00\u6b65\u63a7\u5236\u5e8f\u5217\u5316\u884c\u4e3a\u3002</p> <p>Warning</p> <p>\u6bcf\u4e2a\u5b57\u6bb5/\u6a21\u578b\u53ea\u80fd\u5b9a\u4e49\u4e00\u4e2a\u5e8f\u5217\u5316\u5668\u3002\u4e0d\u53ef\u80fd\u5c06\u591a\u4e2a\u5e8f\u5217\u5316\u5668\u7ec4\u5408\u5728\u4e00\u8d77\uff08\u5305\u62ec plain \u548c wrap \u5e8f\u5217\u5316\u5668\uff09\u3002</p>"},{"location":"concepts/serialization/#field-serializers","title":"\u5b57\u6bb5\u5e8f\u5217\u5316\u5668","text":"API \u6587\u6863 <p><code>pydantic.functional_serializers.PlainSerializer</code> <code>pydantic.functional_serializers.WrapSerializer</code> <code>pydantic.functional_serializers.field_serializer</code></p> <p>\u5728\u6700\u7b80\u5355\u7684\u5f62\u5f0f\u4e2d\uff0c\u5b57\u6bb5\u5e8f\u5217\u5316\u5668\u662f\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u5c06\u8981\u5e8f\u5217\u5316\u7684\u503c\u4f5c\u4e3a\u53c2\u6570\u5e76\u8fd4\u56de\u5e8f\u5217\u5316\u540e\u7684\u503c\u3002</p> <p>\u5982\u679c\u5411\u5e8f\u5217\u5316\u5668\u63d0\u4f9b\u4e86 <code>return_type</code> \u53c2\u6570\uff08\u6216\u8005\u5e8f\u5217\u5316\u5668\u51fd\u6570\u4e0a\u6709\u53ef\u7528\u7684\u8fd4\u56de\u7c7b\u578b\u6ce8\u89e3\uff09\uff0c\u5b83\u5c06\u7528\u4e8e\u6784\u5efa\u989d\u5916\u7684\u5e8f\u5217\u5316\u5668\uff0c\u4ee5\u786e\u4fdd\u5e8f\u5217\u5316\u7684\u5b57\u6bb5\u503c\u7b26\u5408\u6b64\u8fd4\u56de\u7c7b\u578b\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u5e8f\u5217\u5316\u5668\u3002\u5b83\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\u6216\u4f7f\u7528 <code>@field_serializer</code> \u88c5\u9970\u5668\u6765\u5b9a\u4e49\uff0c\u5e94\u7528\u4e8e\u5b9e\u4f8b\u6216\u9759\u6001\u65b9\u6cd5\u3002</p> <ul> <li> <p>Plain \u5e8f\u5217\u5316\u5668\uff1a\u65e0\u6761\u4ef6\u8c03\u7528\u4ee5\u5e8f\u5217\u5316\u5b57\u6bb5\u3002Pydantic\u652f\u6301\u7684\u7c7b\u578b\u7684\u5e8f\u5217\u5316\u903b\u8f91\u5c06\u4e0d\u4f1a\u88ab\u8c03\u7528\u3002\u4f7f\u7528\u6b64\u7c7b\u5e8f\u5217\u5316\u5668\u5bf9\u4e8e\u6307\u5b9a\u4efb\u610f\u7c7b\u578b\u7684\u903b\u8f91\u4e5f\u5f88\u6709\u7528\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668 <pre><code>from typing import Annotated, Any\n\nfrom pydantic import BaseModel, PlainSerializer\n\n\ndef ser_number(value: Any) -&gt; Any:\n    if isinstance(value, int):\n        return value * 2\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    number: Annotated[int, PlainSerializer(ser_number)]\n\n\nprint(Model(number=4).model_dump())\n#&gt; {'number': 8}\nm = Model(number=1)\nm.number = 'invalid'\nprint(m.model_dump())  # (1)!\n#&gt; {'number': 'invalid'}\n</code></pre> <ol> <li>Pydantic \u5c06\u4e0d\u4f1a\u9a8c\u8bc1\u5e8f\u5217\u5316\u540e\u7684\u503c\u662f\u5426\u7b26\u5408 <code>int</code> \u7c7b\u578b\u3002</li> </ol> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, field_serializer\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_serializer('number', mode='plain')  # (1)!\n    def ser_number(self, value: Any) -&gt; Any:\n        if isinstance(value, int):\n            return value * 2\n        else:\n            return value\n\n\nprint(Model(number=4).model_dump())\n#&gt; {'number': 8}\nm = Model(number=1)\nm.number = 'invalid'\nprint(m.model_dump())  # (2)!\n#&gt; {'number': 'invalid'}\n</code></pre> <ol> <li><code>'plain'</code> \u662f\u88c5\u9970\u5668\u7684\u9ed8\u8ba4\u6a21\u5f0f\uff0c\u53ef\u4ee5\u7701\u7565\u3002</li> <li>Pydantic \u5c06\u4e0d\u4f1a\u9a8c\u8bc1\u5e8f\u5217\u5316\u540e\u7684\u503c\u662f\u5426\u7b26\u5408 <code>int</code> \u7c7b\u578b\u3002</li> </ol> </li> <li> <p>Wrap \u5e8f\u5217\u5316\u5668\uff1a\u63d0\u4f9b\u66f4\u5927\u7684\u7075\u6d3b\u6027\u6765\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u884c\u4e3a\u3002\u60a8\u53ef\u4ee5\u5728 Pydantic \u5e8f\u5217\u5316\u903b\u8f91\u4e4b\u524d\u6216\u4e4b\u540e\u8fd0\u884c\u4ee3\u7801\u3002</p> <p>\u6b64\u7c7b\u5e8f\u5217\u5316\u5668\u5fc5\u987b\u5b9a\u4e49\u5f3a\u5236\u6027\u7684\u989d\u5916handler\u53c2\u6570\uff1a\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u5c06\u8981\u5e8f\u5217\u5316\u7684\u503c\u4f5c\u4e3a\u53c2\u6570\u3002\u5728\u5185\u90e8\uff0c\u6b64handler\u5c06\u628a\u503c\u7684\u5e8f\u5217\u5316\u59d4\u6258\u7ed9 Pydantic\u3002\u60a8\u53ef\u4ee5\u5b8c\u5168\u4e0d\u8c03\u7528 handler\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668 <pre><code>from typing import Annotated, Any\n\nfrom pydantic import BaseModel, SerializerFunctionWrapHandler, WrapSerializer\n\n\ndef ser_number(value: Any, handler: SerializerFunctionWrapHandler) -&gt; int:\n    return handler(value) + 1\n\n\nclass Model(BaseModel):\n    number: Annotated[int, WrapSerializer(ser_number)]\n\n\nprint(Model(number=4).model_dump())\n#&gt; {'number': 5}\n</code></pre> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, SerializerFunctionWrapHandler, field_serializer\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_serializer('number', mode='wrap')\n    def ser_number(\n        self, value: Any, handler: SerializerFunctionWrapHandler\n    ) -&gt; int:\n        return handler(value) + 1\n\n\nprint(Model(number=4).model_dump())\n#&gt; {'number': 5}\n</code></pre> </li> </ul>"},{"location":"concepts/serialization/#_2","title":"\u4f7f\u7528\u54ea\u79cd\u5e8f\u5217\u5316\u5668\u6a21\u5f0f","text":"<p>\u867d\u7136\u4e24\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5b9e\u73b0\u76f8\u540c\u7684\u4e8b\u60c5\uff0c\u4f46\u6bcf\u79cd\u6a21\u5f0f\u90fd\u63d0\u4f9b\u4e0d\u540c\u7684\u597d\u5904\u3002</p>"},{"location":"concepts/serialization/#_3","title":"\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f","text":"<p>\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\u7684\u4e3b\u8981\u597d\u5904\u4e4b\u4e00\u662f\u4f7f\u5e8f\u5217\u5316\u5668\u53ef\u91cd\u7528\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field, PlainSerializer\n\nDoubleNumber = Annotated[int, PlainSerializer(lambda v: v * 2)]\n\n\nclass Model1(BaseModel):\n    my_number: DoubleNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[DoubleNumber, Field(description='\u6211\u7684\u5176\u4ed6\u6570\u5b57')]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[DoubleNumber]  # (1)!\n</code></pre> <ol> <li>\u5982\u6ce8\u89e3\u6a21\u5f0f\u6587\u6863\u4e2d\u6240\u8ff0\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5bf9\u6ce8\u89e3\u7684\u7279\u5b9a\u90e8\u5206\u4f7f\u7528\u5e8f\u5217\u5316\u5668\uff08\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5e8f\u5217\u5316\u5e94\u7528\u4e8e\u5217\u8868\u9879\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u5217\u8868\uff09\u3002</li> </ol> <p>\u901a\u8fc7\u67e5\u770b\u5b57\u6bb5\u6ce8\u89e3\uff0c\u4e5f\u66f4\u5bb9\u6613\u7406\u89e3\u54ea\u4e9b\u5e8f\u5217\u5316\u5668\u5e94\u7528\u4e8e\u7c7b\u578b\u3002</p>"},{"location":"concepts/serialization/#_4","title":"\u4f7f\u7528\u88c5\u9970\u5668\u6a21\u5f0f","text":"<p>\u4f7f\u7528 <code>@field_serializer</code> \u88c5\u9970\u5668\u7684\u4e3b\u8981\u597d\u5904\u4e4b\u4e00\u662f\u5c06\u51fd\u6570\u5e94\u7528\u4e8e\u591a\u4e2a\u5b57\u6bb5\uff1a</p> <pre><code>from pydantic import BaseModel, field_serializer\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_serializer('f1', 'f2', mode='plain')\n    def capitalize(self, value: str) -&gt; str:\n        return value.capitalize()\n</code></pre> <p>\u4ee5\u4e0b\u662f\u5173\u4e8e\u88c5\u9970\u5668\u7528\u6cd5\u7684\u4e00\u4e9b\u989d\u5916\u8bf4\u660e\uff1a</p> <ul> <li>\u5982\u679c\u60a8\u5e0c\u671b\u5e8f\u5217\u5316\u5668\u5e94\u7528\u4e8e\u6240\u6709\u5b57\u6bb5\uff08\u5305\u62ec\u5b50\u7c7b\u4e2d\u5b9a\u4e49\u7684\u5b57\u6bb5\uff09\uff0c\u53ef\u4ee5\u5c06 <code>'*'</code> \u4f5c\u4e3a\u5b57\u6bb5\u540d\u53c2\u6570\u4f20\u9012\u3002</li> <li>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u88c5\u9970\u5668\u5c06\u786e\u4fdd\u63d0\u4f9b\u7684\u5b57\u6bb5\u540d\u5728\u6a21\u578b\u4e0a\u5b9a\u4e49\u3002\u5982\u679c\u8981\u5728\u7c7b\u521b\u5efa\u671f\u95f4\u7981\u7528\u6b64\u68c0\u67e5\uff0c\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>False</code> \u4f20\u9012\u7ed9 <code>check_fields</code> \u53c2\u6570\u6765\u5b9e\u73b0\u3002\u5f53\u5b57\u6bb5\u5e8f\u5217\u5316\u5668\u5728\u57fa\u7c7b\u4e0a\u5b9a\u4e49\uff0c\u5e76\u4e14\u671f\u671b\u5b57\u6bb5\u5b58\u5728\u4e8e\u5b50\u7c7b\u4e0a\u65f6\uff0c\u8fd9\u5f88\u6709\u7528\u3002</li> </ul>"},{"location":"concepts/serialization/#_5","title":"\u6a21\u578b\u5e8f\u5217\u5316\u5668","text":"API \u6587\u6863 <p><code>pydantic.functional_serializers.model_serializer</code></p> <p>\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>@model_serializer</code> \u88c5\u9970\u5668\u5728\u6574\u4e2a\u6a21\u578b\u4e0a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u3002</p> <p>\u5982\u679c\u5411 <code>@model_serializer</code> \u88c5\u9970\u5668\u63d0\u4f9b\u4e86 <code>return_type</code> \u53c2\u6570\uff08\u6216\u8005\u5e8f\u5217\u5316\u5668\u51fd\u6570\u4e0a\u6709\u53ef\u7528\u7684\u8fd4\u56de\u7c7b\u578b\u6ce8\u89e3\uff09\uff0c\u5b83\u5c06\u7528\u4e8e\u6784\u5efa\u989d\u5916\u7684\u5e8f\u5217\u5316\u5668\uff0c\u4ee5\u786e\u4fdd\u5e8f\u5217\u5316\u7684\u6a21\u578b\u503c\u7b26\u5408\u6b64\u8fd4\u56de\u7c7b\u578b\u3002</p> <p>\u4e0e\u5b57\u6bb5\u5e8f\u5217\u5316\u5668\u4e00\u6837\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e24\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6a21\u578b\u5e8f\u5217\u5316\u5668\uff1a</p> <ul> <li> <p>Plain \u5e8f\u5217\u5316\u5668\uff1a\u65e0\u6761\u4ef6\u8c03\u7528\u4ee5\u5e8f\u5217\u5316\u6a21\u578b\u3002</p> <pre><code>from pydantic import BaseModel, model_serializer\n\n\nclass UserModel(BaseModel):\n    username: str\n    password: str\n\n    @model_serializer(mode='plain')  # (1)!\n    def serialize_model(self) -&gt; str:  # (2)!\n        return f'{self.username} - {self.password}'\n\n\nprint(UserModel(username='foo', password='bar').model_dump())\n#&gt; foo - bar\n</code></pre> <ol> <li><code>'plain'</code> \u662f\u88c5\u9970\u5668\u7684\u9ed8\u8ba4\u6a21\u5f0f\uff0c\u53ef\u4ee5\u7701\u7565\u3002</li> <li>\u60a8\u53ef\u4ee5\u81ea\u7531\u8fd4\u56de\u4e00\u4e2a\u4e0d\u662f\u5b57\u5178\u7684\u503c\u3002</li> </ol> </li> <li> <p>Wrap \u5e8f\u5217\u5316\u5668\uff1a\u63d0\u4f9b\u66f4\u5927\u7684\u7075\u6d3b\u6027\u6765\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u884c\u4e3a\u3002\u60a8\u53ef\u4ee5\u5728 Pydantic \u5e8f\u5217\u5316\u903b\u8f91\u4e4b\u524d\u6216\u4e4b\u540e\u8fd0\u884c\u4ee3\u7801\u3002</p> <p>\u6b64\u7c7b\u5e8f\u5217\u5316\u5668\u5fc5\u987b\u5b9a\u4e49\u5f3a\u5236\u7684\u989d\u5916\u53c2\u6570 <code>*handler*</code> \uff1a\u4e00\u4e2a\u63a5\u53d7\u6a21\u578b\u5b9e\u4f8b\u4f5c\u4e3a\u53c2\u6570\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u3002\u5728\u5185\u90e8\uff0c\u6b64 handler \u5c06\u6a21\u578b\u7684\u5e8f\u5217\u5316\u59d4\u6258\u7ed9 Pydantic\u3002\u60a8\u53ef\u4ee5\u5b8c\u5168\u4e0d\u8c03\u7528 handler\u3002</p> <pre><code>from pydantic import BaseModel, SerializerFunctionWrapHandler, model_serializer\n\n\nclass UserModel(BaseModel):\n    username: str\n    password: str\n\n    @model_serializer(mode='wrap')\n    def serialize_model(\n        self, handler: SerializerFunctionWrapHandler\n    ) -&gt; dict[str, object]:\n        serialized = handler(self)\n        serialized['fields'] = list(serialized)\n        return serialized\n\n\nprint(UserModel(username='foo', password='bar').model_dump())\n#&gt; {'username': 'foo', 'password': 'bar', 'fields': ['username', 'password']}\n</code></pre> </li> </ul>"},{"location":"concepts/serialization/#_6","title":"\u5e8f\u5217\u5316\u4fe1\u606f","text":"<p>\u5b57\u6bb5\u548c\u6a21\u578b\u5e8f\u5217\u5316\u5668\u53ef\u8c03\u7528\u5bf9\u8c61\uff08\u5728\u6240\u6709\u6a21\u5f0f\u4e0b\uff09\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u63a5\u53d7\u4e00\u4e2a\u989d\u5916\u7684\u53c2\u6570 <code>info</code> \uff0c\u63d0\u4f9b\u6709\u7528\u7684\u989d\u5916\u4fe1\u606f\uff0c\u4f8b\u5982\uff1a</p> <ul> <li>\u7528\u6237\u5b9a\u4e49\u7684\u4e0a\u4e0b\u6587</li> <li>\u5f53\u524d\u5e8f\u5217\u5316\u6a21\u5f0f\uff1a<code>'python'</code> \u6216 <code>'json'</code>\uff08\u53c2\u89c1 <code>mode</code> \u5c5e\u6027\uff09</li> <li>\u4f7f\u7528\u5e8f\u5217\u5316\u65b9\u6cd5\u5728\u5e8f\u5217\u5316\u671f\u95f4\u8bbe\u7f6e\u7684\u5404\u79cd\u53c2\u6570   \uff08\u4f8b\u5982 <code>exclude_unset</code>\u3001<code>serialize_as_any</code>\uff09</li> <li>\u5f53\u524d\u5b57\u6bb5\u540d\uff0c\u5982\u679c\u4f7f\u7528\u5b57\u6bb5\u5e8f\u5217\u5316\u5668\uff08\u53c2\u89c1 <code>field_name</code> \u5c5e\u6027\uff09\u3002</li> </ul>"},{"location":"concepts/serialization/#serialization-context","title":"\u5e8f\u5217\u5316\u4e0a\u4e0b\u6587","text":"<p>\u60a8\u53ef\u4ee5\u5411\u5e8f\u5217\u5316\u65b9\u6cd5\u4f20\u9012\u4e00\u4e2a\u4e0a\u4e0b\u6587\u5bf9\u8c61\uff0c\u53ef\u4ee5\u5728\u5e8f\u5217\u5316\u5668\u51fd\u6570\u5185\u90e8\u4f7f\u7528 <code>context</code> \u5c5e\u6027\u8bbf\u95ee\uff1a</p> <pre><code>from pydantic import BaseModel, FieldSerializationInfo, field_serializer\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_serializer('text', mode='plain')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: FieldSerializationInfo) -&gt; str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\nmodel = Model(text='This is an example document')\nprint(model.model_dump())  # \u65e0\u4e0a\u4e0b\u6587\n#&gt; {'text': 'This is an example document'}\nprint(model.model_dump(context={'stopwords': ['this', 'is', 'an']}))\n#&gt; {'text': 'example document'}\n</code></pre> <p>\u7c7b\u4f3c\u5730\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u4e0a\u4e0b\u6587\u8fdb\u884c\u9a8c\u8bc1\u3002</p>"},{"location":"concepts/serialization/#_7","title":"\u5e8f\u5217\u5316\u5b50\u7c7b","text":""},{"location":"concepts/serialization/#_8","title":"\u652f\u6301\u7c7b\u578b\u7684\u5b50\u7c7b","text":"<p>\u652f\u6301\u7c7b\u578b\u7684\u5b50\u7c7b\u6839\u636e\u5176\u8d85\u7c7b\u8fdb\u884c\u5e8f\u5217\u5316\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass MyDate(date):\n    @property\n    def my_date_format(self) -&gt; str:\n        return self.strftime('%d/%m/%Y')\n\n\nclass FooModel(BaseModel):\n    date: date\n\n\nm = FooModel(date=MyDate(2023, 1, 1))\nprint(m.model_dump_json())\n#&gt; {\"date\":\"2023-01-01\"}\n</code></pre> <p></p>"},{"location":"concepts/serialization/#subclasses-of-model-like-types","title":"\u7c7b\u6a21\u578b\u7c7b\u578b\u7684\u5b50\u7c7b","text":"<p>\u5f53\u4f7f\u7528\u6a21\u578b\u7c7b\uff08Pydantic \u6a21\u578b\u3001\u6570\u636e\u7c7b\u7b49\uff09\u4f5c\u4e3a\u5b57\u6bb5\u6ce8\u89e3\u65f6\uff0c\u9ed8\u8ba4\u884c\u4e3a\u662f\u5c06\u5b57\u6bb5\u503c\u5e8f\u5217\u5316\u4e3a\u8be5\u7c7b\u7684\u5b9e\u4f8b\uff0c\u5373\u4f7f\u5b83\u662f\u5b50\u7c7b\u3002\u66f4\u5177\u4f53\u5730\u8bf4\uff0c\u53ea\u6709\u7c7b\u578b\u6ce8\u89e3\u4e0a\u58f0\u660e\u7684\u5b57\u6bb5\u624d\u4f1a\u5305\u542b\u5728\u5e8f\u5217\u5316\u7ed3\u679c\u4e2d\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user: User\n\n\nuser = UserLogin(name='pydantic', password='hunter2')\n\nm = OuterModel(user=user)\nprint(m)\n#&gt; user=UserLogin(name='pydantic', password='hunter2')\nprint(m.model_dump())  # (1)!\n#&gt; {'user': {'name': 'pydantic'}}\n</code></pre> <ol> <li>\u6ce8\u610f\uff1apassword \u5b57\u6bb5\u672a\u5305\u542b</li> </ol> <p>\u8fc1\u79fb\u8b66\u544a</p> <p>\u6b64\u884c\u4e3a\u4e0e Pydantic V1 \u7684\u5de5\u4f5c\u65b9\u5f0f\u4e0d\u540c\uff0c\u5728 V1 \u4e2d\uff0c\u6211\u4eec\u603b\u662f\u4f1a\u5728\u9012\u5f52\u5e8f\u5217\u5316\u6a21\u578b\u5230\u5b57\u5178\u65f6\u5305\u542b\u6240\u6709\uff08\u5b50\u7c7b\uff09\u5b57\u6bb5\u3002\u6b64\u884c\u4e3a\u66f4\u6539\u80cc\u540e\u7684\u52a8\u673a\u662f\uff0c\u5b83\u6709\u52a9\u4e8e\u786e\u4fdd\u60a8\u786e\u5207\u77e5\u9053\u5728\u5e8f\u5217\u5316\u65f6\u53ef\u80fd\u5305\u542b\u54ea\u4e9b\u5b57\u6bb5\uff0c\u5373\u4f7f\u5728\u5b9e\u4f8b\u5316\u5bf9\u8c61\u65f6\u4f20\u9012\u4e86\u5b50\u7c7b\u3002\u7279\u522b\u662f\uff0c\u8fd9\u6709\u52a9\u4e8e\u9632\u6b62\u5728\u5c06\u654f\u611f\u4fe1\u606f\uff08\u5982\u5bc6\u7801\uff09\u4f5c\u4e3a\u5b50\u7c7b\u5b57\u6bb5\u6dfb\u52a0\u65f6\u51fa\u73b0\u610f\u5916\u3002\u8981\u542f\u7528\u65e7\u7684 V1 \u884c\u4e3a\uff0c\u8bf7\u53c2\u9605\u4e0b\u4e00\u8282\u3002</p>"},{"location":"concepts/serialization/#_9","title":"\u4f7f\u7528\u9e2d\u5b50\u7c7b\u578b\u5e8f\u5217\u5316 \ud83e\udd86","text":"<p>\u9e2d\u5b50\u7c7b\u578b\u5e8f\u5217\u5316\u662f\u57fa\u4e8e\u5b9e\u9645\u5b57\u6bb5\u503c\u800c\u4e0d\u662f\u5b57\u6bb5\u5b9a\u4e49\u6765\u5e8f\u5217\u5316\u6a21\u578b\u5b9e\u4f8b\u7684\u884c\u4e3a\u3002\u8fd9\u610f\u5473\u7740\u5bf9\u4e8e\u4f7f\u7528\u6a21\u578b\u7c7b\u6ce8\u89e3\u7684\u5b57\u6bb5\uff0c\u6b64\u7c7b\u5b50\u7c7b\u4e2d\u5b58\u5728\u7684\u6240\u6709\u5b57\u6bb5\u90fd\u5c06\u5305\u542b\u5728\u5e8f\u5217\u5316\u8f93\u51fa\u4e2d\u3002</p> <p>\u6b64\u884c\u4e3a\u53ef\u4ee5\u5728\u5b57\u6bb5\u7ea7\u522b\u548c\u8fd0\u884c\u65f6\u914d\u7f6e\uff0c\u7528\u4e8e\u7279\u5b9a\u7684\u5e8f\u5217\u5316\u8c03\u7528\uff1a</p> <ul> <li>\u5b57\u6bb5\u7ea7\u522b\uff1a\u4f7f\u7528 <code>SerializeAsAny</code> \u6ce8\u89e3\u3002</li> <li>\u8fd0\u884c\u65f6\u7ea7\u522b\uff1a\u5728\u8c03\u7528\u5e8f\u5217\u5316\u65b9\u6cd5\u65f6\u4f7f\u7528 <code>serialize_as_any</code> \u53c2\u6570\u3002</li> </ul> <p>\u6211\u4eec\u5728\u4e0b\u9762\u66f4\u8be6\u7ec6\u5730\u8ba8\u8bba\u8fd9\u4e9b\u9009\u9879\uff1a</p>"},{"location":"concepts/serialization/#serializeasany-annotation","title":"<code>SerializeAsAny</code> \u6ce8\u89e3","text":"<p>\u5982\u679c\u60a8\u60f3\u8981\u9e2d\u5b50\u7c7b\u578b\u5e8f\u5217\u5316\u884c\u4e3a\uff0c\u53ef\u4ee5\u5728\u7c7b\u578b\u4e0a\u4f7f\u7528 <code>SerializeAsAny</code> \u6ce8\u89e3\uff1a</p> <pre><code>from pydantic import BaseModel, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    as_any: SerializeAsAny[User]\n    as_user: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nprint(OuterModel(as_any=user, as_user=user).model_dump())\n\"\"\"\n{\n    'as_any': {'name': 'pydantic', 'password': 'password'},\n    'as_user': {'name': 'pydantic'},\n}\n\"\"\"\n</code></pre> <p>\u5f53\u7c7b\u578b\u88ab\u6ce8\u89e3\u4e3a <code>SerializeAsAny[&lt;type&gt;]</code> \u65f6\uff0c\u9a8c\u8bc1\u884c\u4e3a\u5c06\u4e0e\u6ce8\u89e3\u4e3a <code>&lt;type&gt;</code> \u76f8\u540c\uff0c\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u5c06\u628a\u6ce8\u89e3\u89c6\u4e3a\u7b80\u5355\u7684 <code>&lt;type&gt;</code>\u3002\u5728\u5e8f\u5217\u5316\u65f6\uff0c\u5b57\u6bb5\u5c06\u88ab\u5e8f\u5217\u5316\uff0c\u5c31\u597d\u50cf\u5b57\u6bb5\u7684\u7c7b\u578b\u63d0\u793a\u662f <code>Any</code>\uff0c\u8fd9\u5c31\u662f\u540d\u79f0\u7684\u7531\u6765\u3002</p>"},{"location":"concepts/serialization/#serialize_as_any","title":"<code>serialize_as_any</code> \u8fd0\u884c\u65f6\u8bbe\u7f6e","text":"<p><code>serialize_as_any</code> \u8fd0\u884c\u65f6\u8bbe\u7f6e\u53ef\u7528\u4e8e\u5e8f\u5217\u5316\u6a21\u578b\u6570\u636e\uff0c\u65e0\u8bba\u662f\u5426\u4f7f\u7528\u9e2d\u5b50\u7c7b\u578b\u5e8f\u5217\u5316\u884c\u4e3a\u3002<code>serialize_as_any</code> \u53ef\u4ee5\u4f5c\u4e3a\u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u7ed9\u5404\u79cd\u5e8f\u5217\u5316\u65b9\u6cd5\uff08\u4f8b\u5982Pydantic\u6a21\u578b\u4e0a\u7684 <code>model_dump()</code> \u548c <code>model_dump_json()</code>\uff09\u3002</p> <pre><code>from pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user1: User\n    user2: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nouter_model = OuterModel(user1=user, user2=user)\nprint(outer_model.model_dump(serialize_as_any=True))  # (1)!\n\"\"\"\n{\n    'user1': {'name': 'pydantic', 'password': 'password'},\n    'user2': {'name': 'pydantic', 'password': 'password'},\n}\n\"\"\"\n\nprint(outer_model.model_dump(serialize_as_any=False))  # (2)!\n#&gt; {'user1': {'name': 'pydantic'}, 'user2': {'name': 'pydantic'}}\n</code></pre> <ol> <li>\u5f53 <code>serialize_as_any</code> \u8bbe\u7f6e\u4e3a <code>True</code> \u65f6\uff0c\u7ed3\u679c\u4e0e V1 \u5339\u914d\u3002</li> <li>\u5f53 <code>serialize_as_any</code> \u8bbe\u7f6e\u4e3a <code>False</code>\uff08V2 \u9ed8\u8ba4\u503c\uff09\u65f6\uff0c\u5b50\u7c7b\u4e2d\u5b58\u5728\u4f46\u57fa\u7c7b\u4e2d\u4e0d\u5b58\u5728\u7684\u5b57\u6bb5\u4e0d\u4f1a\u5305\u542b\u5728\u5e8f\u5217\u5316\u4e2d\u3002</li> </ol> <p></p> <p></p>"},{"location":"concepts/serialization/#_10","title":"\u5b57\u6bb5\u5305\u542b\u548c\u6392\u9664","text":"<p>\u5bf9\u4e8e\u5e8f\u5217\u5316\uff0c\u5b57\u6bb5\u5305\u542b\u548c\u6392\u9664\u53ef\u4ee5\u901a\u8fc7\u4e24\u79cd\u65b9\u5f0f\u914d\u7f6e\uff1a</p> <ul> <li>\u5728\u5b57\u6bb5\u7ea7\u522b\uff0c\u4f7f\u7528 <code>Field()</code> \u51fd\u6570 \u4e0a\u7684 <code>exclude</code> \u548c <code>exclude_if</code> \u53c2\u6570\u3002</li> <li>\u4f7f\u7528\u5e8f\u5217\u5316\u65b9\u6cd5\u4e0a\u7684\u5404\u79cd\u5e8f\u5217\u5316\u53c2\u6570\u3002</li> </ul>"},{"location":"concepts/serialization/#_11","title":"\u5728\u5b57\u6bb5\u7ea7\u522b","text":"<p>\u5728\u5b57\u6bb5\u7ea7\u522b\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>exclude</code> \u548c <code>exclude_if</code> \u53c2\u6570\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Transaction(BaseModel):\n    id: int\n    private_id: int = Field(exclude=True)\n    value: int = Field(ge=0, exclude_if=lambda v: v == 0)\n\n\nprint(Transaction(id=1, private_id=2, value=0).model_dump())\n#&gt; {'id': 1}\n</code></pre> <p>\u5b57\u6bb5\u7ea7\u522b\u7684\u6392\u9664\u4f18\u5148\u4e8e\u4e0b\u9762\u63cf\u8ff0\u7684 <code>include</code> \u5e8f\u5217\u5316\u53c2\u6570\u3002</p>"},{"location":"concepts/serialization/#_12","title":"\u4f5c\u4e3a\u5e8f\u5217\u5316\u65b9\u6cd5\u7684\u53c2\u6570","text":"<p>\u5f53\u4f7f\u7528\u5e8f\u5217\u5316\u65b9\u6cd5\uff08\u4f8b\u5982 <code>model_dump()</code>\uff09\u65f6\uff0c \u53ef\u4ee5\u4f7f\u7528\u51e0\u4e2a\u53c2\u6570\u6765\u6392\u9664\u6216\u5305\u542b\u5b57\u6bb5\u3002</p>"},{"location":"concepts/serialization/#_13","title":"\u6392\u9664\u548c\u5305\u542b\u7279\u5b9a\u5b57\u6bb5","text":"<p>\u8003\u8651\u4ee5\u4e0b\u6a21\u578b\uff1a</p> <pre><code>from pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    private_id: str = Field(exclude=True)\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    private_id='123',\n    user=User(id=42, username='JohnDoe', password='hashedpassword'),\n    value=9876543210,\n)\n</code></pre> <p><code>exclude</code> \u53c2\u6570\u53ef\u7528\u4e8e\u6307\u5b9a\u5e94\u6392\u9664\u54ea\u4e9b\u5b57\u6bb5\uff08\u5305\u62ec\u5176\u4ed6\u5b57\u6bb5\uff09\uff0c\u53cd\u4e4b\u4ea6\u7136\uff0c\u4f7f\u7528 <code>include</code> \u53c2\u6570\u3002</p> <pre><code># \u4f7f\u7528\u96c6\u5408\uff1a\nprint(t.model_dump(exclude={'user', 'value'}))\n#&gt; {'id': '1234567890'}\n\n# \u4f7f\u7528\u5b57\u5178\uff1a\nprint(t.model_dump(exclude={'user': {'username', 'password'}, 'value': True}))\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n\n# \u4f7f\u7528`include`\u7684\u76f8\u540c\u914d\u7f6e\uff1a\nprint(t.model_dump(include={'id': True, 'user': {'id'}}))\n#&gt; {'id': '1234567890', 'user': {'id': 42}}\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u4e0d\u652f\u6301\u4f7f\u7528 <code>False</code> \u5728 <code>exclude</code> \u4e2d\u5305\u542b\u5b57\u6bb5\uff08\u6216\u5728 <code>include</code> \u4e2d\u6392\u9664\u5b57\u6bb5\uff09\u3002</p> <p>\u4e5f\u53ef\u4ee5\u4ece\u5e8f\u5217\u548c\u5b57\u5178\u4e2d\u6392\u9664\u6216\u5305\u542b\u7279\u5b9a\u9879\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    hobbies: list[Hobby]\n\n\nuser = User(\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nprint(user.model_dump(exclude={'hobbies': {-1: {'info'}}}))  # (1)!\n\"\"\"\n{\n    'hobbies': [\n        {'name': 'Programming', 'info': 'Writing code and stuff'},\n        {'name': 'Gaming'},\n    ]\n}\n\"\"\"\n</code></pre> <ol> <li> <p>\u4f7f\u7528 <code>include</code> \u7684\u7b49\u6548\u8c03\u7528\u4e3a\uff1a</p> <pre><code>user.model_dump(\n   include={'hobbies': {0: True, -1: {'name'}}}\n)\n</code></pre> </li> </ol> <p>\u7279\u6b8a\u952e <code>'__all__'</code> \u53ef\u7528\u4e8e\u5c06\u6392\u9664/\u5305\u542b\u6a21\u5f0f\u5e94\u7528\u4e8e\u6240\u6709\u6210\u5458\uff1a</p> <pre><code>print(user.model_dump(exclude={'hobbies': {'__all__': {'info'}}}))\n#&gt; {'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}]}\n</code></pre>"},{"location":"concepts/serialization/#_14","title":"\u57fa\u4e8e\u5b57\u6bb5\u503c\u6392\u9664\u548c\u5305\u542b\u5b57\u6bb5","text":"<p>\u5f53\u4f7f\u7528\u5e8f\u5217\u5316\u65b9\u6cd5\u65f6\uff0c\u53ef\u4ee5\u6839\u636e\u5b57\u6bb5\u503c\u6392\u9664\u5b57\u6bb5\uff0c\u4f7f\u7528\u4ee5\u4e0b\u53c2\u6570\uff1a</p> <ul> <li><code>exclude_defaults</code>\uff1a\u6392\u9664\u6240\u6709\u503c\u7b49\u4e8e\u9ed8\u8ba4\u503c\u7684\u5b57\u6bb5\uff08\u4f7f\u7528\u76f8\u7b49\uff08<code>==</code>\uff09\u6bd4\u8f83\u8fd0\u7b97\u7b26\uff09\u3002</li> <li><code>exclude_none</code>\uff1a\u6392\u9664\u6240\u6709\u503c\u4e3a <code>None</code> \u7684\u5b57\u6bb5\u3002</li> <li> <p><code>exclude_unset</code>\uff1aPydantic \u8ddf\u8e2a\u5728\u5b9e\u4f8b\u5316\u671f\u95f4\u663e\u5f0f\u8bbe\u7f6e\u7684\u5b57\u6bb5\uff08\u4f7f\u7528 <code>model_fields_set</code> \u5c5e\u6027\uff09\u3002\u4f7f\u7528 <code>exclude_unset</code>\uff0c\u4efb\u4f55\u672a\u663e\u5f0f\u63d0\u4f9b\u7684\u5b57\u6bb5\u5c06\u88ab\u6392\u9664\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass UserModel(BaseModel):\n    name: str\n    age: int = 18\n\n\nuser = UserModel(name='John')\nprint(user.model_fields_set)\n#&gt; {'name'}\n\nprint(user.model_dump(exclude_unset=True))\n#&gt; {'name': 'John'}\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5728\u5b9e\u4f8b\u521b\u5efa\u4e4b\u540e\u4fee\u6539\u5b57\u6bb5\u4f1a\u5c06\u5176\u4ece\u672a\u8bbe\u7f6e\u7684\u5b57\u6bb5\u4e2d\u79fb\u9664\uff1a</p> <pre><code>user.age = 21\n\nprint(user.model_dump(exclude_unset=True))\n#&gt; {'name': 'John', 'age': 21}\n</code></pre> <p>Tip</p> <p>\u5b9e\u9a8c\u6027\u7684 <code>MISSING</code> \u54e8\u5175 \u53ef\u4ee5\u7528\u4f5c <code>exclude_unset</code> \u7684\u66ff\u4ee3\u65b9\u6848\u3002 \u4efb\u4f55\u503c\u4e3a <code>MISSING</code> \u7684\u5b57\u6bb5\u90fd\u4f1a\u81ea\u52a8\u4ece\u5e8f\u5217\u5316\u8f93\u51fa\u4e2d\u6392\u9664\u3002</p> </li> </ul>"},{"location":"concepts/strict_mode/","title":"Strict Mode","text":"API \u6587\u6863 <p><code>pydantic.types.Strict</code></p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u4f1a\u5c1d\u8bd5\u5728\u53ef\u80fd\u65f6\u5c06\u503c\u5f3a\u5236\u8f6c\u6362\u4e3a\u6240\u9700\u7684\u7c7b\u578b\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u4ee5\u5c06\u5b57\u7b26\u4e32 <code>'123'</code> \u4f5c\u4e3a <code>int</code> \u6570\u5b57\u7c7b\u578b \u7684\u8f93\u5165\uff0c \u5b83\u5c06\u88ab\u8f6c\u6362\u4e3a\u503c <code>123</code>\u3002 \u8fd9\u79cd\u5f3a\u5236\u8f6c\u6362\u884c\u4e3a\u5728\u8bb8\u591a\u573a\u666f\u4e2d\u5f88\u6709\u7528\u2014\u2014\u60f3\u60f3\uff1aUUID\u3001URL \u53c2\u6570\u3001HTTP \u5934\u3001\u73af\u5883\u53d8\u91cf\u3001 \u65e5\u671f\u7b49\u3002</p> <p>\u7136\u800c\uff0c\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u8fd9\u662f\u4e0d\u53ef\u53d6\u7684\uff0c\u60a8\u5e0c\u671b Pydantic \u62a5\u9519\u800c\u4e0d\u662f\u5f3a\u5236\u8f6c\u6362\u6570\u636e\u3002</p> <p>\u4e3a\u4e86\u66f4\u597d\u5730\u652f\u6301\u8fd9\u79cd\u7528\u4f8b\uff0cPydantic \u63d0\u4f9b\u4e86\"\u4e25\u683c\u6a21\u5f0f\"\u3002\u5f53\u542f\u7528\u4e25\u683c\u6a21\u5f0f\u65f6\uff0cPydantic \u5728\u5f3a\u5236\u8f6c\u6362\u6570\u636e\u65f6\u4f1a \u66f4\u52a0\u4e25\u683c\uff0c\u5982\u679c\u6570\u636e\u4e0d\u662f\u6b63\u786e\u7684\u7c7b\u578b\uff0c\u5219\u4f1a\u62a5\u9519\u3002</p> <p>\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u4e25\u683c\u6a21\u5f0f\u53ea\u5141\u8bb8\u63d0\u4f9b\u7c7b\u578b\u7684\u5b9e\u4f8b\uff0c\u5c3d\u7ba1\u5bf9 JSON \u8f93\u5165\u53ef\u80fd\u9002\u7528\u66f4\u5bbd\u677e\u7684\u89c4\u5219 \uff08\u4f8b\u5982\uff0c\u65e5\u671f\u548c\u65f6\u95f4\u7c7b\u578b \u5373\u4f7f\u5728\u4e25\u683c\u6a21\u5f0f\u4e0b\u4e5f\u5141\u8bb8\u5b57\u7b26\u4e32\uff09\u3002</p> <p>\u6bcf\u79cd\u7c7b\u578b\u7684\u4e25\u683c\u884c\u4e3a\u53ef\u4ee5\u5728 \u6807\u51c6\u5e93\u7c7b\u578b \u6587\u6863\u4e2d\u627e\u5230\uff0c \u5e76\u5728 \u8f6c\u6362\u8868 \u4e2d\u8fdb\u884c\u4e86\u603b\u7ed3\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u7b80\u8981\u793a\u4f8b\uff0c\u5c55\u793a\u4e86\u4e25\u683c\u6a21\u5f0f\u548c\u9ed8\u8ba4\u5bbd\u677e\u6a21\u5f0f\u4e0b\u7684\u9a8c\u8bc1\u884c\u4e3a\u5dee\u5f02\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_validate({'x': '123'}))  # \u5bbd\u677e\u6a21\u5f0f\n#&gt; x=123\n\ntry:\n    MyModel.model_validate({'x': '123'}, strict=True)  # \u4e25\u683c\u6a21\u5f0f\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for MyModel\n    x\n      Input should be a valid integer [type=int_type, input_value='123', input_type=str]\n    \"\"\"\n</code></pre> <p>\u4e25\u683c\u6a21\u5f0f\u53ef\u4ee5\u901a\u8fc7\u591a\u79cd\u65b9\u5f0f\u542f\u7528\uff1a</p> <ul> <li>\u4f5c\u4e3a\u9a8c\u8bc1\u53c2\u6570\uff0c\u4f8b\u5982\u5728\u4f7f\u7528 Pydantic \u6a21\u578b\u4e0a\u7684 <code>model_validate()</code> \u65f6\u3002</li> <li>\u5728\u5b57\u6bb5\u7ea7\u522b\u3002</li> <li>\u5728\u914d\u7f6e\u7ea7\u522b\uff08\u53ef\u4ee5\u5728\u5b57\u6bb5\u7ea7\u522b\u8986\u76d6\uff09\u3002</li> </ul> <p></p>"},{"location":"concepts/strict_mode/#as-a-validation-parameter","title":"\u4f5c\u4e3a\u9a8c\u8bc1\u53c2\u6570","text":"<p>\u4e25\u683c\u6a21\u5f0f\u53ef\u4ee5\u5728\u6bcf\u6b21\u9a8c\u8bc1\u8c03\u7528\u65f6\u542f\u7528\uff0c\u5f53\u4f7f\u7528 Pydantic \u6a21\u578b \u548c \u7c7b\u578b\u9002\u914d\u5668 \u4e0a\u7684 \u9a8c\u8bc1\u65b9\u6cd5 \u65f6\u3002</p> <pre><code>from datetime import date\n\nfrom pydantic import TypeAdapter, ValidationError\n\nprint(TypeAdapter(date).validate_python('2000-01-01'))  # \u6b63\u5e38\uff1a\u5bbd\u677e\u6a21\u5f0f\n#&gt; 2000-01-01\n\ntry:\n    # \u4e0d\u6b63\u5e38\uff1a\u4e25\u683c\u6a21\u5f0f\uff1a\n    TypeAdapter(date).validate_python('2000-01-01', strict=True)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for date\n      Input should be a valid date [type=date_type, input_value='2000-01-01', input_type=str]\n    \"\"\"\n\nTypeAdapter(date).validate_json('\"2000-01-01\"', strict=True)  # (1)!\n#&gt; 2000-01-01\n</code></pre> <ol> <li>\u5982\u524d\u6240\u8ff0\uff0c\u4ece JSON \u9a8c\u8bc1\u65f6\u4e25\u683c\u6a21\u5f0f\u66f4\u5bbd\u677e\u3002</li> </ol> <p></p>"},{"location":"concepts/strict_mode/#at-the-field-level","title":"\u5728\u5b57\u6bb5\u7ea7\u522b","text":"<p>\u4e25\u683c\u6a21\u5f0f\u53ef\u4ee5\u5728\u7279\u5b9a\u5b57\u6bb5\u4e0a\u542f\u7528\uff0c\u901a\u8fc7\u5c06 <code>Field()</code> \u51fd\u6570\u7684 <code>strict</code> \u53c2\u6570\u8bbe\u7f6e\u4e3a <code>True</code>\u3002 \u4e25\u683c\u6a21\u5f0f\u5c06\u5e94\u7528\u4e8e\u8fd9\u4e9b\u5b57\u6bb5\uff0c\u5373\u4f7f \u9a8c\u8bc1\u65b9\u6cd5 \u5728\u5bbd\u677e\u6a21\u5f0f\u4e0b\u8c03\u7528\u3002</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(strict=True)  # (1)!\n\n\nuser = User(name='John', age=42)\nprint(user)\n#&gt; name='John' age=42\n\n\ntry:\n    another_user = User(name='John', age='42')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer [type=int_type, input_value='42', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u4e25\u683c\u7ea6\u675f\u4e5f\u53ef\u4ee5\u4f7f\u7528 \u6ce8\u89e3\u6a21\u5f0f \u5e94\u7528\uff1a    <code>Annotated[int, Field(strict=True)]</code></li> </ol> <p></p>"},{"location":"concepts/strict_mode/#using-the-strict-metadata-class","title":"\u4f7f\u7528 <code>Strict()</code> \u5143\u6570\u636e\u7c7b","text":"API \u6587\u6863 <p><code>pydantic.types.Strict</code></p> <p>\u4f5c\u4e3a <code>Field()</code> \u51fd\u6570\u7684\u66ff\u4ee3\u65b9\u6848\uff0cPydantic \u63d0\u4f9b\u4e86 <code>Strict</code> \u5143\u6570\u636e\u7c7b\uff0c\u65e8\u5728\u4e0e \u6ce8\u89e3\u6a21\u5f0f \u4e00\u8d77\u4f7f\u7528\u3002\u5b83\u8fd8\u63d0\u4f9b\u4e86 \u6700\u5e38\u89c1\u7c7b\u578b\u7684\u4fbf\u6377\u522b\u540d\uff08\u5373 <code>StrictBool</code>\u3001 <code>StrictInt</code>\u3001<code>StrictFloat</code>\u3001<code>StrictStr</code> \u548c <code>StrictBytes</code>\uff09\u3002</p> <pre><code>from typing import Annotated\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, Strict, StrictInt\n\n\nclass User(BaseModel):\n    id: Annotated[UUID, Strict()]\n    age: StrictInt  # (1)!\n</code></pre> <ol> <li>\u7b49\u540c\u4e8e <code>Annotated[int, Strict()]</code>\u3002</li> </ol> <p></p>"},{"location":"concepts/strict_mode/#as-a-configuration-value","title":"\u4f5c\u4e3a\u914d\u7f6e\u503c","text":"<p>\u4e25\u683c\u6a21\u5f0f\u884c\u4e3a\u53ef\u4ee5\u5728 \u914d\u7f6e \u7ea7\u522b\u63a7\u5236\u3002\u5f53\u5728 Pydantic \u6a21\u578b\uff08\u6216\u7c7b\u4f3c\u6a21\u578b\u7684\u7c7b\uff0c\u5982 \u6570\u636e\u7c7b\uff09\u4e0a\u4f7f\u7528\u65f6\uff0c \u4e25\u683c\u6027\u4ecd\u7136\u53ef\u4ee5\u5728 \u5b57\u6bb5\u7ea7\u522b \u88ab\u8986\u76d6\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int = Field(strict=False)\n\n\nprint(User(name='John', age='18'))\n#&gt; name='John' age=18\n</code></pre>"},{"location":"concepts/type_adapter/","title":"Type Adapter","text":"<p>\u60a8\u53ef\u80fd\u6709\u4e00\u4e9b\u4e0d\u662f <code>BaseModel</code> \u7684\u7c7b\u578b\uff0c\u4f46\u60a8\u60f3\u8981\u9a8c\u8bc1\u6570\u636e\u662f\u5426\u7b26\u5408\u8fd9\u4e9b\u7c7b\u578b\u3002\u6216\u8005\u60a8\u53ef\u80fd\u60f3\u8981\u9a8c\u8bc1 <code>list[SomeModel]</code>\uff0c\u6216\u8005\u5c06\u5176\u8f6c\u50a8\u4e3a JSON\u3002</p> API \u6587\u6863 <p><code>pydantic.type_adapter.TypeAdapter</code></p> <p>\u5bf9\u4e8e\u8fd9\u6837\u7684\u4f7f\u7528\u573a\u666f\uff0cPydantic \u63d0\u4f9b\u4e86 <code>TypeAdapter</code>\uff0c \u5b83\u53ef\u4ee5\u7528\u4e8e\u7c7b\u578b\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u548c JSON \u6a21\u5f0f\u751f\u6210\uff0c\u800c\u65e0\u9700\u521b\u5efa <code>BaseModel</code>\u3002</p> <p>\u4e00\u4e2a <code>TypeAdapter</code> \u5b9e\u4f8b\u66b4\u9732\u4e86\u6765\u81ea <code>BaseModel</code> \u5b9e\u4f8b\u65b9\u6cd5\u7684\u4e00\u4e9b\u529f\u80fd\uff0c\u9002\u7528\u4e8e\u90a3\u4e9b\u6ca1\u6709\u6b64\u7c7b\u65b9\u6cd5\u7684\u7c7b\u578b \uff08\u4f8b\u5982\u6570\u636e\u7c7b\u3001\u539f\u59cb\u7c7b\u578b\u7b49\uff09\uff1a</p> Python 3.9 and abovePython 3.13 and above <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nuser_list_adapter = TypeAdapter(list[User])\nuser_list = user_list_adapter.validate_python([{'name': 'Fred', 'id': '3'}])\nprint(repr(user_list))\n#&gt; [{'name': 'Fred', 'id': 3}]\n\ntry:\n    user_list_adapter.validate_python(\n        [{'name': 'Fred', 'id': 'wrong', 'other': 'no'}]\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for list[User]\n    0.id\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n\nprint(repr(user_list_adapter.dump_json(user_list)))\n#&gt; b'[{\"name\":\"Fred\",\"id\":3}]'\n</code></pre> <pre><code>from typing import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nuser_list_adapter = TypeAdapter(list[User])\nuser_list = user_list_adapter.validate_python([{'name': 'Fred', 'id': '3'}])\nprint(repr(user_list))\n#&gt; [{'name': 'Fred', 'id': 3}]\n\ntry:\n    user_list_adapter.validate_python(\n        [{'name': 'Fred', 'id': 'wrong', 'other': 'no'}]\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for list[User]\n    0.id\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n\nprint(repr(user_list_adapter.dump_json(user_list)))\n#&gt; b'[{\"name\":\"Fred\",\"id\":3}]'\n</code></pre> <p><code>dump_json</code> \u8fd4\u56de <code>bytes</code></p> <p><code>TypeAdapter</code> \u7684 <code>dump_json</code> \u65b9\u6cd5\u8fd4\u56de\u4e00\u4e2a <code>bytes</code> \u5bf9\u8c61\uff0c\u8fd9\u4e0e <code>BaseModel</code> \u7684\u5bf9\u5e94\u65b9\u6cd5 <code>model_dump_json</code> \u4e0d\u540c\uff0c\u540e\u8005\u8fd4\u56de\u4e00\u4e2a <code>str</code>\u3002 \u8fd9\u79cd\u5dee\u5f02\u7684\u539f\u56e0\u662f\uff0c\u5728 V1 \u4e2d\uff0c\u6a21\u578b\u8f6c\u50a8\u8fd4\u56de\u7684\u662f str \u7c7b\u578b\uff0c\u56e0\u6b64\u5728 V2 \u4e2d\u4fdd\u7559\u4e86\u8fd9\u79cd\u884c\u4e3a\u4ee5\u4fdd\u6301\u5411\u540e\u517c\u5bb9\u6027\u3002 \u5bf9\u4e8e <code>BaseModel</code> \u7684\u60c5\u51b5\uff0c<code>bytes</code> \u88ab\u5f3a\u5236\u8f6c\u6362\u4e3a <code>str</code> \u7c7b\u578b\uff0c\u4f46 <code>bytes</code> \u901a\u5e38\u662f\u6240\u9700\u7684\u6700\u7ec8\u7c7b\u578b\u3002 \u56e0\u6b64\uff0c\u5bf9\u4e8e V2 \u4e2d\u7684\u65b0 <code>TypeAdapter</code> \u7c7b\uff0c\u8fd4\u56de\u7c7b\u578b\u53ea\u662f <code>bytes</code>\uff0c\u5982\u679c\u9700\u8981\u53ef\u4ee5\u8f7b\u677e\u5730\u5f3a\u5236\u8f6c\u6362\u4e3a <code>str</code> \u7c7b\u578b\u3002</p> <p>Note</p> <p>\u5c3d\u7ba1\u4e0e <code>RootModel</code> \u5728\u4f7f\u7528\u573a\u666f\u4e0a\u6709\u4e00\u4e9b\u91cd\u53e0\uff0c <code>TypeAdapter</code> \u4e0d\u5e94\u88ab\u7528\u4f5c\u7c7b\u578b\u6ce8\u89e3\u6765 \u6307\u5b9a <code>BaseModel</code> \u7684\u5b57\u6bb5\u7b49\u3002</p>"},{"location":"concepts/type_adapter/#_1","title":"\u89e3\u6790\u6570\u636e\u5230\u6307\u5b9a\u7c7b\u578b","text":"<p><code>TypeAdapter</code> \u53ef\u7528\u4e8e\u4ee5\u66f4\u4e34\u65f6\u7684\u65b9\u5f0f\u5e94\u7528\u89e3\u6790\u903b\u8f91\u6765\u586b\u5145 Pydantic \u6a21\u578b\u3002 \u6b64\u51fd\u6570\u7684\u884c\u4e3a\u7c7b\u4f3c\u4e8e <code>BaseModel.model_validate</code>\uff0c \u4f46\u9002\u7528\u4e8e\u4efb\u610f Pydantic \u517c\u5bb9\u7684\u7c7b\u578b\u3002</p> <p>\u5f53\u60a8\u60f3\u8981\u5c06\u7ed3\u679c\u89e3\u6790\u4e3a\u4e0d\u662f <code>BaseModel</code> \u76f4\u63a5\u5b50\u7c7b\u7684\u7c7b\u578b\u65f6\uff0c\u8fd9\u5c24\u5176\u6709\u7528\u3002\u4f8b\u5982\uff1a</p> <pre><code>from pydantic import BaseModel, TypeAdapter\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` \u53ef\u80fd\u6765\u81ea API \u8c03\u7528\uff0c\u4f8b\u5982\u901a\u8fc7\u7c7b\u4f3c\u4ee5\u4e0b\u65b9\u5f0f\uff1a\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = TypeAdapter(list[Item]).validate_python(item_data)\nprint(items)\n#&gt; [Item(id=1, name='My Item')]\n</code></pre> <p><code>TypeAdapter</code> \u80fd\u591f\u5c06\u6570\u636e\u89e3\u6790\u4e3a Pydantic \u53ef\u4ee5 \u4f5c\u4e3a <code>BaseModel</code> \u5b57\u6bb5\u5904\u7406\u7684\u4efb\u4f55\u7c7b\u578b\u3002</p> <p>\u6027\u80fd\u8003\u8651</p> <p>\u5f53\u521b\u5efa <code>TypeAdapter</code> \u5b9e\u4f8b\u65f6\uff0c\u63d0\u4f9b\u7684\u7c7b\u578b\u5fc5\u987b\u88ab\u5206\u6790\u5e76\u8f6c\u6362\u4e3a pydantic-core \u6a21\u5f0f\u3002\u8fd9\u4f1a\u5e26\u6765\u4e00\u4e9b\u4e0d\u5c0f\u7684\u5f00\u9500\uff0c\u56e0\u6b64\u5efa\u8bae\u4e3a\u7ed9\u5b9a\u7c7b\u578b\u53ea\u521b\u5efa\u4e00\u6b21 <code>TypeAdapter</code> \u5e76\u5728\u5faa\u73af\u6216\u5176\u4ed6\u6027\u80fd\u5173\u952e\u4ee3\u7801\u4e2d\u91cd\u590d\u4f7f\u7528\u5b83\u3002</p>"},{"location":"concepts/type_adapter/#typeadapter","title":"\u91cd\u5efa <code>TypeAdapter</code> \u7684\u6a21\u5f0f","text":"<p>\u5728 v2.10+ \u4e2d\uff0c<code>TypeAdapter</code> \u652f\u6301\u5ef6\u8fdf\u6a21\u5f0f\u6784\u5efa\u548c\u624b\u52a8\u91cd\u5efa\u3002\u8fd9\u5bf9\u4e8e\u4ee5\u4e0b\u60c5\u51b5\u5f88\u6709\u5e2e\u52a9\uff1a</p> <ul> <li>\u5177\u6709\u524d\u5411\u5f15\u7528\u7684\u7c7b\u578b</li> <li>\u6838\u5fc3\u6a21\u5f0f\u6784\u5efa\u6210\u672c\u8f83\u9ad8\u7684\u7c7b\u578b</li> </ul> <p>\u5f53\u60a8\u4f7f\u7528\u7c7b\u578b\u521d\u59cb\u5316 <code>TypeAdapter</code> \u65f6\uff0cPydantic \u4f1a\u5206\u6790\u8be5\u7c7b\u578b\u5e76\u4e3a\u5176\u521b\u5efa\u6838\u5fc3\u6a21\u5f0f\u3002 \u6b64\u6838\u5fc3\u6a21\u5f0f\u5305\u542b\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u8be5\u7c7b\u578b\u6570\u636e\u6240\u9700\u7684\u4fe1\u606f\u3002 \u6709\u5173\u6838\u5fc3\u6a21\u5f0f\u7684\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u67b6\u6784\u6587\u6863\u3002</p> <p>\u5982\u679c\u5728\u521d\u59cb\u5316 <code>TypeAdapter</code> \u65f6\u5c06 <code>defer_build</code> \u8bbe\u7f6e\u4e3a <code>True</code>\uff0c Pydantic \u5c06\u5ef6\u8fdf\u6784\u5efa\u6838\u5fc3\u6a21\u5f0f\uff0c\u76f4\u5230\u7b2c\u4e00\u6b21\u9700\u8981\u5b83\u65f6\uff08\u7528\u4e8e\u9a8c\u8bc1\u6216\u5e8f\u5217\u5316\uff09\u3002</p> <p>\u4e3a\u4e86\u624b\u52a8\u89e6\u53d1\u6838\u5fc3\u6a21\u5f0f\u7684\u6784\u5efa\uff0c\u60a8\u53ef\u4ee5\u8c03\u7528 <code>TypeAdapter</code> \u5b9e\u4f8b\u4e0a\u7684 <code>rebuild</code> \u65b9\u6cd5\uff1a</p> <pre><code>from pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter('MyInt', config=ConfigDict(defer_build=True))\n\n# \u4e00\u6bb5\u65f6\u95f4\u540e\uff0c\u524d\u5411\u5f15\u7528\u88ab\u5b9a\u4e49\nMyInt = int\n\nta.rebuild()\nassert ta.validate_python(1) == 1\n</code></pre>"},{"location":"concepts/types/","title":"Types","text":"<p>Pydantic \u4f7f\u7528\u7c7b\u578b\u6765\u5b9a\u4e49\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u5e94\u8be5\u5982\u4f55\u6267\u884c\u3002 \u5185\u7f6e\u548c\u6807\u51c6\u5e93\u7c7b\u578b\uff08\u4f8b\u5982 <code>int</code>\u3001 <code>str</code>\u3001<code>date</code>\uff09\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528\u3002\u4e25\u683c\u6a21\u5f0f \u53ef\u4ee5\u63a7\u5236\uff0c\u5e76\u4e14\u53ef\u4ee5\u5728\u5b83\u4eec\u4e0a\u5e94\u7528\u7ea6\u675f\u3002</p> <p>\u9664\u6b64\u4e4b\u5916\uff0cPydantic \u8fd8\u63d0\u4f9b\u4e86\u989d\u5916\u7684\u7c7b\u578b\uff0c\u8981\u4e48\u76f4\u63a5\u5728\u5e93\u4e2d \uff08\u4f8b\u5982 <code>SecretStr</code>\uff09\uff0c\u8981\u4e48\u5728 <code>pydantic-extra-types</code> \u5916\u90e8\u5e93\u4e2d\u3002\u8fd9\u4e9b\u7c7b\u578b\u4f7f\u7528\u81ea\u5b9a\u4e49\u7c7b\u578b\u90e8\u5206\u63cf\u8ff0\u7684\u6a21\u5f0f\u5b9e\u73b0\u3002 \u4e25\u683c\u6a21\u5f0f\u548c\u7ea6\u675f\u4e0d\u80fd\u5e94\u7528\u4e8e\u5b83\u4eec\u3002</p> <p>\u5185\u7f6e\u548c\u6807\u51c6\u5e93\u7c7b\u578b\u6587\u6863\u8be6\u7ec6\u4ecb\u7ecd\u4e86 \u652f\u6301\u7684\u7c7b\u578b\uff1a\u5141\u8bb8\u7684\u503c\u3001\u53ef\u80fd\u7684\u9a8c\u8bc1\u7ea6\u675f\u4ee5\u53ca\u662f\u5426\u53ef\u4ee5\u914d\u7f6e\u4e25\u683c\u6a21\u5f0f\u3002</p> <p>\u53e6\u8bf7\u53c2\u9605\u8f6c\u6362\u8868\u4ee5\u83b7\u53d6\u6bcf\u4e2a\u7c7b\u578b\u5141\u8bb8\u503c\u7684\u6458\u8981\u3002</p> <p>\u672c\u9875\u5c06\u4ecb\u7ecd\u5982\u4f55\u5b9a\u4e49\u60a8\u81ea\u5df1\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\u3002</p>"},{"location":"concepts/types/#custom-types","title":"\u81ea\u5b9a\u4e49\u7c7b\u578b","text":"<p>\u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5b9a\u4e49\u60a8\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\u3002</p>"},{"location":"concepts/types/#using-the-annotated-pattern","title":"\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f","text":"<p>\u6ce8\u89e3\u6a21\u5f0f\u53ef\u7528\u4e8e\u4f7f\u7c7b\u578b\u5728\u4ee3\u7801\u5e93\u4e2d\u53ef\u91cd\u7528\u3002 \u4f8b\u5982\uff0c\u521b\u5efa\u4e00\u4e2a\u8868\u793a\u6b63\u6574\u6570\u7684\u7c7b\u578b\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field, TypeAdapter, ValidationError\n\nPositiveInt = Annotated[int, Field(gt=0)]  # (1)!\n\nta = TypeAdapter(PositiveInt)\n\nprint(ta.validate_python(1))\n#&gt; 1\n\ntry:\n    ta.validate_python(-1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for constrained-int\n      Input should be greater than 0 [type=greater_than, input_value=-1, input_type=int]\n    \"\"\"\n</code></pre> <ol> <li> <p>\u8bf7\u6ce8\u610f\uff0c\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 annotated-types    \u5e93\u4e2d\u7684\u7ea6\u675f\u6765\u4f7f\u5176\u4e0e Pydantic \u65e0\u5173\uff1a</p> <pre><code>from annotated_types import Gt\n\nPositiveInt = Annotated[int, Gt(0)]\n</code></pre> </li> </ol>"},{"location":"concepts/types/#adding-validation-and-serialization","title":"\u6dfb\u52a0\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528 Pydantic \u5bfc\u51fa\u7684\u6807\u8bb0\u4e3a\u4efb\u610f\u7c7b\u578b\u6dfb\u52a0\u6216\u8986\u76d6\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u548c JSON \u6a21\u5f0f\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import (\n    AfterValidator,\n    PlainSerializer,\n    TypeAdapter,\n    WithJsonSchema,\n)\n\nTruncatedFloat = Annotated[\n    float,\n    AfterValidator(lambda x: round(x, 1)),\n    PlainSerializer(lambda x: f'{x:.1e}', return_type=str),\n    WithJsonSchema({'type': 'string'}, mode='serialization'),\n]\n\n\nta = TypeAdapter(TruncatedFloat)\n\ninput = 1.02345\nassert input != 1.0\n\nassert ta.validate_python(input) == 1.0\n\nassert ta.dump_json(input) == b'\"1.0e+00\"'\n\nassert ta.json_schema(mode='validation') == {'type': 'number'}\nassert ta.json_schema(mode='serialization') == {'type': 'string'}\n</code></pre>"},{"location":"concepts/types/#_1","title":"\u6cdb\u578b","text":"<p>\u7c7b\u578b\u53d8\u91cf \u53ef\u4ee5\u5728 <code>Annotated</code> \u7c7b\u578b\u4e2d\u4f7f\u7528\uff1a</p> <pre><code>from typing import Annotated, TypeVar\n\nfrom annotated_types import Gt, Len\n\nfrom pydantic import TypeAdapter, ValidationError\n\nT = TypeVar('T')\n\n\nShortList = Annotated[list[T], Len(max_length=4)]\n\n\nta = TypeAdapter(ShortList[int])\n\nv = ta.validate_python([1, 2, 3, 4])\nassert v == [1, 2, 3, 4]\n\ntry:\n    ta.validate_python([1, 2, 3, 4, 5])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[int]\n      List should have at most 4 items after validation, not 5 [type=too_long, input_value=[1, 2, 3, 4, 5], input_type=list]\n    \"\"\"\n\n\nPositiveList = list[Annotated[T, Gt(0)]]\n\nta = TypeAdapter(PositiveList[float])\n\nv = ta.validate_python([1.0])\nassert type(v[0]) is float\n\n\ntry:\n    ta.validate_python([-1.0])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[constrained-float]\n    0\n      Input should be greater than 0 [type=greater_than, input_value=-1.0, input_type=float]\n    \"\"\"\n</code></pre>"},{"location":"concepts/types/#_2","title":"\u547d\u540d\u7c7b\u578b\u522b\u540d","text":"<p>\u4e0a\u8ff0\u793a\u4f8b\u4f7f\u7528\u4e86\u9690\u5f0f\u7c7b\u578b\u522b\u540d\uff0c\u5206\u914d\u7ed9\u53d8\u91cf\u3002\u5728\u8fd0\u884c\u65f6\uff0cPydantic \u65e0\u6cd5\u77e5\u9053\u5b83\u88ab\u5206\u914d\u7ed9\u54ea\u4e2a\u53d8\u91cf\u540d\uff0c\u8fd9\u53ef\u80fd\u4f1a\u5e26\u6765\u4e24\u4e2a\u95ee\u9898\uff1a</p> <ul> <li>\u522b\u540d\u7684 JSON Schema \u4e0d\u4f1a\u8f6c\u6362\u4e3a   \u5b9a\u4e49\u3002   \u8fd9\u5728\u60a8\u5728\u6a21\u578b\u5b9a\u4e49\u4e2d\u591a\u6b21\u4f7f\u7528\u522b\u540d\u65f6\u7279\u522b\u6709\u7528\u3002</li> <li>\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u9012\u5f52\u7c7b\u578b\u522b\u540d \u5c06\u65e0\u6cd5\u5de5\u4f5c\u3002</li> </ul> <p>\u901a\u8fc7\u5229\u7528\u65b0\u7684 <code>type</code> \u8bed\u53e5 \uff08\u5728 PEP 695 \u4e2d\u5f15\u5165\uff09\uff0c\u60a8\u53ef\u4ee5\u6309\u5982\u4e0b\u65b9\u5f0f\u5b9a\u4e49\u522b\u540d\uff1a</p> Python 3.9 \u53ca\u4ee5\u4e0aPython 3.12 \u53ca\u4ee5\u4e0a\uff08\u65b0\u8bed\u6cd5\uff09 <pre><code>from typing import Annotated\n\nfrom annotated_types import Gt\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import BaseModel\n\nPositiveIntList = TypeAliasType('PositiveIntList', list[Annotated[int, Gt(0)]])\n\n\nclass Model(BaseModel):\n    x: PositiveIntList\n    y: PositiveIntList\n\n\nprint(Model.model_json_schema())  # (1)!\n\"\"\"\n{\n    '$defs': {\n        'PositiveIntList': {\n            'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n            'type': 'array',\n        }\n    },\n    'properties': {\n        'x': {'$ref': '#/$defs/PositiveIntList'},\n        'y': {'$ref': '#/$defs/PositiveIntList'},\n    },\n    'required': ['x', 'y'],\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <ol> <li>\u5982\u679c <code>PositiveIntList</code> \u88ab\u5b9a\u4e49\u4e3a\u9690\u5f0f\u7c7b\u578b\u522b\u540d\uff0c\u5176\u5b9a\u4e49    \u5c06\u5728 <code>'x'</code> \u548c <code>'y'</code> \u4e2d\u91cd\u590d\u3002</li> </ol> <pre><code>from typing import Annotated\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\ntype PositiveIntList = list[Annotated[int, Gt(0)]]\n\n\nclass Model(BaseModel):\n    x: PositiveIntList\n    y: PositiveIntList\n\n\nprint(Model.model_json_schema())  # (1)!\n\"\"\"\n{\n    '$defs': {\n        'PositiveIntList': {\n            'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n            'type': 'array',\n        }\n    },\n    'properties': {\n        'x': {'$ref': '#/$defs/PositiveIntList'},\n        'y': {'$ref': '#/$defs/PositiveIntList'},\n    },\n    'required': ['x', 'y'],\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n</code></pre> <ol> <li>\u5982\u679c <code>PositiveIntList</code> \u88ab\u5b9a\u4e49\u4e3a\u9690\u5f0f\u7c7b\u578b\u522b\u540d\uff0c\u5176\u5b9a\u4e49    \u5c06\u5728 <code>'x'</code> \u548c <code>'y'</code> \u4e2d\u91cd\u590d\u3002</li> </ol> <p></p> <p>\u4f55\u65f6\u4f7f\u7528\u547d\u540d\u7c7b\u578b\u522b\u540d</p> <p>\u867d\u7136\uff08\u547d\u540d\u7684\uff09PEP 695 \u548c\u9690\u5f0f\u7c7b\u578b\u522b\u540d\u5bf9\u4e8e\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u5e94\u8be5\u662f\u7b49\u4ef7\u7684\uff0c \u4f46 Pydantic \u4e0d\u4f1a\u7406\u89e3\u547d\u540d\u522b\u540d\u4e2d\u7684\u5b57\u6bb5\u7279\u5b9a\u5143\u6570\u636e\u3002\u4e5f\u5c31\u662f\u8bf4\uff0c\u8bf8\u5982 <code>alias</code>\u3001<code>default</code>\u3001<code>deprecated</code> \u4e4b\u7c7b\u7684\u5143\u6570\u636e\u4e0d\u80fd\u4f7f\u7528\uff1a</p> Python 3.9 \u53ca\u4ee5\u4e0aPython 3.12 \u53ca\u4ee5\u4e0a\uff08\u65b0\u8bed\u6cd5\uff09 <pre><code>from typing import Annotated\n\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import BaseModel, Field\n\nMyAlias = TypeAliasType('MyAlias', Annotated[int, Field(default=1)])\n\n\nclass Model(BaseModel):\n    x: MyAlias  # \u8fd9\u662f\u4e0d\u5141\u8bb8\u7684\n</code></pre> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\ntype MyAlias = Annotated[int, Field(default=1)]\n\n\nclass Model(BaseModel):\n    x: MyAlias  # \u8fd9\u662f\u4e0d\u5141\u8bb8\u7684\n</code></pre> <p>\u53ea\u5141\u8bb8\u5e94\u7528\u4e8e\u6ce8\u89e3\u7c7b\u578b\u672c\u8eab\u7684\u5143\u6570\u636e \uff08\u4f8b\u5982\u9a8c\u8bc1\u7ea6\u675f\u548c JSON \u5143\u6570\u636e\uff09\u3002 \u5c1d\u8bd5\u652f\u6301\u5b57\u6bb5\u7279\u5b9a\u5143\u6570\u636e\u9700\u8981\u6025\u5207\u5730\u68c0\u67e5 \u7c7b\u578b\u522b\u540d\u7684 <code>__value__</code>\uff0c\u56e0\u6b64 Pydantic \u5c06\u65e0\u6cd5\u5c06\u522b\u540d\u5b58\u50a8\u4e3a JSON Schema \u5b9a\u4e49\u3002</p> <p>Note</p> <p>\u4e0e\u9690\u5f0f\u7c7b\u578b\u522b\u540d\u4e00\u6837\uff0c\u7c7b\u578b\u53d8\u91cf \u4e5f\u53ef\u4ee5\u5728\u6cdb\u578b\u522b\u540d\u4e2d\u4f7f\u7528\uff1a</p> Python 3.9 \u53ca\u4ee5\u4e0aPython 3.12 \u53ca\u4ee5\u4e0a\uff08\u65b0\u8bed\u6cd5\uff09 <pre><code>from typing import Annotated, TypeVar\n\nfrom annotated_types import Len\nfrom typing_extensions import TypeAliasType\n\nT = TypeVar('T')\n\nShortList = TypeAliasType(\n    'ShortList', Annotated[list[T], Len(max_length=4)], type_params=(T,)\n)\n</code></pre> <pre><code>from typing import Annotated, TypeVar\n\nfrom annotated_types import Len\n\ntype ShortList[T] = Annotated[list[T], Len(max_length=4)]\n</code></pre>"},{"location":"concepts/types/#named-recursive-types","title":"\u547d\u540d\u9012\u5f52\u7c7b\u578b","text":"<p>\u6bcf\u5f53\u60a8\u9700\u8981\u5b9a\u4e49\u9012\u5f52\u7c7b\u578b\u522b\u540d\u65f6\uff0c\u5e94\u4f7f\u7528\u547d\u540d\u7c7b\u578b\u522b\u540d (1)\u3002</p> <ol> <li>\u7531\u4e8e\u591a\u79cd\u539f\u56e0\uff0cPydantic \u65e0\u6cd5\u652f\u6301\u9690\u5f0f\u9012\u5f52\u522b\u540d\u3002\u4f8b\u5982\uff0c    \u5b83\u5c06\u65e0\u6cd5\u89e3\u6790\u8de8\u6a21\u5757\u7684\u524d\u5411\u6ce8\u89e3\u3002</li> </ol> <p>\u4f8b\u5982\uff0c\u8fd9\u91cc\u662f\u4e00\u4e2a JSON \u7c7b\u578b\u7684\u793a\u4f8b\u5b9a\u4e49\uff1a</p> Python 3.9 \u53ca\u4ee5\u4e0aPython 3.12 \u53ca\u4ee5\u4e0a\uff08\u65b0\u8bed\u6cd5\uff09 <pre><code>from typing import Union\n\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import TypeAdapter\n\nJson = TypeAliasType(\n    'Json',\n    'Union[dict[str, Json], list[Json], str, int, float, bool, None]',  # (1)!\n)\n\nta = TypeAdapter(Json)\nprint(ta.json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Json': {\n            'anyOf': [\n                {\n                    'additionalProperties': {'$ref': '#/$defs/Json'},\n                    'type': 'object',\n                },\n                {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                {'type': 'string'},\n                {'type': 'integer'},\n                {'type': 'number'},\n                {'type': 'boolean'},\n                {'type': 'null'},\n            ]\n        }\n    },\n    '$ref': '#/$defs/Json',\n}\n\"\"\"\n</code></pre> <ol> <li>\u5c06\u6ce8\u89e3\u7528\u5f15\u53f7\u62ec\u8d77\u6765\u662f\u5fc5\u8981\u7684\uff0c\u56e0\u4e3a\u5b83\u4f1a\u88ab\u6025\u5207\u6c42\u503c    \uff08\u5e76\u4e14 <code>Json</code> \u5c1a\u672a\u5b9a\u4e49\uff09\u3002</li> </ol> <pre><code>from pydantic import TypeAdapter\n\ntype Json = dict[str, Json] | list[Json] | str | int | float | bool | None  # (1)!\n\nta = TypeAdapter(Json)\nprint(ta.json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Json': {\n            'anyOf': [\n                {\n                    'additionalProperties': {'$ref': '#/$defs/Json'},\n                    'type': 'object',\n                },\n                {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                {'type': 'string'},\n                {'type': 'integer'},\n                {'type': 'number'},\n                {'type': 'boolean'},\n                {'type': 'null'},\n            ]\n        }\n    },\n    '$ref': '#/$defs/Json',\n}\n\"\"\"\n</code></pre> <ol> <li>\u547d\u540d\u7c7b\u578b\u522b\u540d\u7684\u503c\u662f\u60f0\u6027\u6c42\u503c\u7684\uff0c\u56e0\u6b64\u4e0d\u9700\u8981\u4f7f\u7528\u524d\u5411\u6ce8\u89e3\u3002</li> </ol> <p>Tip</p> <p>Pydantic \u5b9a\u4e49\u4e86\u4e00\u4e2a <code>JsonValue</code> \u7c7b\u578b\u4f5c\u4e3a\u4fbf\u5229\u5de5\u5177\u3002</p>"},{"location":"concepts/types/#__get_pydantic_core_schema__","title":"\u4f7f\u7528 <code>__get_pydantic_core_schema__</code> \u81ea\u5b9a\u4e49\u9a8c\u8bc1","text":"<p>\u8981\u5bf9 Pydantic \u5904\u7406\u81ea\u5b9a\u4e49\u7c7b\u7684\u65b9\u5f0f\u8fdb\u884c\u66f4\u5e7f\u6cdb\u7684\u5b9a\u5236\uff0c\u7279\u522b\u662f\u5f53\u60a8\u53ef\u4ee5\u8bbf\u95ee\u7c7b\u6216\u53ef\u4ee5\u5bf9\u5176\u8fdb\u884c\u5b50\u7c7b\u5316\u65f6\uff0c \u60a8\u53ef\u4ee5\u5b9e\u73b0\u4e00\u4e2a\u7279\u6b8a\u7684 <code>__get_pydantic_core_schema__</code> \u6765\u544a\u8bc9 Pydantic \u5982\u4f55\u751f\u6210 <code>pydantic-core</code> \u6a21\u5f0f\u3002</p> <p>\u867d\u7136 <code>pydantic</code> \u5728\u5185\u90e8\u4f7f\u7528 <code>pydantic-core</code> \u6765\u5904\u7406\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\uff0c\u4f46\u8fd9\u662f Pydantic V2 \u7684\u4e00\u4e2a\u65b0 API\uff0c \u56e0\u6b64\u8fd9\u662f\u672a\u6765\u6700\u6709\u53ef\u80fd\u8fdb\u884c\u8c03\u6574\u7684\u9886\u57df\u4e4b\u4e00\uff0c\u60a8\u5e94\u8be5\u5c3d\u91cf\u575a\u6301\u4f7f\u7528\u5185\u7f6e\u7684 \u6784\u9020\uff0c\u4f8b\u5982 <code>annotated-types</code>\u3001<code>pydantic.Field</code> \u6216 <code>BeforeValidator</code> \u7b49\u63d0\u4f9b\u7684\u6784\u9020\u3002</p> <p>\u60a8\u53ef\u4ee5\u5728\u81ea\u5b9a\u4e49\u7c7b\u578b\u4e0a\u4ee5\u53ca\u6253\u7b97\u653e\u5165 <code>Annotated</code> \u7684\u5143\u6570\u636e\u4e0a\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code>\u3002 \u5728\u8fd9\u4e24\u79cd\u60c5\u51b5\u4e0b\uff0cAPI \u90fd\u662f\u4e2d\u95f4\u4ef6\u5f0f\u7684\uff0c\u7c7b\u4f3c\u4e8e\"\u5305\u88c5\"\u9a8c\u8bc1\u5668\uff1a\u60a8\u4f1a\u5f97\u5230\u4e00\u4e2a <code>source_type</code>\uff08\u5b83\u4e0d\u4e00\u5b9a \u4e0e\u7c7b\u76f8\u540c\uff0c\u7279\u522b\u662f\u5bf9\u4e8e\u6cdb\u578b\uff09\u548c\u4e00\u4e2a <code>handler</code>\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u7c7b\u578b\u8c03\u7528\u5b83\u6765 \u8c03\u7528 <code>Annotated</code> \u4e2d\u7684\u4e0b\u4e00\u4e2a\u5143\u6570\u636e\u6216\u8c03\u7528 Pydantic \u7684\u5185\u90e8\u6a21\u5f0f\u751f\u6210\u3002</p> <p>\u6700\u7b80\u5355\u7684\u65e0\u64cd\u4f5c\u5b9e\u73b0\u662f\u4f7f\u7528\u7ed9\u5b9a\u7684\u7c7b\u578b\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\uff0c\u7136\u540e\u5c06\u5176\u4f5c\u4e3a\u7ed3\u679c\u8fd4\u56de\u3002\u60a8\u4e5f\u53ef\u4ee5 \u9009\u62e9\u5728\u8c03\u7528\u5904\u7406\u7a0b\u5e8f\u4e4b\u524d\u4fee\u6539\u7c7b\u578b\uff0c\u4fee\u6539\u5904\u7406\u7a0b\u5e8f\u8fd4\u56de\u7684\u6838\u5fc3\u6a21\u5f0f\uff0c\u6216\u8005\u6839\u672c\u4e0d\u8c03\u7528 \u5904\u7406\u7a0b\u5e8f\u3002</p>"},{"location":"concepts/types/#as-a-method-on-a-custom-type","title":"\u4f5c\u4e3a\u81ea\u5b9a\u4e49\u7c7b\u578b\u7684\u65b9\u6cd5","text":"<p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f7f\u7528 <code>__get_pydantic_core_schema__</code> \u6765\u81ea\u5b9a\u4e49\u5176\u9a8c\u8bc1\u65b9\u5f0f\u7684\u7c7b\u578b\u793a\u4f8b\u3002 \u8fd9\u76f8\u5f53\u4e8e\u5728 Pydantic V1 \u4e2d\u5b9e\u73b0 <code>__get_validators__</code>\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass Username(str):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n\n\nta = TypeAdapter(Username)\nres = ta.validate_python('abc')\nassert isinstance(res, Username)\nassert res == 'abc'\n</code></pre> <p>\u6709\u5173\u5982\u4f55\u4e3a\u81ea\u5b9a\u4e49\u7c7b\u578b\u81ea\u5b9a\u4e49 JSON \u6a21\u5f0f\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 JSON Schema\u3002</p>"},{"location":"concepts/types/#_3","title":"\u4f5c\u4e3a\u6ce8\u89e3","text":"<p>\u901a\u5e38\uff0c\u60a8\u4f1a\u5e0c\u671b\u901a\u8fc7\u4e0d\u4ec5\u4ec5\u662f\u6cdb\u578b\u7c7b\u578b\u53c2\u6570\u6765\u53c2\u6570\u5316\u60a8\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\uff08\u60a8\u53ef\u4ee5\u901a\u8fc7\u7c7b\u578b\u7cfb\u7edf\u6765\u5b9e\u73b0\uff0c\u7a0d\u540e\u5c06\u8ba8\u8bba\uff09\u3002\u6216\u8005\u60a8\u53ef\u80fd\u5b9e\u9645\u4e0a\u5e76\u4e0d\u5173\u5fc3\uff08\u6216\u60f3\u8981\uff09\u521b\u5efa\u5b50\u7c7b\u7684\u5b9e\u4f8b\uff1b\u60a8\u5b9e\u9645\u4e0a\u60f3\u8981\u539f\u59cb\u7c7b\u578b\uff0c\u53ea\u662f\u8fdb\u884c\u4e00\u4e9b\u989d\u5916\u7684\u9a8c\u8bc1\u3002</p> <p>\u4f8b\u5982\uff0c\u5982\u679c\u60a8\u8981\u81ea\u5df1\u5b9e\u73b0 <code>pydantic.AfterValidator</code>\uff08\u8bf7\u53c2\u9605\u6dfb\u52a0\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\uff09\uff0c\u60a8\u4f1a\u6267\u884c\u7c7b\u4f3c\u4ee5\u4e0b\u7684\u64cd\u4f5c\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from dataclasses import dataclass\nfrom typing import Annotated, Any, Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)  # (1)!\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'  # (2)!\n</code></pre> <ol> <li><code>frozen=True</code> \u89c4\u8303\u4f7f <code>MyAfterValidator</code> \u53ef\u54c8\u5e0c\u3002\u6ca1\u6709\u8fd9\u4e2a\uff0c\u50cf <code>Username | None</code> \u8fd9\u6837\u7684\u8054\u5408\u7c7b\u578b\u4f1a\u5f15\u53d1\u9519\u8bef\u3002</li> <li>\u8bf7\u6ce8\u610f\uff0c\u7c7b\u578b\u68c0\u67e5\u5668\u4e0d\u4f1a\u50cf\u4e0a\u4e00\u4e2a\u793a\u4f8b\u4e2d\u90a3\u6837\u62b1\u6028\u5c06 <code>'ABC'</code> \u8d4b\u503c\u7ed9 <code>Username</code>\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e0d\u8ba4\u4e3a <code>Username</code> \u662f\u4e0e <code>str</code> \u4e0d\u540c\u7684\u7c7b\u578b\u3002</li> </ol> <pre><code>from dataclasses import dataclass\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)  # (1)!\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'  # (2)!\n</code></pre> <ol> <li><code>frozen=True</code> \u89c4\u8303\u4f7f <code>MyAfterValidator</code> \u53ef\u54c8\u5e0c\u3002\u6ca1\u6709\u8fd9\u4e2a\uff0c\u50cf <code>Username | None</code> \u8fd9\u6837\u7684\u8054\u5408\u7c7b\u578b\u4f1a\u5f15\u53d1\u9519\u8bef\u3002</li> <li>\u8bf7\u6ce8\u610f\uff0c\u7c7b\u578b\u68c0\u67e5\u5668\u4e0d\u4f1a\u50cf\u4e0a\u4e00\u4e2a\u793a\u4f8b\u4e2d\u90a3\u6837\u62b1\u6028\u5c06 <code>'ABC'</code> \u8d4b\u503c\u7ed9 <code>Username</code>\uff0c\u56e0\u4e3a\u5b83\u4eec\u4e0d\u8ba4\u4e3a <code>Username</code> \u662f\u4e0e <code>str</code> \u4e0d\u540c\u7684\u7c7b\u578b\u3002</li> </ol>"},{"location":"concepts/types/#_4","title":"\u5904\u7406\u7b2c\u4e09\u65b9\u7c7b\u578b","text":"<p>\u4e0a\u4e00\u8282\u4e2d\u6a21\u5f0f\u7684\u53e6\u4e00\u4e2a\u7528\u4f8b\u662f\u5904\u7406\u7b2c\u4e09\u65b9\u7c7b\u578b\u3002</p> <pre><code>from typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    GetJsonSchemaHandler,\n    ValidationError,\n)\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass ThirdPartyType:\n    \"\"\"\n    \u8fd9\u65e8\u5728\u8868\u793a\u6765\u81ea\u7b2c\u4e09\u65b9\u5e93\u7684\u7c7b\u578b\uff0c\u8be5\u5e93\u5728\u8bbe\u8ba1\u65f6\u6ca1\u6709\u8003\u8651 Pydantic\n    \u96c6\u6210\uff0c\u56e0\u6b64\u6ca1\u6709 `pydantic_core.CoreSchema` \u6216\u4efb\u4f55\u76f8\u5173\u5185\u5bb9\u3002\n    \"\"\"\n\n    x: int\n\n    def __init__(self):\n        self.x = 0\n\n\nclass _ThirdPartyTypePydanticAnnotation:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: GetCoreSchemaHandler,\n    ) -&gt; core_schema.CoreSchema:\n        \"\"\"\n        \u6211\u4eec\u8fd4\u56de\u4e00\u4e2a `pydantic_core.CoreSchema`\uff0c\u5176\u884c\u4e3a\u65b9\u5f0f\u5982\u4e0b\uff1a\n\n        * int \u5c06\u88ab\u89e3\u6790\u4e3a `ThirdPartyType` \u5b9e\u4f8b\uff0c\u5176\u4e2d int \u4f5c\u4e3a x \u5c5e\u6027\n        * `ThirdPartyType` \u5b9e\u4f8b\u5c06\u88ab\u89e3\u6790\u4e3a `ThirdPartyType` \u5b9e\u4f8b\uff0c\u4e0d\u505a\u4efb\u4f55\u66f4\u6539\n        * \u5176\u4ed6\u4efb\u4f55\u5185\u5bb9\u90fd\u65e0\u6cd5\u901a\u8fc7\u9a8c\u8bc1\n        * \u5e8f\u5217\u5316\u5c06\u59cb\u7ec8\u53ea\u8fd4\u56de\u4e00\u4e2a int\n        \"\"\"\n\n        def validate_from_int(value: int) -&gt; ThirdPartyType:\n            result = ThirdPartyType()\n            result.x = value\n            return result\n\n        from_int_schema = core_schema.chain_schema(\n            [\n                core_schema.int_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_int),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_int_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    # \u9996\u5148\u68c0\u67e5\u5b83\u662f\u5426\u662f\u4e00\u4e2a\u5b9e\u4f8b\uff0c\u7136\u540e\u518d\u8fdb\u884c\u8fdb\u4e00\u6b65\u7684\u5de5\u4f5c\n                    core_schema.is_instance_schema(ThirdPartyType),\n                    from_int_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda instance: instance.x\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; JsonSchemaValue:\n        # \u4f7f\u7528\u4e0e `int` \u76f8\u540c\u7684\u6a21\u5f0f\n        return handler(core_schema.int_schema())\n\n\n# \u6211\u4eec\u73b0\u5728\u521b\u5efa\u4e00\u4e2a `Annotated` \u5305\u88c5\u5668\uff0c\u6211\u4eec\u5c06\u7528\u5b83\u4f5c\u4e3a `BaseModel` \u7b49\u5b57\u6bb5\u7684\u6ce8\u89e3\nPydanticThirdPartyType = Annotated[\n    ThirdPartyType, _ThirdPartyTypePydanticAnnotation\n]\n\n\n# \u521b\u5efa\u4e00\u4e2a\u4f7f\u7528\u6b64\u6ce8\u89e3\u4f5c\u4e3a\u5b57\u6bb5\u7684\u6a21\u578b\u7c7b\nclass Model(BaseModel):\n    third_party_type: PydanticThirdPartyType\n\n\n# \u6f14\u793a\u6b64\u5b57\u6bb5\u88ab\u6b63\u786e\u5904\u7406\uff0cint \u88ab\u89e3\u6790\u4e3a `ThirdPartyType`\uff0c\u5e76\u4e14\n# \u8fd9\u4e9b\u5b9e\u4f8b\u4e5f\u6309\u9884\u671f\u76f4\u63a5\"\u8f6c\u50a8\"\u4e3a int\nm_int = Model(third_party_type=1)\nassert isinstance(m_int.third_party_type, ThirdPartyType)\nassert m_int.third_party_type.x == 1\nassert m_int.model_dump() == {'third_party_type': 1}\n\n# \u4f20\u5165 ThirdPartyType \u5b9e\u4f8b\u65f6\u6267\u884c\u76f8\u540c\u7684\u64cd\u4f5c\ninstance = ThirdPartyType()\nassert instance.x == 0\ninstance.x = 10\n\nm_instance = Model(third_party_type=instance)\nassert isinstance(m_instance.third_party_type, ThirdPartyType)\nassert m_instance.third_party_type.x == 10\nassert m_instance.model_dump() == {'third_party_type': 10}\n\n# \u6f14\u793a\u5bf9\u4e8e\u65e0\u6548\u8f93\u5165\u4f1a\u6309\u9884\u671f\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\ntry:\n    Model(third_party_type='a')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    third_party_type.is-instance[ThirdPartyType]\n      Input should be an instance of ThirdPartyType [type=is_instance_of, input_value='a', input_type=str]\n    third_party_type.chain[int,function-plain[validate_from_int()]]\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\n\nassert Model.model_json_schema() == {\n    'properties': {\n        'third_party_type': {'title': 'Third Party Type', 'type': 'integer'}\n    },\n    'required': ['third_party_type'],\n    'title': 'Model',\n    'type': 'object',\n}\n</code></pre> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\u6765\u5b9a\u4e49 Pandas \u6216 Numpy \u7c7b\u578b\u7684\u884c\u4e3a\u3002</p>"},{"location":"concepts/types/#getpydanticschema","title":"\u4f7f\u7528 <code>GetPydanticSchema</code> \u51cf\u5c11\u6837\u677f\u4ee3\u7801","text":"API \u6587\u6863 <p><code>pydantic.types.GetPydanticSchema</code></p> <p>\u60a8\u53ef\u80fd\u4f1a\u6ce8\u610f\u5230\uff0c\u4e0a\u9762\u6211\u4eec\u521b\u5efa\u6807\u8bb0\u7c7b\u7684\u793a\u4f8b\u9700\u8981\u5927\u91cf\u7684\u6837\u677f\u4ee3\u7801\u3002 \u5bf9\u4e8e\u8bb8\u591a\u7b80\u5355\u7684\u60c5\u51b5\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>pydantic.GetPydanticSchema</code> \u6765\u5927\u5927\u51cf\u5c11\u8fd9\u4e9b\u4ee3\u7801\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\n\nclass Model(BaseModel):\n    y: Annotated[\n        str,\n        GetPydanticSchema(\n            lambda tp, handler: core_schema.no_info_after_validator_function(\n                lambda x: x * 2, handler(tp)\n            )\n        ),\n    ]\n\n\nassert Model(y='ab').y == 'abab'\n</code></pre>"},{"location":"concepts/types/#_5","title":"\u603b\u7ed3","text":"<p>\u8ba9\u6211\u4eec\u56de\u987e\u4e00\u4e0b\uff1a</p> <ol> <li>Pydantic \u63d0\u4f9b\u4e86\u901a\u8fc7 <code>Annotated</code> \u81ea\u5b9a\u4e49\u7c7b\u578b\u7684\u9ad8\u7ea7\u94a9\u5b50\uff0c\u5982 <code>AfterValidator</code> \u548c <code>Field</code>\u3002\u5c3d\u53ef\u80fd\u4f7f\u7528\u8fd9\u4e9b\u3002</li> <li>\u5728\u5e95\u5c42\uff0c\u8fd9\u4e9b\u4f7f\u7528 <code>pydantic-core</code> \u6765\u81ea\u5b9a\u4e49\u9a8c\u8bc1\uff0c\u60a8\u53ef\u4ee5\u76f4\u63a5\u4f7f\u7528 <code>GetPydanticSchema</code> \u6216\u5e26\u6709 <code>__get_pydantic_core_schema__</code> \u7684\u6807\u8bb0\u7c7b\u6765\u6302\u94a9\u3002</li> <li>\u5982\u679c\u60a8\u771f\u7684\u60f3\u8981\u4e00\u4e2a\u81ea\u5b9a\u4e49\u7c7b\u578b\uff0c\u60a8\u53ef\u4ee5\u5728\u7c7b\u578b\u672c\u8eab\u4e0a\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code>\u3002</li> </ol>"},{"location":"concepts/types/#_6","title":"\u5904\u7406\u81ea\u5b9a\u4e49\u6cdb\u578b\u7c7b","text":"<p>Warning</p> <p>\u8fd9\u662f\u4e00\u79cd\u9ad8\u7ea7\u6280\u672f\uff0c\u60a8\u53ef\u80fd\u4e00\u5f00\u59cb\u4e0d\u9700\u8981\u3002\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c \u60a8\u53ef\u80fd\u4f7f\u7528\u6807\u51c6\u7684 Pydantic \u6a21\u578b\u5c31\u8db3\u591f\u4e86\u3002</p> <p>\u60a8\u53ef\u4ee5\u4f7f\u7528 \u6cdb\u578b\u7c7b\u4f5c\u4e3a \u5b57\u6bb5\u7c7b\u578b\uff0c\u5e76\u4f7f\u7528 <code>__get_pydantic_core_schema__</code> \u57fa\u4e8e\"\u7c7b\u578b\u53c2\u6570\"\uff08\u6216\u5b50\u7c7b\u578b\uff09 \u6267\u884c\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u3002</p> <p>\u5982\u679c\u60a8\u7528\u4f5c\u5b50\u7c7b\u578b\u7684\u6cdb\u578b\u7c7b\u5177\u6709\u7c7b\u65b9\u6cd5 <code>__get_pydantic_core_schema__</code>\uff0c\u60a8\u4e0d\u9700\u8981\u4f7f\u7528 <code>arbitrary_types_allowed</code> \u6765\u4f7f\u5176\u5de5\u4f5c\u3002</p> <p>\u56e0\u4e3a <code>source_type</code> \u53c2\u6570\u4e0e <code>cls</code> \u53c2\u6570\u4e0d\u540c\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 <code>typing.get_args</code>\uff08\u6216 <code>typing_extensions.get_args</code>\uff09\u6765\u63d0\u53d6\u6cdb\u578b\u53c2\u6570\u3002 \u7136\u540e\u60a8\u53ef\u4ee5\u901a\u8fc7\u8c03\u7528 <code>handler.generate_schema</code> \u6765\u4e3a\u5b83\u4eec\u751f\u6210\u6a21\u5f0f\u3002 \u8bf7\u6ce8\u610f\uff0c\u6211\u4eec\u4e0d\u6267\u884c\u7c7b\u4f3c <code>handler(get_args(source_type)[0])</code> \u7684\u64cd\u4f5c\uff0c\u56e0\u4e3a\u6211\u4eec\u60f3\u8981\u4e3a\u90a3\u4e2a\u6cdb\u578b\u53c2\u6570\u751f\u6210\u4e00\u4e2a\u4e0d\u76f8\u5173\u7684 \u6a21\u5f0f\uff0c\u800c\u4e0d\u662f\u53d7\u5f53\u524d <code>Annotated</code> \u5143\u6570\u636e\u7b49\u4e0a\u4e0b\u6587\u5f71\u54cd\u7684\u6a21\u5f0f\u3002 \u8fd9\u5bf9\u4e8e\u81ea\u5b9a\u4e49\u7c7b\u578b\u4e0d\u592a\u91cd\u8981\uff0c\u4f46\u5bf9\u4e8e\u4fee\u6539\u6a21\u5f0f\u6784\u5efa\u7684\u6ce8\u89e3\u5143\u6570\u636e\u81f3\u5173\u91cd\u8981\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from dataclasses import dataclass\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom typing_extensions import get_args, get_origin\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    ValidationError,\n    ValidatorFunctionWrapHandler,\n)\n\nItemType = TypeVar('ItemType')\n\n\n# This is not a pydantic model, it's an arbitrary generic class\n@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        # both calling handler(...) and handler.generate_schema(...)\n        # would work, but prefer the latter for conceptual and consistency reasons\n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(\n            v: Owner[Any], handler: ValidatorFunctionWrapHandler\n        ) -&gt; Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            # `chain_schema` means do the following steps in order:\n            [\n                # Ensure the value is an instance of Owner\n                core_schema.is_instance_schema(cls),\n                # Use the item_schema to validate `items`\n                core_schema.no_info_wrap_validator_function(\n                    val_item, item_schema\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            # for JSON accept an object with name and item keys\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    # after validating the json data convert it to python\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        # note that we reuse the same schema here as below\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n\n\nclass Car(BaseModel):\n    color: str\n\n\nclass House(BaseModel):\n    rooms: int\n\n\nclass Model(BaseModel):\n    car_owner: Owner[Car]\n    home_owner: Owner[House]\n\n\nmodel = Model(\n    car_owner=Owner(name='John', item=Car(color='black')),\n    home_owner=Owner(name='James', item=House(rooms=3)),\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        car_owner=Owner(name='John', item=House(rooms=3)),\n        home_owner=Owner(name='James', item=Car(color='black')),\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    wine\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='Kinda good', input_type=str]\n    cheese\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='yeah', input_type=str]\n    \"\"\"\n\n# Similarly with JSON\nmodel = Model.model_validate_json(\n    '{\"car_owner\":{\"name\":\"John\",\"item\":{\"color\":\"black\"}},\"home_owner\":{\"name\":\"James\",\"item\":{\"rooms\":3}}}'\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    Model.model_validate_json(\n        '{\"car_owner\":{\"name\":\"John\",\"item\":{\"rooms\":3}},\"home_owner\":{\"name\":\"James\",\"item\":{\"color\":\"black\"}}}'\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    car_owner.item.color\n      Field required [type=missing, input_value={'rooms': 3}, input_type=dict]\n    home_owner.item.rooms\n      Field required [type=missing, input_value={'color': 'black'}, input_type=dict]\n    \"\"\"\n</code></pre> <pre><code>from dataclasses import dataclass\nfrom typing import Any, Generic, TypeVar\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom typing import get_args, get_origin\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    ValidationError,\n    ValidatorFunctionWrapHandler,\n)\n\nItemType = TypeVar('ItemType')\n\n\n# This is not a pydantic model, it's an arbitrary generic class\n@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        # both calling handler(...) and handler.generate_schema(...)\n        # would work, but prefer the latter for conceptual and consistency reasons\n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(\n            v: Owner[Any], handler: ValidatorFunctionWrapHandler\n        ) -&gt; Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            # `chain_schema` means do the following steps in order:\n            [\n                # Ensure the value is an instance of Owner\n                core_schema.is_instance_schema(cls),\n                # Use the item_schema to validate `items`\n                core_schema.no_info_wrap_validator_function(\n                    val_item, item_schema\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            # for JSON accept an object with name and item keys\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    # after validating the json data convert it to python\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        # note that we reuse the same schema here as below\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n\n\nclass Car(BaseModel):\n    color: str\n\n\nclass House(BaseModel):\n    rooms: int\n\n\nclass Model(BaseModel):\n    car_owner: Owner[Car]\n    home_owner: Owner[House]\n\n\nmodel = Model(\n    car_owner=Owner(name='John', item=Car(color='black')),\n    home_owner=Owner(name='James', item=House(rooms=3)),\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    # If the values of the sub-types are invalid, we get an error\n    Model(\n        car_owner=Owner(name='John', item=House(rooms=3)),\n        home_owner=Owner(name='James', item=Car(color='black')),\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    wine\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='Kinda good', input_type=str]\n    cheese\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='yeah', input_type=str]\n    \"\"\"\n\n# Similarly with JSON\nmodel = Model.model_validate_json(\n    '{\"car_owner\":{\"name\":\"John\",\"item\":{\"color\":\"black\"}},\"home_owner\":{\"name\":\"James\",\"item\":{\"rooms\":3}}}'\n)\nprint(model)\n\"\"\"\ncar_owner=Owner(name='John', item=Car(color='black')) home_owner=Owner(name='James', item=House(rooms=3))\n\"\"\"\n\ntry:\n    Model.model_validate_json(\n        '{\"car_owner\":{\"name\":\"John\",\"item\":{\"rooms\":3}},\"home_owner\":{\"name\":\"James\",\"item\":{\"color\":\"black\"}}}'\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    car_owner.item.color\n      Field required [type=missing, input_value={'rooms': 3}, input_type=dict]\n    home_owner.item.rooms\n      Field required [type=missing, input_value={'color': 'black'}, input_type=dict]\n    \"\"\"\n</code></pre>"},{"location":"concepts/types/#_7","title":"\u6cdb\u578b\u5bb9\u5668","text":"<p>\u540c\u6837\u7684\u60f3\u6cd5\u53ef\u4ee5\u5e94\u7528\u4e8e\u521b\u5efa\u6cdb\u578b\u5bb9\u5668\u7c7b\u578b\uff0c\u6bd4\u5982\u81ea\u5b9a\u4e49\u7684 <code>Sequence</code> \u7c7b\u578b\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from collections.abc import Sequence\nfrom typing import Any, TypeVar\n\nfrom pydantic_core import ValidationError, core_schema\nfrom typing_extensions import get_args\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\nT = TypeVar('T')\n\n\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]\n\n    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            # replace the type and rely on Pydantic to generate the right schema\n            # for `Sequence`\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n\n\nclass M(BaseModel):\n    model_config = dict(validate_default=True)\n\n    s1: MySequence = [3]\n\n\nm = M()\nprint(m)\n#&gt; s1=&lt;__main__.MySequence object at 0x0123456789ab&gt;\nprint(m.s1.v)\n#&gt; [3]\n\n\nclass M(BaseModel):\n    s1: MySequence[int]\n\n\nM(s1=[1])\ntry:\n    M(s1=['a'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for M\n    s1.is-instance[MySequence]\n      Input should be an instance of MySequence [type=is_instance_of, input_value=['a'], input_type=list]\n    s1.function-after[MySequence(), json-or-python[json=list[int],python=chain[is-instance[Sequence],function-wrap[sequence_validator()]]]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n</code></pre> <pre><code>from collections.abc import Sequence\nfrom typing import Any, TypeVar\n\nfrom pydantic_core import ValidationError, core_schema\nfrom typing import get_args\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\nT = TypeVar('T')\n\n\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]\n\n    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            # replace the type and rely on Pydantic to generate the right schema\n            # for `Sequence`\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n\n\nclass M(BaseModel):\n    model_config = dict(validate_default=True)\n\n    s1: MySequence = [3]\n\n\nm = M()\nprint(m)\n#&gt; s1=&lt;__main__.MySequence object at 0x0123456789ab&gt;\nprint(m.s1.v)\n#&gt; [3]\n\n\nclass M(BaseModel):\n    s1: MySequence[int]\n\n\nM(s1=[1])\ntry:\n    M(s1=['a'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for M\n    s1.is-instance[MySequence]\n      Input should be an instance of MySequence [type=is_instance_of, input_value=['a'], input_type=list]\n    s1.function-after[MySequence(), json-or-python[json=list[int],python=chain[is-instance[Sequence],function-wrap[sequence_validator()]]]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"concepts/types/#_8","title":"\u8bbf\u95ee\u5b57\u6bb5\u540d\u79f0","text":"<p>Note</p> <p>\u8fd9\u5728 Pydantic V2 \u5230 V2.3 \u4e2d\u662f\u4e0d\u53ef\u80fd\u7684\uff0c\u5b83\u5728 Pydantic V2.4 \u4e2d\u91cd\u65b0\u6dfb\u52a0\u3002</p> <p>\u4ece Pydantic V2.4 \u5f00\u59cb\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7 <code>__get_pydantic_core_schema__</code> \u4e2d\u7684 <code>handler.field_name</code> \u8bbf\u95ee\u5b57\u6bb5\u540d\u79f0\uff0c \u4ece\u800c\u8bbe\u7f6e\u53ef\u4ee5\u4ece <code>info.field_name</code> \u83b7\u53d6\u7684\u5b57\u6bb5\u540d\u79f0\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationInfo\n\n\nclass CustomType:\n    \"\"\"Custom type that stores the field it was used in.\"\"\"\n\n    def __init__(self, value: int, field_name: str):\n        self.value = value\n        self.field_name = field_name\n\n    def __repr__(self):\n        return f'CustomType&lt;{self.value} {self.field_name!r}&gt;'\n\n    @classmethod\n    def validate(cls, value: int, info: ValidationInfo):\n        return cls(value, info.field_name)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -&gt; core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            cls.validate, handler(int)\n        )\n\n\nclass MyModel(BaseModel):\n    my_field: CustomType\n\n\nm = MyModel(my_field=1)\nprint(m.my_field)\n#&gt; CustomType&lt;1 'my_field'&gt;\n</code></pre> <p>\u60a8\u4e5f\u53ef\u4ee5\u4ece\u4e0e <code>Annotated</code> \u4e00\u8d77\u4f7f\u7528\u7684\u6807\u8bb0\u4e2d\u8bbf\u95ee <code>field_name</code>\uff0c\u4f8b\u5982 <code>AfterValidator</code>\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationInfo\n\n\ndef my_validators(value: int, info: ValidationInfo):\n    return f'&lt;{value} {info.field_name!r}&gt;'\n\n\nclass MyModel(BaseModel):\n    my_field: Annotated[int, AfterValidator(my_validators)]\n\n\nm = MyModel(my_field=1)\nprint(m.my_field)\n#&gt; &lt;1 'my_field'&gt;\n</code></pre>"},{"location":"concepts/unions/","title":"Unions","text":"<p>\u8054\u5408\u7c7b\u578b\uff08Unions\uff09\u4e0ePydantic\u9a8c\u8bc1\u7684\u6240\u6709\u5176\u4ed6\u7c7b\u578b\u6709\u7740\u6839\u672c\u6027\u7684\u4e0d\u540c - \u4e0d\u662f\u8981\u6c42\u6240\u6709\u5b57\u6bb5/\u9879/\u503c\u90fd\u6709\u6548\uff0c\u8054\u5408\u7c7b\u578b\u53ea\u9700\u8981\u5176\u4e2d\u4e00\u4e2a\u6210\u5458\u6709\u6548\u5373\u53ef\u3002</p> <p>\u8fd9\u5bfc\u81f4\u5728\u5982\u4f55\u9a8c\u8bc1\u8054\u5408\u7c7b\u578b\u65b9\u9762\u5b58\u5728\u4e00\u4e9b\u7ec6\u5fae\u5dee\u522b\uff1a</p> <ul> <li>\u5e94\u8be5\u9488\u5bf9\u8054\u5408\u7c7b\u578b\u7684\u54ea\u4e2a\u6210\u5458\uff08\u6216\u591a\u4e2a\u6210\u5458\uff09\u9a8c\u8bc1\u6570\u636e\uff0c\u4ee5\u53ca\u6309\u4ec0\u4e48\u987a\u5e8f\uff1f</li> <li>\u9a8c\u8bc1\u5931\u8d25\u65f6\u5e94\u5f15\u53d1\u54ea\u4e9b\u9519\u8bef\uff1f</li> </ul> <p>\u9a8c\u8bc1\u8054\u5408\u7c7b\u578b\u611f\u89c9\u50cf\u662f\u4e3a\u9a8c\u8bc1\u8fc7\u7a0b\u6dfb\u52a0\u4e86\u53e6\u4e00\u4e2a\u6b63\u4ea4\u7ef4\u5ea6\u3002</p> <p>\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e9b\u95ee\u9898\uff0cPydantic\u652f\u6301\u4e09\u79cd\u57fa\u672c\u7684\u8054\u5408\u7c7b\u578b\u9a8c\u8bc1\u65b9\u6cd5\uff1a</p> <ol> <li>\u4ece\u5de6\u5230\u53f3\u6a21\u5f0f - \u6700\u7b80\u5355\u7684\u65b9\u6cd5\uff0c\u6309\u987a\u5e8f\u5c1d\u8bd5\u8054\u5408\u7c7b\u578b\u7684\u6bcf\u4e2a\u6210\u5458\uff0c\u8fd4\u56de\u7b2c\u4e00\u4e2a\u5339\u914d\u9879</li> <li>\u667a\u80fd\u6a21\u5f0f - \u7c7b\u4f3c\u4e8e\"\u4ece\u5de6\u5230\u53f3\u6a21\u5f0f\"\uff0c\u6309\u987a\u5e8f\u5c1d\u8bd5\u6210\u5458\uff1b\u4f46\u662f\uff0c\u9a8c\u8bc1\u4f1a\u7ee7\u7eed\u5bfb\u627e\u66f4\u597d\u7684\u5339\u914d\u9879\uff0c\u8fd9\u662f\u5927\u591a\u6570\u8054\u5408\u7c7b\u578b\u9a8c\u8bc1\u7684\u9ed8\u8ba4\u6a21\u5f0f</li> <li>\u533a\u5206\u8054\u5408\u7c7b\u578b - \u57fa\u4e8e\u533a\u5206\u5668\uff0c\u53ea\u5c1d\u8bd5\u8054\u5408\u7c7b\u578b\u7684\u4e00\u4e2a\u6210\u5458</li> </ol> <p>Tip</p> <p>\u4e00\u822c\u6765\u8bf4\uff0c\u6211\u4eec\u63a8\u8350\u4f7f\u7528\u533a\u5206\u8054\u5408\u7c7b\u578b\u3002\u5b83\u4eec\u6bd4\u672a\u6807\u8bb0\u7684\u8054\u5408\u7c7b\u578b\u65e2\u66f4\u9ad8\u6548\u53c8\u66f4\u53ef\u9884\u6d4b\uff0c\u56e0\u4e3a\u5b83\u4eec\u5141\u8bb8\u60a8\u63a7\u5236\u8981\u9a8c\u8bc1\u8054\u5408\u7c7b\u578b\u7684\u54ea\u4e2a\u6210\u5458\u3002</p> <p>\u5bf9\u4e8e\u590d\u6742\u60c5\u51b5\uff0c\u5982\u679c\u60a8\u4f7f\u7528\u672a\u6807\u8bb0\u7684\u8054\u5408\u7c7b\u578b\uff0c\u5efa\u8bae\u4f7f\u7528 <code>union_mode='left_to_right'</code>\uff0c\u5982\u679c\u60a8\u9700\u8981\u5bf9\u8054\u5408\u7c7b\u578b\u6210\u5458\u7684\u9a8c\u8bc1\u5c1d\u8bd5\u987a\u5e8f\u6709\u4fdd\u8bc1\u3002</p> <p>\u5982\u679c\u60a8\u9700\u8981\u6781\u5176\u4e13\u4e1a\u5316\u7684\u884c\u4e3a\uff0c\u53ef\u4ee5\u4f7f\u7528\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u3002</p>"},{"location":"concepts/unions/#union-modes","title":"\u8054\u5408\u7c7b\u578b\u6a21\u5f0f","text":""},{"location":"concepts/unions/#left-to-right-mode","title":"\u4ece\u5de6\u5230\u53f3\u6a21\u5f0f","text":"<p>Note</p> <p>\u7531\u4e8e\u6b64\u6a21\u5f0f\u7ecf\u5e38\u5bfc\u81f4\u610f\u5916\u7684\u9a8c\u8bc1\u7ed3\u679c\uff0c\u5b83\u4e0d\u662fPydantic &gt;=2\u4e2d\u7684\u9ed8\u8ba4\u6a21\u5f0f\uff0c\u800c\u662f <code>union_mode='smart'</code> \u662f\u9ed8\u8ba4\u6a21\u5f0f\u3002</p> <p>\u4f7f\u7528\u8fd9\u79cd\u65b9\u6cd5\uff0c\u9a8c\u8bc1\u4f1a\u6309\u7167\u8054\u5408\u7c7b\u578b\u6210\u5458\u5b9a\u4e49\u7684\u987a\u5e8f\u4f9d\u6b21\u5c1d\u8bd5\u6bcf\u4e2a\u6210\u5458\uff0c\u7b2c\u4e00\u4e2a\u6210\u529f\u7684\u9a8c\u8bc1\u88ab\u63a5\u53d7\u4e3a\u8f93\u5165\u3002</p> <p>\u5982\u679c\u6240\u6709\u6210\u5458\u7684\u9a8c\u8bc1\u90fd\u5931\u8d25\uff0c\u9a8c\u8bc1\u9519\u8bef\u5c06\u5305\u542b\u8054\u5408\u7c7b\u578b\u6240\u6709\u6210\u5458\u7684\u9519\u8bef\u3002</p> <p><code>union_mode='left_to_right'</code> \u5fc5\u987b\u4f5c\u4e3a <code>Field</code> \u53c2\u6570\u8bbe\u7f6e\u5728\u60a8\u60f3\u8981\u4f7f\u7528\u5b83\u7684\u8054\u5408\u7c7b\u578b\u5b57\u6bb5\u4e0a\u3002</p> Python 3.9 and abovePython 3.10 and above Union with left to right mode<pre><code>from typing import Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    id: Union[str, int] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))\n#&gt; id=123\nprint(User(id='hello'))\n#&gt; id='hello'\n\ntry:\n    User(id=[])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for User\n    id.str\n      Input should be a valid string [type=string_type, input_value=[], input_type=list]\n    id.int\n      Input should be a valid integer [type=int_type, input_value=[], input_type=list]\n    \"\"\"\n</code></pre> Union with left to right mode<pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    id: str | int = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))\n#&gt; id=123\nprint(User(id='hello'))\n#&gt; id='hello'\n\ntry:\n    User(id=[])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for User\n    id.str\n      Input should be a valid string [type=string_type, input_value=[], input_type=list]\n    id.int\n      Input should be a valid integer [type=int_type, input_value=[], input_type=list]\n    \"\"\"\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6210\u5458\u7684\u987a\u5e8f\u975e\u5e38\u91cd\u8981\uff0c\u6b63\u5982\u901a\u8fc7\u8c03\u6574\u4e0a\u8ff0\u793a\u4f8b\u6240\u5c55\u793a\u7684\uff1a</p> Python 3.9 and abovePython 3.10 and above Union with left to right - unexpected results<pre><code>from typing import Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: Union[int, str] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))  # (1)\n#&gt; id=123\nprint(User(id='456'))  # (2)\n#&gt; id=456\n</code></pre> <ol> <li>\u6b63\u5982\u9884\u671f\u7684\u90a3\u6837\uff0c\u8f93\u5165\u9488\u5bf9 <code>int</code> \u6210\u5458\u8fdb\u884c\u9a8c\u8bc1\uff0c\u7ed3\u679c\u7b26\u5408\u9884\u671f\u3002</li> <li>\u6211\u4eec\u5904\u4e8e\u5bbd\u677e\u6a21\u5f0f\uff0c\u6570\u5b57\u5b57\u7b26\u4e32 <code>'123'</code> \u4f5c\u4e3a\u8054\u5408\u7c7b\u578b\u7b2c\u4e00\u4e2a\u6210\u5458 <code>int</code> \u7684\u8f93\u5165\u662f\u6709\u6548\u7684\u3002    \u7531\u4e8e\u5b83\u9996\u5148\u88ab\u5c1d\u8bd5\uff0c\u6211\u4eec\u5f97\u5230\u4e86\u4ee4\u4eba\u60ca\u8bb6\u7684\u7ed3\u679c\uff1a<code>id</code> \u662f <code>int</code> \u800c\u4e0d\u662f <code>str</code>\u3002</li> </ol> Union with left to right - unexpected results<pre><code>from pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: int | str = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))  # (1)\n#&gt; id=123\nprint(User(id='456'))  # (2)\n#&gt; id=456\n</code></pre> <ol> <li>\u6b63\u5982\u9884\u671f\u7684\u90a3\u6837\uff0c\u8f93\u5165\u9488\u5bf9 <code>int</code> \u6210\u5458\u8fdb\u884c\u9a8c\u8bc1\uff0c\u7ed3\u679c\u7b26\u5408\u9884\u671f\u3002</li> <li>\u6211\u4eec\u5904\u4e8e\u5bbd\u677e\u6a21\u5f0f\uff0c\u6570\u5b57\u5b57\u7b26\u4e32 <code>'123'</code> \u4f5c\u4e3a\u8054\u5408\u7c7b\u578b\u7b2c\u4e00\u4e2a\u6210\u5458 <code>int</code> \u7684\u8f93\u5165\u662f\u6709\u6548\u7684\u3002    \u7531\u4e8e\u5b83\u9996\u5148\u88ab\u5c1d\u8bd5\uff0c\u6211\u4eec\u5f97\u5230\u4e86\u4ee4\u4eba\u60ca\u8bb6\u7684\u7ed3\u679c\uff1a<code>id</code> \u662f <code>int</code> \u800c\u4e0d\u662f <code>str</code>\u3002</li> </ol>"},{"location":"concepts/unions/#smart-mode","title":"\u667a\u80fd\u6a21\u5f0f","text":"<p>\u7531\u4e8e <code>union_mode='left_to_right'</code> \u53ef\u80fd\u4ea7\u751f\u4ee4\u4eba\u60ca\u8bb6\u7684\u7ed3\u679c\uff0c\u5728Pydantic &gt;=2\u4e2d\uff0c<code>Union</code> \u9a8c\u8bc1\u7684\u9ed8\u8ba4\u6a21\u5f0f\u662f <code>union_mode='smart'</code>\u3002</p> <p>\u5728\u8fd9\u79cd\u6a21\u5f0f\u4e0b\uff0cpydantic\u5c1d\u8bd5\u4ece\u8054\u5408\u7c7b\u578b\u6210\u5458\u4e2d\u9009\u62e9\u4e0e\u8f93\u5165\u6700\u5339\u914d\u7684\u9879\u3002\u786e\u5207\u7684\u7b97\u6cd5\u53ef\u80fd\u4f1a\u5728Pydantic\u6b21\u8981\u7248\u672c\u4e4b\u95f4\u66f4\u6539\uff0c\u4ee5\u5141\u8bb8\u5728\u6027\u80fd\u548c\u51c6\u786e\u6027\u65b9\u9762\u8fdb\u884c\u6539\u8fdb\u3002</p> <p>Note</p> <p>\u6211\u4eec\u4fdd\u7559\u5728\u672a\u6765\u7248\u672c\u7684Pydantic\u4e2d\u8c03\u6574\u5185\u90e8 <code>smart</code> \u5339\u914d\u7b97\u6cd5\u7684\u6743\u5229\u3002\u5982\u679c\u60a8\u4f9d\u8d56\u975e\u5e38\u7279\u5b9a\u7684\u5339\u914d\u884c\u4e3a\uff0c\u5efa\u8bae\u4f7f\u7528 <code>union_mode='left_to_right'</code> \u6216\u533a\u5206\u8054\u5408\u7c7b\u578b\u3002</p> \u667a\u80fd\u6a21\u5f0f\u7b97\u6cd5 <p>\u667a\u80fd\u6a21\u5f0f\u7b97\u6cd5\u4f7f\u7528\u4e24\u4e2a\u6307\u6807\u6765\u786e\u5b9a\u4e0e\u8f93\u5165\u7684\u6700\u4f73\u5339\u914d\uff1a</p> <ol> <li>\u6709\u6548\u5b57\u6bb5\u8bbe\u7f6e\u7684\u6570\u91cf\uff08\u4e0e\u6a21\u578b\u3001\u6570\u636e\u7c7b\u548c\u7c7b\u578b\u5316\u5b57\u5178\u76f8\u5173\uff09</li> <li>\u5339\u914d\u7684\u7cbe\u786e\u5ea6\uff08\u4e0e\u6240\u6709\u7c7b\u578b\u76f8\u5173\uff09</li> </ol> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Union\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[int, str, UUID]\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#&gt; id=123 name='John Doe'\nprint(user_01.id)\n#&gt; 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#&gt; id='1234' name='John Doe'\nprint(user_02.id)\n#&gt; 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#&gt; id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#&gt; cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#&gt; 275603287559914445491632874575877060712\n</code></pre> <pre><code>from uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: int | str | UUID\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#&gt; id=123 name='John Doe'\nprint(user_01.id)\n#&gt; 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#&gt; id='1234' name='John Doe'\nprint(user_02.id)\n#&gt; 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#&gt; id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#&gt; cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#&gt; 275603287559914445491632874575877060712\n</code></pre>"},{"location":"concepts/unions/#_1","title":"\u6709\u6548\u5b57\u6bb5\u8bbe\u7f6e\u7684\u6570\u91cf","text":"<p>Note</p> <p>\u6b64\u6307\u6807\u5728Pydantic v2.8.0\u4e2d\u5f15\u5165\u3002\u5728\u6b64\u7248\u672c\u4e4b\u524d\uff0c\u4ec5\u4f7f\u7528\u7cbe\u786e\u5ea6\u6765\u786e\u5b9a\u6700\u4f73\u5339\u914d\u3002</p> <p>\u6b64\u6307\u6807\u76ee\u524d\u4ec5\u4e0e\u6a21\u578b\u3001\u6570\u636e\u7c7b\u548c\u7c7b\u578b\u5316\u5b57\u5178\u76f8\u5173\u3002</p> <p>\u6709\u6548\u5b57\u6bb5\u8bbe\u7f6e\u7684\u6570\u91cf\u8d8a\u591a\uff0c\u5339\u914d\u8d8a\u597d\u3002\u5d4c\u5957\u6a21\u578b\u4e0a\u8bbe\u7f6e\u7684\u5b57\u6bb5\u6570\u91cf\u4e5f\u4f1a\u88ab\u8003\u8651\u5728\u5185\u3002 \u8fd9\u4e9b\u8ba1\u6570\u4f1a\u5192\u6ce1\u5230\u9876\u7ea7\u8054\u5408\u7c7b\u578b\uff0c\u5176\u4e2d\u5177\u6709\u6700\u9ad8\u8ba1\u6570\u7684\u8054\u5408\u7c7b\u578b\u6210\u5458\u88ab\u8ba4\u4e3a\u662f\u6700\u4f73\u5339\u914d\u3002</p> <p>\u5bf9\u4e8e\u6b64\u6307\u6807\u76f8\u5173\u7684\u6570\u636e\u7c7b\u578b\uff0c\u6211\u4eec\u4f18\u5148\u8003\u8651\u6b64\u8ba1\u6570\u800c\u4e0d\u662f\u7cbe\u786e\u5ea6\u3002\u5bf9\u4e8e\u6240\u6709\u5176\u4ed6\u7c7b\u578b\uff0c\u6211\u4eec\u4ec5\u4f7f\u7528\u7cbe\u786e\u5ea6\u3002</p>"},{"location":"concepts/unions/#_2","title":"\u7cbe\u786e\u5ea6","text":"<p>\u5bf9\u4e8e <code>exactness</code>\uff0cPydantic\u5c06\u8054\u5408\u7c7b\u578b\u6210\u5458\u7684\u5339\u914d\u8bc4\u5206\u5230\u4ee5\u4e0b\u4e09\u4e2a\u7ec4\u4e4b\u4e00\uff08\u4ece\u6700\u9ad8\u5206\u5230\u6700\u4f4e\u5206\uff09\uff1a</p> <ul> <li>\u7cbe\u786e\u7c7b\u578b\u5339\u914d\uff0c\u4f8b\u5982 <code>int</code> \u8f93\u5165\u5230 <code>float | int</code> \u8054\u5408\u7c7b\u578b\u9a8c\u8bc1\u662f <code>int</code> \u6210\u5458\u7684\u7cbe\u786e\u7c7b\u578b\u5339\u914d</li> <li>\u9a8c\u8bc1\u5c06\u5728<code>strict</code>\u6a21\u5f0f\u4e2d\u6210\u529f</li> <li>\u9a8c\u8bc1\u5c06\u5728\u5bbd\u677e\u6a21\u5f0f\u4e2d\u6210\u529f</li> </ul> <p>\u4ea7\u751f\u6700\u9ad8\u7cbe\u786e\u5ea6\u5f97\u5206\u7684\u8054\u5408\u7c7b\u578b\u5339\u914d\u5c06\u88ab\u8ba4\u4e3a\u662f\u6700\u4f73\u5339\u914d\u3002</p> <p>\u5728\u667a\u80fd\u6a21\u5f0f\u4e0b\uff0c\u91c7\u53d6\u4ee5\u4e0b\u6b65\u9aa4\u6765\u5c1d\u8bd5\u9009\u62e9\u4e0e\u8f93\u5165\u7684\u6700\u4f73\u5339\u914d\uff1a</p> <code>BaseModel</code>, <code>dataclass</code>, and <code>TypedDict</code>\u6240\u6709\u5176\u4ed6\u6570\u636e\u7c7b\u578b <ol> <li>\u4ece\u5de6\u5230\u53f3\u5c1d\u8bd5\u8054\u5408\u7c7b\u578b\u6210\u5458\uff0c\u4efb\u4f55\u6210\u529f\u7684\u5339\u914d\u90fd\u4f1a\u6839\u636e\u4e0a\u8ff0\u4e09\u4e2a\u7cbe\u786e\u5ea6\u7c7b\u522b\u8fdb\u884c\u8bc4\u5206\uff0c\u540c\u65f6\u7edf\u8ba1\u6709\u6548\u5b57\u6bb5\u8bbe\u7f6e\u7684\u6570\u91cf\u3002</li> <li>\u8bc4\u4f30\u6240\u6709\u6210\u5458\u540e\uff0c\u8fd4\u56de\u5177\u6709\u6700\u9ad8\"\u6709\u6548\u5b57\u6bb5\u8bbe\u7f6e\"\u8ba1\u6570\u7684\u6210\u5458\u3002</li> <li>\u5982\u679c\u6700\u9ad8\"\u6709\u6548\u5b57\u6bb5\u8bbe\u7f6e\"\u8ba1\u6570\u51fa\u73b0\u5e73\u5c40\uff0c\u5219\u4f7f\u7528\u7cbe\u786e\u5ea6\u5f97\u5206\u4f5c\u4e3a\u51b3\u80dc\u5c40\uff0c\u8fd4\u56de\u5177\u6709\u6700\u9ad8\u7cbe\u786e\u5ea6\u5f97\u5206\u7684\u6210\u5458\u3002</li> <li>\u5982\u679c\u6240\u6709\u6210\u5458\u7684\u9a8c\u8bc1\u90fd\u5931\u8d25\uff0c\u5219\u8fd4\u56de\u6240\u6709\u9519\u8bef\u3002</li> </ol> <ol> <li>\u4ece\u5de6\u5230\u53f3\u5c1d\u8bd5\u8054\u5408\u7c7b\u578b\u6210\u5458\uff0c\u4efb\u4f55\u6210\u529f\u7684\u5339\u914d\u90fd\u4f1a\u6839\u636e\u4e0a\u8ff0\u4e09\u4e2a\u7cbe\u786e\u5ea6\u7c7b\u522b\u8fdb\u884c\u8bc4\u5206\u3002<ul> <li>\u5982\u679c\u9a8c\u8bc1\u4ee5\u7cbe\u786e\u7c7b\u578b\u5339\u914d\u6210\u529f\uff0c\u5219\u7acb\u5373\u8fd4\u56de\u8be5\u6210\u5458\uff0c\u5e76\u4e14\u4e0d\u4f1a\u5c1d\u8bd5\u540e\u7eed\u6210\u5458\u3002</li> </ul> </li> <li>\u5982\u679c\u81f3\u5c11\u6709\u4e00\u4e2a\u6210\u5458\u4f5c\u4e3a\"strict\"\u5339\u914d\u6210\u529f\uff0c\u5219\u8fd4\u56de\u6700\u5de6\u8fb9\u7684\"strict\"\u5339\u914d\u3002</li> <li>\u5982\u679c\u81f3\u5c11\u6709\u4e00\u4e2a\u6210\u5458\u5728\"lax\"\u6a21\u5f0f\u4e0b\u6210\u529f\uff0c\u5219\u8fd4\u56de\u6700\u5de6\u8fb9\u7684\u5339\u914d\u3002</li> <li>\u6240\u6709\u6210\u5458\u7684\u9a8c\u8bc1\u90fd\u5931\u8d25\uff0c\u8fd4\u56de\u6240\u6709\u9519\u8bef\u3002</li> </ol>"},{"location":"concepts/unions/#_3","title":"\u533a\u5206\u8054\u5408\u7c7b\u578b","text":"<p>\u533a\u5206\u8054\u5408\u7c7b\u578b\u6709\u65f6\u88ab\u79f0\u4e3a\"\u6807\u8bb0\u8054\u5408\u7c7b\u578b\"\u3002</p> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u533a\u5206\u8054\u5408\u7c7b\u578b\u6765\u66f4\u6709\u6548\u5730\u9a8c\u8bc1 <code>Union</code> \u7c7b\u578b\uff0c\u901a\u8fc7\u9009\u62e9\u8981\u9a8c\u8bc1\u7684\u8054\u5408\u7c7b\u578b\u6210\u5458\u3002</p> <p>\u8fd9\u4f7f\u5f97\u9a8c\u8bc1\u66f4\u52a0\u9ad8\u6548\uff0c\u5e76\u4e14\u5728\u9a8c\u8bc1\u5931\u8d25\u65f6\u907f\u514d\u4e86\u9519\u8bef\u6269\u6563\u3002</p> <p>\u5411\u8054\u5408\u7c7b\u578b\u6dfb\u52a0\u533a\u5206\u5668\u8fd8\u610f\u5473\u7740\u751f\u6210\u7684JSON\u6a21\u5f0f\u5b9e\u73b0\u4e86\u76f8\u5173\u7684OpenAPI\u89c4\u8303\u3002</p>"},{"location":"concepts/unions/#str","title":"\u4f7f\u7528 <code>str</code> \u533a\u5206\u5668\u7684\u533a\u5206\u8054\u5408\u7c7b\u578b","text":"<p>\u901a\u5e38\uff0c\u5728\u5177\u6709\u591a\u4e2a\u6a21\u578b\u7684 <code>Union</code> \u60c5\u51b5\u4e0b\uff0c \u8054\u5408\u7c7b\u578b\u7684\u6240\u6709\u6210\u5458\u90fd\u6709\u4e00\u4e2a\u5171\u540c\u7684\u5b57\u6bb5\uff0c\u53ef\u4ee5\u7528\u6765\u533a\u5206 \u6570\u636e\u5e94\u8be5\u9488\u5bf9\u54ea\u4e2a\u8054\u5408\u7c7b\u578b\u60c5\u51b5\u8fdb\u884c\u9a8c\u8bc1\uff1b\u8fd9\u5728 OpenAPI\u4e2d\u88ab\u79f0\u4e3a\"\u533a\u5206\u5668\"\u3002</p> <p>\u8981\u57fa\u4e8e\u8be5\u4fe1\u606f\u9a8c\u8bc1\u6a21\u578b\uff0c\u60a8\u53ef\u4ee5\u5728\u6bcf\u4e2a\u6a21\u578b\u4e2d\u8bbe\u7f6e\u76f8\u540c\u7684\u5b57\u6bb5 - \u6211\u4eec\u79f0\u4e4b\u4e3a <code>my_discriminator</code> - \u5e76\u4e3a\u5176\u8bbe\u7f6e\u4e00\u4e2a\u533a\u5206\u503c\uff0c\u8be5\u503c\u662f\u4e00\u4e2a\uff08\u6216\u591a\u4e2a\uff09<code>Literal</code> \u503c\u3002 \u5bf9\u4e8e\u60a8\u7684 <code>Union</code>\uff0c\u60a8\u53ef\u4ee5\u5728\u5176\u503c\u4e2d\u8bbe\u7f6e\u533a\u5206\u5668\uff1a<code>Field(discriminator='my_discriminator')</code>\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog, Lizard] = Field(discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#&gt; pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.dog.barks\n      Field required [type=missing, input_value={'pet_type': 'dog'}, input_type=dict]\n    \"\"\"\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog | Lizard = Field(discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#&gt; pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.dog.barks\n      Field required [type=missing, input_value={'pet_type': 'dog'}, input_type=dict]\n    \"\"\"\n</code></pre>"},{"location":"concepts/unions/#discriminated-unions","title":"\u4f7f\u7528\u53ef\u8c03\u7528 <code>Discriminator</code> \u7684\u533a\u5206\u8054\u5408\u7c7b\u578b","text":"API \u6587\u6863 <p><code>pydantic.types.Discriminator</code></p> <p>\u5728\u5177\u6709\u591a\u4e2a\u6a21\u578b\u7684 <code>Union</code> \u60c5\u51b5\u4e0b\uff0c\u6709\u65f6\u5728\u6240\u6709\u6a21\u578b\u4e2d\u6ca1\u6709\u7edf\u4e00\u7684\u5b57\u6bb5 \u53ef\u4ee5\u4f5c\u4e3a\u533a\u5206\u5668\u4f7f\u7528\u3002 \u8fd9\u662f\u53ef\u8c03\u7528 <code>Discriminator</code> \u7684\u5b8c\u7f8e\u7528\u4f8b\u3002</p> <p>Tip</p> <p>\u5f53\u60a8\u8bbe\u8ba1\u53ef\u8c03\u7528\u533a\u5206\u5668\u65f6\uff0c\u8bf7\u8bb0\u4f4f\u60a8\u53ef\u80fd\u9700\u8981\u540c\u65f6\u8003\u8651 <code>dict</code> \u548c\u6a21\u578b\u7c7b\u578b\u7684\u8f93\u5165\u3002\u8fd9\u79cd\u6a21\u5f0f\u7c7b\u4f3c\u4e8e <code>mode='before'</code> \u9a8c\u8bc1\u5668\uff0c \u60a8\u9700\u8981\u9884\u6d4b\u5404\u79cd\u5f62\u5f0f\u7684\u8f93\u5165\u3002</p> <p>\u4f46\u662f\u7b49\u7b49\uff01\u60a8\u53ef\u80fd\u4f1a\u95ee\uff0c\u6211\u53ea\u671f\u671b\u4f20\u5165 <code>dict</code> \u7c7b\u578b\uff0c\u4e3a\u4ec0\u4e48\u9700\u8981\u8003\u8651\u6a21\u578b\uff1f Pydantic\u4e5f\u4f7f\u7528\u53ef\u8c03\u7528\u533a\u5206\u5668\u8fdb\u884c\u5e8f\u5217\u5316\uff0c\u6b64\u65f6\u60a8\u7684\u53ef\u8c03\u7528\u51fd\u6570\u7684\u8f93\u5165 \u5f88\u53ef\u80fd\u662f\u6a21\u578b\u5b9e\u4f8b\u3002</p> <p>\u5728\u4ee5\u4e0b\u793a\u4f8b\u4e2d\uff0c\u60a8\u5c06\u770b\u5230\u53ef\u8c03\u7528\u533a\u5206\u5668\u88ab\u8bbe\u8ba1\u4e3a\u5904\u7406 <code>dict</code> \u548c\u6a21\u578b\u8f93\u5165\u3002 \u5982\u679c\u60a8\u4e0d\u9075\u5faa\u8fd9\u79cd\u505a\u6cd5\uff0c\u5f88\u53ef\u80fd\u5728\u6700\u597d\u7684\u60c5\u51b5\u4e0b\u4f1a\u5728\u5e8f\u5217\u5316\u671f\u95f4\u6536\u5230\u8b66\u544a\uff0c \u800c\u5728\u6700\u574f\u7684\u60c5\u51b5\u4e0b\u4f1a\u5728\u9a8c\u8bc1\u671f\u95f4\u51fa\u73b0\u8fd0\u884c\u65f6\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\n\ndef get_discriminator_value(v: Any) -&gt; str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n\"\"\"\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n\"\"\"\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n\"\"\"\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n\"\"\"\n</code></pre> <pre><code>from typing import Annotated, Any, Literal\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\n\ndef get_discriminator_value(v: Any) -&gt; str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        (\n            Annotated[ApplePie, Tag('apple')] |\n            Annotated[PumpkinPie, Tag('pumpkin')]\n        ),\n        Discriminator(get_discriminator_value),\n    ]\n\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n\"\"\"\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n\"\"\"\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n\"\"\"\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n\"\"\"\n</code></pre> <p><code>Discriminator</code> \u4e5f\u53ef\u4ee5\u7528\u4e8e\u9a8c\u8bc1\u5305\u542b\u6a21\u578b\u548c\u57fa\u672c\u7c7b\u578b\u7ec4\u5408\u7684 <code>Union</code> \u7c7b\u578b\u3002</p> <p>\u4f8b\u5982\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Annotated, Any, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\ndef model_x_discriminator(v: Any) -&gt; str:\n    if isinstance(v, int):\n        return 'int'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n    else:\n        # return None if the discriminator value isn't found\n        return None\n\n\nclass SpecialValue(BaseModel):\n    value: int\n\n\nclass DiscriminatedModel(BaseModel):\n    value: Annotated[\n        Union[\n            Annotated[int, Tag('int')],\n            Annotated['SpecialValue', Tag('model')],\n        ],\n        Discriminator(model_x_discriminator),\n    ]\n\n\nmodel_data = {'value': {'value': 1}}\nm = DiscriminatedModel.model_validate(model_data)\nprint(m)\n#&gt; value=SpecialValue(value=1)\n\nint_data = {'value': 123}\nm = DiscriminatedModel.model_validate(int_data)\nprint(m)\n#&gt; value=123\n\ntry:\n    DiscriminatedModel.model_validate({'value': 'not an int or a model'})\nexcept ValidationError as e:\n    print(e)  # (1)!\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    value\n      Unable to extract tag using discriminator model_x_discriminator() [type=union_tag_not_found, input_value='not an int or a model', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u672a\u627e\u5230\u533a\u5206\u5668\u503c\uff0c\u53ef\u8c03\u7528\u533a\u5206\u5668\u51fd\u6570\u8fd4\u56de <code>None</code>\u3002    \u5f53\u8fd4\u56de <code>None</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64 <code>union_tag_not_found</code> \u9519\u8bef\u3002</li> </ol> <pre><code>from typing import Annotated, Any\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\ndef model_x_discriminator(v: Any) -&gt; str:\n    if isinstance(v, int):\n        return 'int'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n    else:\n        # return None if the discriminator value isn't found\n        return None\n\n\nclass SpecialValue(BaseModel):\n    value: int\n\n\nclass DiscriminatedModel(BaseModel):\n    value: Annotated[\n        (\n            Annotated[int, Tag('int')] |\n            Annotated['SpecialValue', Tag('model')]\n        ),\n        Discriminator(model_x_discriminator),\n    ]\n\n\nmodel_data = {'value': {'value': 1}}\nm = DiscriminatedModel.model_validate(model_data)\nprint(m)\n#&gt; value=SpecialValue(value=1)\n\nint_data = {'value': 123}\nm = DiscriminatedModel.model_validate(int_data)\nprint(m)\n#&gt; value=123\n\ntry:\n    DiscriminatedModel.model_validate({'value': 'not an int or a model'})\nexcept ValidationError as e:\n    print(e)  # (1)!\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    value\n      Unable to extract tag using discriminator model_x_discriminator() [type=union_tag_not_found, input_value='not an int or a model', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li>\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u672a\u627e\u5230\u533a\u5206\u5668\u503c\uff0c\u53ef\u8c03\u7528\u533a\u5206\u5668\u51fd\u6570\u8fd4\u56de <code>None</code>\u3002    \u5f53\u8fd4\u56de <code>None</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64 <code>union_tag_not_found</code> \u9519\u8bef\u3002</li> </ol> <p>Note</p> <p>\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\u53ef\u4ee5\u65b9\u4fbf\u5730\u91cd\u65b0\u7ec4\u7ec7 <code>Union</code> \u548c <code>discriminator</code> \u4fe1\u606f\u3002\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u4e0b\u4e00\u4e2a\u793a\u4f8b\u3002</p> <p>\u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u4e3a\u5b57\u6bb5\u8bbe\u7f6e\u533a\u5206\u5668\uff0c\u8bed\u6cd5\u7565\u6709\u4e0d\u540c\u3002</p> <p>\u5bf9\u4e8e <code>str</code> \u533a\u5206\u5668\uff1a</p> <pre><code>some_field: Union[...] = Field(discriminator='my_discriminator')\nsome_field: Annotated[Union[...], Field(discriminator='my_discriminator')]\n</code></pre> <p>\u5bf9\u4e8e\u53ef\u8c03\u7528 <code>Discriminator</code>\uff1a</p> <pre><code>some_field: Union[...] = Field(discriminator=Discriminator(...))\nsome_field: Annotated[Union[...], Discriminator(...)]\nsome_field: Annotated[Union[...], Field(discriminator=Discriminator(...))]\n</code></pre> <p>Warning</p> <p>\u533a\u5206\u8054\u5408\u7c7b\u578b\u4e0d\u80fd\u4ec5\u4e0e\u5355\u4e2a\u53d8\u4f53\u4e00\u8d77\u4f7f\u7528\uff0c\u4f8b\u5982 <code>Union[Cat]</code>\u3002</p> <p>Python\u5728\u89e3\u91ca\u65f6\u5c06 <code>Union[T]</code> \u66f4\u6539\u4e3a <code>T</code>\uff0c\u56e0\u6b64 <code>pydantic</code> \u4e0d\u53ef\u80fd \u533a\u5206 <code>Union[T]</code> \u7684\u5b57\u6bb5\u4e0e <code>T</code> \u7684\u5b57\u6bb5\u3002</p>"},{"location":"concepts/unions/#_4","title":"\u5d4c\u5957\u533a\u5206\u8054\u5408\u7c7b\u578b","text":"<p>\u4e00\u4e2a\u5b57\u6bb5\u53ea\u80fd\u8bbe\u7f6e\u4e00\u4e2a\u533a\u5206\u5668\uff0c\u4f46\u6709\u65f6\u60a8\u60f3\u8981\u7ec4\u5408\u591a\u4e2a\u533a\u5206\u5668\u3002 \u60a8\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa\u5d4c\u5957\u7684 <code>Annotated</code> \u7c7b\u578b\u6765\u5b9e\u73b0\uff0c\u4f8b\u5982\uff1a</p> <pre><code>from typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\n#&gt; pet=BlackCat(pet_type='cat', color='black', black_name='felix') n=1\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat\n      Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white' [type=union_tag_invalid, input_value={'pet_type': 'cat', 'color': 'red'}, input_type=dict]\n    \"\"\"\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat.black.black_name\n      Field required [type=missing, input_value={'pet_type': 'cat', 'color': 'black'}, input_type=dict]\n    \"\"\"\n</code></pre> <p>Tip</p> <p>\u5982\u679c\u60a8\u60f3\u9488\u5bf9\u8054\u5408\u7c7b\u578b\u9a8c\u8bc1\u6570\u636e\uff0c\u5e76\u4e14\u4ec5\u9488\u5bf9\u8054\u5408\u7c7b\u578b\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528pydantic\u7684<code>TypeAdapter</code>\u6784\u9020\uff0c\u800c\u4e0d\u662f\u7ee7\u627f\u6807\u51c6\u7684 <code>BaseModel</code>\u3002</p> <p>\u5728\u524d\u4e00\u4e2a\u793a\u4f8b\u7684\u4e0a\u4e0b\u6587\u4e2d\uff0c\u6211\u4eec\u6709\uff1a</p> <pre><code>type_adapter = TypeAdapter(Pet)\n\npet = type_adapter.validate_python(\n    {'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}\n)\nprint(repr(pet))\n#&gt; BlackCat(pet_type='cat', color='black', black_name='felix')\n</code></pre>"},{"location":"concepts/unions/#_5","title":"\u8054\u5408\u7c7b\u578b\u9a8c\u8bc1\u9519\u8bef","text":"<p>\u5f53 <code>Union</code> \u9a8c\u8bc1\u5931\u8d25\u65f6\uff0c\u9519\u8bef\u6d88\u606f\u53ef\u80fd\u975e\u5e38\u5197\u957f\uff0c\u56e0\u4e3a\u5b83\u4eec\u4f1a\u4e3a \u8054\u5408\u7c7b\u578b\u4e2d\u7684\u6bcf\u79cd\u60c5\u51b5\u4ea7\u751f\u9a8c\u8bc1\u9519\u8bef\u3002 \u5728\u5904\u7406\u9012\u5f52\u6a21\u578b\u65f6\u5c24\u5176\u660e\u663e\uff0c\u5176\u4e2d\u9519\u8bef\u539f\u56e0\u53ef\u80fd\u5728\u6bcf\u4e2a\u9012\u5f52\u7ea7\u522b\u751f\u6210\u3002 \u533a\u5206\u8054\u5408\u7c7b\u578b\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\u6709\u52a9\u4e8e\u7b80\u5316\u9519\u8bef\u6d88\u606f\uff0c\u56e0\u4e3a\u9a8c\u8bc1\u9519\u8bef\u4ec5\u9488\u5bf9 \u5177\u6709\u5339\u914d\u533a\u5206\u5668\u503c\u7684\u60c5\u51b5\u4ea7\u751f\u3002</p> <p>\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5c06\u8fd9\u4e9b\u89c4\u8303\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9 <code>Discriminator</code> \u6784\u9020\u51fd\u6570\u6765\u81ea\u5b9a\u4e49 <code>Discriminator</code> \u7684\u9519\u8bef\u7c7b\u578b\u3001\u6d88\u606f\u548c\u4e0a\u4e0b\u6587\uff0c\u5982\u4e0b\u4f8b\u6240\u793a\u3002</p> <pre><code>from typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\n# Errors are quite verbose with a normal Union:\nclass Model(BaseModel):\n    x: Union[str, 'Model']\n\n\ntry:\n    Model.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': 1}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': 1}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    x.Model.x.Model.x.Model\n      Input should be a valid dictionary or instance of Model [type=model_type, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    Model.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': {}}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': {}}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={}, input_type=dict]\n    x.Model.x.Model.x.Model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"\n\n\n# Errors are much simpler with a discriminated union:\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\nclass DiscriminatedModel(BaseModel):\n    x: Annotated[\n        Union[\n            Annotated[str, Tag('str')],\n            Annotated['DiscriminatedModel', Tag('model')],\n        ],\n        Discriminator(\n            model_x_discriminator,\n            custom_error_type='invalid_union_member',  # (1)!\n            custom_error_message='Invalid union member',  # (2)!\n            custom_error_context={'discriminator': 'str_or_model'},  # (3)!\n        ),\n    ]\n\n\ntry:\n    DiscriminatedModel.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    x.model.x.model.x\n      Invalid union member [type=invalid_union_member, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    DiscriminatedModel.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    x.model.x.model.x.model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"\n\n# The data is still handled properly when valid:\ndata = {'x': {'x': {'x': 'a'}}}\nm = DiscriminatedModel.model_validate(data)\nprint(m.model_dump())\n#&gt; {'x': {'x': {'x': 'a'}}}\n</code></pre> <ol> <li><code>custom_error_type</code> \u662f\u9a8c\u8bc1\u5931\u8d25\u65f6\u5f15\u53d1\u7684 <code>ValidationError</code> \u7684 <code>type</code> \u5c5e\u6027\u3002</li> <li><code>custom_error_message</code> \u662f\u9a8c\u8bc1\u5931\u8d25\u65f6\u5f15\u53d1\u7684 <code>ValidationError</code> \u7684 <code>msg</code> \u5c5e\u6027\u3002</li> <li><code>custom_error_context</code> \u662f\u9a8c\u8bc1\u5931\u8d25\u65f6\u5f15\u53d1\u7684 <code>ValidationError</code> \u7684 <code>ctx</code> \u5c5e\u6027\u3002</li> </ol> <p>\u60a8\u8fd8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>Tag</code> \u6807\u8bb0\u6bcf\u79cd\u60c5\u51b5\u6765\u7b80\u5316\u9519\u8bef\u6d88\u606f\u3002 \u5f53\u60a8\u6709\u50cf\u6b64\u793a\u4f8b\u4e2d\u7684\u590d\u6742\u7c7b\u578b\u65f6\uff0c\u8fd9\u5c24\u5176\u6709\u7528\uff1a</p> <pre><code>from typing import Annotated, Union\n\nfrom pydantic import AfterValidator, Tag, TypeAdapter, ValidationError\n\nDoubledList = Annotated[list[int], AfterValidator(lambda x: x * 2)]\nStringsMap = dict[str, str]\n\n\n# \u5982\u679c\u4e0d\u4e3a\u6bcf\u4e2a\u8054\u5408\u7c7b\u578b\u60c5\u51b5\u4f7f\u7528 `Tag`\uff0c\u9519\u8bef\u4fe1\u606f\u770b\u8d77\u6765\u5c31\u4e0d\u90a3\u4e48\u7f8e\u89c2\nadapter = TypeAdapter(Union[DoubledList, StringsMap])\n\ntry:\n    adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    2 validation errors for union[function-after[&lt;lambda&gt;(), list[int]],dict[str,str]]\n    function-after[&lt;lambda&gt;(), list[int]].0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    dict[str,str]\n      Input should be a valid dictionary [type=dict_type, input_value=['a'], input_type=list]\n    \"\"\"\n\ntag_adapter = TypeAdapter(\n    Union[\n        Annotated[DoubledList, Tag('DoubledList')],\n        Annotated[StringsMap, Tag('StringsMap')],\n    ]\n)\n\ntry:\n    tag_adapter.validate_python(['a'])\nexcept ValidationError as exc_info:\n    print(exc_info)\n    \"\"\"\n    2 validation errors for union[DoubledList,StringsMap]\n    DoubledList.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    StringsMap\n      Input should be a valid dictionary [type=dict_type, input_value=['a'], input_type=list]\n    \"\"\"\n</code></pre>"},{"location":"concepts/validation_decorator/","title":"Validation Decorator","text":"API \u6587\u6863 <p><code>pydantic.validate_call_decorator.validate_call</code></p> <p><code>validate_call()</code> \u88c5\u9970\u5668\u5141\u8bb8\u5728\u51fd\u6570\u88ab\u8c03\u7528\u4e4b\u524d\uff0c\u4f7f\u7528\u51fd\u6570\u7684\u6ce8\u89e3\u6765\u89e3\u6790\u548c\u9a8c\u8bc1\u4f20\u9012\u7ed9\u51fd\u6570\u7684\u53c2\u6570\u3002</p> <p>\u867d\u7136\u5728\u5e95\u5c42\u8fd9\u4f7f\u7528\u4e86\u4e0e\u6a21\u578b\u521b\u5efa\u548c\u521d\u59cb\u5316\u76f8\u540c\u7684\u65b9\u6cd5\uff08\u8be6\u89c1\u9a8c\u8bc1\u5668\uff09\uff0c\u4f46\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u6781\u5176\u7b80\u5355\u7684\u65b9\u5f0f\u6765\u4e3a\u4f60\u7684\u4ee3\u7801\u5e94\u7528\u9a8c\u8bc1\uff0c\u4e14\u6837\u677f\u4ee3\u7801\u6700\u5c11\u3002</p> <p>\u4f7f\u7528\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -&gt; bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#&gt; b'hellohellohello'\n\nb = repeat('x', '4', separator=b' ')\nprint(b)\n#&gt; b'x x x x'\n\ntry:\n    c = repeat('hello', 'wrong')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for repeat\n    1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n</code></pre>"},{"location":"concepts/validation_decorator/#_1","title":"\u53c2\u6570\u7c7b\u578b","text":"<p>\u53c2\u6570\u7c7b\u578b\u662f\u4ece\u51fd\u6570\u7684\u7c7b\u578b\u6ce8\u89e3\u4e2d\u63a8\u65ad\u51fa\u6765\u7684\uff0c\u5982\u679c\u6ca1\u6709\u6ce8\u89e3\uff0c\u5219\u63a8\u65ad\u4e3a <code>Any</code>\u3002\u7c7b\u578b\u4e2d\u5217\u51fa\u7684\u6240\u6709\u7c7b\u578b\u90fd\u53ef\u4ee5\u88ab\u9a8c\u8bc1\uff0c\u5305\u62ec Pydantic \u6a21\u578b\u548c\u81ea\u5b9a\u4e49\u7c7b\u578b\u3002 \u4e0e Pydantic \u7684\u5176\u4ed6\u90e8\u5206\u4e00\u6837\uff0c\u7c7b\u578b\u5728\u4f20\u9012\u7ed9\u5b9e\u9645\u51fd\u6570\u4e4b\u524d\u9ed8\u8ba4\u4f1a\u88ab\u88c5\u9970\u5668\u5f3a\u5236\u8f6c\u6362\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import validate_call\n\n\n@validate_call\ndef greater_than(d1: date, d2: date, *, include_equal=False) -&gt; date:  # (1)!\n    if include_equal:\n        return d1 &gt;= d2\n    else:\n        return d1 &gt; d2\n\n\nd1 = '2000-01-01'  # (2)!\nd2 = date(2001, 1, 1)\ngreater_than(d1, d2, include_equal=True)\n</code></pre> <ol> <li>\u56e0\u4e3a <code>include_equal</code> \u6ca1\u6709\u7c7b\u578b\u6ce8\u89e3\uff0c\u5b83\u5c06\u88ab\u63a8\u65ad\u4e3a <code>Any</code>\u3002</li> <li>\u867d\u7136 <code>d1</code> \u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\uff0c\u4f46\u5b83\u5c06\u88ab\u8f6c\u6362\u4e3a <code>date</code> \u5bf9\u8c61\u3002</li> </ol> <p>\u50cf\u8fd9\u6837\u7684\u7c7b\u578b\u5f3a\u5236\u8f6c\u6362\u53ef\u80fd\u975e\u5e38\u6709\u5e2e\u52a9\uff0c\u4f46\u4e5f\u53ef\u80fd\u4ee4\u4eba\u56f0\u60d1\u6216\u4e0d\u5e0c\u671b\u53d1\u751f\uff08\u53c2\u89c1\u6a21\u578b\u6570\u636e\u8f6c\u6362\uff09\u3002\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u81ea\u5b9a\u4e49\u914d\u7f6e\u6765\u542f\u7528\u4e25\u683c\u6a21\u5f0f\u3002</p> <p>\u9a8c\u8bc1\u8fd4\u56de\u503c</p> <p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u51fd\u6570\u7684\u8fd4\u56de\u503c\u4e0d\u4f1a\u88ab\u9a8c\u8bc1\u3002\u8981\u9a8c\u8bc1\u8fd4\u56de\u503c\uff0c\u53ef\u4ee5\u5c06\u88c5\u9970\u5668\u7684 <code>validate_return</code> \u53c2\u6570\u8bbe\u7f6e\u4e3a <code>True</code>\u3002</p>"},{"location":"concepts/validation_decorator/#_2","title":"\u51fd\u6570\u7b7e\u540d","text":"<p><code>validate_call()</code> \u88c5\u9970\u5668\u8bbe\u8ba1\u7528\u4e8e\u5904\u7406\u4f7f\u7528\u6240\u6709\u53ef\u80fd\u7684\u53c2\u6570\u914d\u7f6e\u53ca\u5176\u6240\u6709\u7ec4\u5408\u7684\u51fd\u6570\uff1a</p> <ul> <li>\u5e26\u6216\u4e0d\u5e26\u9ed8\u8ba4\u503c\u7684\u4f4d\u7f6e\u53c2\u6570\u6216\u5173\u952e\u5b57\u53c2\u6570</li> <li>\u4ec5\u5173\u952e\u5b57\u53c2\u6570\uff1a<code>*,</code> \u4e4b\u540e\u7684\u53c2\u6570</li> <li>\u4ec5\u4f4d\u7f6e\u53c2\u6570\uff1a<code>, /</code> \u4e4b\u524d\u7684\u53c2\u6570</li> <li>\u901a\u8fc7 <code>*</code> \u5b9a\u4e49\u7684\u53d8\u91cf\u4f4d\u7f6e\u53c2\u6570\uff08\u901a\u5e38\u662f <code>*args</code>\uff09</li> <li>\u901a\u8fc7 <code>**</code> \u5b9a\u4e49\u7684\u53d8\u91cf\u5173\u952e\u5b57\u53c2\u6570\uff08\u901a\u5e38\u662f <code>**kwargs</code>\uff09</li> </ul> Example <pre><code>from pydantic import validate_call\n\n\n@validate_call\ndef pos_or_kw(a: int, b: int = 2) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(pos_or_kw(1, b=3))\n#&gt; a=1 b=3\n\n\n@validate_call\ndef kw_only(*, a: int, b: int = 2) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(kw_only(a=1))\n#&gt; a=1 b=2\nprint(kw_only(a=1, b=3))\n#&gt; a=1 b=3\n\n\n@validate_call\ndef pos_only(a: int, b: int = 2, /) -&gt; str:\n    return f'a={a} b={b}'\n\n\nprint(pos_only(1))\n#&gt; a=1 b=2\n\n\n@validate_call\ndef var_args(*args: int) -&gt; str:\n    return str(args)\n\n\nprint(var_args(1))\n#&gt; (1,)\nprint(var_args(1, 2, 3))\n#&gt; (1, 2, 3)\n\n\n@validate_call\ndef var_kwargs(**kwargs: int) -&gt; str:\n    return str(kwargs)\n\n\nprint(var_kwargs(a=1))\n#&gt; {'a': 1}\nprint(var_kwargs(a=1, b=2))\n#&gt; {'a': 1, 'b': 2}\n\n\n@validate_call\ndef armageddon(\n    a: int,\n    /,\n    b: int,\n    *c: int,\n    d: int,\n    e: int = None,\n    **f: int,\n) -&gt; str:\n    return f'a={a} b={b} c={c} d={d} e={e} f={f}'\n\n\nprint(armageddon(1, 2, d=3))\n#&gt; a=1 b=2 c=() d=3 e=None f={}\nprint(armageddon(1, 2, 3, 4, 5, 6, d=8, e=9, f=10, spam=11))\n#&gt; a=1 b=2 c=(3, 4, 5, 6) d=8 e=9 f={'f': 10, 'spam': 11}\n</code></pre> <p>\u5173\u952e\u5b57\u53c2\u6570\u7684 <code>Unpack</code></p> <p><code>Unpack</code> \u548c\u7c7b\u578b\u5316\u5b57\u5178\u53ef\u7528\u4e8e\u6ce8\u89e3\u51fd\u6570\u7684\u53d8\u91cf\u5173\u952e\u5b57\u53c2\u6570\uff1a</p> <pre><code>from typing_extensions import TypedDict, Unpack\n\nfrom pydantic import validate_call\n\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\n\n@validate_call\ndef add_coords(**kwargs: Unpack[Point]) -&gt; int:\n    return kwargs['x'] + kwargs['y']\n\n\nadd_coords(x=1, y=2)\n</code></pre> <p>\u6709\u5173\u53c2\u8003\uff0c\u8bf7\u53c2\u9605\u76f8\u5173\u89c4\u8303\u90e8\u5206\u548c PEP 692\u3002</p>"},{"location":"concepts/validation_decorator/#field","title":"\u4f7f\u7528 <code>Field()</code> \u51fd\u6570\u63cf\u8ff0\u51fd\u6570\u53c2\u6570","text":"<p><code>Field()</code> \u51fd\u6570\u4e5f\u53ef\u4ee5\u4e0e\u88c5\u9970\u5668\u4e00\u8d77\u4f7f\u7528\uff0c\u4ee5\u63d0\u4f9b\u6709\u5173\u5b57\u6bb5\u548c\u9a8c\u8bc1\u7684\u989d\u5916\u4fe1\u606f\u3002\u5982\u679c\u4f60\u4e0d\u4f7f\u7528 <code>default</code> \u6216 <code>default_factory</code> \u53c2\u6570\uff0c\u5efa\u8bae\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\uff08\u4ee5\u4fbf\u7c7b\u578b\u68c0\u67e5\u5668\u63a8\u65ad\u53c2\u6570\u662f\u5fc5\u9700\u7684\uff09\u3002\u5426\u5219\uff0c<code>Field()</code> \u51fd\u6570\u53ef\u4ee5\u7528\u4f5c\u9ed8\u8ba4\u503c\uff08\u518d\u6b21\uff0c\u4ee5\u6b3a\u9a97\u7c7b\u578b\u68c0\u67e5\u5668\u8ba4\u4e3a\u4e3a\u8be5\u53c2\u6570\u63d0\u4f9b\u4e86\u9ed8\u8ba4\u503c\uff09\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field, ValidationError, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10)]):\n    return num\n\n\ntry:\n    how_many(1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for how_many\n    0\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    \"\"\"\n\n\n@validate_call\ndef return_value(value: str = Field(default='default value')):\n    return value\n\n\nprint(return_value())\n#&gt; default value\n</code></pre> <p>\u522b\u540d\u53ef\u4ee5\u6b63\u5e38\u4e0e\u88c5\u9970\u5668\u4e00\u8d77\u4f7f\u7528\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import Field, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10, alias='number')]):\n    return num\n\n\nhow_many(number=42)\n</code></pre>"},{"location":"concepts/validation_decorator/#accessing-the-original-function","title":"\u8bbf\u95ee\u539f\u59cb\u51fd\u6570","text":"<p>\u88ab\u88c5\u9970\u7684\u539f\u59cb\u51fd\u6570\u4ecd\u7136\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>raw_function</code> \u5c5e\u6027\u6765\u8bbf\u95ee\u3002 \u8fd9\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u5f88\u6709\u7528\uff0c\u5982\u679c\u4f60\u4fe1\u4efb\u8f93\u5165\u53c2\u6570\u5e76\u5e0c\u671b\u4ee5\u6700\u6709\u6548\u7684\u65b9\u5f0f\u8c03\u7528\u51fd\u6570\uff08\u53c2\u89c1\u4e0b\u9762\u7684\u6027\u80fd\u8bf4\u660e\uff09\uff1a</p> <pre><code>from pydantic import validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -&gt; bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#&gt; b'hellohellohello'\n\nb = repeat.raw_function('good bye', 2, separator=b', ')\nprint(b)\n#&gt; b'good bye, good bye'\n</code></pre>"},{"location":"concepts/validation_decorator/#_3","title":"\u5f02\u6b65\u51fd\u6570","text":"<p><code>validate_call()</code> \u4e5f\u53ef\u4ee5\u7528\u4e8e\u5f02\u6b65\u51fd\u6570\uff1a</p> <pre><code>class Connection:\n    async def execute(self, sql, *args):\n        return 'testing@example.com'\n\n\nconn = Connection()\n# ignore-above\nimport asyncio\n\nfrom pydantic import PositiveInt, ValidationError, validate_call\n\n\n@validate_call\nasync def get_user_email(user_id: PositiveInt):\n    # `conn` is some fictional connection to a database\n    email = await conn.execute('select email from users where id=$1', user_id)\n    if email is None:\n        raise RuntimeError('user not found')\n    else:\n        return email\n\n\nasync def main():\n    email = await get_user_email(123)\n    print(email)\n    #&gt; testing@example.com\n    try:\n        await get_user_email(-4)\n    except ValidationError as exc:\n        print(exc.errors())\n        \"\"\"\n        [\n            {\n                'type': 'greater_than',\n                'loc': (0,),\n                'msg': 'Input should be greater than 0',\n                'input': -4,\n                'ctx': {'gt': 0},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        \"\"\"\n\n\nasyncio.run(main())\n# requires: `conn.execute()` that will return `'testing@example.com'`\n</code></pre>"},{"location":"concepts/validation_decorator/#_4","title":"\u4e0e\u7c7b\u578b\u68c0\u67e5\u5668\u7684\u517c\u5bb9\u6027","text":"<p>\u7531\u4e8e <code>validate_call()</code> \u88c5\u9970\u5668\u4fdd\u7559\u4e86\u88ab\u88c5\u9970\u51fd\u6570\u7684\u7b7e\u540d\uff0c\u5b83\u5e94\u8be5\u4e0e\u7c7b\u578b\u68c0\u67e5\u5668\uff08\u5982 mypy \u548c pyright\uff09\u517c\u5bb9\u3002\u7136\u800c\uff0c\u7531\u4e8e\u5f53\u524d Python \u7c7b\u578b\u7cfb\u7edf\u7684\u9650\u5236\uff0c<code>raw_function</code> \u6216\u5176\u4ed6\u5c5e\u6027\u5c06\u4e0d\u4f1a\u88ab\u8bc6\u522b\uff0c\u4f60\u9700\u8981\u4f7f\u7528\uff08\u901a\u5e38\u4f7f\u7528 <code># type: ignore</code> \u6ce8\u91ca\uff09\u6765\u6291\u5236\u9519\u8bef\u3002</p>"},{"location":"concepts/validation_decorator/#custom-configuration","title":"\u81ea\u5b9a\u4e49\u914d\u7f6e","text":"<p>\u4e0e Pydantic \u6a21\u578b\u7c7b\u4f3c\uff0c\u88c5\u9970\u5668\u7684 <code>config</code> \u53c2\u6570\u53ef\u7528\u4e8e\u6307\u5b9a\u81ea\u5b9a\u4e49\u914d\u7f6e\uff1a</p> <pre><code>from pydantic import ConfigDict, ValidationError, validate_call\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -&gt; str:\n        return f'{self} + {other}'\n\n    def __str__(self) -&gt; str:\n        return f'Foobar({self.v})'\n\n\n@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n#&gt; Foobar(a) + Foobar(b)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for add_foobars\n    0\n      Input should be an instance of Foobar [type=is_instance_of, input_value=1, input_type=int]\n    1\n      Input should be an instance of Foobar [type=is_instance_of, input_value=2, input_type=int]\n    \"\"\"\n</code></pre>"},{"location":"concepts/validation_decorator/#_5","title":"\u6269\u5c55 \u2014 \u5728\u8c03\u7528\u51fd\u6570\u4e4b\u524d\u9a8c\u8bc1\u53c2\u6570","text":"<p>\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u5c06\u51fd\u6570\u53c2\u6570\u7684\u9a8c\u8bc1\u4e0e\u51fd\u6570\u8c03\u7528\u672c\u8eab\u5206\u5f00\u53ef\u80fd\u4f1a\u5f88\u6709\u5e2e\u52a9\u3002 \u5f53\u7279\u5b9a\u51fd\u6570\u6210\u672c\u9ad8/\u8017\u65f6\u8f83\u957f\u65f6\uff0c\u8fd9\u53ef\u80fd\u5f88\u6709\u7528\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u4f60\u53ef\u4ee5\u7528\u4e8e\u8be5\u6a21\u5f0f\u7684\u53d8\u901a\u65b9\u6cd5\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import validate_call\n\n\n@validate_call\ndef validate_foo(a: int, b: int):\n    def foo():\n        return a + b\n\n    return foo\n\n\nfoo = validate_foo(a=1, b=2)\nprint(foo())\n#&gt; 3\n</code></pre>"},{"location":"concepts/validation_decorator/#_6","title":"\u9650\u5236","text":""},{"location":"concepts/validation_decorator/#_7","title":"\u9a8c\u8bc1\u5f02\u5e38","text":"<p>\u76ee\u524d\uff0c\u5728\u9a8c\u8bc1\u5931\u8d25\u65f6\uff0c\u4f1a\u5f15\u53d1\u6807\u51c6\u7684 Pydantic <code>ValidationError</code> \uff08\u8be6\u89c1\u6a21\u578b\u9519\u8bef\u5904\u7406\uff09\u3002\u5bf9\u4e8e\u7f3a\u5c11\u5fc5\u9700\u53c2\u6570\u7684\u60c5\u51b5\u4e5f\u662f\u5982\u6b64\uff0c \u800c Python \u901a\u5e38\u4f1a\u5f15\u53d1 <code>TypeError</code>\u3002</p>"},{"location":"concepts/validation_decorator/#performance","title":"\u6027\u80fd","text":"<p>\u6211\u4eec\u5df2\u7ecf\u4ed8\u51fa\u4e86\u5de8\u5927\u52aa\u529b\uff0c\u4f7f Pydantic \u5c3d\u53ef\u80fd\u9ad8\u6027\u80fd\u3002\u867d\u7136\u5bf9\u88ab\u88c5\u9970\u51fd\u6570\u7684\u68c0\u67e5\u53ea\u6267\u884c\u4e00\u6b21\uff0c \u4f46\u4e0e\u4f7f\u7528\u539f\u59cb\u51fd\u6570\u76f8\u6bd4\uff0c\u8c03\u7528\u51fd\u6570\u65f6\u4ecd\u7136\u4f1a\u6709\u6027\u80fd\u5f71\u54cd\u3002</p> <p>\u5728\u8bb8\u591a\u60c5\u51b5\u4e0b\uff0c\u8fd9\u51e0\u4e4e\u6ca1\u6709\u6216\u6ca1\u6709\u660e\u663e\u7684\u5f71\u54cd\u3002\u4f46\u662f\uff0c\u8bf7\u6ce8\u610f <code>validate_call()</code> \u5e76\u4e0d\u662f\u5f3a\u7c7b\u578b\u8bed\u8a00\u4e2d\u51fd\u6570\u5b9a\u4e49\u7684\u7b49\u4ef7\u7269\u6216\u66ff\u4ee3\u54c1\uff0c \u800c\u4e14\u6c38\u8fdc\u4e0d\u4f1a\u662f\u3002</p>"},{"location":"concepts/validators/","title":"Validators","text":"<p>\u9664\u4e86 Pydantic \u7684\u5185\u7f6e\u9a8c\u8bc1\u529f\u80fd\u4e4b\u5916\uff0c\u60a8\u8fd8\u53ef\u4ee5\u5229\u7528\u5b57\u6bb5\u7ea7\u522b\u548c\u6a21\u578b\u7ea7\u522b\u7684\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u6765\u5f3a\u5236\u6267\u884c\u66f4\u590d\u6742\u7684\u7ea6\u675f\u5e76\u786e\u4fdd\u6570\u636e\u7684\u5b8c\u6574\u6027\u3002</p> <p>Tip</p> <p>\u60f3\u8981\u5feb\u901f\u8df3\u8f6c\u5230\u76f8\u5173\u7684\u9a8c\u8bc1\u5668\u90e8\u5206\uff1f</p> <ul> <li> <p>\u5b57\u6bb5\u9a8c\u8bc1\u5668</p> <ul> <li>\u5b57\u6bb5 after \u9a8c\u8bc1\u5668</li> <li>\u5b57\u6bb5 before \u9a8c\u8bc1\u5668</li> <li>\u5b57\u6bb5 plain \u9a8c\u8bc1\u5668</li> <li>\u5b57\u6bb5 wrap \u9a8c\u8bc1\u5668</li> </ul> </li> <li> <p>\u6a21\u578b\u9a8c\u8bc1\u5668</p> <ul> <li>\u6a21\u578b before \u9a8c\u8bc1\u5668</li> <li>\u6a21\u578b after \u9a8c\u8bc1\u5668</li> <li>\u6a21\u578b wrap \u9a8c\u8bc1\u5668</li> </ul> </li> </ul>"},{"location":"concepts/validators/#field-validators","title":"\u5b57\u6bb5\u9a8c\u8bc1\u5668","text":"API \u6587\u6863 <p><code>pydantic.functional_validators.WrapValidator</code> <code>pydantic.functional_validators.PlainValidator</code> <code>pydantic.functional_validators.BeforeValidator</code> <code>pydantic.functional_validators.AfterValidator</code> <code>pydantic.functional_validators.field_validator</code></p> <p>\u5728\u6700\u7b80\u5355\u7684\u5f62\u5f0f\u4e2d\uff0c\u5b57\u6bb5\u9a8c\u8bc1\u5668\u662f\u4e00\u4e2a\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u5b83\u63a5\u6536\u8981\u9a8c\u8bc1\u7684\u503c\u4f5c\u4e3a\u53c2\u6570\u5e76\u8fd4\u56de\u9a8c\u8bc1\u540e\u7684\u503c\u3002\u8be5\u53ef\u8c03\u7528\u5bf9\u8c61\u53ef\u4ee5\u6267\u884c\u7279\u5b9a\u6761\u4ef6\u7684\u68c0\u67e5\uff08\u53c2\u89c1\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\uff09\u5e76\u5bf9\u9a8c\u8bc1\u540e\u7684\u503c\u8fdb\u884c\u66f4\u6539\uff08\u5f3a\u5236\u8f6c\u6362\u6216\u4fee\u6539\uff09\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528\u56db\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u9a8c\u8bc1\u5668\u3002\u5b83\u4eec\u90fd\u53ef\u4ee5\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\u6216\u4f7f\u7528 <code>field_validator()</code> \u88c5\u9970\u5668\u6765\u5b9a\u4e49\uff0c\u5e94\u7528\u4e8e\u7c7b\u65b9\u6cd5\uff1a</p> <ul> <li> <p>After \u9a8c\u8bc1\u5668\uff1a\u5728Pydantic\u7684\u5185\u90e8\u9a8c\u8bc1\u4e4b\u540e\u8fd0\u884c\u3002\u5b83\u4eec\u901a\u5e38\u66f4\u7c7b\u578b\u5b89\u5168\uff0c\u56e0\u6b64\u66f4\u5bb9\u6613\u5b9e\u73b0\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668\u6a21\u5f0f <p>\u8fd9\u662f\u4e00\u4e2a\u6267\u884c\u9a8c\u8bc1\u68c0\u67e5\u5e76\u8fd4\u56de\u672a\u66f4\u6539\u503c\u7684\u9a8c\u8bc1\u5668\u793a\u4f8b\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationError\n\n\ndef is_even(value: int) -&gt; int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value  # (1)!\n\n\nclass Model(BaseModel):\n    number: Annotated[int, AfterValidator(is_even)]\n\n\ntry:\n    Model(number=1)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    number\n      Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n    \"\"\"\n</code></pre> <ol> <li>\u6ce8\u610f\u8fd4\u56de\u9a8c\u8bc1\u540e\u7684\u503c\u5f88\u91cd\u8981\u3002</li> </ol> <p>\u8fd9\u662f\u4e00\u4e2a\u6267\u884c\u9a8c\u8bc1\u68c0\u67e5\u5e76\u8fd4\u56de\u672a\u66f4\u6539\u503c\u7684\u9a8c\u8bc1\u5668\u793a\u4f8b\uff0c \u8fd9\u6b21\u4f7f\u7528 <code>field_validator()</code> \u88c5\u9970\u5668\u3002</p> <pre><code>from pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_validator('number', mode='after')  # (1)!\n    @classmethod\n    def is_even(cls, value: int) -&gt; int:\n        if value % 2 == 1:\n            raise ValueError(f'{value} is not an even number')\n        return value  # (2)!\n\n\ntry:\n    Model(number=1)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    number\n      Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n    \"\"\"\n</code></pre> <ol> <li><code>'after'</code> \u662f\u88c5\u9970\u5668\u7684\u9ed8\u8ba4\u6a21\u5f0f\uff0c\u53ef\u4ee5\u7701\u7565\u3002</li> <li>\u6ce8\u610f\u8fd4\u56de\u9a8c\u8bc1\u540e\u7684\u503c\u5f88\u91cd\u8981\u3002</li> </ol> \u4fee\u6539\u503c\u7684\u793a\u4f8b <p>\u8fd9\u662f\u4e00\u4e2a\u5bf9\u9a8c\u8bc1\u540e\u7684\u503c\u8fdb\u884c\u66f4\u6539\u7684\u9a8c\u8bc1\u5668\u793a\u4f8b\uff08\u4e0d\u5f15\u53d1\u5f02\u5e38\uff09\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668\u6a21\u5f0f <pre><code>from typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef double_number(value: int) -&gt; int:\n    return value * 2\n\n\nclass Model(BaseModel):\n    number: Annotated[int, AfterValidator(double_number)]\n\n\nprint(Model(number=2))\n#&gt; number=4\n</code></pre> <pre><code>from pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_validator('number', mode='after')  # (1)!\n    @classmethod\n    def double_number(cls, value: int) -&gt; int:\n        return value * 2\n\n\nprint(Model(number=2))\n#&gt; number=4\n</code></pre> <ol> <li><code>'after'</code>\u662f\u88c5\u9970\u5668\u7684\u9ed8\u8ba4\u6a21\u5f0f\uff0c\u53ef\u4ee5\u7701\u7565\u3002</li> </ol> </li> <li> <p>Before \u9a8c\u8bc1\u5668\uff1a\u5728 Pydantic \u7684\u5185\u90e8\u89e3\u6790\u548c\u9a8c\u8bc1\u4e4b\u524d\u8fd0\u884c\uff08\u4f8b\u5982\uff0c\u5c06 <code>str</code> \u5f3a\u5236\u8f6c\u6362\u4e3a <code>int</code>\uff09\u3002   \u8fd9\u4e9b\u6bd4 after \u9a8c\u8bc1\u5668\u66f4\u7075\u6d3b\uff0c\u4f46\u5b83\u4eec\u4e5f\u5fc5\u987b\u5904\u7406\u539f\u59cb\u8f93\u5165\uff0c   \u7406\u8bba\u4e0a\u53ef\u4ee5\u662f\u4efb\u4f55\u4efb\u610f\u5bf9\u8c61\u3002\u5982\u679c\u60a8\u7a0d\u540e\u5728\u9a8c\u8bc1\u5668\u51fd\u6570\u4e2d\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\uff0c   \u8fd8\u5e94\u907f\u514d\u76f4\u63a5\u4fee\u6539\u503c\uff0c\u56e0\u4e3a\u5982\u679c\u4f7f\u7528\u8054\u5408\u7c7b\u578b\uff0c\u4fee\u6539\u540e\u7684\u503c\u53ef\u80fd\u4f1a\u4f20\u9012\u7ed9\u5176\u4ed6\u9a8c\u8bc1\u5668\u3002</p> <p>\u7136\u540e\uff0cPydantic \u4f1a\u6839\u636e\u63d0\u4f9b\u7684\u7c7b\u578b\u6ce8\u89e3\u9a8c\u8bc1\u4ece\u6b64\u53ef\u8c03\u7528\u5bf9\u8c61\u8fd4\u56de\u7684\u503c\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668\u6a21\u5f0f <pre><code>from typing import Annotated, Any\n\nfrom pydantic import BaseModel, BeforeValidator, ValidationError\n\n\ndef ensure_list(value: Any) -&gt; Any:  # (1)!\n    if not isinstance(value, list):  # (2)!\n        return [value]\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    numbers: Annotated[list[int], BeforeValidator(ensure_list)]\n\n\nprint(Model(numbers=2))\n#&gt; numbers=[2]\ntry:\n    Model(numbers='str')\nexcept ValidationError as err:\n    print(err)  # (3)!\n    \"\"\"\n    1 validation error for Model\n    numbers.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li> <p>\u6ce8\u610f\u4f7f\u7528 <code>Any</code> \u4f5c\u4e3a <code>value</code> \u7684\u7c7b\u578b\u63d0\u793a\u3002Before \u9a8c\u8bc1\u5668\u63a5\u6536\u539f\u59cb\u8f93\u5165\uff0c    \u53ef\u4ee5\u662f\u4efb\u4f55\u4e1c\u897f\u3002</p> </li> <li> <p>\u6ce8\u610f\u60a8\u53ef\u80fd\u60f3\u8981\u68c0\u67e5\u5176\u4ed6\u5e8f\u5217\u7c7b\u578b\uff08\u4f8b\u5982\u5143\u7ec4\uff09\uff0c\u8fd9\u4e9b\u7c7b\u578b\u901a\u5e38\u53ef\u4ee5\u6210\u529f\u9a8c\u8bc1\u4e3a<code>list</code>\u7c7b\u578b\u3002    Before \u9a8c\u8bc1\u5668\u7ed9\u60a8\u66f4\u591a\u7075\u6d3b\u6027\uff0c\u4f46\u60a8\u5fc5\u987b\u8003\u8651\u6240\u6709\u53ef\u80fd\u7684\u60c5\u51b5\u3002</p> </li> <li> <p>Pydantic \u4ecd\u7136\u5bf9 <code>int</code> \u7c7b\u578b\u6267\u884c\u9a8c\u8bc1\uff0c\u65e0\u8bba\u6211\u4eec\u7684 <code>ensure_list</code> \u9a8c\u8bc1\u5668\u662f\u5426\u5bf9\u539f\u59cb\u8f93\u5165\u7c7b\u578b\u8fdb\u884c\u4e86\u64cd\u4f5c\u3002</p> </li> </ol> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    numbers: list[int]\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def ensure_list(cls, value: Any) -&gt; Any:  # (1)!\n        if not isinstance(value, list):  # (2)!\n            return [value]\n        else:\n            return value\n\n\nprint(Model(numbers=2))\n#&gt; numbers=[2]\ntry:\n    Model(numbers='str')\nexcept ValidationError as err:\n    print(err)  # (3)!\n    \"\"\"\n    1 validation error for Model\n    numbers.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n    \"\"\"\n</code></pre> <ol> <li> <p>\u6ce8\u610f\u4f7f\u7528 <code>Any</code> \u4f5c\u4e3a <code>value</code> \u7684\u7c7b\u578b\u63d0\u793a\u3002Before \u9a8c\u8bc1\u5668\u63a5\u6536\u539f\u59cb\u8f93\u5165\uff0c    \u53ef\u4ee5\u662f\u4efb\u4f55\u4e1c\u897f\u3002</p> </li> <li> <p>\u6ce8\u610f\u60a8\u53ef\u80fd\u60f3\u8981\u68c0\u67e5\u5176\u4ed6\u5e8f\u5217\u7c7b\u578b\uff08\u4f8b\u5982\u5143\u7ec4\uff09\uff0c\u8fd9\u4e9b\u7c7b\u578b\u901a\u5e38\u53ef\u4ee5\u6210\u529f\u9a8c\u8bc1\u4e3a <code>list</code> \u7c7b\u578b\u3002    Before \u9a8c\u8bc1\u5668\u7ed9\u60a8\u66f4\u591a\u7075\u6d3b\u6027\uff0c\u4f46\u60a8\u5fc5\u987b\u8003\u8651\u6240\u6709\u53ef\u80fd\u7684\u60c5\u51b5\u3002</p> </li> <li> <p>Pydantic \u4ecd\u7136\u5bf9 <code>int</code> \u7c7b\u578b\u6267\u884c\u9a8c\u8bc1\uff0c\u65e0\u8bba\u6211\u4eec\u7684 <code>ensure_list</code> \u9a8c\u8bc1\u5668\u662f\u5426\u5bf9\u539f\u59cb\u8f93\u5165\u7c7b\u578b\u8fdb\u884c\u4e86\u64cd\u4f5c\u3002</p> </li> </ol> </li> <li> <p>Plain \u9a8c\u8bc1\u5668\uff1a\u884c\u4e3a\u7c7b\u4f3c\u4e8e before \u9a8c\u8bc1\u5668\uff0c\u4f46\u5b83\u4eec\u5728\u8fd4\u56de\u540e\u7acb\u5373\u7ec8\u6b62\u9a8c\u8bc1\uff0c   \u56e0\u6b64\u4e0d\u4f1a\u8c03\u7528\u5176\u4ed6\u9a8c\u8bc1\u5668\uff0cPydantic \u4e5f\u4e0d\u4f1a\u5bf9\u5b57\u6bb5\u7c7b\u578b\u8fdb\u884c\u4efb\u4f55\u5185\u90e8\u9a8c\u8bc1\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668\u6a21\u5f0f <pre><code>from typing import Annotated, Any\n\nfrom pydantic import BaseModel, PlainValidator\n\n\ndef val_number(value: Any) -&gt; Any:\n    if isinstance(value, int):\n        return value * 2\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    number: Annotated[int, PlainValidator(val_number)]\n\n\nprint(Model(number=4))\n#&gt; number=8\nprint(Model(number='invalid'))  # (1)!\n#&gt; number='invalid'\n</code></pre> <ol> <li>\u867d\u7136 <code>'invalid'</code> \u4e0d\u5e94\u8be5\u9a8c\u8bc1\u4e3a <code>int</code> \u7c7b\u578b\uff0c\u4f46 Pydantic \u63a5\u53d7\u4e86\u8f93\u5165\u3002</li> </ol> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_validator('number', mode='plain')\n    @classmethod\n    def val_number(cls, value: Any) -&gt; Any:\n        if isinstance(value, int):\n            return value * 2\n        else:\n            return value\n\n\nprint(Model(number=4))\n#&gt; number=8\nprint(Model(number='invalid'))  # (1)!\n#&gt; number='invalid'\n</code></pre> <ol> <li>\u867d\u7136 <code>'invalid'</code> \u4e0d\u5e94\u8be5\u9a8c\u8bc1\u4e3a <code>int</code> \u7c7b\u578b\uff0c\u4f46 Pydantic \u63a5\u53d7\u4e86\u8f93\u5165\u3002</li> </ol> </li> <li> <p>Wrap \u9a8c\u8bc1\u5668\uff1a\u662f\u6240\u6709\u9a8c\u8bc1\u5668\u4e2d\u6700\u7075\u6d3b\u7684\u3002\u60a8\u53ef\u4ee5\u5728 Pydantic \u548c\u5176\u4ed6\u9a8c\u8bc1\u5668\u5904\u7406\u8f93\u5165\u4e4b\u524d\u6216\u4e4b\u540e\u8fd0\u884c\u4ee3\u7801\uff0c   \u6216\u8005\u901a\u8fc7\u63d0\u524d\u8fd4\u56de\u503c\u6216\u5f15\u53d1\u9519\u8bef\u6765\u7acb\u5373\u7ec8\u6b62\u9a8c\u8bc1\u3002</p> <p>\u6b64\u7c7b\u9a8c\u8bc1\u5668\u5fc5\u987b\u5b9a\u4e49\u5f3a\u5236\u7684\u989d\u5916\u53c2\u6570 <code>handler</code>\uff1a\u4e00\u4e2a\u63a5\u6536\u8981\u9a8c\u8bc1\u7684\u503c\u4f5c\u4e3a\u53c2\u6570\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u3002 \u5728\u5185\u90e8\uff0c\u6b64\u5904\u7406\u7a0b\u5e8f\u5c06\u628a\u503c\u7684\u9a8c\u8bc1\u59d4\u6258\u7ed9 Pydantic\u3002\u60a8\u53ef\u4ee5\u81ea\u7531\u5730\u5c06\u5bf9\u5904\u7406\u7a0b\u5e8f\u7684\u8c03\u7528\u5305\u88c5\u5728 <code>try..except</code> \u5757\u4e2d\uff0c\u6216\u8005\u6839\u672c\u4e0d\u8c03\u7528\u5b83\u3002</p> \u6ce8\u89e3\u6a21\u5f0f\u88c5\u9970\u5668\u6a21\u5f0f <pre><code>from typing import Any\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, WrapValidator\n\n\ndef truncate(value: Any, handler: ValidatorFunctionWrapHandler) -&gt; str:\n    try:\n        return handler(value)\n    except ValidationError as err:\n        if err.errors()[0]['type'] == 'string_too_long':\n            return handler(value[:5])\n        else:\n            raise\n\n\nclass Model(BaseModel):\n    my_string: Annotated[str, Field(max_length=5), WrapValidator(truncate)]\n\n\nprint(Model(my_string='abcde'))\n#&gt; my_string='abcde'\nprint(Model(my_string='abcdef'))\n#&gt; my_string='abcde'\n</code></pre> <pre><code>from typing import Any\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, field_validator\n\n\nclass Model(BaseModel):\n    my_string: Annotated[str, Field(max_length=5)]\n\n    @field_validator('my_string', mode='wrap')\n    @classmethod\n    def truncate(cls, value: Any, handler: ValidatorFunctionWrapHandler) -&gt; str:\n        try:\n            return handler(value)\n        except ValidationError as err:\n            if err.errors()[0]['type'] == 'string_too_long':\n                return handler(value[:5])\n            else:\n                raise\n\n\nprint(Model(my_string='abcde'))\n#&gt; my_string='abcde'\nprint(Model(my_string='abcdef'))\n#&gt; my_string='abcde'\n</code></pre> </li> </ul> <p>\u9ed8\u8ba4\u503c\u7684\u9a8c\u8bc1</p> <p>\u5982\u5b57\u6bb5\u6587\u6863\u4e2d\u6240\u8ff0\uff0c\u5b57\u6bb5\u7684\u9ed8\u8ba4\u503c \u4e0d\u4f1a\u88ab\u9a8c\u8bc1\uff0c\u9664\u975e\u914d\u7f6e\u4e3a\u8fd9\u6837\u505a\uff0c\u56e0\u6b64\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u4e5f\u4e0d\u4f1a\u88ab\u5e94\u7528\u3002</p>"},{"location":"concepts/validators/#_1","title":"\u9009\u62e9\u54ea\u79cd\u9a8c\u8bc1\u5668\u6a21\u5f0f","text":"<p>\u867d\u7136\u4e24\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5b9e\u73b0\u76f8\u540c\u7684\u529f\u80fd\uff0c\u4f46\u6bcf\u79cd\u6a21\u5f0f\u90fd\u63d0\u4f9b\u4e0d\u540c\u7684\u597d\u5904\u3002</p>"},{"location":"concepts/validators/#using-the-annotated-pattern","title":"\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f","text":"<p>\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\u7684\u4e00\u4e2a\u5173\u952e\u597d\u5904\u662f\u4f7f\u9a8c\u8bc1\u5668\u53ef\u91cd\u7528\uff1a</p> <pre><code>from typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef is_even(value: int) -&gt; int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value\n\n\nEvenNumber = Annotated[int, AfterValidator(is_even)]\n\n\nclass Model1(BaseModel):\n    my_number: EvenNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[EvenNumber, AfterValidator(lambda v: v + 2)]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[EvenNumber]  # (1)!\n</code></pre> <ol> <li>\u5982\u6ce8\u89e3\u6a21\u5f0f\u6587\u6863\u4e2d\u6240\u8ff0\uff0c\u6211\u4eec\u8fd8\u53ef\u4ee5\u5bf9\u6ce8\u89e3\u7684\u7279\u5b9a\u90e8\u5206\u4f7f\u7528\u9a8c\u8bc1\u5668\uff08\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u9a8c\u8bc1\u5e94\u7528\u4e8e\u5217\u8868\u9879\uff0c\u800c\u4e0d\u662f\u6574\u4e2a\u5217\u8868\uff09\u3002</li> </ol> <p>\u901a\u8fc7\u67e5\u770b\u5b57\u6bb5\u6ce8\u89e3\uff0c\u4e5f\u66f4\u5bb9\u6613\u7406\u89e3\u54ea\u4e9b\u9a8c\u8bc1\u5668\u5e94\u7528\u4e8e\u7c7b\u578b\u3002</p>"},{"location":"concepts/validators/#using-the-decorator-pattern","title":"\u4f7f\u7528\u88c5\u9970\u5668\u6a21\u5f0f","text":"<p>\u4f7f\u7528  <code>field_validator()</code> \u88c5\u9970\u5668\u7684\u4e00\u4e2a\u5173\u952e\u597d\u5904\u662f\u5c06\u51fd\u6570\u5e94\u7528\u4e8e\u591a\u4e2a\u5b57\u6bb5\uff1a</p> <pre><code>from pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_validator('f1', 'f2', mode='before')\n    @classmethod\n    def capitalize(cls, value: str) -&gt; str:\n        return value.capitalize()\n</code></pre> <p>\u4ee5\u4e0b\u662f\u5173\u4e8e\u88c5\u9970\u5668\u7528\u6cd5\u7684\u4e00\u4e9b\u989d\u5916\u8bf4\u660e\uff1a</p> <ul> <li>\u5982\u679c\u60a8\u5e0c\u671b\u9a8c\u8bc1\u5668\u5e94\u7528\u4e8e\u6240\u6709\u5b57\u6bb5\uff08\u5305\u62ec\u5b50\u7c7b\u4e2d\u5b9a\u4e49\u7684\u5b57\u6bb5\uff09\uff0c\u53ef\u4ee5\u4f20\u9012 <code>'*'</code> \u4f5c\u4e3a\u5b57\u6bb5\u540d\u79f0\u53c2\u6570\u3002</li> <li>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u88c5\u9970\u5668\u5c06\u786e\u4fdd\u63d0\u4f9b\u7684\u5b57\u6bb5\u540d\u79f0\u5728\u6a21\u578b\u4e0a\u5b9a\u4e49\u3002\u5982\u679c\u60a8\u60f3\u5728\u7c7b\u521b\u5efa\u671f\u95f4\u7981\u7528\u6b64\u68c0\u67e5\uff0c\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>False</code> \u4f20\u9012\u7ed9 <code>check_fields</code> \u53c2\u6570\u6765\u5b9e\u73b0\u3002\u5f53\u5b57\u6bb5\u9a8c\u8bc1\u5668\u5728\u57fa\u7c7b\u4e0a\u5b9a\u4e49\uff0c\u5e76\u4e14\u671f\u671b\u5b57\u6bb5\u5b58\u5728\u4e8e\u5b50\u7c7b\u4e0a\u65f6\uff0c\u8fd9\u5f88\u6709\u7528\u3002</li> </ul>"},{"location":"concepts/validators/#model-validators","title":"\u6a21\u578b\u9a8c\u8bc1\u5668","text":"API \u6587\u6863 <p><code>pydantic.functional_validators.model_validator</code></p> <p>\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>model_validator()</code> \u88c5\u9970\u5668\u5bf9\u6574\u4e2a\u6a21\u578b\u7684\u6570\u636e\u6267\u884c\u9a8c\u8bc1\u3002</p> <p>\u53ef\u4ee5\u4f7f\u7528\u4e09\u79cd\u4e0d\u540c\u7c7b\u578b\u7684\u6a21\u578b\u9a8c\u8bc1\u5668\uff1a</p> <ul> <li> <p>After \u9a8c\u8bc1\u5668\uff1a\u5728\u6574\u4e2a\u6a21\u578b\u9a8c\u8bc1\u4e4b\u540e\u8fd0\u884c\u3002\u56e0\u6b64\uff0c\u5b83\u4eec\u88ab\u5b9a\u4e49\u4e3a\u5b9e\u4f8b\u65b9\u6cd5\uff0c   \u53ef\u4ee5\u770b\u4f5c\u662f\u540e\u521d\u59cb\u5316\u94a9\u5b50\u3002\u91cd\u8981\u8bf4\u660e\uff1a\u5e94\u8fd4\u56de\u9a8c\u8bc1\u540e\u7684\u5b9e\u4f8b\u3002</p> <pre><code>from typing_extensions import Self\n\nfrom pydantic import BaseModel, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n    password: str\n    password_repeat: str\n\n    @model_validator(mode='after')\n    def check_passwords_match(self) -&gt; Self:\n        if self.password != self.password_repeat:\n            raise ValueError('Passwords do not match')\n        return self\n</code></pre> </li> <li> <p>Before \u9a8c\u8bc1\u5668\uff1a\u5728\u6a21\u578b\u5b9e\u4f8b\u5316\u4e4b\u524d\u8fd0\u884c\u3002\u8fd9\u4e9b\u6bd4 after \u9a8c\u8bc1\u5668\u66f4\u7075\u6d3b\uff0c   \u4f46\u5b83\u4eec\u4e5f\u5fc5\u987b\u5904\u7406\u539f\u59cb\u8f93\u5165\uff0c\u7406\u8bba\u4e0a\u53ef\u4ee5\u662f\u4efb\u4f55\u4efb\u610f\u5bf9\u8c61\u3002\u5982\u679c\u60a8\u7a0d\u540e\u5728\u9a8c\u8bc1\u5668\u51fd\u6570\u4e2d   \u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\uff0c\u8fd8\u5e94\u907f\u514d\u76f4\u63a5\u4fee\u6539\u503c\uff0c\u56e0\u4e3a\u5982\u679c\u4f7f\u7528   \u8054\u5408\u7c7b\u578b\uff0c\u4fee\u6539\u540e\u7684\u503c\u53ef\u80fd\u4f1a\u4f20\u9012\u7ed9\u5176\u4ed6\u9a8c\u8bc1\u5668\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n\n    @model_validator(mode='before')\n    @classmethod\n    def check_card_number_not_present(cls, data: Any) -&gt; Any:  # (1)!\n        if isinstance(data, dict):  # (2)!\n            if 'card_number' in data:\n                raise ValueError(\"'card_number' should not be included\")\n        return data\n</code></pre> <ol> <li>\u6ce8\u610f\u4f7f\u7528 <code>Any</code> \u4f5c\u4e3a <code>data</code> \u7684\u7c7b\u578b\u63d0\u793a\u3002Before \u9a8c\u8bc1\u5668\u63a5\u6536\u539f\u59cb\u8f93\u5165\uff0c    \u53ef\u4ee5\u662f\u4efb\u4f55\u4e1c\u897f\u3002</li> <li>\u5927\u591a\u6570\u60c5\u51b5\u4e0b\uff0c\u8f93\u5165\u6570\u636e\u5c06\u662f\u4e00\u4e2a\u5b57\u5178\uff08\u4f8b\u5982\uff0c\u5f53\u8c03\u7528 <code>UserModel(username='...')</code> \u65f6\uff09\u3002\u7136\u800c\uff0c    \u60c5\u51b5\u5e76\u975e\u603b\u662f\u5982\u6b64\u3002\u4f8b\u5982\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86 <code>from_attributes</code>    \u914d\u7f6e\u503c\uff0c\u60a8\u53ef\u80fd\u4f1a\u6536\u5230\u4e00\u4e2a\u4efb\u610f\u7c7b\u5b9e\u4f8b\u4f5c\u4e3a <code>data</code> \u53c2\u6570\u3002</li> </ol> </li> <li> <p>Wrap \u9a8c\u8bc1\u5668\uff1a\u662f\u6240\u6709\u9a8c\u8bc1\u5668\u4e2d\u6700\u7075\u6d3b\u7684\u3002\u60a8\u53ef\u4ee5\u5728Pydantic\u548c\u5176\u4ed6\u9a8c\u8bc1\u5668\u5904\u7406\u8f93\u5165\u6570\u636e\u4e4b\u524d\u6216\u4e4b\u540e\u8fd0\u884c\u4ee3\u7801\uff0c   \u6216\u8005\u901a\u8fc7\u63d0\u524d\u8fd4\u56de\u6570\u636e\u6216\u5f15\u53d1\u9519\u8bef\u6765\u7acb\u5373\u7ec8\u6b62\u9a8c\u8bc1\u3002</p> <pre><code>import logging\nfrom typing import Any\n\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ModelWrapValidatorHandler, ValidationError, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n\n    @model_validator(mode='wrap')\n    @classmethod\n    def log_failed_validation(cls, data: Any, handler: ModelWrapValidatorHandler[Self]) -&gt; Self:\n        try:\n            return handler(data)\n        except ValidationError:\n            logging.error('Model %s failed to validate with data %s', cls, data)\n            raise\n</code></pre> </li> </ul> <p>\u5173\u4e8e\u7ee7\u627f</p> <p>\u5728\u57fa\u7c7b\u4e2d\u5b9a\u4e49\u7684\u6a21\u578b\u9a8c\u8bc1\u5668\u5c06\u5728\u5b50\u7c7b\u5b9e\u4f8b\u9a8c\u8bc1\u671f\u95f4\u88ab\u8c03\u7528\u3002</p> <p>\u5728\u5b50\u7c7b\u4e2d\u91cd\u5199\u6a21\u578b\u9a8c\u8bc1\u5668\u5c06\u8986\u76d6\u57fa\u7c7b\u7684\u9a8c\u8bc1\u5668\uff0c\u56e0\u6b64\u53ea\u4f1a\u8c03\u7528\u8be5\u9a8c\u8bc1\u5668\u7684\u5b50\u7c7b\u7248\u672c\u3002</p>"},{"location":"concepts/validators/#raising-validation-errors","title":"\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef","text":"<p>\u8981\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e09\u79cd\u7c7b\u578b\u7684\u5f02\u5e38\uff1a</p> <ul> <li><code>ValueError</code>\uff1a\u8fd9\u662f\u5728\u9a8c\u8bc1\u5668\u5185\u90e8\u5f15\u53d1\u7684\u6700\u5e38\u89c1\u5f02\u5e38\u3002</li> <li><code>AssertionError</code>\uff1a\u4f7f\u7528 <code>assert</code> \u8bed\u53e5\u4e5f\u6709\u6548\uff0c\u4f46\u8bf7\u6ce8\u610f\u5f53 Python \u4f7f\u7528 -O \u4f18\u5316\u6807\u5fd7\u8fd0\u884c\u65f6\uff0c\u8fd9\u4e9b\u8bed\u53e5\u4f1a\u88ab\u8df3\u8fc7\u3002</li> <li> <p><code>PydanticCustomError</code>\uff1a\u7a0d\u5fae\u5197\u957f\u4e00\u4e9b\uff0c\u4f46\u63d0\u4f9b\u4e86\u989d\u5916\u7684\u7075\u6d3b\u6027\uff1a</p> <pre><code>from pydantic_core import PydanticCustomError\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x', mode='after')\n    @classmethod\n    def validate_x(cls, v: int) -&gt; int:\n        if v % 42 == 0:\n            raise PydanticCustomError(\n                'the_answer_error',\n                '{number} is the answer!',\n                {'number': v},\n            )\n        return v\n\n\ntry:\n    Model(x=42 * 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    x\n      84 is the answer! [type=the_answer_error, input_value=84, input_type=int]\n    \"\"\"\n</code></pre> </li> </ul>"},{"location":"concepts/validators/#_2","title":"\u9a8c\u8bc1\u4fe1\u606f","text":"<p>\u5b57\u6bb5\u548c\u6a21\u578b\u9a8c\u8bc1\u5668\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\uff08\u5728\u6240\u6709\u6a21\u5f0f\u4e0b\uff09\u90fd\u53ef\u4ee5\u9009\u62e9\u6027\u5730\u63a5\u53d7\u4e00\u4e2a\u989d\u5916\u7684 <code>ValidationInfo</code> \u53c2\u6570\uff0c\u63d0\u4f9b\u6709\u7528\u7684\u989d\u5916\u4fe1\u606f\uff0c\u4f8b\u5982\uff1a</p> <ul> <li>\u5df2\u9a8c\u8bc1\u7684\u6570\u636e</li> <li>\u7528\u6237\u5b9a\u4e49\u7684\u4e0a\u4e0b\u6587</li> <li>\u5f53\u524d\u9a8c\u8bc1\u6a21\u5f0f\uff1a<code>'python'</code> \u6216 <code>'json'</code>\uff08\u53c2\u89c1 <code>mode</code> \u5c5e\u6027\uff09</li> <li>\u5f53\u524d\u5b57\u6bb5\u540d\u79f0\uff0c\u5982\u679c\u4f7f\u7528\u5b57\u6bb5\u9a8c\u8bc1\u5668\uff08\u53c2\u89c1 <code>field_name</code> \u5c5e\u6027\uff09\u3002</li> </ul>"},{"location":"concepts/validators/#validation-data","title":"\u9a8c\u8bc1\u6570\u636e","text":"<p>\u5bf9\u4e8e\u5b57\u6bb5\u9a8c\u8bc1\u5668\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>data</code> \u5c5e\u6027\u8bbf\u95ee\u5df2\u9a8c\u8bc1\u7684\u6570\u636e\u3002 \u4ee5\u4e0b\u662f\u4e00\u4e2a\u53ef\u4ee5\u4f5c\u4e3a   after    \u6a21\u578b\u9a8c\u8bc1\u5668\u793a\u4f8b\u66ff\u4ee3\u65b9\u6848\u7684\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass UserModel(BaseModel):\n    password: str\n    password_repeat: str\n    username: str\n\n    @field_validator('password_repeat', mode='after')\n    @classmethod\n    def check_passwords_match(cls, value: str, info: ValidationInfo) -&gt; str:\n        if value != info.data['password']:\n            raise ValueError('Passwords do not match')\n        return value\n</code></pre> <p>Warning</p> <p>\u7531\u4e8e\u9a8c\u8bc1\u662f\u6309\u7167\u5b57\u6bb5\u5b9a\u4e49\u7684\u987a\u5e8f\u6267\u884c\u7684\uff0c\u60a8\u5fc5\u987b \u786e\u4fdd\u4e0d\u8bbf\u95ee\u5c1a\u672a\u9a8c\u8bc1\u7684\u5b57\u6bb5\u3002\u4f8b\u5982\uff0c\u5728\u4e0a\u9762\u7684\u4ee3\u7801\u4e2d\uff0c <code>username</code> \u7684\u9a8c\u8bc1\u503c\u5c1a\u4e0d\u53ef\u7528\uff0c\u56e0\u4e3a\u5b83\u662f\u5728 <code>password_repeat</code> \u4e4b\u540e \u5b9a\u4e49\u7684\u3002</p> <p>\u5bf9\u4e8e\u6a21\u578b\u9a8c\u8bc1\u5668\uff0c<code>data</code> \u5c5e\u6027\u4e3a <code>None</code>\u3002</p>"},{"location":"concepts/validators/#validation-context","title":"\u9a8c\u8bc1\u4e0a\u4e0b\u6587","text":"<p>\u60a8\u53ef\u4ee5\u5411\u9a8c\u8bc1\u65b9\u6cd5\u4f20\u9012\u4e00\u4e2a\u4e0a\u4e0b\u6587\u5bf9\u8c61\uff0c\u8be5\u5bf9\u8c61\u53ef\u4ee5\u5728\u9a8c\u8bc1\u5668\u51fd\u6570\u5185\u90e8 \u901a\u8fc7 <code>context</code> \u5c5e\u6027\u8bbf\u95ee\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_validator('text', mode='after')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: ValidationInfo) -&gt; str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\ndata = {'text': 'This is an example document'}\nprint(Model.model_validate(data))  # \u65e0\u4e0a\u4e0b\u6587\n#&gt; text='This is an example document'\nprint(Model.model_validate(data, context={'stopwords': ['this', 'is', 'an']}))\n#&gt; text='example document'\n</code></pre> <p>\u7c7b\u4f3c\u5730\uff0c\u60a8\u53ef\u4ee5\u4e3a\u5e8f\u5217\u5316\u4f7f\u7528\u4e0a\u4e0b\u6587\u3002</p> \u5728\u76f4\u63a5\u5b9e\u4f8b\u5316\u6a21\u578b\u65f6\u63d0\u4f9b\u4e0a\u4e0b\u6587 <p>\u76ee\u524d\u65e0\u6cd5\u5728\u76f4\u63a5\u5b9e\u4f8b\u5316\u6a21\u578b\u65f6\u63d0\u4f9b\u4e0a\u4e0b\u6587 \uff08\u5373\u8c03\u7528 <code>Model(...)</code> \u65f6\uff09\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528 <code>ContextVar</code> \u548c\u81ea\u5b9a\u4e49 <code>__init__</code> \u65b9\u6cd5\u6765\u53d8\u901a\u89e3\u51b3\uff1a</p> <pre><code>from __future__ import annotations\n\nfrom collections.abc import Generator\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Any\n\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n_init_context_var = ContextVar('_init_context_var', default=None)\n\n\n@contextmanager\ndef init_context(value: dict[str, Any]) -&gt; Generator[None]:\n    token = _init_context_var.set(value)\n    try:\n        yield\n    finally:\n        _init_context_var.reset(token)\n\n\nclass Model(BaseModel):\n    my_number: int\n\n    def __init__(self, /, **data: Any) -&gt; None:\n        self.__pydantic_validator__.validate_python(\n            data,\n            self_instance=self,\n            context=_init_context_var.get(),\n        )\n\n    @field_validator('my_number')\n    @classmethod\n    def multiply_with_context(cls, value: int, info: ValidationInfo) -&gt; int:\n        if isinstance(info.context, dict):\n            multiplier = info.context.get('multiplier', 1)\n            value = value * multiplier\n        return value\n\n\nprint(Model(my_number=2))\n#&gt; my_number=2\n\nwith init_context({'multiplier': 3}):\n    print(Model(my_number=2))\n    #&gt; my_number=6\n\nprint(Model(my_number=2))\n#&gt; my_number=2\n</code></pre>"},{"location":"concepts/validators/#_3","title":"\u9a8c\u8bc1\u5668\u6392\u5e8f","text":"<p>\u4f7f\u7528\u6ce8\u89e3\u6a21\u5f0f\u65f6\uff0c\u9a8c\u8bc1\u5668\u7684\u5e94\u7528\u987a\u5e8f\u5b9a\u4e49\u5982\u4e0b\uff1a before \u548c wrap \u9a8c\u8bc1\u5668\u4ece\u53f3\u5230\u5de6\u8fd0\u884c\uff0c \u7136\u540e after \u9a8c\u8bc1\u5668\u4ece\u5de6\u5230\u53f3\u8fd0\u884c\uff1a</p> <pre><code>from pydantic import AfterValidator, BaseModel, BeforeValidator, WrapValidator\n\n\nclass Model(BaseModel):\n    name: Annotated[\n        str,\n        AfterValidator(runs_3rd),\n        AfterValidator(runs_4th),\n        BeforeValidator(runs_2nd),\n        WrapValidator(runs_1st),\n    ]\n</code></pre> <p>\u5728\u5185\u90e8\uff0c\u4f7f\u7528\u88c5\u9970\u5668\u6a21\u5f0f\u5b9a\u4e49\u7684\u9a8c\u8bc1\u5668\u4f1a\u88ab\u8f6c\u6362\u4e3a\u5176\u6ce8\u89e3\u5f62\u5f0f\u7684\u5bf9\u5e94\u7269\uff0c \u5e76\u6dfb\u52a0\u5230\u5b57\u6bb5\u73b0\u6709\u5143\u6570\u636e\u7684\u6700\u540e\u3002\u8fd9\u610f\u5473\u7740\u76f8\u540c\u7684\u6392\u5e8f\u903b\u8f91\u9002\u7528\u3002</p>"},{"location":"concepts/validators/#_4","title":"\u7279\u6b8a\u7c7b\u578b","text":"<p>Pydantic \u63d0\u4f9b\u4e86\u4e00\u4e9b\u7279\u6b8a\u5b9e\u7528\u7a0b\u5e8f\uff0c\u53ef\u7528\u4e8e\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u3002</p> <ul> <li> <p><code>InstanceOf</code> \u53ef\u7528\u4e8e\u9a8c\u8bc1\u503c\u662f\u5426\u4e3a\u7ed9\u5b9a\u7c7b\u7684\u5b9e\u4f8b\u3002</p> <pre><code>from pydantic import BaseModel, InstanceOf, ValidationError\n\n\nclass Fruit:\n    def __repr__(self):\n        return self.__class__.__name__\n\n\nclass Banana(Fruit): ...\n\n\nclass Apple(Fruit): ...\n\n\nclass Basket(BaseModel):\n    fruits: list[InstanceOf[Fruit]]\n\n\nprint(Basket(fruits=[Banana(), Apple()]))\n#&gt; fruits=[Banana, Apple]\ntry:\n    Basket(fruits=[Banana(), 'Apple'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Basket\n    fruits.1\n      Input should be an instance of Fruit [type=is_instance_of, input_value='Apple', input_type=str]\n    \"\"\"\n</code></pre> </li> <li> <p><code>SkipValidation</code> \u53ef\u7528\u4e8e\u8df3\u8fc7\u5b57\u6bb5\u7684\u9a8c\u8bc1\u3002</p> <pre><code>from pydantic import BaseModel, SkipValidation\n\n\nclass Model(BaseModel):\n    names: list[SkipValidation[str]]\n\n\nm = Model(names=['foo', 'bar'])\nprint(m)\n#&gt; names=['foo', 'bar']\n\nm = Model(names=['foo', 123])  # (1)!\nprint(m)\n#&gt; names=['foo', 123]\n</code></pre> <ol> <li>\u6ce8\u610f\u7b2c\u4e8c\u4e2a\u9879\u76ee\u7684\u9a8c\u8bc1\u88ab\u8df3\u8fc7\u4e86\u3002\u5982\u679c\u7c7b\u578b\u9519\u8bef\uff0c\u5b83\u5c06\u5728\u5e8f\u5217\u5316\u671f\u95f4\u53d1\u51fa\u8b66\u544a\u3002</li> </ol> </li> <li> <p><code>ValidateAs</code> \u53ef\u7528\u4e8e\u4ece Pydantic \u539f\u751f\u652f\u6301\u7684\u7c7b\u578b\u9a8c\u8bc1\u81ea\u5b9a\u4e49\u7c7b\u578b\u3002   \u8fd9\u5728\u5904\u7406\u5177\u6709\u591a\u4e2a\u5b57\u6bb5\u7684\u81ea\u5b9a\u4e49\u7c7b\u578b\u65f6\u7279\u522b\u6709\u7528\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, TypeAdapter, ValidateAs\n\nclass MyCls:\n    def __init__(self, a: int) -&gt; None:\n        self.a = a\n\n    def __repr__(self) -&gt; str:\n        return f\"MyCls(a={self.a})\"\n\nclass ValModel(BaseModel):\n    a: int\n\n\nta = TypeAdapter(\n    Annotated[MyCls, ValidateAs(ValModel, lambda v: MyCls(a=v.a))]\n)\n\nprint(ta.validate_python({'a': 1}))\n#&gt; MyCls(a=1)\n</code></pre> </li> <li> <p><code>PydanticUseDefault</code> \u53ef\u7528\u4e8e\u901a\u77e5 Pydantic \u5e94\u4f7f\u7528\u9ed8\u8ba4\u503c\u3002</p> <pre><code>from typing import Annotated, Any\n\nfrom pydantic_core import PydanticUseDefault\n\nfrom pydantic import BaseModel, BeforeValidator\n\n\ndef default_if_none(value: Any) -&gt; Any:\n    if value is None:\n        raise PydanticUseDefault()\n    return value\n\n\nclass Model(BaseModel):\n    name: Annotated[str, BeforeValidator(default_if_none)] = 'default_name'\n\n\nprint(Model(name=None))\n#&gt; name='default_name'\n</code></pre> </li> </ul>"},{"location":"concepts/validators/#json-schema-and-field-validators","title":"JSON Schema \u548c\u5b57\u6bb5\u9a8c\u8bc1\u5668","text":"<p>\u4f7f\u7528 before\u3001plain \u6216 wrap \u5b57\u6bb5\u9a8c\u8bc1\u5668\u65f6\uff0c\u63a5\u53d7\u7684\u8f93\u5165\u7c7b\u578b\u53ef\u80fd\u4e0e\u5b57\u6bb5\u6ce8\u89e3\u4e0d\u540c\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator('value', mode='before')\n    @classmethod\n    def cast_ints(cls, value: Any) -&gt; Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model(value='a'))\n#&gt; value='a'\nprint(Model(value=1))\n#&gt; value='1'\n</code></pre> <p>\u867d\u7136 <code>value</code> \u7684\u7c7b\u578b\u63d0\u793a\u662f <code>str</code>\uff0c\u4f46 <code>cast_ints</code> \u9a8c\u8bc1\u5668\u4e5f\u5141\u8bb8\u6574\u6570\u3002\u8981\u6307\u5b9a\u6b63\u786e\u7684\u8f93\u5165\u7c7b\u578b\uff0c \u53ef\u4ee5\u63d0\u4f9b <code>json_schema_input_type</code> \u53c2\u6570\uff1a</p> <pre><code>from typing import Any, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator(\n        'value', mode='before', json_schema_input_type=Union[int, str]\n    )\n    @classmethod\n    def cast_ints(cls, value: Any) -&gt; Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model.model_json_schema()['properties']['value'])\n#&gt; {'anyOf': [{'type': 'integer'}, {'type': 'string'}], 'title': 'Value'}\n</code></pre> <p>\u4e3a\u65b9\u4fbf\u8d77\u89c1\uff0c\u5982\u679c\u672a\u63d0\u4f9b\u53c2\u6570\uff0cPydantic \u5c06\u4f7f\u7528\u5b57\u6bb5\u7c7b\u578b\uff08\u9664\u975e\u60a8\u4f7f\u7528\u7684\u662f plain \u9a8c\u8bc1\u5668\uff0c \u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c<code>json_schema_input_type</code>\u9ed8\u8ba4\u4e3a <code>Any</code>\uff0c\u56e0\u4e3a\u5b57\u6bb5\u7c7b\u578b\u88ab\u5b8c\u5168\u4e22\u5f03\uff09\u3002</p>"},{"location":"errors/errors/","title":"Error Handling","text":"<p>Pydantic \u5728\u9a8c\u8bc1\u6570\u636e\u65f6\u53d1\u73b0\u9519\u8bef\u65f6\u4f1a\u629b\u51fa <code>ValidationError</code>\u3002</p> <p>Note</p> <p>\u9a8c\u8bc1\u4ee3\u7801\u672c\u8eab\u4e0d\u5e94\u629b\u51fa <code>ValidationError</code>\uff0c \u800c\u5e94\u629b\u51fa <code>ValueError</code> \u6216 <code>AssertionError</code>\uff08\u6216\u5176\u5b50\u7c7b\uff09\uff0c\u8fd9\u4e9b\u9519\u8bef\u5c06\u88ab\u6355\u83b7\u5e76\u7528\u4e8e\u586b\u5145\u6700\u7ec8\u7684 <code>ValidationError</code>\u3002</p> <p>\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u9a8c\u8bc1\u5668\u6587\u6863\u4e2d\u7684\u4e13\u95e8\u7ae0\u8282\u3002</p> <p>\u8be5 <code>ValidationError</code> \u5c06\u5305\u542b\u6240\u6709\u9519\u8bef\u7684\u4fe1\u606f\u4ee5\u53ca\u5b83\u4eec\u662f\u5982\u4f55\u53d1\u751f\u7684\u3002</p> <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u51e0\u79cd\u65b9\u5f0f\u8bbf\u95ee\u8fd9\u4e9b\u9519\u8bef\uff1a</p> \u65b9\u6cd5 \u63cf\u8ff0 <code>errors()</code> \u8fd4\u56de\u8f93\u5165\u6570\u636e\u4e2d\u627e\u5230\u7684 <code>ErrorDetails</code> \u9519\u8bef\u5217\u8868\u3002 <code>error_count()</code> \u8fd4\u56de\u9519\u8bef\u6570\u91cf\u3002 <code>json()</code> \u8fd4\u56de\u9519\u8bef\u5217\u8868\u7684 JSON \u8868\u793a\u5f62\u5f0f\u3002 <code>str(e)</code> \u8fd4\u56de\u9519\u8bef\u7684\u4eba\u7c7b\u53ef\u8bfb\u8868\u793a\u5f62\u5f0f\u3002 <p><code>ErrorDetails</code> \u5bf9\u8c61\u662f\u4e00\u4e2a\u5b57\u5178\u3002\u5b83\u5305\u542b\u4ee5\u4e0b\u5185\u5bb9\uff1a</p> \u5c5e\u6027 \u63cf\u8ff0 <code>ctx</code> \u4e00\u4e2a\u53ef\u9009\u5bf9\u8c61\uff0c\u5305\u542b\u6e32\u67d3\u9519\u8bef\u6d88\u606f\u6240\u9700\u7684\u503c\u3002 <code>input</code> \u7528\u4e8e\u9a8c\u8bc1\u7684\u8f93\u5165\u6570\u636e\u3002 <code>loc</code> \u9519\u8bef\u7684\u4f4d\u7f6e\uff0c\u4ee5\u5217\u8868\u5f62\u5f0f\u8868\u793a\u3002 <code>msg</code> \u9519\u8bef\u7684\u4eba\u7c7b\u53ef\u8bfb\u89e3\u91ca\u3002 <code>type</code> \u9519\u8bef\u7c7b\u578b\u7684\u8ba1\u7b97\u673a\u53ef\u8bfb\u6807\u8bc6\u7b26\u3002 <code>url</code> \u63d0\u4f9b\u9519\u8bef\u4fe1\u606f\u7684\u6587\u6863 URL\u3002 <p><code>loc</code> \u5217\u8868\u4e2d\u7684\u7b2c\u4e00\u9879\u5c06\u662f\u53d1\u751f\u9519\u8bef\u7684\u5b57\u6bb5\uff0c\u5982\u679c\u8be5\u5b57\u6bb5\u662f\u5b50\u6a21\u578b\uff0c\u5219\u540e\u7eed\u9879\u5c06\u5b58\u5728\u4ee5\u6307\u793a\u9519\u8bef\u7684\u5d4c\u5957\u4f4d\u7f6e\u3002</p> <p>\u4f5c\u4e3a\u6f14\u793a\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError, field_validator\n\n\nclass Location(BaseModel):\n    lat: float = 0.1\n    lng: float = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: int = Field(gt=42)\n    list_of_ints: list[int]\n    a_float: float\n    recursive_model: Location\n\n    @field_validator('a_float', mode='after')\n    @classmethod\n    def validate_float(cls, value: float) -&gt; float:\n        if value &gt; 2.0:\n            raise ValueError('Invalid float value')\n        return value\n\n\ndata = {\n    'list_of_ints': ['1', 2, 'bad'],\n    'a_float': 3.0,\n    'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n    'gt_int': 21,\n}\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    5 validation errors for Model\n    is_required\n      Field required [type=missing, input_value={'list_of_ints': ['1', 2,...ew York'}, 'gt_int': 21}, input_type=dict]\n    gt_int\n      Input should be greater than 42 [type=greater_than, input_value=21, input_type=int]\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Value error, Invalid float value [type=value_error, input_value=3.0, input_type=float]\n    recursive_model.lng\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='New York', input_type=str]\n    \"\"\"\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('is_required',),\n            'msg': 'Field required',\n            'input': {\n                'list_of_ints': ['1', 2, 'bad'],\n                'a_float': 3.0,\n                'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n                'gt_int': 21,\n            },\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        },\n        {\n            'type': 'greater_than',\n            'loc': ('gt_int',),\n            'msg': 'Input should be greater than 42',\n            'input': 21,\n            'ctx': {'gt': 42},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        },\n        {\n            'type': 'int_parsing',\n            'loc': ('list_of_ints', 2),\n            'msg': 'Input should be a valid integer, unable to parse string as an integer',\n            'input': 'bad',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'value_error',\n            'loc': ('a_float',),\n            'msg': 'Value error, Invalid float value',\n            'input': 3.0,\n            'ctx': {'error': ValueError('Invalid float value')},\n            'url': 'https://errors.pydantic.dev/2/v/value_error',\n        },\n        {\n            'type': 'float_parsing',\n            'loc': ('recursive_model', 'lng'),\n            'msg': 'Input should be a valid number, unable to parse string as a number',\n            'input': 'New York',\n            'url': 'https://errors.pydantic.dev/2/v/float_parsing',\n        },\n    ]\n    \"\"\"\n</code></pre>"},{"location":"errors/errors/#_1","title":"\u9519\u8bef\u6d88\u606f","text":"<p>Pydantic \u5c1d\u8bd5\u4e3a\u9a8c\u8bc1\u9519\u8bef\u548c\u4f7f\u7528\u9519\u8bef\u63d0\u4f9b\u6709\u7528\u7684\u9ed8\u8ba4\u9519\u8bef\u6d88\u606f\uff0c\u53ef\u4ee5\u5728\u8fd9\u91cc\u627e\u5230\uff1a</p> <ul> <li>\u9a8c\u8bc1\u9519\u8bef\uff1a\u5728\u6570\u636e\u9a8c\u8bc1\u671f\u95f4\u53d1\u751f\u7684\u9519\u8bef\u3002</li> <li>\u4f7f\u7528\u9519\u8bef\uff1a\u5728\u4f7f\u7528 Pydantic \u65f6\u53d1\u751f\u7684\u9519\u8bef\u3002</li> </ul>"},{"location":"errors/errors/#_2","title":"\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f","text":"<p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u521b\u5efa\u81ea\u5b9a\u4e49\u9519\u8bef\u5904\u7406\u7a0b\u5e8f\u6765\u81ea\u5b9a\u4e49\u9519\u8bef\u6d88\u606f\u3002</p> <pre><code>from pydantic_core import ErrorDetails\n\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nCUSTOM_MESSAGES = {\n    'int_parsing': 'This is not an integer! \ud83e\udd26',\n    'url_scheme': 'Hey, use the right URL scheme! I wanted {expected_schemes}.',\n}\n\n\ndef convert_errors(\n    e: ValidationError, custom_messages: dict[str, str]\n) -&gt; list[ErrorDetails]:\n    new_errors: list[ErrorDetails] = []\n    for error in e.errors():\n        custom_message = custom_messages.get(error['type'])\n        if custom_message:\n            ctx = error.get('ctx')\n            error['msg'] = (\n                custom_message.format(**ctx) if ctx else custom_message\n            )\n        new_errors.append(error)\n    return new_errors\n\n\nclass Model(BaseModel):\n    a: int\n    b: HttpUrl\n\n\ntry:\n    Model(a='wrong', b='ftp://example.com')\nexcept ValidationError as e:\n    errors = convert_errors(e, CUSTOM_MESSAGES)\n    print(errors)\n    \"\"\"\n    [\n        {\n            'type': 'int_parsing',\n            'loc': ('a',),\n            'msg': 'This is not an integer! \ud83e\udd26',\n            'input': 'wrong',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'url_scheme',\n            'loc': ('b',),\n            'msg': \"Hey, use the right URL scheme! I wanted 'http' or 'https'.\",\n            'input': 'ftp://example.com',\n            'ctx': {'expected_schemes': \"'http' or 'https'\"},\n            'url': 'https://errors.pydantic.dev/2/v/url_scheme',\n        },\n    ]\n    \"\"\"\n</code></pre> <p>\u4e00\u4e2a\u5e38\u89c1\u7684\u7528\u4f8b\u662f\u7ffb\u8bd1\u9519\u8bef\u6d88\u606f\u3002\u4f8b\u5982\uff0c\u5728\u4e0a\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u53ef\u4ee5\u901a\u8fc7\u5c06 <code>CUSTOM_MESSAGES</code> \u5b57\u5178\u66ff\u6362\u4e3a\u7ffb\u8bd1\u5b57\u5178\u6765\u7ffb\u8bd1\u9519\u8bef\u6d88\u606f\u3002</p> <p>\u53e6\u4e00\u4e2a\u4f8b\u5b50\u662f\u81ea\u5b9a\u4e49\u9519\u8bef <code>'loc'</code> \u503c\u7684\u8868\u793a\u65b9\u5f0f\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Any, Union\n\nfrom pydantic import BaseModel, ValidationError\n\n\ndef loc_to_dot_sep(loc: tuple[Union[str, int], ...]) -&gt; str:\n    path = ''\n    for i, x in enumerate(loc):\n        if isinstance(x, str):\n            if i &gt; 0:\n                path += '.'\n            path += x\n        elif isinstance(x, int):\n            path += f'[{x}]'\n        else:\n            raise TypeError('Unexpected type')\n    return path\n\n\ndef convert_errors(e: ValidationError) -&gt; list[dict[str, Any]]:\n    new_errors: list[dict[str, Any]] = e.errors()\n    for error in new_errors:\n        error['loc'] = loc_to_dot_sep(error['loc'])\n    return new_errors\n\n\nclass TestNestedModel(BaseModel):\n    key: str\n    value: str\n\n\nclass TestModel(BaseModel):\n    items: list[TestNestedModel]\n\n\ndata = {'items': [{'key': 'foo', 'value': 'bar'}, {'key': 'baz'}]}\n\ntry:\n    TestModel.model_validate(data)\nexcept ValidationError as e:\n    print(e.errors())  # (1)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('items', 1, 'value'),\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n    pretty_errors = convert_errors(e)\n    print(pretty_errors)  # (2)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': 'items[1].value',\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n</code></pre> <ol> <li>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>e.errors()</code> \u4f1a\u4ea7\u751f\u4e00\u4e2a\u9519\u8bef\u5217\u8868\uff0c\u5176\u4e2d <code>loc</code> \u503c\u91c7\u7528\u5143\u7ec4\u5f62\u5f0f\u3002</li> <li>\u4f7f\u7528\u6211\u4eec\u81ea\u5b9a\u4e49\u7684 <code>loc_to_dot_sep</code> \u51fd\u6570\uff0c\u6211\u4eec\u4fee\u6539\u4e86 <code>loc</code> \u7684\u8868\u793a\u5f62\u5f0f\u3002</li> </ol> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, ValidationError\n\n\ndef loc_to_dot_sep(loc: tuple[str | int, ...]) -&gt; str:\n    path = ''\n    for i, x in enumerate(loc):\n        if isinstance(x, str):\n            if i &gt; 0:\n                path += '.'\n            path += x\n        elif isinstance(x, int):\n            path += f'[{x}]'\n        else:\n            raise TypeError('Unexpected type')\n    return path\n\n\ndef convert_errors(e: ValidationError) -&gt; list[dict[str, Any]]:\n    new_errors: list[dict[str, Any]] = e.errors()\n    for error in new_errors:\n        error['loc'] = loc_to_dot_sep(error['loc'])\n    return new_errors\n\n\nclass TestNestedModel(BaseModel):\n    key: str\n    value: str\n\n\nclass TestModel(BaseModel):\n    items: list[TestNestedModel]\n\n\ndata = {'items': [{'key': 'foo', 'value': 'bar'}, {'key': 'baz'}]}\n\ntry:\n    TestModel.model_validate(data)\nexcept ValidationError as e:\n    print(e.errors())  # (1)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('items', 1, 'value'),\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n    pretty_errors = convert_errors(e)\n    print(pretty_errors)  # (2)!\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': 'items[1].value',\n            'msg': 'Field required',\n            'input': {'key': 'baz'},\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        }\n    ]\n    \"\"\"\n</code></pre> <ol> <li>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c<code>e.errors()</code> \u4f1a\u4ea7\u751f\u4e00\u4e2a\u9519\u8bef\u5217\u8868\uff0c\u5176\u4e2d <code>loc</code> \u503c\u91c7\u7528\u5143\u7ec4\u5f62\u5f0f\u3002</li> <li>\u4f7f\u7528\u6211\u4eec\u81ea\u5b9a\u4e49\u7684 <code>loc_to_dot_sep</code> \u51fd\u6570\uff0c\u6211\u4eec\u4fee\u6539\u4e86 <code>loc</code> \u7684\u8868\u793a\u5f62\u5f0f\u3002</li> </ol>"},{"location":"errors/usage_errors/","title":"Usage Errors","text":"<p>Pydantic \u5c1d\u8bd5\u63d0\u4f9b\u6709\u7528\u7684\u9519\u8bef\u4fe1\u606f\u3002\u4ee5\u4e0b\u90e8\u5206\u8be6\u7ec6\u4ecb\u7ecd\u4e86\u5f00\u53d1\u4eba\u5458\u5728\u4f7f\u7528 Pydantic \u65f6\u53ef\u80fd\u9047\u5230\u7684\u5e38\u89c1\u9519\u8bef\uff0c\u4ee5\u53ca\u89e3\u51b3\u9519\u8bef\u6761\u4ef6\u7684\u5efa\u8bae\u3002</p>"},{"location":"errors/usage_errors/#class-not-fully-defined","title":"\u7c7b\u672a\u5b8c\u5168\u5b9a\u4e49","text":"<p>\u5f53\u5728 pydantic \u9a8c\u8bc1\u7c7b\u578b\u7684\u6ce8\u89e3\u4e2d\u5f15\u7528\u7684\u7c7b\u578b\uff08\u4f8b\u5982 <code>BaseModel</code> \u7684\u5b50\u7c7b\u6216 pydantic <code>dataclass</code>\uff09\u672a\u5b9a\u4e49\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from typing import ForwardRef\n\nfrom pydantic import BaseModel, PydanticUserError\n\nUndefinedType = ForwardRef('UndefinedType')\n\n\nclass Foobar(BaseModel):\n    a: UndefinedType\n\n\ntry:\n    Foobar(a=1)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n</code></pre> <p>\u6216\u8005\u5f53\u7c7b\u578b\u5728\u4f7f\u7528\u540e\u624d\u5b9a\u4e49\u65f6\uff1a</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\ntry:\n    # \u8fd9\u4e0d\u8d77\u4f5c\u7528\uff0c\u8bf7\u67e5\u770b\u5f15\u53d1\u7684\u9519\u8bef\n    foo = Foo(a={'b': {'a': None}})\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\n# \u4e0d\u8fc7\uff0c\u8fd9\u6837\u53ef\u4ee5\u5de5\u4f5c\nfoo = Foo(a={'b': {'a': None}})\n</code></pre> <p>\u5bf9\u4e8e BaseModel \u5b50\u7c7b\uff0c\u53ef\u4ee5\u901a\u8fc7\u5b9a\u4e49\u7c7b\u578b\u7136\u540e\u8c03\u7528 <code>.model_rebuild()</code> \u6765\u4fee\u590d\uff1a</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\nFoo.model_rebuild()\n\nfoo = Foo(a={'b': {'a': None}})\n</code></pre> <p>\u5728\u5176\u4ed6\u60c5\u51b5\u4e0b\uff0c\u9519\u8bef\u6d88\u606f\u5e94\u6307\u793a\u5982\u4f55\u4f7f\u7528\u9002\u5f53\u7684\u7c7b\u578b\u5b9a\u4e49\u91cd\u65b0\u6784\u5efa\u7c7b\u3002</p>"},{"location":"errors/usage_errors/#custom-json-schema","title":"\u81ea\u5b9a\u4e49 JSON Schema","text":"<p><code>__modify_schema__</code> \u65b9\u6cd5\u5728 V2 \u4e2d\u4e0d\u518d\u53d7\u652f\u6301\u3002\u60a8\u5e94\u8be5\u6539\u7528 <code>__get_pydantic_json_schema__</code> \u65b9\u6cd5\u3002</p> <p><code>__modify_schema__</code> \u8fc7\u53bb\u63a5\u6536\u4e00\u4e2a\u8868\u793a JSON schema \u7684\u53c2\u6570\u3002\u8bf7\u53c2\u89c1\u4e0b\u9762\u7684\u793a\u4f8b\uff1a</p> \u65e7\u65b9\u5f0f<pre><code>from pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        @classmethod\n        def __modify_schema__(cls, field_schema):\n            field_schema.update(examples=['example'])\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'custom-json-schema'\n</code></pre> <p>\u65b0\u7684 <code>__get_pydantic_json_schema__</code> \u65b9\u6cd5\u63a5\u6536\u4e24\u4e2a\u53c2\u6570\uff1a\u7b2c\u4e00\u4e2a\u662f\u8868\u793a\u4e3a <code>CoreSchema</code> \u7684\u5b57\u5178\uff0c \u7b2c\u4e8c\u4e2a\u662f\u4e00\u4e2a\u53ef\u8c03\u7528\u7684 <code>handler</code>\uff0c\u5b83\u63a5\u6536\u4e00\u4e2a <code>CoreSchema</code> \u4f5c\u4e3a\u53c2\u6570\uff0c\u5e76\u8fd4\u56de\u4e00\u4e2a JSON schema\u3002\u8bf7\u53c2\u89c1\u4e0b\u9762\u7684\u793a\u4f8b\uff1a</p> \u65b0\u65b9\u5f0f<pre><code>from typing import Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import BaseModel, GetJsonSchemaHandler\n\n\nclass Model(BaseModel):\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n    ) -&gt; dict[str, Any]:\n        json_schema = super().__get_pydantic_json_schema__(core_schema, handler)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema.update(examples=['example'])\n        return json_schema\n\n\nprint(Model.model_json_schema())\n\"\"\"\n{'examples': ['example'], 'properties': {}, 'title': 'Model', 'type': 'object'}\n\"\"\"\n</code></pre>"},{"location":"errors/usage_errors/#decorator-missing-field","title":"\u88c5\u9970\u5668\u5e94\u7528\u4e8e\u7f3a\u5931\u7684\u5b57\u6bb5","text":"<p>\u5f53\u60a8\u4f7f\u7528\u65e0\u6548\u7684\u5b57\u6bb5\u5b9a\u4e49\u88c5\u9970\u5668\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('b')\n        def check_b(cls, v: Any):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'decorator-missing-field'\n</code></pre> <p>\u5982\u679c\u60a8\u4ece\u6a21\u578b\u7ee7\u627f\u5e76\u4e14\u6709\u610f\u8fd9\u6837\u505a\uff0c\u53ef\u4ee5\u4f7f\u7528 <code>check_fields=False</code>\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel, create_model, field_validator\n\n\nclass Model(BaseModel):\n    @field_validator('a', check_fields=False)\n    def check_a(cls, v: Any):\n        return v\n\n\nmodel = create_model('FooModel', a=(str, 'cake'), __base__=Model)\n</code></pre>"},{"location":"errors/usage_errors/#discriminator-no-field","title":"\u9274\u522b\u5668\u65e0\u5b57\u6bb5","text":"<p>\u5f53\u9274\u522b\u8054\u5408\u4e2d\u7684\u6a21\u578b\u672a\u5b9a\u4e49\u9274\u522b\u5668\u5b57\u6bb5\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n</code></pre>"},{"location":"errors/usage_errors/#discriminator-alias-type","title":"\u9274\u522b\u5668\u522b\u540d\u7c7b\u578b","text":"<p>\u5f53\u60a8\u5728\u9274\u522b\u5668\u5b57\u6bb5\u4e0a\u5b9a\u4e49\u975e\u5b57\u7b26\u4e32\u522b\u540d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import AliasChoices, BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(\n        validation_alias=AliasChoices('Pet', 'PET')\n    )\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias-type'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import AliasChoices, BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(\n        validation_alias=AliasChoices('Pet', 'PET')\n    )\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias-type'\n</code></pre>"},{"location":"errors/usage_errors/#discriminator-needs-literal","title":"\u9274\u522b\u5668\u9700\u8981\u5b57\u9762\u91cf","text":"<p>\u5f53\u60a8\u5728\u9274\u522b\u5668\u5b57\u6bb5\u4e0a\u5b9a\u4e49\u975e <code>Literal</code> \u7c7b\u578b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: int\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-needs-literal'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: int\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-needs-literal'\n</code></pre>"},{"location":"errors/usage_errors/#discriminator-alias","title":"\u9274\u522b\u5668\u522b\u540d","text":"<p>\u5f53\u60a8\u5728\u9274\u522b\u5668\u5b57\u6bb5\u4e0a\u5b9a\u4e49\u4e0d\u540c\u7684\u522b\u540d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(validation_alias='PET')\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog'] = Field(validation_alias='Pet')\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat'] = Field(validation_alias='PET')\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog'] = Field(validation_alias='Pet')\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-alias'\n</code></pre>"},{"location":"errors/usage_errors/#discriminator-validator","title":"\u65e0\u6548\u7684\u9274\u522b\u5668\u9a8c\u8bc1\u5668","text":"<p>\u5f53\u60a8\u5728\u9274\u522b\u5668\u5b57\u6bb5\u4e0a\u4f7f\u7528 before\u3001wrap \u6216 plain \u9a8c\u8bc1\u5668\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u8fd9\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u56e0\u4e3a\u9274\u522b\u5668\u5b57\u6bb5\u7528\u4e8e\u786e\u5b9a\u7528\u4e8e\u9a8c\u8bc1\u7684\u6a21\u578b\u7c7b\u578b\uff0c \u56e0\u6b64\u60a8\u4e0d\u80fd\u4f7f\u7528\u53ef\u80fd\u6539\u53d8\u5176\u503c\u7684\u9a8c\u8bc1\u5668\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-validator'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, PydanticUserError, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Cat | Dog = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-validator'\n</code></pre> <p>\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u6807\u51c6\u7684 <code>Union</code> \u5e76\u53bb\u6389\u9274\u522b\u5668\u6765\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog]\n\n\nassert Model(pet={'pet_type': 'kitten'}).pet.pet_type == 'cat'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\nclass Model(BaseModel):\n    pet: Cat | Dog\n\n\nassert Model(pet={'pet_type': 'kitten'}).pet.pet_type == 'cat'\n</code></pre>"},{"location":"errors/usage_errors/#callable-discriminator-no-tag","title":"\u53ef\u8c03\u7528\u9274\u522b\u5668\u60c5\u51b5\u65e0\u6807\u7b7e","text":"<p>\u5f53\u4f7f\u7528\u53ef\u8c03\u7528 <code>Discriminator</code> \u7684 <code>Union</code> \u6ca1\u6709\u4e3a\u6240\u6709\u60c5\u51b5\u63d0\u4f9b <code>Tag</code> \u6ce8\u89e3\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, PydanticUserError, Tag\n\n\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\n# \u8054\u5408\u9009\u62e9\u7f3a\u5c11\u6807\u7b7e\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# `'DiscriminatedModel'` \u8054\u5408\u9009\u62e9\u7f3a\u5c11\u6807\u7b7e\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[Annotated[str, Tag('str')], 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# `str` \u8054\u5408\u9009\u62e9\u7f3a\u5c11\u6807\u7b7e\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, Annotated['DiscriminatedModel', Tag('model')]],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n</code></pre> <pre><code>from typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, PydanticUserError, Tag\n\n\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\n# \u8054\u5408\u9009\u62e9\u7f3a\u5c11\u6807\u7b7e\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# `'DiscriminatedModel'` \u8054\u5408\u9009\u62e9\u7f3a\u5c11\u6807\u7b7e\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[Annotated[str, Tag('str')], 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# `str` \u8054\u5408\u9009\u62e9\u7f3a\u5c11\u6807\u7b7e\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            str | Annotated['DiscriminatedModel', Tag('model')],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n</code></pre>"},{"location":"errors/usage_errors/#typed-dict-version","title":"<code>TypedDict</code> \u7248\u672c","text":"<p>\u5f53\u60a8\u5728 Python &lt; 3.12 \u4e0a\u4f7f\u7528 typing.TypedDict \u800c\u4e0d\u662f <code>typing_extensions.TypedDict</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/usage_errors/#model-field-overridden","title":"\u6a21\u578b\u7236\u7c7b\u5b57\u6bb5\u88ab\u8986\u76d6","text":"<p>\u5f53\u57fa\u7c7b\u4e0a\u5b9a\u4e49\u7684\u5b57\u6bb5\u88ab\u975e\u6ce8\u89e3\u5c5e\u6027\u8986\u76d6\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: float\n\n\ntry:\n\n    class Bar(Foo):\n        x: float = 12.3\n        a = 123.0\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-overridden'\n</code></pre>"},{"location":"errors/usage_errors/#model-field-missing-annotation","title":"\u6a21\u578b\u5b57\u6bb5\u7f3a\u5c11\u6ce8\u89e3","text":"<p>\u5f53\u5b57\u6bb5\u6ca1\u6709\u6ce8\u89e3\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a = Field('foobar')\n        b = None\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-missing-annotation'\n</code></pre> <p>\u5982\u679c\u8be5\u5b57\u6bb5\u4e0d\u6253\u7b97\u6210\u4e3a\u5b57\u6bb5\uff0c\u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06\u5176\u6ce8\u89e3\u4e3a <code>ClassVar</code> \u6765\u89e3\u51b3\u9519\u8bef\uff1a</p> <pre><code>from typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: ClassVar[str]\n</code></pre> <p>\u6216\u8005\u66f4\u65b0 <code>model_config['ignored_types']</code>\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass IgnoredType:\n    pass\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(ignored_types=(IgnoredType,))\n\n    _a = IgnoredType()\n    _b: int = IgnoredType()\n    _c: IgnoredType\n    _d: IgnoredType = IgnoredType()\n</code></pre>"},{"location":"errors/usage_errors/#config-both","title":"<code>Config</code> \u548c <code>model_config</code> \u540c\u65f6\u5b9a\u4e49","text":"<p>\u5f53 <code>class Config</code> \u548c <code>model_config</code> \u4e00\u8d77\u4f7f\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, ConfigDict, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config = ConfigDict(from_attributes=True)\n\n        a: str\n\n        class Config:\n            from_attributes = True\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'config-both'\n</code></pre>"},{"location":"errors/usage_errors/#removed-kwargs","title":"\u5173\u952e\u5b57\u53c2\u6570\u5df2\u79fb\u9664","text":"<p>\u5f53\u5173\u952e\u5b57\u53c2\u6570\u5728 Pydantic V2 \u4e2d\u4e0d\u53ef\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u4f8b\u5982\uff0c<code>regex</code> \u5df2\u4ece Pydantic V2 \u4e2d\u79fb\u9664\uff1a</p> <pre><code>from pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: str = Field(regex='test')\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'removed-kwargs'\n</code></pre>"},{"location":"errors/usage_errors/#circular-reference-schema","title":"\u5faa\u73af\u5f15\u7528\u6a21\u5f0f","text":"<p>\u5f53\u53d1\u73b0\u4f1a\u5bfc\u81f4\u65e0\u9650\u9012\u5f52\u7684\u5faa\u73af\u5f15\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u4f8b\u5982\uff0c\u8fd9\u662f\u4e00\u4e2a\u6709\u6548\u7684\u7c7b\u578b\u522b\u540d\uff1a</p> <pre><code>type A = list[A] | None\n</code></pre> <p>\u800c\u8fd9\u4e9b\u4e0d\u662f\uff1a</p> <pre><code>type A = A\n\ntype B = C\ntype C = B\n</code></pre>"},{"location":"errors/usage_errors/#invalid-for-json-schema","title":"JSON schema \u65e0\u6548\u7c7b\u578b","text":"<p>\u5f53 Pydantic \u65e0\u6cd5\u4e3a\u67d0\u4e9b <code>CoreSchema</code> \u751f\u6210 JSON schema \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, ImportString, PydanticUserError\n\n\nclass Model(BaseModel):\n    a: ImportString\n\n\ntry:\n    Model.model_json_schema()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-for-json-schema'\n</code></pre>"},{"location":"errors/usage_errors/#json-schema-already-used","title":"JSON schema \u5df2\u4f7f\u7528","text":"<p>\u5f53 JSON schema \u751f\u6210\u5668\u5df2\u88ab\u7528\u4e8e\u751f\u6210 JSON schema \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002 \u60a8\u5fc5\u987b\u521b\u5efa\u4e00\u4e2a\u65b0\u5b9e\u4f8b\u6765\u751f\u6210\u65b0\u7684 JSON schema\u3002</p>"},{"location":"errors/usage_errors/#base-model-instantiated","title":"BaseModel \u88ab\u5b9e\u4f8b\u5316","text":"<p>\u5f53\u60a8\u76f4\u63a5\u5b9e\u4f8b\u5316 <code>BaseModel</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002Pydantic \u6a21\u578b\u5e94\u8be5\u7ee7\u627f\u81ea <code>BaseModel</code>\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError\n\ntry:\n    BaseModel()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'base-model-instantiated'\n</code></pre>"},{"location":"errors/usage_errors/#undefined-annotation","title":"\u672a\u5b9a\u4e49\u7684\u6ce8\u89e3","text":"<p>\u5728 <code>CoreSchema</code> \u751f\u6210\u8fc7\u7a0b\u4e2d\u5904\u7406\u672a\u5b9a\u4e49\u7684\u6ce8\u89e3\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUndefinedAnnotation\n\n\nclass Model(BaseModel):\n    a: 'B'  # noqa F821\n\n\ntry:\n    Model.model_rebuild()\nexcept PydanticUndefinedAnnotation as exc_info:\n    assert exc_info.code == 'undefined-annotation'\n</code></pre>"},{"location":"errors/usage_errors/#schema-for-unknown-type","title":"\u672a\u77e5\u7c7b\u578b\u7684\u6a21\u5f0f","text":"<p>\u5f53 Pydantic \u65e0\u6cd5\u4e3a\u67d0\u4e9b\u7c7b\u578b\u751f\u6210 <code>CoreSchema</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: 43 = 123\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'schema-for-unknown-type'\n</code></pre>"},{"location":"errors/usage_errors/#import-error","title":"\u5bfc\u5165\u9519\u8bef","text":"<p>\u5f53\u60a8\u5c1d\u8bd5\u5bfc\u5165\u5728 Pydantic V1 \u4e2d\u53ef\u7528\u4f46\u5728 Pydantic V2 \u4e2d\u5df2\u88ab\u79fb\u9664\u7684\u5bf9\u8c61\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u8fc1\u79fb\u6307\u5357\u3002</p>"},{"location":"errors/usage_errors/#create-model-field-definitions","title":"<code>create_model</code> \u5b57\u6bb5\u5b9a\u4e49","text":"<p>\u5f53\u60a8\u5728 <code>create_model()</code> \u4e2d\u63d0\u4f9b\u65e0\u6548\u7684\u5b57\u6bb5\u5b9a\u4e49\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import PydanticUserError, create_model\n\ntry:\n    create_model('FooModel', foo=(str, 'default value', 'more'))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'create-model-field-definitions'\n</code></pre> <p>\u5b57\u6bb5\u5b9a\u4e49\u8bed\u6cd5\u53ef\u4ee5\u5728\u52a8\u6001\u6a21\u578b\u521b\u5efa\u6587\u6863\u4e2d\u627e\u5230\u3002</p>"},{"location":"errors/usage_errors/#validator-no-fields","title":"\u9a8c\u8bc1\u5668\u65e0\u5b57\u6bb5","text":"<p>\u5f53\u60a8\u4f7f\u7528\u88f8\u9a8c\u8bc1\u5668\uff08\u6ca1\u6709\u5b57\u6bb5\uff09\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator\n        def checker(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-no-fields'\n</code></pre> <p>\u9a8c\u8bc1\u5668\u5e94\u8be5\u4e0e\u5b57\u6bb5\u548c\u5173\u952e\u5b57\u53c2\u6570\u4e00\u8d77\u4f7f\u7528\u3002</p> <pre><code>from pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    def checker(cls, v):\n        return v\n</code></pre>"},{"location":"errors/usage_errors/#validator-invalid-fields","title":"\u65e0\u6548\u7684\u9a8c\u8bc1\u5668\u5b57\u6bb5","text":"<p>\u5f53\u60a8\u4f7f\u7528\u975e\u5b57\u7b26\u4e32\u5b57\u6bb5\u7684\u9a8c\u8bc1\u5668\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n        b: str\n\n        @field_validator(['a', 'b'])\n        def check_fields(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-invalid-fields'\n</code></pre> <p>\u5b57\u6bb5\u5e94\u8be5\u4f5c\u4e3a\u5355\u72ec\u7684\u5b57\u7b26\u4e32\u53c2\u6570\u4f20\u9012\uff1a</p> <pre><code>from pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n    b: str\n\n    @field_validator('a', 'b')\n    def check_fields(cls, v):\n        return v\n</code></pre>"},{"location":"errors/usage_errors/#validator-instance-method","title":"\u9a8c\u8bc1\u5668\u5e94\u7528\u4e8e\u5b9e\u4f8b\u65b9\u6cd5","text":"<p>\u5f53\u60a8\u5c06\u9a8c\u8bc1\u5668\u5e94\u7528\u4e8e\u5b9e\u4f8b\u65b9\u6cd5\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a')\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-instance-method'\n</code></pre>"},{"location":"errors/usage_errors/#validator-input-type","title":"<code>json_schema_input_type</code> \u4e0e\u9519\u8bef\u7684\u6a21\u5f0f\u4e00\u8d77\u4f7f\u7528","text":"<p>\u5f53\u60a8\u660e\u786e\u4e3a <code>json_schema_input_type</code> \u53c2\u6570\u6307\u5b9a\u503c\uff0c\u4f46 <code>mode</code> \u672a\u8bbe\u7f6e\u4e3a <code>'before'</code>\u3001<code>'plain'</code> \u6216 <code>'wrap'</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a', mode='after', json_schema_input_type=int)\n        @classmethod\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-input-type'\n</code></pre> <p>\u8bb0\u5f55 JSON Schema \u8f93\u5165\u7c7b\u578b\u4ec5\u9002\u7528\u4e8e\u7ed9\u5b9a\u503c\u53ef\u4ee5\u662f\u4efb\u4f55\u5185\u5bb9\u7684\u9a8c\u8bc1\u5668\u3002\u8fd9\u5c31\u662f\u4e3a\u4ec0\u4e48\u5b83\u4e0d\u9002\u7528\u4e8e <code>after</code> \u9a8c\u8bc1\u5668\uff0c\u56e0\u4e3a\u5728 <code>after</code> \u9a8c\u8bc1\u5668\u4e2d\uff0c\u503c\u9996\u5148\u6839\u636e\u7c7b\u578b\u6ce8\u89e3\u8fdb\u884c\u9a8c\u8bc1\u3002</p>"},{"location":"errors/usage_errors/#root-validator-pre-skip","title":"\u6839\u9a8c\u8bc1\u5668\uff0c<code>pre</code>\uff0c<code>skip_on_failure</code>","text":"<p>\u5982\u679c\u60a8\u4f7f\u7528 <code>@root_validator</code> \u4e14 <code>pre=False</code>\uff08\u9ed8\u8ba4\u503c\uff09\uff0c\u5219\u5fc5\u987b\u6307\u5b9a <code>skip_on_failure=True</code>\u3002 <code>skip_on_failure=False</code> \u9009\u9879\u4e0d\u518d\u53ef\u7528\u3002</p> <p>\u5982\u679c\u60a8\u6ca1\u6709\u5c1d\u8bd5\u8bbe\u7f6e <code>skip_on_failure=False</code>\uff0c\u53ef\u4ee5\u5b89\u5168\u5730\u8bbe\u7f6e <code>skip_on_failure=True</code>\u3002 \u5982\u679c\u8fd9\u6837\u505a\uff0c\u5f53\u4efb\u4f55\u5b57\u6bb5\u9a8c\u8bc1\u5931\u8d25\u65f6\uff0c\u6b64\u6839\u9a8c\u8bc1\u5668\u5c06\u4e0d\u518d\u88ab\u8c03\u7528\u3002</p> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u8fc1\u79fb\u6307\u5357\u3002</p>"},{"location":"errors/usage_errors/#model-serializer-instance-method","title":"<code>model_serializer</code> \u5b9e\u4f8b\u65b9\u6cd5","text":"<p><code>@model_serializer</code> \u5fc5\u987b\u5e94\u7528\u4e8e\u5b9e\u4f8b\u65b9\u6cd5\u3002</p> <p>\u5f53\u60a8\u5728\u5b9e\u4f8b\u65b9\u6cd5\u4e0a\u5e94\u7528 <code>model_serializer</code> \u4f46\u6ca1\u6709 <code>self</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(slf, x, y, z):\n            return slf\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n</code></pre> <p>\u6216\u8005\u5728\u7c7b\u65b9\u6cd5\u4e0a\uff1a</p> <pre><code>from pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        @classmethod\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n</code></pre>"},{"location":"errors/usage_errors/#validator-field-config-info","title":"<code>validator</code>\u3001<code>field</code>\u3001<code>config</code> \u548c <code>info</code>","text":"<p><code>field</code> \u548c <code>config</code> \u53c2\u6570\u5728 Pydantic V2 \u4e2d\u4e0d\u53ef\u7528\u3002 \u8bf7\u6539\u7528 <code>info</code> \u53c2\u6570\u3002</p> <p>\u60a8\u53ef\u4ee5\u901a\u8fc7 <code>info.config</code> \u8bbf\u95ee\u914d\u7f6e\uff0c \u4f46\u5b83\u662f\u4e00\u4e2a\u5b57\u5178\uff0c\u800c\u4e0d\u662f\u50cf Pydantic V1 \u4e2d\u90a3\u6837\u7684\u5bf9\u8c61\u3002</p> <p><code>field</code> \u53c2\u6570\u4e0d\u518d\u53ef\u7528\u3002</p>"},{"location":"errors/usage_errors/#validator-v1-signature","title":"Pydantic V1 \u9a8c\u8bc1\u5668\u7b7e\u540d","text":"<p>\u5f53\u60a8\u4f7f\u7528\u4e0d\u652f\u6301\u7684 Pydantic V1 \u98ce\u683c\u9a8c\u8bc1\u5668\u7b7e\u540d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>import warnings\n\nfrom pydantic import BaseModel, PydanticUserError, validator\n\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\n\ntry:\n\n    class Model(BaseModel):\n        a: int\n\n        @validator('a')\n        def check_a(cls, value, foo):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-v1-signature'\n</code></pre>"},{"location":"errors/usage_errors/#validator-signature","title":"\u65e0\u6cd5\u8bc6\u522b\u7684 <code>field_validator</code> \u7b7e\u540d","text":"<p>\u5f53 <code>field_validator</code> \u6216 <code>model_validator</code> \u51fd\u6570\u5177\u6709\u9519\u8bef\u7684\u7b7e\u540d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def check_a(cls):\n            return 'a'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-signature'\n</code></pre>"},{"location":"errors/usage_errors/#field-serializer-signature","title":"\u65e0\u6cd5\u8bc6\u522b\u7684 <code>field_serializer</code> \u7b7e\u540d","text":"<p>\u5f53 <code>field_serializer</code> \u51fd\u6570\u5177\u6709\u9519\u8bef\u7684\u7b7e\u540d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class Model(BaseModel):\n        x: int\n\n        @field_serializer('x')\n        def no_args():\n            return 'x'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'field-serializer-signature'\n</code></pre> <p>\u6709\u6548\u7684\u5b57\u6bb5\u5e8f\u5217\u5316\u5668\u7b7e\u540d\u662f\uff1a</p> <pre><code>from pydantic import FieldSerializationInfo, SerializerFunctionWrapHandler, field_serializer\n\n# \u5177\u6709\u9ed8\u8ba4\u6a21\u5f0f\u6216 `mode='plain'` \u7684\u5b9e\u4f8b\u65b9\u6cd5\n@field_serializer('x')  # \u6216 @field_serializer('x', mode='plain')\ndef ser_x(self, value: Any, info: FieldSerializationInfo): ...\n\n# \u5177\u6709\u9ed8\u8ba4\u6a21\u5f0f\u6216 `mode='plain'` \u7684\u9759\u6001\u65b9\u6cd5\u6216\u51fd\u6570\n@field_serializer('x')  # \u6216 @field_serializer('x', mode='plain')\n@staticmethod\ndef ser_x(value: Any, info: FieldSerializationInfo): ...\n\n# \u7b49\u540c\u4e8e\ndef ser_x(value: Any, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)\n\n# \u5177\u6709 `mode='wrap'` \u7684\u5b9e\u4f8b\u65b9\u6cd5\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\n\n# \u5177\u6709 `mode='wrap'` \u7684\u9759\u6001\u65b9\u6cd5\u6216\u51fd\u6570\n@field_serializer('x', mode='wrap')\n@staticmethod\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\n\n# \u7b49\u540c\u4e8e\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)\n\n# \u5bf9\u4e8e\u6240\u6709\u8fd9\u4e9b\uff0c\u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u7701\u7565 `info` \u53c2\u6570\uff0c\u4f8b\u5982\uff1a\n@field_serializer('x')\ndef ser_x(self, value: Any): ...\n\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, handler: SerializerFunctionWrapHandler): ...\n</code></pre>"},{"location":"errors/usage_errors/#model-serializer-signature","title":"\u65e0\u6cd5\u8bc6\u522b\u7684 <code>model_serializer</code> \u7b7e\u540d","text":"<p>\u5f53 <code>model_serializer</code> \u51fd\u6570\u5177\u6709\u9519\u8bef\u7684\u7b7e\u540d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-signature'\n</code></pre> <p>\u6709\u6548\u7684\u6a21\u578b\u5e8f\u5217\u5316\u5668\u7b7e\u540d\u662f\uff1a</p> <pre><code>from pydantic import SerializerFunctionWrapHandler, SerializationInfo, model_serializer\n\n# \u5177\u6709\u9ed8\u8ba4\u6a21\u5f0f\u6216 `mode='plain'` \u7684\u5b9e\u4f8b\u65b9\u6cd5\n@model_serializer  # \u6216 model_serializer(mode='plain')\ndef mod_ser(self, info: SerializationInfo): ...\n\n# \u5177\u6709 `mode='wrap'` \u7684\u5b9e\u4f8b\u65b9\u6cd5\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler, info: SerializationInfo):\n\n# \u5bf9\u4e8e\u6240\u6709\u8fd9\u4e9b\uff0c\u60a8\u4e5f\u53ef\u4ee5\u9009\u62e9\u7701\u7565 `info` \u53c2\u6570\uff0c\u4f8b\u5982\uff1a\n@model_serializer(mode='plain')\ndef mod_ser(self): ...\n\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler): ...\n</code></pre>"},{"location":"errors/usage_errors/#multiple-field-serializers","title":"\u591a\u4e2a\u5b57\u6bb5\u5e8f\u5217\u5316\u5668","text":"<p>\u5f53\u4e3a\u5b57\u6bb5\u5b9a\u4e49\u4e86\u591a\u4e2a <code>model_serializer</code> \u51fd\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        x: int\n        y: int\n\n        @field_serializer('x', 'y')\n        def serializer1(v):\n            return f'{v:,}'\n\n        @field_serializer('x')\n        def serializer2(v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'multiple-field-serializers'\n</code></pre>"},{"location":"errors/usage_errors/#invalid-annotated-type","title":"\u65e0\u6548\u7684\u6ce8\u89e3\u7c7b\u578b","text":"<p>\u5f53\u6ce8\u89e3\u65e0\u6cd5\u6ce8\u89e3\u7c7b\u578b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from typing import Annotated\n\nfrom pydantic import BaseModel, FutureDate, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        foo: Annotated[str, FutureDate()]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-annotated-type'\n</code></pre>"},{"location":"errors/usage_errors/#type-adapter-config-unused","title":"<code>config</code> \u4e0e <code>TypeAdapter</code> \u4e00\u8d77\u4f7f\u7528\u65f6\u672a\u4f7f\u7528","text":"<p>\u5982\u679c\u60a8\u5c1d\u8bd5\u5c06 <code>config</code> \u4f20\u9012\u7ed9 <code>TypeAdapter</code>\uff0c\u4f46\u8be5\u7c7b\u578b\u5177\u6709\u65e0\u6cd5\u88ab\u8986\u76d6\u7684\u81ea\u5df1\u7684\u914d\u7f6e\uff08\u76ee\u524d\u53ea\u6709 <code>BaseModel</code>\u3001<code>TypedDict</code> \u548c <code>dataclass</code>\uff09\uff0c\u60a8\u5c06\u6536\u5230\u6b64\u9519\u8bef\uff1a</p> Python 3.9 and abovePython 3.13 and above <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, PydanticUserError, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n\ntry:\n    TypeAdapter(MyTypedDict, config=ConfigDict(strict=True))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'type-adapter-config-unused'\n</code></pre> <pre><code>from typing import TypedDict\n\nfrom pydantic import ConfigDict, PydanticUserError, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n\ntry:\n    TypeAdapter(MyTypedDict, config=ConfigDict(strict=True))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'type-adapter-config-unused'\n</code></pre> <p>\u76f8\u53cd\uff0c\u60a8\u9700\u8981\u5b50\u7c7b\u5316\u8be5\u7c7b\u578b\u5e76\u5728\u5176\u4e0a\u8986\u76d6\u6216\u8bbe\u7f6e\u914d\u7f6e\uff1a</p> Python 3.9 and abovePython 3.13 and above <pre><code>from typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n    # \u6216\u8005\u5bf9\u4e8e BaseModel \u4f7f\u7528 `model_config = ...`\n    __pydantic_config__ = ConfigDict(strict=True)\n\n\nTypeAdapter(MyTypedDict)  # \u6b63\u5e38\n</code></pre> <pre><code>from typing import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n    # \u6216\u8005\u5bf9\u4e8e BaseModel \u4f7f\u7528 `model_config = ...`\n    __pydantic_config__ = ConfigDict(strict=True)\n\n\nTypeAdapter(MyTypedDict)  # \u6b63\u5e38\n</code></pre>"},{"location":"errors/usage_errors/#root-model-extra","title":"\u65e0\u6cd5\u4e3a <code>RootModel</code> \u6307\u5b9a <code>model_config['extra']</code>","text":"<p>\u7531\u4e8e <code>RootModel</code> \u65e0\u6cd5\u5728\u521d\u59cb\u5316\u671f\u95f4\u5b58\u50a8\u751a\u81f3\u63a5\u53d7\u989d\u5916\u5b57\u6bb5\uff0c\u5982\u679c\u60a8\u5c1d\u8bd5\u5728\u521b\u5efa <code>RootModel</code> \u7684\u5b50\u7c7b\u65f6\u4e3a\u914d\u7f6e\u8bbe\u7f6e <code>'extra'</code> \u6307\u5b9a\u503c\uff0c\u6211\u4eec\u4f1a\u5f15\u53d1\u9519\u8bef\uff1a</p> <pre><code>from pydantic import PydanticUserError, RootModel\n\ntry:\n\n    class MyRootModel(RootModel):\n        model_config = {'extra': 'allow'}\n        root: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'root-model-extra'\n</code></pre>"},{"location":"errors/usage_errors/#unevaluable-type-annotation","title":"\u65e0\u6cd5\u8bc4\u4f30\u7c7b\u578b\u6ce8\u89e3","text":"<p>\u7531\u4e8e\u7c7b\u578b\u6ce8\u89e3\u5728\u8d4b\u503c\u4e4b\u540e\u8fdb\u884c\u8bc4\u4f30\uff0c\u5f53\u4f7f\u7528\u4e0e\u5b57\u6bb5\u540d\u79f0\u51b2\u7a81\u7684\u7c7b\u578b\u6ce8\u89e3\u540d\u79f0\u65f6\uff0c\u60a8\u53ef\u80fd\u4f1a\u5f97\u5230\u610f\u5916\u7684\u7ed3\u679c\u3002\u5728\u4ee5\u4e0b\u60c5\u51b5\u4e0b\u6211\u4eec\u4f1a\u5f15\u53d1\u9519\u8bef\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    date: date = Field(description='A date')\n</code></pre> <p>\u4f5c\u4e3a\u89e3\u51b3\u65b9\u6cd5\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528\u522b\u540d\u6216\u66f4\u6539\u5bfc\u5165\uff1a</p> <pre><code>import datetime\n# \u6216\u8005 `from datetime import date as _date`\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    date: datetime.date = Field(description='A date')\n</code></pre>"},{"location":"errors/usage_errors/#dataclass-init-false-extra-allow","title":"\u4e0d\u517c\u5bb9\u7684 <code>dataclass</code> <code>init</code> \u548c <code>extra</code> \u8bbe\u7f6e","text":"<p>Pydantic \u4e0d\u5141\u8bb8\u5728\u6570\u636e\u7c7b\u4e0a\u6307\u5b9a <code>extra='allow'</code> \u8bbe\u7f6e\uff0c\u540c\u65f6\u4efb\u4f55\u5b57\u6bb5\u8bbe\u7f6e\u4e86 <code>init=False</code>\u3002</p> <p>\u56e0\u6b64\uff0c\u60a8\u4e0d\u80fd\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a</p> <pre><code>from pydantic import ConfigDict, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(extra='allow'))\nclass A:\n    a: int = Field(init=False, default=1)\n</code></pre> <p>\u4e0a\u8ff0\u4ee3\u7801\u7247\u6bb5\u5728\u6784\u5efa\u6570\u636e\u7c7b <code>A</code> \u7684\u6a21\u5f0f\u65f6\u4f1a\u5bfc\u81f4\u4ee5\u4e0b\u9519\u8bef\uff1a</p> <pre><code>pydantic.errors.PydanticUserError: Field a has `init=False` and dataclass has config setting `extra=\"allow\"`.\nThis combination is not allowed.\n</code></pre>"},{"location":"errors/usage_errors/#clashing-init-and-init-var","title":"<code>dataclass</code> \u5b57\u6bb5\u4e0a\u4e0d\u517c\u5bb9\u7684 <code>init</code> \u548c <code>init_var</code> \u8bbe\u7f6e","text":"<p><code>init=False</code> \u548c <code>init_var=True</code> \u8bbe\u7f6e\u662f\u4e92\u65a5\u7684\u3002\u8fd9\u6837\u505a\u4f1a\u5bfc\u81f4\u5982\u4e0b\u793a\u4f8b\u4e2d\u6240\u793a\u7684 <code>PydanticUserError</code>\u3002</p> <pre><code>from pydantic import Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str = Field(init=False, init_var=True)\n\n\n\"\"\"\npydantic.errors.PydanticUserError: Dataclass field bar has init=False and init_var=True, but these are mutually exclusive.\n\"\"\"\n</code></pre>"},{"location":"errors/usage_errors/#model-config-invalid-field-name","title":"<code>model_config</code> \u88ab\u7528\u4f5c\u6a21\u578b\u5b57\u6bb5","text":"<p>\u5f53 <code>model_config</code> \u88ab\u7528\u4f5c\u5b57\u6bb5\u540d\u79f0\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-config-invalid-field-name'\n</code></pre>"},{"location":"errors/usage_errors/#with-config-on-model","title":"<code>with_config</code> \u5728 <code>BaseModel</code> \u5b50\u7c7b\u4e0a\u4f7f\u7528","text":"<p>\u5f53 <code>with_config</code> \u88c5\u9970\u5668\u7528\u4e8e\u5df2\u7ecf\u662f Pydantic \u6a21\u578b\u7684\u7c7b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff08\u8bf7\u6539\u7528 <code>model_config</code> \u5c5e\u6027\uff09\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError, with_config\n\ntry:\n\n    @with_config({'allow_inf_nan': True})\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'with-config-on-model'\n</code></pre>"},{"location":"errors/usage_errors/#dataclass-on-model","title":"<code>dataclass</code> \u5728 <code>BaseModel</code> \u5b50\u7c7b\u4e0a\u4f7f\u7528","text":"<p>\u5f53 Pydantic <code>dataclass</code> \u88c5\u9970\u5668\u7528\u4e8e\u5df2\u7ecf\u662f Pydantic \u6a21\u578b\u7684\u7c7b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <pre><code>from pydantic import BaseModel, PydanticUserError\nfrom pydantic.dataclasses import dataclass\n\ntry:\n\n    @dataclass\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'dataclass-on-model'\n</code></pre>"},{"location":"errors/usage_errors/#validate-call-type","title":"<code>validate_call</code> \u4e0d\u652f\u6301\u7684\u7c7b\u578b","text":"<p><code>validate_call</code> \u5bf9\u5176\u53ef\u4ee5\u9a8c\u8bc1\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u6709\u4e00\u4e9b\u9650\u5236\u3002\u5f53\u60a8\u5c1d\u8bd5\u5c06\u5176\u4e0e\u4e0d\u652f\u6301\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u4e00\u8d77\u4f7f\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002 \u76ee\u524d\u652f\u6301\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u5305\u62ec\u51fd\u6570\uff08\u5305\u62ec lambda\uff0c\u4f46\u4e0d\u5305\u62ec\u5185\u7f6e\u51fd\u6570\uff09\u3001\u65b9\u6cd5\u4ee5\u53ca <code>partial</code> \u7684\u5b9e\u4f8b\u3002 \u5bf9\u4e8e <code>partial</code>\uff0c\u88ab\u90e8\u5206\u5e94\u7528\u7684\u51fd\u6570\u5fc5\u987b\u662f\u53d7\u652f\u6301\u7684\u53ef\u8c03\u7528\u5bf9\u8c61\u4e4b\u4e00\u3002</p>"},{"location":"errors/usage_errors/#classmethodstaticmethod-property","title":"<code>@classmethod</code>\u3001<code>@staticmethod</code> \u548c <code>@property</code>","text":"<p>\u8fd9\u4e9b\u88c5\u9970\u5668\u5fc5\u987b\u653e\u5728 <code>validate_call</code> \u4e4b\u524d\u3002</p> <pre><code>from pydantic import PydanticUserError, validate_call\n\n# \u9519\u8bef\ntry:\n\n    class A:\n        @validate_call\n        @classmethod\n        def f1(cls): ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# \u6b63\u786e\n@classmethod\n@validate_call\ndef f2(cls): ...\n</code></pre>"},{"location":"errors/usage_errors/#_1","title":"\u7c7b","text":"<p>\u867d\u7136\u7c7b\u672c\u8eab\u662f\u53ef\u8c03\u7528\u5bf9\u8c61\uff0c\u4f46 <code>validate_call</code> \u4e0d\u80fd\u5e94\u7528\u4e8e\u5b83\u4eec\uff0c\u56e0\u4e3a\u5b83\u9700\u8981\u77e5\u9053\u4f7f\u7528\u54ea\u4e2a\u65b9\u6cd5\uff08<code>__init__</code> \u6216 <code>__new__</code>\uff09\u6765\u83b7\u53d6\u7c7b\u578b\u6ce8\u89e3\u3002\u5982\u679c\u60a8\u60f3\u9a8c\u8bc1\u7c7b\u7684\u6784\u9020\u51fd\u6570\uff0c\u5e94\u8be5\u5c06 <code>validate_call</code> \u653e\u5728\u9002\u5f53\u7684\u65b9\u6cd5\u4e0a\u3002</p> <pre><code>from pydantic import PydanticUserError, validate_call\n\n# \u9519\u8bef\ntry:\n\n    @validate_call\n    class A1: ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# \u6b63\u786e\nclass A2:\n    @validate_call\n    def __init__(self): ...\n\n    @validate_call\n    def __new__(cls): ...\n</code></pre>"},{"location":"errors/usage_errors/#_2","title":"\u53ef\u8c03\u7528\u5b9e\u4f8b","text":"<p>\u867d\u7136\u5b9e\u4f8b\u53ef\u4ee5\u901a\u8fc7\u5b9e\u73b0 <code>__call__</code> \u65b9\u6cd5\u53d8\u5f97\u53ef\u8c03\u7528\uff0c\u4f46\u76ee\u524d\u8fd9\u4e9b\u7c7b\u578b\u7684\u5b9e\u4f8b\u65e0\u6cd5\u4f7f\u7528 <code>validate_call</code> \u8fdb\u884c\u9a8c\u8bc1\u3002 \u8fd9\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u6539\u53d8\uff0c\u4f46\u76ee\u524d\uff0c\u60a8\u5e94\u8be5\u660e\u786e\u5728 <code>__call__</code> \u4e0a\u4f7f\u7528 <code>validate_call</code>\u3002</p> <pre><code>from pydantic import PydanticUserError, validate_call\n\n# \u9519\u8bef\ntry:\n\n    class A1:\n        def __call__(self): ...\n\n    validate_call(A1())\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# \u6b63\u786e\nclass A2:\n    @validate_call\n    def __call__(self): ...\n</code></pre>"},{"location":"errors/usage_errors/#_3","title":"\u65e0\u6548\u7b7e\u540d","text":"<p>\u8fd9\u79cd\u60c5\u51b5\u901a\u5e38\u8f83\u5c11\u89c1\uff0c\u4f46\u53ef\u80fd\u7684\u539f\u56e0\u662f\u60a8\u5c1d\u8bd5\u9a8c\u8bc1\u4e00\u4e2a\u6ca1\u6709\u81f3\u5c11\u4e00\u4e2a\u53c2\u6570\uff08\u901a\u5e38\u662f <code>self</code>\uff09\u7684\u65b9\u6cd5\u3002</p> <pre><code>from pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class A:\n        def f(): ...\n\n    validate_call(A().f)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n</code></pre>"},{"location":"errors/usage_errors/#unpack-typed-dict","title":"<code>Unpack</code> \u4e0e\u975e <code>TypedDict</code> \u4e00\u8d77\u4f7f\u7528","text":"<p>\u5f53 <code>Unpack</code> \u4e0e\u4e0d\u662f\u6709\u6548 <code>TypedDict</code> \u7684 <code>TypedDict</code> \u7c7b\u5bf9\u8c61\u4e00\u8d77\u4f7f\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u6709\u5173\u53c2\u8003\uff0c\u8bf7\u53c2\u9605[\u76f8\u5173\u89c4\u8303\u90e8\u5206]\u548cPEP 692\u3002</p> Python 3.9 and abovePython 3.12 and abovePython 3.13 and above <pre><code>from typing_extensions import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class TD(TypedDict):\n        x: int\n\n    @validate_call\n    def func(**kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n</code></pre> <pre><code>from typing_extensions import TypedDict\nfrom typing import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class TD(TypedDict):\n        x: int\n\n    @validate_call\n    def func(**kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n</code></pre> <pre><code>from typing import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class TD(TypedDict):\n        x: int\n\n    @validate_call\n    def func(**kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n</code></pre>"},{"location":"errors/usage_errors/#overlapping-unpack-typed-dict","title":"\u91cd\u53e0\u7684\u89e3\u5305 <code>TypedDict</code> \u5b57\u6bb5\u548c\u53c2\u6570","text":"<p>\u5f53\u7528\u4e8e\u7c7b\u578b\u63d0\u793a\u53ef\u53d8\u5173\u952e\u5b57\u53c2\u6570\u7684\u7c7b\u578b\u5b57\u5178\u7684\u5b57\u6bb5\u540d\u79f0\u4e0e\u5176\u4ed6\u53c2\u6570\u91cd\u53e0\u65f6\uff08\u9664\u975e\u662f\u4ec5\u4f4d\u7f6e\u53c2\u6570\uff09\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u6709\u5173\u53c2\u8003\uff0c\u8bf7\u53c2\u9605[\u76f8\u5173\u89c4\u8303\u90e8\u5206]\u548cPEP 692\u3002</p> Python 3.9 and abovePython 3.12 and abovePython 3.13 and above <pre><code>from typing_extensions import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n</code></pre> <pre><code>from typing_extensions import TypedDict\nfrom typing import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n</code></pre> <pre><code>from typing import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n</code></pre>"},{"location":"errors/usage_errors/#invalid-self-type","title":"\u65e0\u6548\u7684 <code>Self</code> \u7c7b\u578b","text":"<p>\u76ee\u524d\uff0c<code>Self</code> \u53ea\u80fd\u7528\u4e8e\u6ce8\u89e3\u7c7b\u7684\u5b57\u6bb5\uff08\u7279\u522b\u662f <code>BaseModel</code>\u3001<code>NamedTuple</code>\u3001<code>TypedDict</code> \u6216\u6570\u636e\u7c7b\u7684\u5b50\u7c7b\uff09\u3002\u5c1d\u8bd5\u4ee5\u4efb\u4f55\u5176\u4ed6\u65b9\u5f0f\u4f7f\u7528 <code>Self</code> \u90fd\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> Python 3.9 and abovePython 3.11 and above <pre><code>from typing_extensions import Self\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(self: Self):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n</code></pre> <pre><code>from typing import Self\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(self: Self):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n</code></pre> <p>\u4ee5\u4e0b <code>validate_call()</code> \u793a\u4f8b\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff0c\u5373\u4f7f\u4ece\u7c7b\u578b\u68c0\u67e5\u7684\u89d2\u5ea6\u6765\u770b\u662f\u6b63\u786e\u7684\u3002\u8fd9\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u5f97\u5230\u652f\u6301\u3002</p> Python 3.9 and abovePython 3.11 and above <pre><code>from typing_extensions import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n</code></pre> <pre><code>from typing import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n</code></pre>"},{"location":"errors/usage_errors/#validate-by-alias-and-name-false","title":"<code>validate_by_alias</code> \u548c <code>validate_by_name</code> \u90fd\u8bbe\u7f6e\u4e3a <code>False</code>","text":"<p>\u5f53\u60a8\u5728\u914d\u7f6e\u4e2d\u5c06 <code>validate_by_alias</code> \u548c <code>validate_by_name</code> \u90fd\u8bbe\u7f6e\u4e3a <code>False</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p> <p>\u8fd9\u662f\u4e0d\u5141\u8bb8\u7684\uff0c\u56e0\u4e3a\u5b83\u4f1a\u4f7f\u586b\u5145\u5c5e\u6027\u53d8\u5f97\u4e0d\u53ef\u80fd\u3002</p> <pre><code>from pydantic import BaseModel, ConfigDict, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a: int = Field(alias='A')\n\n        model_config = ConfigDict(\n            validate_by_alias=False, validate_by_name=False\n        )\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-by-alias-and-name-false'\n</code></pre>"},{"location":"errors/validation_errors/","title":"Validation Errors","text":"<p>Pydantic \u5c1d\u8bd5\u63d0\u4f9b\u6709\u7528\u7684\u9a8c\u8bc1\u9519\u8bef\u3002\u4ee5\u4e0b\u662f\u7528\u6237\u5728\u4f7f\u7528 pydantic \u65f6\u53ef\u80fd\u9047\u5230\u7684\u5e38\u89c1\u9a8c\u8bc1\u9519\u8bef\u7684\u8be6\u7ec6\u4fe1\u606f\uff0c\u4ee5\u53ca\u4e00\u4e9b\u4fee\u590d\u5efa\u8bae\u3002</p>"},{"location":"errors/validation_errors/#arguments_type","title":"<code>arguments_type</code>","text":"<p>\u5f53\u5728\u9a8c\u8bc1\u671f\u95f4\u4f20\u9012\u7ed9\u51fd\u6570\u4f5c\u4e3a\u53c2\u6570\u7684\u5bf9\u8c61\u4e0d\u662f <code>tuple</code>\u3001<code>list</code> \u6216 <code>dict</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002\u56e0\u4e3a <code>NamedTuple</code> \u5728\u5176\u5b9e\u73b0\u4e2d\u4f7f\u7528\u4e86\u51fd\u6570\u8c03\u7528\uff0c\u8fd9\u662f\u4ea7\u751f\u6b64\u9519\u8bef\u7684\u4e00\u79cd\u65b9\u5f0f\uff1a</p> <pre><code>from typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n\n\nclass MyModel(BaseModel):\n    field: MyNamedTuple\n\n\ntry:\n    MyModel.model_validate({'field': 'invalid'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'arguments_type'\n</code></pre>"},{"location":"errors/validation_errors/#assertion_error","title":"<code>assertion_error</code>","text":"<p>\u5f53\u5728\u9a8c\u8bc1\u671f\u95f4\u9047\u5230\u5931\u8d25\u7684 <code>assert</code> \u8bed\u53e5\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    @classmethod\n    def force_x_positive(cls, v):\n        assert v &gt; 0\n        return v\n\n\ntry:\n    Model(x=-1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'assertion_error'\n</code></pre>"},{"location":"errors/validation_errors/#bool_parsing","title":"<code>bool_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u4e00\u4e2a\u65e0\u6cd5\u5f3a\u5236\u8f6c\u6362\u4e3a\u5e03\u5c14\u503c\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\nModel(x='true')  # \u6b63\u5e38\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'bool_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#bool_type","title":"<code>bool_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>bool</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'bool_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>bool</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#bytes_invalid_encoding","title":"<code>bytes_invalid_encoding</code>","text":"<p>\u5f53 <code>bytes</code> \u503c\u5728\u914d\u7f6e\u7684\u7f16\u7801\u4e0b\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002 \u5728\u4ee5\u4e0b\u793a\u4f8b\u4e2d\uff0c<code>b'a'</code> \u662f\u65e0\u6548\u7684\u5341\u516d\u8fdb\u5236\uff08\u5947\u6570\u4f4d\u6570\uff09\u3002</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n    model_config = {'val_json_bytes': 'hex'}\n\n\ntry:\n    Model(x=b'a')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'bytes_invalid_encoding'\n</code></pre>"},{"location":"errors/validation_errors/#bytes_too_long","title":"<code>bytes_too_long</code>","text":"<p>\u5f53 <code>bytes</code> \u503c\u7684\u957f\u5ea6\u5927\u4e8e\u5b57\u6bb5\u7684 <code>max_length</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes = Field(max_length=3)\n\n\ntry:\n    Model(x=b'test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'bytes_too_long'\n</code></pre>"},{"location":"errors/validation_errors/#bytes_too_short","title":"<code>bytes_too_short</code>","text":"<p>\u5f53 <code>bytes</code> \u503c\u7684\u957f\u5ea6\u5c0f\u4e8e\u5b57\u6bb5\u7684 <code>min_length</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes = Field(min_length=3)\n\n\ntry:\n    Model(x=b't')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'bytes_too_short'\n</code></pre>"},{"location":"errors/validation_errors/#bytes_type","title":"<code>bytes_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>bytes</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bytes\n\n\ntry:\n    Model(x=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'bytes_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>bytes</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#callable_type","title":"<code>callable_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4f5c\u4e3a <code>Callable</code> \u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Any, Callable\n\nfrom pydantic import BaseModel, ImportString, ValidationError\n\n\nclass Model(BaseModel):\n    x: ImportString[Callable[[Any], Any]]\n\n\nModel(x='math:cos')  # \u6b63\u5e38\n\ntry:\n    Model(x='os.path')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'callable_type'\n</code></pre> <pre><code>from typing import Any\nfrom collections.abc import Callable\n\nfrom pydantic import BaseModel, ImportString, ValidationError\n\n\nclass Model(BaseModel):\n    x: ImportString[Callable[[Any], Any]]\n\n\nModel(x='math:cos')  # \u6b63\u5e38\n\ntry:\n    Model(x='os.path')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'callable_type'\n</code></pre>"},{"location":"errors/validation_errors/#complex_str_parsing","title":"<code>complex_str_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u4e00\u4e2a\u5b57\u7b26\u4e32\u4f46\u65e0\u6cd5\u89e3\u6790\u4e3a\u590d\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff0c\u56e0\u4e3a\u5b83\u4e0d\u9075\u5faa Python \u4e2d\u7684\u89c4\u5219\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    num: complex\n\n\ntry:\n    # JSON \u4e2d\u7684\u590d\u6570\u5e94\u4e3a\u6709\u6548\u7684\u590d\u6570\u5b57\u7b26\u4e32\u3002\n    # \u503c `abc` \u4e0d\u662f\u6709\u6548\u7684\u590d\u6570\u5b57\u7b26\u4e32\u3002\n    Model.model_validate_json('{\"num\": \"abc\"}')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'complex_str_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#complex_type","title":"<code>complex_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u65e0\u6cd5\u89e3\u91ca\u4e3a\u590d\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    num: complex\n\n\ntry:\n    Model(num=False)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'complex_type'\n</code></pre>"},{"location":"errors/validation_errors/#dataclass_exact_type","title":"<code>dataclass_exact_type</code>","text":"<p>\u5f53\u4f7f\u7528 <code>strict=True</code> \u9a8c\u8bc1\u6570\u636e\u7c7b\u4e14\u8f93\u5165\u4e0d\u662f\u8be5\u6570\u636e\u7c7b\u7684\u5b9e\u4f8b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>import pydantic.dataclasses\nfrom pydantic import TypeAdapter, ValidationError\n\n\n@pydantic.dataclasses.dataclass\nclass MyDataclass:\n    x: str\n\n\nadapter = TypeAdapter(MyDataclass)\n\nprint(adapter.validate_python(MyDataclass(x='test'), strict=True))\n#&gt; MyDataclass(x='test')\nprint(adapter.validate_python({'x': 'test'}))\n#&gt; MyDataclass(x='test')\n\ntry:\n    adapter.validate_python({'x': 'test'}, strict=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'dataclass_exact_type'\n</code></pre>"},{"location":"errors/validation_errors/#dataclass_type","title":"<code>dataclass_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u5bf9\u4e8e <code>dataclass</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, dataclasses\n\n\n@dataclasses.dataclass\nclass Inner:\n    x: int\n\n\n@dataclasses.dataclass\nclass Outer:\n    y: Inner\n\n\nOuter(y=Inner(x=1))  # \u6b63\u5e38\n\ntry:\n    Outer(y=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'dataclass_type'\n</code></pre>"},{"location":"errors/validation_errors/#date_from_datetime_inexact","title":"<code>date_from_datetime_inexact</code>","text":"<p>\u5f53\u4e3a <code>date</code> \u5b57\u6bb5\u63d0\u4f9b\u7684\u8f93\u5165 <code>datetime</code> \u503c\u5177\u6709\u975e\u96f6\u65f6\u95f4\u5206\u91cf\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002 \u5bf9\u4e8e\u8981\u89e3\u6790\u4e3a <code>date</code> \u7c7b\u578b\u5b57\u6bb5\u7684\u65f6\u95f4\u6233\uff0c\u65f6\u95f4\u5206\u91cf\u5fc5\u987b\u5168\u90e8\u4e3a\u96f6\uff1a</p> <pre><code>from datetime import date, datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\nModel(x='2023-01-01')  # \u6b63\u5e38\nModel(x=datetime(2023, 1, 1))  # \u6b63\u5e38\n\ntry:\n    Model(x=datetime(2023, 1, 1, 12))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'date_from_datetime_inexact'\n</code></pre>"},{"location":"errors/validation_errors/#date_from_datetime_parsing","title":"<code>date_from_datetime_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u4e00\u4e2a\u65e0\u6cd5\u4e3a <code>date</code> \u5b57\u6bb5\u89e3\u6790\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x='XX1494012000')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'date_from_datetime_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#date_future","title":"<code>date_future</code>","text":"<p>\u5f53\u4e3a <code>FutureDate</code> \u5b57\u6bb5\u63d0\u4f9b\u7684\u8f93\u5165\u503c\u4e0d\u5728\u672a\u6765\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel, FutureDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDate\n\n\ntry:\n    Model(x=date(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'date_future'\n</code></pre>"},{"location":"errors/validation_errors/#date_parsing","title":"<code>date_parsing</code>","text":"<p>\u5f53\u9a8c\u8bc1 JSON \u65f6\uff0c\u8f93\u5165\u503c\u662f\u65e0\u6cd5\u4e3a <code>date</code> \u5b57\u6bb5\u89e3\u6790\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>import json\nfrom datetime import date\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: date = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': '1'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'date_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#date_past","title":"<code>date_past</code>","text":"<p>\u5f53\u4e3a <code>PastDate</code> \u5b57\u6bb5\u63d0\u4f9b\u7684\u503c\u4e0d\u5728\u8fc7\u53bb\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import date, timedelta\n\nfrom pydantic import BaseModel, PastDate, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDate\n\n\ntry:\n    Model(x=date.today() + timedelta(1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'date_past'\n</code></pre>"},{"location":"errors/validation_errors/#date_type","title":"<code>date_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>date</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import date\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: date\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'date_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>date</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#datetime_from_date_parsing","title":"<code>datetime_from_date_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u4e00\u4e2a\u65e0\u6cd5\u4e3a <code>datetime</code> \u5b57\u6bb5\u89e3\u6790\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    # \u6ca1\u6709\u7b2c13\u4e2a\u6708\n    Model(x='2023-13-01')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'datetime_from_date_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#datetime_future","title":"<code>datetime_future</code>","text":"<p>\u5f53\u4e3a <code>FutureDatetime</code> \u5b57\u6bb5\u63d0\u4f9b\u7684\u503c\u4e0d\u5728\u672a\u6765\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, FutureDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: FutureDatetime\n\n\ntry:\n    Model(x=datetime(2000, 1, 1))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'datetime_future'\n</code></pre>"},{"location":"errors/validation_errors/#datetime_object_invalid","title":"<code>datetime_object_invalid</code>","text":"<p>\u5f53 <code>datetime</code> \u5bf9\u8c61\u7684\u67d0\u4e9b\u65b9\u9762\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime, tzinfo\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass CustomTz(tzinfo):\n    # utcoffset \u672a\u5b9e\u73b0\uff01\n\n    def tzname(self, _dt):\n        return 'CustomTZ'\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime(2023, 1, 1, tzinfo=CustomTz()))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'datetime_object_invalid'\n</code></pre>"},{"location":"errors/validation_errors/#datetime_parsing","title":"<code>datetime_parsing</code>","text":"<p>\u5f53\u503c\u662f\u4e00\u4e2a\u65e0\u6cd5\u4e3a <code>datetime</code> \u5b57\u6bb5\u89e3\u6790\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>import json\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': 'not a datetime'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'datetime_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#datetime_past","title":"<code>datetime_past</code>","text":"<p>\u5f53\u4e3a <code>PastDatetime</code> \u5b57\u6bb5\u63d0\u4f9b\u7684\u503c\u4e0d\u5728\u8fc7\u53bb\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime, timedelta\n\nfrom pydantic import BaseModel, PastDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDatetime\n\n\ntry:\n    Model(x=datetime.now() + timedelta(100))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'datetime_past'\n</code></pre>"},{"location":"errors/validation_errors/#datetime_type","title":"<code>datetime_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>datetime</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'datetime_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>datetime</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#decimal_max_digits","title":"<code>decimal_max_digits</code>","text":"<p>\u5f53\u4e3a <code>Decimal</code> \u63d0\u4f9b\u7684\u503c\u6709\u592a\u591a\u4f4d\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'decimal_max_digits'\n</code></pre>"},{"location":"errors/validation_errors/#decimal_max_places","title":"<code>decimal_max_places</code>","text":"<p>\u5f53\u4e3a <code>Decimal</code> \u63d0\u4f9b\u7684\u503c\u5728\u5c0f\u6570\u70b9\u540e\u6709\u592a\u591a\u4f4d\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='42.1234')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'decimal_max_places'\n</code></pre>"},{"location":"errors/validation_errors/#decimal_parsing","title":"<code>decimal_parsing</code>","text":"<p>\u5f53\u4e3a <code>Decimal</code> \u63d0\u4f9b\u7684\u503c\u65e0\u6cd5\u89e3\u6790\u4e3a\u5341\u8fdb\u5236\u6570\u5b57\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'decimal_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#decimal_type","title":"<code>decimal_type</code>","text":"<p>\u5f53\u4e3a <code>Decimal</code> \u63d0\u4f9b\u7684\u503c\u7c7b\u578b\u9519\u8bef\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(decimal_places=3)\n\n\ntry:\n    Model(x=[1, 2, 3])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'decimal_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>Decimal</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#decimal_whole_digits","title":"<code>decimal_whole_digits</code>","text":"<p>\u5f53\u4e3a <code>Decimal</code> \u63d0\u4f9b\u7684\u503c\u5728\u5c0f\u6570\u70b9\u524d\u7684\u4f4d\u6570\u8d85\u8fc7 <code>max_digits</code> - <code>decimal_places</code> \u65f6\uff08\u53ea\u8981\u4e24\u8005\u90fd\u6307\u5b9a\uff09\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from decimal import Decimal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: Decimal = Field(max_digits=6, decimal_places=3)\n\n\ntry:\n    Model(x='12345.6')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'decimal_whole_digits'\n</code></pre>"},{"location":"errors/validation_errors/#default_factory_not_called","title":"<code>default_factory_not_called</code>","text":"<p>\u5f53\u4f7f\u7528\u5df2\u9a8c\u8bc1\u6570\u636e\u7684\u9ed8\u8ba4\u5de5\u5382 \u65e0\u6cd5\u88ab\u8c03\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff0c\u56e0\u4e3a\u5148\u524d\u5b57\u6bb5\u7684\u9a8c\u8bc1\u5931\u8d25\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    a: int = Field(gt=10)\n    b: int = Field(default_factory=lambda data: data['a'])\n\n\ntry:\n    Model(a=1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    a\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    b\n      The default factory uses validated data, but at least one validation error occurred [type=default_factory_not_called]\n    \"\"\"\n    print(repr(exc.errors()[1]['type']))\n    #&gt; 'default_factory_not_called'\n</code></pre>"},{"location":"errors/validation_errors/#dict_type","title":"<code>dict_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>dict</code> \u5b57\u6bb5\u4e0d\u662f <code>dict</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict\n\n\ntry:\n    Model(x=['1', '2'])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'dict_type'\n</code></pre>"},{"location":"errors/validation_errors/#enum","title":"<code>enum</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u5b58\u5728\u4e8e <code>enum</code> \u5b57\u6bb5\u7684\u6210\u5458\u4e2d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from enum import Enum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyEnum(str, Enum):\n    option = 'option'\n\n\nclass Model(BaseModel):\n    x: MyEnum\n\n\ntry:\n    Model(x='other_option')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'enum'\n</code></pre>"},{"location":"errors/validation_errors/#extra_forbidden","title":"<code>extra_forbidden</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u5305\u542b\u989d\u5916\u5b57\u6bb5\uff0c\u4f46 <code>model_config['extra'] == 'forbid'</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n    model_config = ConfigDict(extra='forbid')\n\n\ntry:\n    Model(x='test', y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'extra_forbidden'\n</code></pre> <p>\u60a8\u53ef\u4ee5\u5728\u989d\u5916\u5c5e\u6027\u90e8\u5206\u9605\u8bfb\u66f4\u591a\u5173\u4e8e <code>extra</code> \u914d\u7f6e\u7684\u4fe1\u606f\u3002</p>"},{"location":"errors/validation_errors/#finite_number","title":"<code>finite_number</code>","text":"<p>\u5f53\u503c\u65e0\u9650\u5927\uff0c\u6216\u8005\u5728\u9a8c\u8bc1\u671f\u95f4\u592a\u5927\u800c\u65e0\u6cd5\u8868\u793a\u4e3a64\u4f4d\u6d6e\u70b9\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=2.2250738585072011e308)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'finite_number'\n</code></pre>"},{"location":"errors/validation_errors/#float_parsing","title":"<code>float_parsing</code>","text":"<p>\u5f53\u503c\u662f\u4e00\u4e2a\u65e0\u6cd5\u89e3\u6790\u4e3a <code>float</code> \u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: float\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'float_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#float_type","title":"<code>float_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>float</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: float\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'float_type'\n</code></pre>"},{"location":"errors/validation_errors/#frozen_field","title":"<code>frozen_field</code>","text":"<p>\u5f53\u60a8\u5c1d\u8bd5\u4e3a\u5177\u6709 <code>frozen=True</code> \u7684\u5b57\u6bb5\u8d4b\u503c\u6216\u5220\u9664\u6b64\u7c7b\u5b57\u6bb5\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field('test', frozen=True)\n\n\nmodel = Model()\n\ntry:\n    model.x = 'test1'\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'frozen_field'\n\ntry:\n    del model.x\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'frozen_field'\n</code></pre>"},{"location":"errors/validation_errors/#frozen_instance","title":"<code>frozen_instance</code>","text":"<p>\u5f53\u5728\u914d\u7f6e\u4e2d\u8bbe\u7f6e\u4e86 <code>frozen</code> \u5e76\u4e14\u60a8\u5c1d\u8bd5\u5220\u9664\u6216\u4e3a\u4efb\u4f55\u5b57\u6bb5\u5206\u914d\u65b0\u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(frozen=True)\n\n\nm = Model(x=1)\n\ntry:\n    m.x = 2\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'frozen_instance'\n\ntry:\n    del m.x\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'frozen_instance'\n</code></pre>"},{"location":"errors/validation_errors/#frozen_set_type","title":"<code>frozen_set_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>frozenset</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: frozenset\n\n\ntry:\n    model = Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'frozen_set_type'\n</code></pre>"},{"location":"errors/validation_errors/#get_attribute_error","title":"<code>get_attribute_error</code>","text":"<p>\u5f53 <code>model_config['from_attributes'] == True</code> \u5e76\u4e14\u5728\u8bfb\u53d6\u5c5e\u6027\u65f6\u5f15\u53d1\u9519\u8bef\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Foobar:\n    def __init__(self):\n        self.x = 1\n\n    @property\n    def y(self):\n        raise RuntimeError('intentional error')\n\n\nclass Model(BaseModel):\n    x: int\n    y: str\n\n    model_config = ConfigDict(from_attributes=True)\n\n\ntry:\n    Model.model_validate(Foobar())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'get_attribute_error'\n</code></pre>"},{"location":"errors/validation_errors/#greater_than","title":"<code>greater_than</code>","text":"<p>\u5f53\u503c\u4e0d\u5927\u4e8e\u5b57\u6bb5\u7684 <code>gt</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(gt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'greater_than'\n</code></pre>"},{"location":"errors/validation_errors/#greater_than_equal","title":"<code>greater_than_equal</code>","text":"<p>\u5f53\u503c\u4e0d\u5927\u4e8e\u6216\u7b49\u4e8e\u5b57\u6bb5\u7684 <code>ge</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(ge=10)\n\n\ntry:\n    Model(x=9)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'greater_than_equal'\n</code></pre>"},{"location":"errors/validation_errors/#int_from_float","title":"<code>int_from_float</code>","text":"<p>\u5f53\u60a8\u4e3a <code>int</code> \u5b57\u6bb5\u63d0\u4f9b <code>float</code> \u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=0.5)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'int_from_float'\n</code></pre>"},{"location":"errors/validation_errors/#int_parsing","title":"<code>int_parsing</code>","text":"<p>\u5f53\u503c\u65e0\u6cd5\u89e3\u6790\u4e3a <code>int</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'int_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#int_parsing_size","title":"<code>int_parsing_size</code>","text":"<p>\u5f53\u5c1d\u8bd5\u4ece\u8d85\u51fa Python <code>str</code> \u5230 <code>int</code> \u89e3\u6790\u5141\u8bb8\u7684\u6700\u5927\u8303\u56f4\u7684\u5b57\u7b26\u4e32\u89e3\u6790 Python \u6216 JSON \u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\n# \u4ece Python\nassert Model(x='1' * 4_300).x == int('1' * 4_300)  # \u6b63\u5e38\n\ntoo_long = '1' * 4_301\ntry:\n    Model(x=too_long)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'int_parsing_size'\n\n# \u4ece JSON\ntry:\n    Model.model_validate_json(json.dumps({'x': too_long}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'int_parsing_size'\n</code></pre>"},{"location":"errors/validation_errors/#int_type","title":"<code>int_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>int</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'int_type'\n</code></pre>"},{"location":"errors/validation_errors/#invalid_key","title":"<code>invalid_key</code>","text":"<p>\u5f53\u5c1d\u8bd5\u9a8c\u8bc1\u5177\u6709\u975e <code>str</code> \u5b9e\u4f8b\u952e\u7684 <code>dict</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\ntry:\n    Model.model_validate({'x': 1, b'y': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'invalid_key'\n</code></pre>"},{"location":"errors/validation_errors/#is_instance_of","title":"<code>is_instance_of</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u662f\u9884\u671f\u7c7b\u578b\u7684\u5b9e\u4f8b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: Nested\n\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'is_instance_of'\n</code></pre>"},{"location":"errors/validation_errors/#is_subclass_of","title":"<code>is_subclass_of</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u662f\u9884\u671f\u7c7b\u578b\u7684\u5b50\u7c7b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Nested:\n    x: str\n\n\nclass Model(BaseModel):\n    y: type[Nested]\n\n\ntry:\n    Model(y='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'is_subclass_of'\n</code></pre>"},{"location":"errors/validation_errors/#iterable_type","title":"<code>iterable_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4f5c\u4e3a <code>Iterable</code> \u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from collections.abc import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    y: Iterable[str]\n\n\ntry:\n    Model(y=123)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'iterable_type'\n</code></pre>"},{"location":"errors/validation_errors/#iteration_error","title":"<code>iteration_error</code>","text":"<p>\u5f53\u5728\u8fed\u4ee3\u671f\u95f4\u53d1\u751f\u9519\u8bef\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\ndef gen():\n    yield 1\n    raise RuntimeError('error')\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=gen())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'iteration_error'\n</code></pre>"},{"location":"errors/validation_errors/#json_invalid","title":"<code>json_invalid</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u662f\u6709\u6548\u7684 JSON \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'json_invalid'\n</code></pre>"},{"location":"errors/validation_errors/#json_type","title":"<code>json_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u65e0\u6cd5\u89e3\u6790\u4e3a JSON \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Json, ValidationError\n\n\nclass Model(BaseModel):\n    x: Json\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'json_type'\n</code></pre>"},{"location":"errors/validation_errors/#less_than","title":"<code>less_than</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u5c0f\u4e8e\u5b57\u6bb5\u7684 <code>lt</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(lt=10)\n\n\ntry:\n    Model(x=10)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'less_than'\n</code></pre>"},{"location":"errors/validation_errors/#less_than_equal","title":"<code>less_than_equal</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u5927\u4e8e\u6216\u7b49\u4e8e\u5b57\u6bb5\u7684 <code>le</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(le=10)\n\n\ntry:\n    Model(x=11)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'less_than_equal'\n</code></pre>"},{"location":"errors/validation_errors/#list_type","title":"<code>list_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>list</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int]\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'list_type'\n</code></pre>"},{"location":"errors/validation_errors/#literal_error","title":"<code>literal_error</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u662f\u9884\u671f\u7684\u5b57\u9762\u503c\u4e4b\u4e00\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: Literal['a', 'b']\n\n\nModel(x='a')  # \u6b63\u5e38\n\ntry:\n    Model(x='c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'literal_error'\n</code></pre>"},{"location":"errors/validation_errors/#mapping_type","title":"<code>mapping_type</code>","text":"<p>\u5f53\u7531\u4e8e\u8c03\u7528 <code>Mapping</code> \u534f\u8bae\u7684\u65b9\u6cd5\uff08\u4f8b\u5982 <code>.items()</code>\uff09\u5931\u8d25\u800c\u5728\u9a8c\u8bc1\u671f\u95f4\u53d1\u751f\u95ee\u9898\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from collections.abc import Mapping\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BadMapping(Mapping):\n    def items(self):\n        raise ValueError()\n\n    def __iter__(self):\n        raise ValueError()\n\n    def __getitem__(self, key):\n        raise ValueError()\n\n    def __len__(self):\n        return 1\n\n\nclass Model(BaseModel):\n    x: dict[str, str]\n\n\ntry:\n    Model(x=BadMapping())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'mapping_type'\n</code></pre>"},{"location":"errors/validation_errors/#missing","title":"<code>missing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e2d\u7f3a\u5c11\u5fc5\u9700\u5b57\u6bb5\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'missing'\n</code></pre>"},{"location":"errors/validation_errors/#missing_argument","title":"<code>missing_argument</code>","text":"<p>\u5f53\u672a\u5c06\u5fc5\u9700\u7684\u4f4d\u7f6e\u6216\u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u7ed9\u4f7f\u7528 <code>validate_call</code> \u88c5\u9970\u7684\u51fd\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'missing_argument'\n</code></pre>"},{"location":"errors/validation_errors/#missing_keyword_only_argument","title":"<code>missing_keyword_only_argument</code>","text":"<p>\u5f53\u672a\u5c06\u5fc5\u9700\u7684\u4ec5\u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\u7ed9\u4f7f\u7528 <code>validate_call</code> \u88c5\u9970\u7684\u51fd\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'missing_keyword_only_argument'\n</code></pre>"},{"location":"errors/validation_errors/#missing_positional_only_argument","title":"<code>missing_positional_only_argument</code>","text":"<p>\u5f53\u672a\u5c06\u5fc5\u9700\u7684\u4ec5\u4f4d\u7f6e\u53c2\u6570\u4f20\u9012\u7ed9\u4f7f\u7528 <code>validate_call</code> \u88c5\u9970\u7684\u51fd\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo()\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'missing_positional_only_argument'\n</code></pre>"},{"location":"errors/validation_errors/#missing_sentinel_error","title":"<code>missing_sentinel_error</code>","text":"<p>\u5f53\u5b9e\u9a8c\u6027\u7684 <code>MISSING</code> \u6807\u8bb0\u662f\u552f\u4e00\u5141\u8bb8\u7684\u503c\uff0c\u5e76\u4e14\u5728\u9a8c\u8bc1\u671f\u95f4\u672a\u63d0\u4f9b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\nfrom pydantic.experimental.missing_sentinel import MISSING\n\n\nclass Model(BaseModel):\n    f: MISSING\n\n\ntry:\n    Model(f=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'missing_sentinel_error'\n</code></pre>"},{"location":"errors/validation_errors/#model_attributes_type","title":"<code>model_attributes_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0d\u662f\u6709\u6548\u7684\u5b57\u5178\u3001\u6a21\u578b\u5b9e\u4f8b\u6216\u53ef\u4ee5\u4ece\u4e2d\u63d0\u53d6\u5b57\u6bb5\u7684\u5b9e\u4f8b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\n\n# \u7b80\u5355\u5730\u9a8c\u8bc1\u5b57\u5178\nprint(Model.model_validate({'a': 1, 'b': 2}))\n#&gt; a=1 b=2\n\n\nclass CustomObj:\n    def __init__(self, a, b):\n        self.a = a\n        self.b = b\n\n\n# \u4f7f\u7528 from_attributes \u4ece\u5bf9\u8c61\u4e2d\u63d0\u53d6\u5b57\u6bb5\nprint(Model.model_validate(CustomObj(3, 4), from_attributes=True))\n#&gt; a=3 b=4\n\ntry:\n    Model.model_validate('not an object', from_attributes=True)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'model_attributes_type'\n</code></pre>"},{"location":"errors/validation_errors/#model_type","title":"<code>model_type</code>","text":"<p>\u5f53\u6a21\u578b\u7684\u8f93\u5165\u4e0d\u662f\u6a21\u578b\u5b9e\u4f8b\u6216\u5b57\u5178\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int\n\n\n# \u7b80\u5355\u5730\u9a8c\u8bc1\u5b57\u5178\nm = Model.model_validate({'a': 1, 'b': 2})\nprint(m)\n#&gt; a=1 b=2\n\n# \u9a8c\u8bc1\u73b0\u6709\u7684\u6a21\u578b\u5b9e\u4f8b\nprint(Model.model_validate(m))\n#&gt; a=1 b=2\n\ntry:\n    Model.model_validate('not an object')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'model_type'\n</code></pre>"},{"location":"errors/validation_errors/#multiple_argument_values","title":"<code>multiple_argument_values</code>","text":"<p>\u5f53\u5728\u8c03\u7528\u4f7f\u7528 <code>validate_call</code> \u88c5\u9970\u7684\u51fd\u6570\u65f6\u4e3a\u5355\u4e2a\u53c2\u6570\u63d0\u4f9b\u591a\u4e2a\u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int):\n    return a\n\n\ntry:\n    foo(1, a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'multiple_argument_values'\n</code></pre>"},{"location":"errors/validation_errors/#multiple_of","title":"<code>multiple_of</code>","text":"<p>\u5f53\u8f93\u5165\u4e0d\u662f\u5b57\u6bb5\u7684 <code>multiple_of</code> \u7ea6\u675f\u7684\u500d\u6570\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: int = Field(multiple_of=5)\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'multiple_of'\n</code></pre>"},{"location":"errors/validation_errors/#needs_python_object","title":"<code>needs_python_object</code>","text":"<p>\u5f53\u5c1d\u8bd5\u9a8c\u8bc1\u65e0\u6cd5\u8f6c\u6362\u4e3a Python \u5bf9\u8c61\u7684\u683c\u5f0f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u7c7b\u9519\u8bef\u3002 \u4f8b\u5982\uff0c\u6211\u4eec\u65e0\u6cd5\u4ece JSON \u68c0\u67e5 <code>isinstance</code> \u6216 <code>issubclass</code>\uff1a</p> <pre><code>import json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    bm: type[BaseModel]\n\n\ntry:\n    Model.model_validate_json(json.dumps({'bm': 'not a basemodel class'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'needs_python_object'\n</code></pre>"},{"location":"errors/validation_errors/#no_such_attribute","title":"<code>no_such_attribute</code>","text":"<p>\u5f53\u914d\u7f6e\u4e2d\u8bbe\u7f6e\u4e86 <code>validate_assignment=True</code>\uff0c\u5e76\u4e14\u60a8\u5c1d\u8bd5\u4e3a\u4e0d\u662f\u73b0\u6709\u5b57\u6bb5\u7684\u5c5e\u6027\u8d4b\u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ConfigDict, ValidationError, dataclasses\n\n\n@dataclasses.dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass:\n    x: int\n\n\nm = MyDataclass(x=1)\ntry:\n    m.y = 10\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'no_such_attribute'\n</code></pre>"},{"location":"errors/validation_errors/#none_required","title":"<code>none_required</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u5bf9\u4e8e\u9700\u8981 <code>None</code> \u7684\u5b57\u6bb5\u4e0d\u662f <code>None</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: None\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'none_required'\n</code></pre> <p>Note</p> <p>\u5f53\u60a8\u7684\u6a21\u578b\u4e2d\u5b57\u6bb5\u540d\u79f0\u4e0e\u5176\u7c7b\u578b\u4e4b\u95f4\u5b58\u5728\u547d\u540d\u51b2\u7a81\u65f6\uff0c\u60a8\u53ef\u80fd\u4f1a\u9047\u5230\u6b64\u9519\u8bef\u3002\u66f4\u5177\u4f53\u5730\u8bf4\uff0c\u5f53\u8be5\u5b57\u6bb5\u7684\u9ed8\u8ba4\u503c\u4e3a <code>None</code> \u65f6\uff0c\u5f88\u53ef\u80fd\u4f1a\u629b\u51fa\u6b64\u9519\u8bef\u3002</p> <p>\u4f8b\u5982\uff0c\u4ee5\u4e0b\u4ee3\u7801\u4f1a\u4ea7\u751f <code>none_required</code> \u9a8c\u8bc1\u9519\u8bef\uff0c\u56e0\u4e3a\u5b57\u6bb5 <code>int</code> \u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u503c <code>None</code>\uff0c\u5e76\u4e14\u4e0e\u5176\u7c7b\u578b\u540d\u79f0\u5b8c\u5168\u76f8\u540c\uff0c\u8fd9\u4f1a\u5bfc\u81f4\u9a8c\u8bc1\u95ee\u9898\u3002</p> <pre><code>from typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass M1(BaseModel):\n    int: Optional[int] = None\n\n\nm = M1(int=123)  # \u9519\u8bef\n</code></pre>"},{"location":"errors/validation_errors/#recursion_loop","title":"<code>recursion_loop</code>","text":"<p>\u5f53\u68c0\u6d4b\u5230\u5faa\u73af\u5f15\u7528\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list['Model']\n\n\nd = {'x': []}\nd['x'].append(d)\ntry:\n    Model(**d)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'recursion_loop'\n</code></pre>"},{"location":"errors/validation_errors/#set_item_not_hashable","title":"<code>set_item_not_hashable</code>","text":"<p>\u5f53\u4e0d\u53ef\u54c8\u5e0c\u7684\u503c\u9488\u5bf9 <code>set</code> \u6216 <code>frozenset</code> \u8fdb\u884c\u9a8c\u8bc1\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[object]\n\n\nclass Unhashable:\n    __hash__ = None\n\n\ntry:\n    Model(x=[{'a': 'b'}, Unhashable()])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'set_item_not_hashable'\n    print(repr(exc.errors()[1]['type']))\n    #&gt; 'set_item_not_hashable'\n</code></pre>"},{"location":"errors/validation_errors/#set_type","title":"<code>set_type</code>","text":"<p>\u5f53\u503c\u7c7b\u578b\u5bf9\u4e8e <code>set</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[int]\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'set_type'\n</code></pre>"},{"location":"errors/validation_errors/#string_pattern_mismatch","title":"<code>string_pattern_mismatch</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u4e0e\u5b57\u6bb5\u7684 <code>pattern</code> \u7ea6\u675f\u4e0d\u5339\u914d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(pattern='test')\n\n\ntry:\n    Model(x='1')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'string_pattern_mismatch'\n</code></pre>"},{"location":"errors/validation_errors/#string_sub_type","title":"<code>string_sub_type</code>","text":"<p>\u5f53\u5b57\u6bb5\u662f\u4e25\u683c\u7684\u4e14\u503c\u662f <code>str</code> \u7684\u4e25\u683c\u5b50\u7c7b\u578b\u7684\u5b9e\u4f8b\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from enum import Enum\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass MyEnum(str, Enum):\n    foo = 'foo'\n\n\nclass Model(BaseModel):\n    x: str = Field(strict=True)\n\n\ntry:\n    Model(x=MyEnum.foo)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'string_sub_type'\n</code></pre>"},{"location":"errors/validation_errors/#string_too_long","title":"<code>string_too_long</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u4e00\u4e2a\u957f\u5ea6\u5927\u4e8e\u5b57\u6bb5\u7684 <code>max_length</code> \u7ea6\u675f\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(max_length=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'string_too_long'\n</code></pre>"},{"location":"errors/validation_errors/#string_too_short","title":"<code>string_too_short</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u4e00\u4e2a\u957f\u5ea6\u5c0f\u4e8e\u5b57\u6bb5\u7684 <code>min_length</code> \u7ea6\u675f\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(min_length=3)\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'string_too_short'\n</code></pre>"},{"location":"errors/validation_errors/#string_type","title":"<code>string_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>str</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'string_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>str</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#string_unicode","title":"<code>string_unicode</code>","text":"<p>\u5f53\u503c\u65e0\u6cd5\u89e3\u6790\u4e3a Unicode \u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=b'\\x81')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'string_unicode'\n</code></pre>"},{"location":"errors/validation_errors/#time_delta_parsing","title":"<code>time_delta_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u65e0\u6cd5\u4e3a <code>timedelta</code> \u5b57\u6bb5\u89e3\u6790\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'time_delta_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#time_delta_type","title":"<code>time_delta_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>timedelta</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'time_delta_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>timedelta</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#time_parsing","title":"<code>time_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u662f\u65e0\u6cd5\u4e3a <code>time</code> \u5b57\u6bb5\u89e3\u6790\u7684\u5b57\u7b26\u4e32\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x='25:20:30.400')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'time_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#time_type","title":"<code>time_type</code>","text":"<p>\u5f53\u503c\u7c7b\u578b\u5bf9\u4e8e <code>time</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'time_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>time</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#timezone_aware","title":"<code>timezone_aware</code>","text":"<p>\u5f53\u4e3a\u65f6\u533a\u611f\u77e5\u7684 <code>datetime</code> \u5b57\u6bb5\u63d0\u4f9b\u7684 <code>datetime</code> \u503c\u6ca1\u6709\u65f6\u533a\u4fe1\u606f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime.now())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'timezone_aware'\n</code></pre>"},{"location":"errors/validation_errors/#timezone_naive","title":"<code>timezone_naive</code>","text":"<p>\u5f53\u4e3a\u65f6\u533a\u65e0\u5173\u7684 <code>datetime</code> \u5b57\u6bb5\u63d0\u4f9b\u7684 <code>datetime</code> \u503c\u6709\u65f6\u533a\u4fe1\u606f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from datetime import datetime, timezone\n\nfrom pydantic import BaseModel, NaiveDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: NaiveDatetime\n\n\ntry:\n    Model(x=datetime.now(tz=timezone.utc))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'timezone_naive'\n</code></pre>"},{"location":"errors/validation_errors/#too_long","title":"<code>too_long</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u957f\u5ea6\u5927\u4e8e\u5b57\u6bb5\u7684 <code>max_length</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(max_length=3)\n\n\ntry:\n    Model(x=[1, 2, 3, 4])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'too_long'\n</code></pre>"},{"location":"errors/validation_errors/#too_short","title":"<code>too_short</code>","text":"<p>\u5f53\u503c\u957f\u5ea6\u5c0f\u4e8e\u5b57\u6bb5\u7684 <code>min_length</code> \u7ea6\u675f\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(min_length=3)\n\n\ntry:\n    Model(x=[1, 2])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'too_short'\n</code></pre>"},{"location":"errors/validation_errors/#tuple_type","title":"<code>tuple_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e <code>tuple</code> \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: tuple[int]\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'tuple_type'\n</code></pre> <p>\u5bf9\u4e8e\u4e25\u683c\u5b57\u6bb5\uff0c\u5f53\u8f93\u5165\u503c\u4e0d\u662f <code>tuple</code> \u7684\u5b9e\u4f8b\u65f6\uff0c\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\u3002</p>"},{"location":"errors/validation_errors/#unexpected_keyword_argument","title":"<code>unexpected_keyword_argument</code>","text":"<p>\u5f53\u60a8\u5728\u8c03\u7528\u4f7f\u7528 <code>validate_call</code> \u88c5\u9970\u7684\u51fd\u6570\u65f6\uff0c\u4e3a\u4ec5\u9650\u4f4d\u7f6e\u7684\u53c2\u6570\u63d0\u4f9b\u5173\u952e\u5b57\u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo(a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #&gt; 'unexpected_keyword_argument'\n</code></pre> <p>\u5728\u4f7f\u7528 pydantic.dataclasses \u548c <code>extra=forbid</code> \u65f6\u4e5f\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import TypeAdapter, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config={'extra': 'forbid'})\nclass Foo:\n    bar: int\n\n\ntry:\n    TypeAdapter(Foo).validate_python({'bar': 1, 'foobar': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'unexpected_keyword_argument'\n</code></pre>"},{"location":"errors/validation_errors/#unexpected_positional_argument","title":"<code>unexpected_positional_argument</code>","text":"<p>\u5f53\u60a8\u5728\u8c03\u7528\u4f7f\u7528 <code>validate_call</code> \u88c5\u9970\u7684\u51fd\u6570\u65f6\uff0c\u4e3a\u4ec5\u9650\u5173\u952e\u5b57\u7684\u53c2\u6570\u63d0\u4f9b\u4f4d\u7f6e\u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo(2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #&gt; 'unexpected_positional_argument'\n</code></pre>"},{"location":"errors/validation_errors/#union_tag_invalid","title":"<code>union_tag_invalid</code>","text":"<p>\u5f53\u8f93\u5165\u7684\u9274\u522b\u5668\u4e0d\u662f\u9884\u671f\u503c\u4e4b\u4e00\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'pet_type': 'dog'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'union_tag_invalid'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: BlackCat | WhiteCat = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'pet_type': 'dog'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'union_tag_invalid'\n</code></pre>"},{"location":"errors/validation_errors/#union_tag_not_found","title":"<code>union_tag_not_found</code>","text":"<p>\u5f53\u65e0\u6cd5\u4ece\u8f93\u5165\u4e2d\u63d0\u53d6\u9274\u522b\u5668\u503c\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'name': 'blackcat'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'union_tag_not_found'\n</code></pre> <pre><code>from typing import Literal\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: BlackCat | WhiteCat = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'name': 'blackcat'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'union_tag_not_found'\n</code></pre>"},{"location":"errors/validation_errors/#url_parsing","title":"<code>url_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u65e0\u6cd5\u89e3\u6790\u4e3a URL \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import AnyUrl, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AnyUrl\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'url_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#url_scheme","title":"<code>url_scheme</code>","text":"<p>\u5f53 URL \u65b9\u6848\u5bf9\u4e8e\u5b57\u6bb5\u7684 URL \u7c7b\u578b\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='ftp://example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'url_scheme'\n</code></pre>"},{"location":"errors/validation_errors/#url_syntax_violation","title":"<code>url_syntax_violation</code>","text":"<p>\u5f53 URL \u8bed\u6cd5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, Field, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl = Field(strict=True)\n\n\ntry:\n    Model(x='http:////example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'url_syntax_violation'\n</code></pre>"},{"location":"errors/validation_errors/#url_too_long","title":"<code>url_too_long</code>","text":"<p>\u5f53 URL \u957f\u5ea6\u5927\u4e8e 2083 \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='x' * 2084)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'url_too_long'\n</code></pre>"},{"location":"errors/validation_errors/#url_type","title":"<code>url_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e URL \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'url_type'\n</code></pre>"},{"location":"errors/validation_errors/#uuid_parsing","title":"<code>uuid_parsing</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u5bf9\u4e8e UUID \u5b57\u6bb5\u65e0\u6548\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u='12345678-124-1234-1234-567812345678')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'uuid_parsing'\n</code></pre>"},{"location":"errors/validation_errors/#uuid_type","title":"<code>uuid_type</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u4e0d\u662f UUID \u5b57\u6bb5\u7684\u6709\u6548\u5b9e\u4f8b\uff08str\u3001bytes \u6216 UUID\uff09\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u=1234567812412341234567812345678)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'uuid_type'\n</code></pre>"},{"location":"errors/validation_errors/#uuid_version","title":"<code>uuid_version</code>","text":"<p>\u5f53\u8f93\u5165\u503c\u7684\u7c7b\u578b\u4e0e UUID \u7248\u672c\u4e0d\u5339\u914d\u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import UUID5, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID5\n\n\ntry:\n    Model(u='a6cc5730-2261-11ee-9c43-2eb5a363657c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'uuid_version'\n</code></pre>"},{"location":"errors/validation_errors/#value_error","title":"<code>value_error</code>","text":"<p>\u5f53\u5728\u9a8c\u8bc1\u8fc7\u7a0b\u4e2d\u5f15\u53d1 <code>ValueError</code> \u65f6\uff0c\u4f1a\u5f15\u53d1\u6b64\u9519\u8bef\uff1a</p> <pre><code>from pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: str\n\n    @field_validator('x')\n    @classmethod\n    def repeat_b(cls, v):\n        raise ValueError()\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #&gt; 'value_error'\n</code></pre>"},{"location":"examples/custom_validators/","title":"Custom Validators","text":"<p>\u672c\u9875\u9762\u63d0\u4f9b\u4e86\u521b\u5efa\u66f4\u590d\u6742\u7684\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u7684\u793a\u4f8b\u4ee3\u7801\u7247\u6bb5\u3002 \u8fd9\u4e9b\u793a\u4f8b\u5927\u591a\u6539\u7f16\u81ea Pydantic \u7684\u95ee\u9898\u548c\u8ba8\u8bba\uff0c\u65e8\u5728\u5c55\u793a Pydantic \u9a8c\u8bc1\u7cfb\u7edf\u7684\u7075\u6d3b\u6027\u548c\u5f3a\u5927\u529f\u80fd\u3002</p>"},{"location":"examples/custom_validators/#annotated-datetime","title":"\u901a\u8fc7 <code>Annotated</code> \u5143\u6570\u636e\u7684\u81ea\u5b9a\u4e49 <code>datetime</code> \u9a8c\u8bc1\u5668","text":"<p>\u5728\u8fd9\u4e2a\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u5c06\u6784\u5efa\u4e00\u4e2a\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\uff0c\u9644\u52a0\u5230 <code>Annotated</code> \u7c7b\u578b\u4e0a\uff0c \u786e\u4fdd <code>datetime</code> \u5bf9\u8c61\u7b26\u5408\u7ed9\u5b9a\u7684\u65f6\u533a\u7ea6\u675f\u3002</p> <p>\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u652f\u6301\u5b57\u7b26\u4e32\u5f62\u5f0f\u7684\u65f6\u533a\u89c4\u8303\uff0c\u5982\u679c <code>datetime</code> \u5bf9\u8c61\u6ca1\u6709\u6b63\u786e\u7684\u65f6\u533a\uff0c\u5c06\u5f15\u53d1\u9519\u8bef\u3002</p> <p>\u6211\u4eec\u5728\u9a8c\u8bc1\u5668\u4e2d\u4f7f\u7528 <code>__get_pydantic_core_schema__</code> \u6765\u81ea\u5b9a\u4e49\u6ce8\u89e3\u7c7b\u578b\u7684\u6a21\u5f0f\uff08\u5728\u672c\u4f8b\u4e2d\u4e3a <code>datetime</code>\uff09\uff0c\u8fd9\u5141\u8bb8\u6211\u4eec\u6dfb\u52a0\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u903b\u8f91\u3002\u503c\u5f97\u6ce8\u610f\u7684\u662f\uff0c\u6211\u4eec\u4f7f\u7528 <code>wrap</code> \u9a8c\u8bc1\u5668\u51fd\u6570\uff0c\u4ee5\u4fbf\u6211\u4eec\u53ef\u4ee5\u5728\u9ed8\u8ba4\u7684 <code>pydantic</code> \u5bf9 <code>datetime</code> \u7684\u9a8c\u8bc1\u524d\u540e\u6267\u884c\u64cd\u4f5c\u3002</p> Python 3.9 and abovePython 3.10 and above <pre><code>import datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable, Optional\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: Optional[str] = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)!\n    ):\n        \"\"\"\u9a8c\u8bc1 tz_constraint \u548c tz_info\u3002\"\"\"\n        # \u5904\u7406\u6734\u7d20\u65e5\u671f\u65f6\u95f4\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint \u4e3a None\uff0c\u4f46\u63d0\u4f9b\u7684\u503c\u6709\u65f6\u533a\u4fe1\u606f\u3002'\n            return handler(value)\n\n        # \u9a8c\u8bc1 tz_constraint \u548c\u6709\u65f6\u533a\u4fe1\u606f\u7684 tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'\u65e0\u6548\u7684 tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!\n        assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'\u65e0\u6548\u7684 tzinfo: {str(result.tzinfo)}, \u671f\u671b: {self.tz_constraint}'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#&gt; 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=&lt;DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD&gt;),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n</code></pre> <ol> <li><code>handler</code> \u51fd\u6570\u662f\u6211\u4eec\u7528\u6765\u4f7f\u7528\u6807\u51c6 <code>pydantic</code> \u9a8c\u8bc1\u6765\u9a8c\u8bc1\u8f93\u5165\u7684\u51fd\u6570</li> <li>\u5728\u8fd9\u4e2a\u5305\u88c5\u9a8c\u8bc1\u5668\u4e2d\uff0c\u6211\u4eec\u8c03\u7528 <code>handler</code> \u51fd\u6570\u6765\u4f7f\u7528\u6807\u51c6 <code>pydantic</code> \u9a8c\u8bc1\u6765\u9a8c\u8bc1\u8f93\u5165</li> </ol> <pre><code>import datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: str | None = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)!\n    ):\n        \"\"\"\u9a8c\u8bc1 tz_constraint \u548c tz_info\u3002\"\"\"\n        # \u5904\u7406\u6734\u7d20\u65e5\u671f\u65f6\u95f4\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint \u4e3a None\uff0c\u4f46\u63d0\u4f9b\u7684\u503c\u6709\u65f6\u533a\u4fe1\u606f\u3002'\n            return handler(value)\n\n        # \u9a8c\u8bc1 tz_constraint \u548c\u6709\u65f6\u533a\u4fe1\u606f\u7684 tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'\u65e0\u6548\u7684 tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!\n        assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'\u65e0\u6548\u7684 tzinfo: {str(result.tzinfo)}, \u671f\u671b: {self.tz_constraint}'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#&gt; 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=&lt;DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD&gt;),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n</code></pre> <ol> <li><code>handler</code> \u51fd\u6570\u662f\u6211\u4eec\u7528\u6765\u4f7f\u7528\u6807\u51c6 <code>pydantic</code> \u9a8c\u8bc1\u6765\u9a8c\u8bc1\u8f93\u5165\u7684\u51fd\u6570</li> <li>\u5728\u8fd9\u4e2a\u5305\u88c5\u9a8c\u8bc1\u5668\u4e2d\uff0c\u6211\u4eec\u8c03\u7528 <code>handler</code> \u51fd\u6570\u6765\u4f7f\u7528\u6807\u51c6 <code>pydantic</code> \u9a8c\u8bc1\u6765\u9a8c\u8bc1\u8f93\u5165</li> </ol> <p>\u6211\u4eec\u4e5f\u53ef\u4ee5\u7528\u7c7b\u4f3c\u7684\u65b9\u5f0f\u5f3a\u5236\u6267\u884cUTC\u504f\u79fb\u7ea6\u675f\u3002\u5047\u8bbe\u6211\u4eec\u6709\u4e00\u4e2a <code>lower_bound</code> \u548c\u4e00\u4e2a <code>upper_bound</code>\uff0c\u6211\u4eec\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\u6765\u786e\u4fdd\u6211\u4eec\u7684 <code>datetime</code> \u7684UTC\u504f\u79fb\u5728\u6211\u4eec\u5b9a\u4e49\u7684\u8fb9\u754c\u5185\uff08\u5305\u542b\u8fb9\u754c\uff09\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>import datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter, ValidationError\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    lower_bound: int\n    upper_bound: int\n\n    def validate_tz_bounds(self, value: dt.datetime, handler: Callable):\n        \"\"\"\u9a8c\u8bc1\u548c\u6d4b\u8bd5\u8fb9\u754c\"\"\"\n        assert value.utcoffset() is not None, 'UTC\u504f\u79fb\u5fc5\u987b\u5b58\u5728'\n        assert self.lower_bound &lt;= self.upper_bound, '\u65e0\u6548\u7684\u8fb9\u754c'\n\n        result = handler(value)\n\n        hours_offset = value.utcoffset().total_seconds() / 3600\n        assert (\n            self.lower_bound &lt;= hours_offset &lt;= self.upper_bound\n        ), '\u503c\u8d85\u51fa\u8fb9\u754c'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.validate_tz_bounds,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'  # UTC-7 or UTC-8\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(-10, -5)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#&gt; 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    print(\n        ta.validate_python(\n            dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n        )\n    )\nexcept ValidationError as e:\n    pprint(e.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Value out of bounds')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=&lt;DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD&gt;),\n    'loc': (),\n    'msg': 'Assertion failed, Value out of bounds',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n</code></pre> <pre><code>import datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any\nfrom collections.abc import Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter, ValidationError\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    lower_bound: int\n    upper_bound: int\n\n    def validate_tz_bounds(self, value: dt.datetime, handler: Callable):\n        \"\"\"\u9a8c\u8bc1\u548c\u6d4b\u8bd5\u8fb9\u754c\"\"\"\n        assert value.utcoffset() is not None, 'UTC\u504f\u79fb\u5fc5\u987b\u5b58\u5728'\n        assert self.lower_bound &lt;= self.upper_bound, '\u65e0\u6548\u7684\u8fb9\u754c'\n\n        result = handler(value)\n\n        hours_offset = value.utcoffset().total_seconds() / 3600\n        assert (\n            self.lower_bound &lt;= hours_offset &lt;= self.upper_bound\n        ), '\u503c\u8d85\u51fa\u8fb9\u754c'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -&gt; CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.validate_tz_bounds,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'  # UTC-7 or UTC-8\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(-10, -5)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#&gt; 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    print(\n        ta.validate_python(\n            dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n        )\n    )\nexcept ValidationError as e:\n    pprint(e.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Value out of bounds')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=&lt;DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD&gt;),\n    'loc': (),\n    'msg': 'Assertion failed, Value out of bounds',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n</code></pre>"},{"location":"examples/custom_validators/#_1","title":"\u9a8c\u8bc1\u5d4c\u5957\u6a21\u578b\u5b57\u6bb5","text":"<p>\u5728\u8fd9\u91cc\uff0c\u6211\u4eec\u6f14\u793a\u4e86\u4e24\u79cd\u9a8c\u8bc1\u5d4c\u5957\u6a21\u578b\u5b57\u6bb5\u7684\u65b9\u6cd5\uff0c\u5176\u4e2d\u9a8c\u8bc1\u5668\u5229\u7528\u6765\u81ea\u7236\u6a21\u578b\u7684\u6570\u636e\u3002</p> <p>\u5728\u8fd9\u4e2a\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u6784\u5efa\u4e00\u4e2a\u9a8c\u8bc1\u5668\uff0c\u68c0\u67e5\u6bcf\u4e2a\u7528\u6237\u7684\u5bc6\u7801\u662f\u5426\u4e0d\u5728\u7236\u6a21\u578b\u6307\u5b9a\u7684\u7981\u6b62\u5bc6\u7801\u5217\u8868\u4e2d\u3002</p> <p>\u4e00\u79cd\u65b9\u6cd5\u662f\u5728\u5916\u90e8\u6a21\u578b\u4e0a\u653e\u7f6e\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\uff1a</p> Python 3.9 and abovePython 3.11 and above <pre><code>from typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @model_validator(mode='after')\n    def validate_user_passwords(self) -&gt; Self:\n        \"\"\"\u68c0\u67e5\u7528\u6237\u5bc6\u7801\u662f\u5426\u4e0d\u5728\u7981\u6b62\u5217\u8868\u4e2d\u3002\u5982\u679c\u9047\u5230\u7981\u6b62\u5bc6\u7801\uff0c\u5219\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\u3002\"\"\"\n        for user in self.users:\n            current_pw = user.password\n            if current_pw in self.forbidden_passwords:\n                raise ValueError(\n                    f'Password {current_pw} is forbidden. Please choose another password for user {user.username}.'\n                )\n        return self\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\ntry:\n    org = Organization(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n      Value error, Password 123 is forbidden. Please choose another password for user Spartacat. [type=value_error, input_value={'forbidden_passwords': [...gh', 'password': '87'}]}, input_type=dict]\n    \"\"\"\n</code></pre> <pre><code>from typing import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @model_validator(mode='after')\n    def validate_user_passwords(self) -&gt; Self:\n        \"\"\"\u68c0\u67e5\u7528\u6237\u5bc6\u7801\u662f\u5426\u4e0d\u5728\u7981\u6b62\u5217\u8868\u4e2d\u3002\u5982\u679c\u9047\u5230\u7981\u6b62\u5bc6\u7801\uff0c\u5219\u5f15\u53d1\u9a8c\u8bc1\u9519\u8bef\u3002\"\"\"\n        for user in self.users:\n            current_pw = user.password\n            if current_pw in self.forbidden_passwords:\n                raise ValueError(\n                    f'Password {current_pw} is forbidden. Please choose another password for user {user.username}.'\n                )\n        return self\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\ntry:\n    org = Organization(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n      Value error, Password 123 is forbidden. Please choose another password for user Spartacat. [type=value_error, input_value={'forbidden_passwords': [...gh', 'password': '87'}]}, input_type=dict]\n    \"\"\"\n</code></pre> <p>\u6216\u8005\uff0c\u53ef\u4ee5\u5728\u5d4c\u5957\u6a21\u578b\u7c7b\uff08<code>User</code>\uff09\u4e2d\u4f7f\u7528\u81ea\u5b9a\u4e49\u9a8c\u8bc1\u5668\uff0c\u901a\u8fc7\u9a8c\u8bc1\u4e0a\u4e0b\u6587\u4f20\u9012\u6765\u81ea\u7236\u6a21\u578b\u7684\u7981\u6b62\u5bc6\u7801\u6570\u636e\u3002</p> <p>Warning</p> <p>\u5728\u9a8c\u8bc1\u5668\u5185\u4fee\u6539\u4e0a\u4e0b\u6587\u7684\u80fd\u529b\u4e3a\u5d4c\u5957\u9a8c\u8bc1\u589e\u52a0\u4e86\u5f88\u5927\u7684\u7075\u6d3b\u6027\uff0c\u4f46\u4e5f\u53ef\u80fd\u5bfc\u81f4\u4ee3\u7801\u96be\u4ee5\u7406\u89e3\u6216\u8c03\u8bd5\u3002\u8bf7\u81ea\u884c\u627f\u62c5\u4f7f\u7528\u6b64\u65b9\u6cd5\u7684\u98ce\u9669\uff01</p> <pre><code>from pydantic import BaseModel, ValidationError, ValidationInfo, field_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n    @field_validator('password', mode='after')\n    @classmethod\n    def validate_user_passwords(\n        cls, password: str, info: ValidationInfo\n    ) -&gt; str:\n        \"\"\"\u68c0\u67e5\u7528\u6237\u5bc6\u7801\u662f\u5426\u4e0d\u5728\u7981\u6b62\u5217\u8868\u4e2d\u3002\"\"\"\n        forbidden_passwords = (\n            info.context.get('forbidden_passwords', []) if info.context else []\n        )\n        if password in forbidden_passwords:\n            raise ValueError(f'Password {password} is forbidden.')\n        return password\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @field_validator('forbidden_passwords', mode='after')\n    @classmethod\n    def add_context(cls, v: list[str], info: ValidationInfo) -&gt; list[str]:\n        if info.context is not None:\n            info.context.update({'forbidden_passwords': v})\n        return v\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\n\ntry:\n    org = Organization.model_validate(data, context={})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n    users.0.password\n      Value error, Password 123 is forbidden. [type=value_error, input_value='123', input_type=str]\n    \"\"\"\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u5982\u679c\u5728 <code>model_validate</code> \u4e2d\u672a\u5305\u542b context \u5c5e\u6027\uff0c\u5219 <code>info.context</code> \u5c06\u4e3a <code>None</code>\uff0c\u5e76\u4e14\u5728\u4e0a\u9762\u7684\u5b9e\u73b0\u4e2d\uff0c\u7981\u6b62\u5bc6\u7801\u5217\u8868\u5c06\u4e0d\u4f1a\u88ab\u6dfb\u52a0\u5230\u4e0a\u4e0b\u6587\u4e2d\u3002\u56e0\u6b64\uff0c<code>validate_user_passwords</code> \u5c06\u4e0d\u4f1a\u6267\u884c\u6240\u9700\u7684\u5bc6\u7801\u9a8c\u8bc1\u3002</p> <p>\u6709\u5173\u9a8c\u8bc1\u4e0a\u4e0b\u6587\u7684\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605\u9a8c\u8bc1\u5668\u6587\u6863\u3002</p>"},{"location":"examples/files/","title":"Validating File Data","text":"<p><code>pydantic</code> \u662f\u4e00\u4e2a\u7528\u4e8e\u9a8c\u8bc1\u6765\u81ea\u5404\u79cd\u6765\u6e90\u6570\u636e\u7684\u5f3a\u5927\u5de5\u5177\u3002 \u5728\u672c\u8282\u4e2d\uff0c\u6211\u4eec\u5c06\u4e86\u89e3\u5982\u4f55\u9a8c\u8bc1\u6765\u81ea\u4e0d\u540c\u7c7b\u578b\u6587\u4ef6\u7684\u6570\u636e\u3002</p> <p>Note</p> <p>\u5982\u679c\u60a8\u4f7f\u7528\u4ee5\u4e0b\u4efb\u4f55\u6587\u4ef6\u683c\u5f0f\u6765\u89e3\u6790\u914d\u7f6e/\u8bbe\u7f6e\uff0c\u60a8\u53ef\u80fd\u60f3\u8981 \u8003\u8651\u4f7f\u7528 <code>pydantic-settings</code> \u5e93\uff0c\u5b83\u63d0\u4f9b\u4e86\u5185\u7f6e\u7684 \u652f\u6301\u6765\u89e3\u6790\u6b64\u7c7b\u6570\u636e\u3002</p>"},{"location":"examples/files/#json","title":"JSON \u6570\u636e","text":"<p><code>.json</code> \u6587\u4ef6\u662f\u4e00\u79cd\u4ee5\u4eba\u7c7b\u53ef\u8bfb\u683c\u5f0f\u5b58\u50a8\u952e/\u503c\u6570\u636e\u7684\u5e38\u89c1\u65b9\u5f0f\u3002 \u4ee5\u4e0b\u662f\u4e00\u4e2a <code>.json</code> \u6587\u4ef6\u7684\u793a\u4f8b\uff1a</p> <pre><code>{\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"email\": \"john@example.com\"\n}\n</code></pre> <p>\u8981\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\uff0c\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a <code>pydantic</code> \u6a21\u578b\uff1a</p> <pre><code>import pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\nperson = Person.model_validate_json(json_string)\nprint(person)\n#&gt; name='John Doe' age=30 email='john@example.com'\n</code></pre> <p>\u5982\u679c\u6587\u4ef6\u4e2d\u7684\u6570\u636e\u65e0\u6548\uff0c<code>pydantic</code> \u5c06\u5f15\u53d1\u4e00\u4e2a <code>ValidationError</code>\u3002 \u5047\u8bbe\u6211\u4eec\u6709\u4ee5\u4e0b <code>.json</code> \u6587\u4ef6\uff1a</p> <pre><code>{\n    \"age\": -30,\n    \"email\": \"not-an-email-address\"\n}\n</code></pre> <p>\u8fd9\u4e9b\u6570\u636e\u5b58\u5728\u4e09\u4e2a\u95ee\u9898\uff1a</p> <ol> <li>\u7f3a\u5c11 <code>name</code> \u5b57\u6bb5\u3002</li> <li><code>age</code> \u5b57\u6bb5\u4e3a\u8d1f\u6570\u3002</li> <li><code>email</code> \u5b57\u6bb5\u4e0d\u662f\u6709\u6548\u7684\u7535\u5b50\u90ae\u4ef6\u5730\u5740\u3002</li> </ol> <p>\u5f53\u6211\u4eec\u5c1d\u8bd5\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\u65f6\uff0c<code>pydantic</code> \u4f1a\u5f15\u53d1\u4e00\u4e2a <code>ValidationError</code>\uff0c\u5176\u4e2d\u5305\u542b\u6240\u6709 \u4e0a\u8ff0\u95ee\u9898\uff1a</p> <pre><code>import pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, ValidationError\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\ntry:\n    person = Person.model_validate_json(json_string)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    3 validation errors for Person\n    name\n    Field required [type=missing, input_value={'age': -30, 'email': 'not-an-email-address'}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2.10/v/missing\n    age\n    Input should be greater than 0 [type=greater_than, input_value=-30, input_type=int]\n        For further information visit https://errors.pydantic.dev/2.10/v/greater_than\n    email\n    value is not a valid email address: An email address must have an @-sign. [type=value_error, input_value='not-an-email-address', input_type=str]\n    \"\"\"\n</code></pre> <p>\u901a\u5e38\uff0c\u60a8\u53ef\u80fd\u5728 <code>.json</code> \u6587\u4ef6\u4e2d\u62e5\u6709\u5927\u91cf\u67d0\u79cd\u7c7b\u578b\u7684\u6570\u636e\u3002 \u4f8b\u5982\uff0c\u60a8\u53ef\u80fd\u6709\u4e00\u4e2a\u4eba\u5458\u5217\u8868\uff1a</p> <pre><code>[\n    {\n        \"name\": \"John Doe\",\n        \"age\": 30,\n        \"email\": \"john@example.com\"\n    },\n    {\n        \"name\": \"Jane Doe\",\n        \"age\": 25,\n        \"email\": \"jane@example.com\"\n    }\n]\n</code></pre> <p>\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u60a8\u53ef\u4ee5\u9488\u5bf9 <code>list[Person]</code> \u6a21\u578b\u9a8c\u8bc1\u6570\u636e\uff1a</p> <pre><code>import pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, TypeAdapter\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nperson_list_adapter = TypeAdapter(list[Person])  # (1)!\n\njson_string = pathlib.Path('people.json').read_text()\npeople = person_list_adapter.validate_json(json_string)\nprint(people)\n#&gt; [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n</code></pre> <ol> <li>\u6211\u4eec\u4f7f\u7528 <code>TypeAdapter</code> \u6765\u9a8c\u8bc1 <code>Person</code> \u5bf9\u8c61\u5217\u8868\u3002 <code>TypeAdapter</code> \u662f\u4e00\u4e2a Pydantic \u6784\u9020\uff0c\u7528\u4e8e\u9488\u5bf9\u5355\u4e00\u7c7b\u578b\u9a8c\u8bc1\u6570\u636e\u3002</li> </ol>"},{"location":"examples/files/#json-lines","title":"JSON lines \u6587\u4ef6","text":"<p>\u4e0e\u9a8c\u8bc1\u6765\u81ea <code>.json</code> \u6587\u4ef6\u7684\u5bf9\u8c61\u5217\u8868\u7c7b\u4f3c\uff0c\u60a8\u53ef\u4ee5\u9a8c\u8bc1\u6765\u81ea <code>.jsonl</code> \u6587\u4ef6\u7684\u5bf9\u8c61\u5217\u8868\u3002 <code>.jsonl</code> \u6587\u4ef6\u662f\u7531\u6362\u884c\u7b26\u5206\u9694\u7684 JSON \u5bf9\u8c61\u5e8f\u5217\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b <code>.jsonl</code> \u6587\u4ef6\uff1a</p> <pre><code>{\"name\": \"John Doe\", \"age\": 30, \"email\": \"john@example.com\"}\n{\"name\": \"Jane Doe\", \"age\": 25, \"email\": \"jane@example.com\"}\n</code></pre> <p>\u6211\u4eec\u53ef\u4ee5\u4f7f\u7528\u4e0e\u5904\u7406 <code>.json</code> \u6587\u4ef6\u7c7b\u4f3c\u7684\u65b9\u6cd5\u6765\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\uff1a</p> <pre><code>import pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_lines = pathlib.Path('people.jsonl').read_text().splitlines()\npeople = [Person.model_validate_json(line) for line in json_lines]\nprint(people)\n#&gt; [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n</code></pre>"},{"location":"examples/files/#csv","title":"CSV \u6587\u4ef6","text":"<p>CSV \u662f\u5b58\u50a8\u8868\u683c\u6570\u636e\u6700\u5e38\u89c1\u7684\u6587\u4ef6\u683c\u5f0f\u4e4b\u4e00\u3002 \u8981\u9a8c\u8bc1\u6765\u81ea CSV \u6587\u4ef6\u7684\u6570\u636e\uff0c\u60a8\u53ef\u4ee5\u4f7f\u7528 Python \u6807\u51c6\u5e93\u4e2d\u7684 <code>csv</code> \u6a21\u5757\u6765\u52a0\u8f7d \u6570\u636e\uff0c\u5e76\u4f7f\u7528 Pydantic \u6a21\u578b\u8fdb\u884c\u9a8c\u8bc1\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b CSV \u6587\u4ef6\uff1a</p> <pre><code>name,age,email\nJohn Doe,30,john@example.com\nJane Doe,25,jane@example.com\n</code></pre> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\u7684\u65b9\u6cd5\uff1a</p> <pre><code>import csv\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('people.csv') as f:\n    reader = csv.DictReader(f)\n    people = [Person.model_validate(row) for row in reader]\n\nprint(people)\n#&gt; [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n</code></pre>"},{"location":"examples/files/#toml","title":"TOML \u6587\u4ef6","text":"<p>TOML \u6587\u4ef6\u56e0\u5176\u7b80\u5355\u6027\u548c\u53ef\u8bfb\u6027\u800c\u5e38\u7528\u4e8e\u914d\u7f6e\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b TOML \u6587\u4ef6\uff1a</p> <pre><code>name = \"John Doe\"\nage = 30\nemail = \"john@example.com\"\n</code></pre> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\u7684\u65b9\u6cd5\uff1a</p> <pre><code>import tomllib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.toml', 'rb') as f:\n    data = tomllib.load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#&gt; name='John Doe' age=30 email='john@example.com'\n</code></pre>"},{"location":"examples/files/#yaml","title":"YAML \u6587\u4ef6","text":"<p>YAML\uff08YAML Ain't Markup Language\uff09\u662f\u4e00\u79cd\u4eba\u7c7b\u53ef\u8bfb\u7684\u6570\u636e\u5e8f\u5217\u5316\u683c\u5f0f\uff0c\u5e38\u7528\u4e8e\u914d\u7f6e\u6587\u4ef6\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b YAML \u6587\u4ef6\uff1a</p> <pre><code>name: John Doe\nage: 30\nemail: john@example.com\n</code></pre> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\u7684\u65b9\u6cd5\uff1a</p> <pre><code>import yaml\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.yaml') as f:\n    data = yaml.safe_load(f)\n\nperson = Person.model_validate(data)\nprint(person)\n#&gt; name='John Doe' age=30 email='john@example.com'\n</code></pre>"},{"location":"examples/files/#xml","title":"XML \u6587\u4ef6","text":"<p>XML\uff08\u53ef\u6269\u5c55\u6807\u8bb0\u8bed\u8a00\uff09\u662f\u4e00\u79cd\u6807\u8bb0\u8bed\u8a00\uff0c\u5b9a\u4e49\u4e86\u4e00\u7ec4\u89c4\u5219\uff0c\u7528\u4e8e\u4ee5\u4eba\u7c7b\u53ef\u8bfb\u548c\u673a\u5668\u53ef\u8bfb\u7684\u683c\u5f0f\u7f16\u7801\u6587\u6863\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b XML \u6587\u4ef6\uff1a</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;person&gt;\n    &lt;name&gt;John Doe&lt;/name&gt;\n    &lt;age&gt;30&lt;/age&gt;\n    &lt;email&gt;john@example.com&lt;/email&gt;\n&lt;/person&gt;\n</code></pre> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\u7684\u65b9\u6cd5\uff1a</p> <pre><code>import xml.etree.ElementTree as ET\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\ntree = ET.parse('person.xml').getroot()\ndata = {child.tag: child.text for child in tree}\nperson = Person.model_validate(data)\nprint(person)\n#&gt; name='John Doe' age=30 email='john@example.com'\n</code></pre>"},{"location":"examples/files/#ini","title":"INI \u6587\u4ef6","text":"<p>INI \u6587\u4ef6\u662f\u4e00\u79cd\u7b80\u5355\u7684\u914d\u7f6e\u6587\u4ef6\u683c\u5f0f\uff0c\u4f7f\u7528\u8282\u548c\u952e\u503c\u5bf9\u3002\u5b83\u4eec\u5e38\u7528\u4e8e Windows \u5e94\u7528\u7a0b\u5e8f\u548c\u8f83\u65e7\u7684\u8f6f\u4ef6\u3002</p> <p>\u8003\u8651\u4ee5\u4e0b INI \u6587\u4ef6\uff1a</p> <pre><code>[PERSON]\nname = John Doe\nage = 30\nemail = john@example.com\n</code></pre> <p>\u4ee5\u4e0b\u662f\u6211\u4eec\u9a8c\u8bc1\u8fd9\u4e9b\u6570\u636e\u7684\u65b9\u6cd5\uff1a</p> <pre><code>import configparser\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nconfig = configparser.ConfigParser()\nconfig.read('person.ini')\nperson = Person.model_validate(config['PERSON'])\nprint(person)\n#&gt; name='John Doe' age=30 email='john@example.com'\n</code></pre>"},{"location":"examples/orms/","title":"Databases","text":"<p>Pydantic \u662f\u5b9a\u4e49 ORM\uff08\u5bf9\u8c61\u5173\u7cfb\u6620\u5c04\uff09\u5e93\u6a21\u578b\u7684\u7edd\u4f73\u5de5\u5177\u3002 ORM \u7528\u4e8e\u5c06\u5bf9\u8c61\u6620\u5c04\u5230\u6570\u636e\u5e93\u8868\uff0c\u53cd\u4e4b\u4ea6\u7136\u3002</p>"},{"location":"examples/orms/#sqlalchemy","title":"SQLAlchemy","text":"<p>Pydantic \u53ef\u4ee5\u4e0e SQLAlchemy \u914d\u5408\u4f7f\u7528\uff0c\u56e0\u4e3a\u5b83\u53ef\u4ee5\u7528\u4e8e\u5b9a\u4e49\u6570\u636e\u5e93\u6a21\u578b\u7684\u6a21\u5f0f\u3002</p> <p>\u4ee3\u7801\u91cd\u590d</p> <p>\u5982\u679c\u60a8\u5c06 Pydantic \u4e0e SQLAlchemy \u4e00\u8d77\u4f7f\u7528\uff0c\u53ef\u80fd\u4f1a\u9047\u5230\u4ee3\u7801\u91cd\u590d\u7684\u56f0\u6270\u3002 \u5982\u679c\u60a8\u9047\u5230\u8fd9\u79cd\u56f0\u96be\uff0c\u4e5f\u53ef\u4ee5\u8003\u8651\u4f7f\u7528 <code>SQLModel</code>\uff0c\u5b83\u5c06 Pydantic \u4e0e SQLAlchemy \u96c6\u6210\uff0c\u4ece\u800c\u6d88\u9664\u4e86\u5927\u90e8\u5206\u4ee3\u7801\u91cd\u590d\u3002</p> <p>\u5982\u679c\u60a8\u66f4\u503e\u5411\u4e8e\u4f7f\u7528\u7eaf Pydantic \u4e0e SQLAlchemy\uff0c\u6211\u4eec\u5efa\u8bae\u5c06 Pydantic \u6a21\u578b\u4e0e SQLAlchemy \u6a21\u578b\u4e00\u8d77\u4f7f\u7528\uff0c \u5982\u4e0b\u9762\u7684\u793a\u4f8b\u6240\u793a\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u6211\u4eec\u5229\u7528 Pydantic \u7684\u522b\u540d\u529f\u80fd\uff0c\u5c06 <code>Column</code> \u547d\u540d\u4e3a\u4fdd\u7559\u7684 SQLAlchemy \u5b57\u6bb5\u4e4b\u540e\uff0c\u4ece\u800c\u907f\u514d\u51b2\u7a81\u3002</p> <pre><code>import sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    metadata: dict[str, str] = Field(alias='metadata_')\n\n\nBase = declarative_base()\n\n\nclass MyTableModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' \u662f SQLAlchemy \u7684\u4fdd\u7559\u5b57\u6bb5\uff0c\u56e0\u6b64\u6dfb\u52a0\u4e86 '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = MyTableModel(metadata_={'key': 'val'}, id=1)\npydantic_model = MyModel.model_validate(sql_model)\n\nprint(pydantic_model.model_dump())\n#&gt; {'metadata': {'key': 'val'}}\nprint(pydantic_model.model_dump(by_alias=True))\n#&gt; {'metadata_': {'key': 'val'}}\n</code></pre> <p>Note</p> <p>\u4e0a\u9762\u7684\u793a\u4f8b\u4e4b\u6240\u4ee5\u6709\u6548\uff0c\u662f\u56e0\u4e3a\u522b\u540d\u5728\u5b57\u6bb5\u586b\u5145\u65f6\u4f18\u5148\u4e8e\u5b57\u6bb5\u540d\u79f0\u3002 \u8bbf\u95ee <code>SQLModel</code> \u7684 <code>metadata</code> \u5c5e\u6027\u5c06\u5bfc\u81f4 <code>ValidationError</code>\u3002</p>"},{"location":"examples/queues/","title":"Queues","text":"<p>Pydantic \u5bf9\u4e8e\u9a8c\u8bc1\u8fdb\u51fa\u961f\u5217\u7684\u6570\u636e\u975e\u5e38\u6709\u5e2e\u52a9\u3002\u4e0b\u9762\uff0c \u6211\u4eec\u5c06\u63a2\u8ba8\u5982\u4f55\u4f7f\u7528\u5404\u79cd\u961f\u5217\u7cfb\u7edf\u6765\u9a8c\u8bc1/\u5e8f\u5217\u5316\u6570\u636e\u3002</p>"},{"location":"examples/queues/#redis","title":"Redis \u961f\u5217","text":"<p>Redis \u662f\u4e00\u79cd\u6d41\u884c\u7684\u5185\u5b58\u6570\u636e\u7ed3\u6784\u5b58\u50a8\u3002</p> <p>\u4e3a\u4e86\u5728\u672c\u5730\u8fd0\u884c\u6b64\u793a\u4f8b\uff0c\u60a8\u9996\u5148\u9700\u8981\u5b89\u88c5 Redis \u5e76\u5728\u672c\u5730\u542f\u52a8\u670d\u52a1\u5668\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\uff0c\u5c55\u793a\u5982\u4f55\u4f7f\u7528 Pydantic \u6765\uff1a</p> <ol> <li>\u5e8f\u5217\u5316\u6570\u636e\u4ee5\u63a8\u9001\u5230\u961f\u5217</li> <li>\u4ece\u961f\u5217\u4e2d\u5f39\u51fa\u6570\u636e\u65f6\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u548c\u9a8c\u8bc1</li> </ol> <pre><code>import redis\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nQUEUE_NAME = 'user_queue'\n\n\ndef push_to_queue(user_data: User) -&gt; None:\n    serialized_data = user_data.model_dump_json()\n    r.rpush(QUEUE_NAME, serialized_data)\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n#&gt; \u5df2\u6dfb\u52a0\u5230\u961f\u5217: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n#&gt; \u5df2\u6dfb\u52a0\u5230\u961f\u5217: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\n\ndef pop_from_queue() -&gt; None:\n    data = r.lpop(QUEUE_NAME)\n\n    if data:\n        user = User.model_validate_json(data)\n        print(f'Validated user: {repr(user)}')\n    else:\n        print('Queue is empty')\n\n\npop_from_queue()\n#&gt; \u5df2\u9a8c\u8bc1\u7528\u6237: User(id=1, name='John Doe', email='john@example.com')\n\npop_from_queue()\n#&gt; \u5df2\u9a8c\u8bc1\u7528\u6237: User(id=2, name='Jane Doe', email='jane@example.com')\n\npop_from_queue()\n#&gt; \u961f\u5217\u4e3a\u7a7a\n</code></pre>"},{"location":"examples/queues/#rabbitmq","title":"RabbitMQ","text":"<p>RabbitMQ \u662f\u4e00\u79cd\u6d41\u884c\u7684\u6d88\u606f\u4ee3\u7406\uff0c\u5b9e\u73b0\u4e86 AMQP \u534f\u8bae\u3002</p> <p>\u4e3a\u4e86\u5728\u672c\u5730\u8fd0\u884c\u6b64\u793a\u4f8b\uff0c\u60a8\u9996\u5148\u9700\u8981\u5b89\u88c5 RabbitMQ \u5e76\u542f\u52a8\u670d\u52a1\u5668\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\uff0c\u5c55\u793a\u5982\u4f55\u4f7f\u7528 Pydantic \u6765\uff1a</p> <ol> <li>\u5e8f\u5217\u5316\u6570\u636e\u4ee5\u63a8\u9001\u5230\u961f\u5217</li> <li>\u4ece\u961f\u5217\u4e2d\u5f39\u51fa\u6570\u636e\u65f6\u8fdb\u884c\u53cd\u5e8f\u5217\u5316\u548c\u9a8c\u8bc1</li> </ol> <p>\u9996\u5148\uff0c\u8ba9\u6211\u4eec\u521b\u5efa\u4e00\u4e2a\u53d1\u9001\u8005\u811a\u672c\u3002</p> <pre><code>import pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\nQUEUE_NAME = 'user_queue'\nchannel.queue_declare(queue=QUEUE_NAME)\n\n\ndef push_to_queue(user_data: User) -&gt; None:\n    serialized_data = user_data.model_dump_json()\n    channel.basic_publish(\n        exchange='',\n        routing_key=QUEUE_NAME,\n        body=serialized_data,\n    )\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n#&gt; \u5df2\u6dfb\u52a0\u5230\u961f\u5217: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n#&gt; \u5df2\u6dfb\u52a0\u5230\u961f\u5217: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\nconnection.close()\n</code></pre> <p>\u8fd9\u662f\u63a5\u6536\u8005\u811a\u672c\u3002</p> <pre><code>import pika\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\ndef main():\n    connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\n    channel = connection.channel()\n    QUEUE_NAME = 'user_queue'\n    channel.queue_declare(queue=QUEUE_NAME)\n\n    def process_message(\n        ch: pika.channel.Channel,\n        method: pika.spec.Basic.Deliver,\n        properties: pika.spec.BasicProperties,\n        body: bytes,\n    ):\n        user = User.model_validate_json(body)\n        print(f'Validated user: {repr(user)}')\n        ch.basic_ack(delivery_tag=method.delivery_tag)\n\n    channel.basic_consume(queue=QUEUE_NAME, on_message_callback=process_message)\n    channel.start_consuming()\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except KeyboardInterrupt:\n        pass\n</code></pre> <p>\u8981\u6d4b\u8bd5\u6b64\u793a\u4f8b\uff1a</p> <ol> <li>\u5728\u4e00\u4e2a\u7ec8\u7aef\u4e2d\u8fd0\u884c\u63a5\u6536\u8005\u811a\u672c\u4ee5\u542f\u52a8\u6d88\u8d39\u8005\u3002</li> <li>\u5728\u53e6\u4e00\u4e2a\u7ec8\u7aef\u4e2d\u8fd0\u884c\u53d1\u9001\u8005\u811a\u672c\u4ee5\u53d1\u9001\u6d88\u606f\u3002</li> </ol>"},{"location":"examples/queues/#arq","title":"ARQ","text":"<p>ARQ \u662f\u4e00\u4e2a\u5feb\u901f\u7684\u57fa\u4e8e Redis \u7684 Python \u4f5c\u4e1a\u961f\u5217\u3002 \u5b83\u6784\u5efa\u5728 Redis \u4e4b\u4e0a\uff0c\u63d0\u4f9b\u4e86\u4e00\u79cd\u7b80\u5355\u7684\u65b9\u5f0f\u6765\u5904\u7406\u540e\u53f0\u4efb\u52a1\u3002</p> <p>\u4e3a\u4e86\u5728\u672c\u5730\u8fd0\u884c\u6b64\u793a\u4f8b\uff0c\u60a8\u9700\u8981\u5b89\u88c5 Redis \u5e76\u542f\u52a8\u670d\u52a1\u5668\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u7b80\u5355\u7684\u793a\u4f8b\uff0c\u5c55\u793a\u5982\u4f55\u4f7f\u7528 Pydantic \u4e0e ARQ \u6765\uff1a</p> <ol> <li>\u4e3a\u4f5c\u4e1a\u6570\u636e\u5b9a\u4e49\u6a21\u578b</li> <li>\u5728\u5165\u961f\u4f5c\u4e1a\u65f6\u5e8f\u5217\u5316\u6570\u636e</li> <li>\u5728\u5904\u7406\u4f5c\u4e1a\u65f6\u9a8c\u8bc1\u548c\u53cd\u5e8f\u5217\u5316\u6570\u636e</li> </ol> <pre><code>import asyncio\nfrom typing import Any\n\nfrom arq import create_pool\nfrom arq.connections import RedisSettings\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nREDIS_SETTINGS = RedisSettings()\n\n\nasync def process_user(ctx: dict[str, Any], user_data: dict[str, Any]) -&gt; None:\n    user = User.model_validate(user_data)\n    print(f'Processing user: {repr(user)}')\n\n\nasync def enqueue_jobs(redis):\n    user1 = User(id=1, name='John Doe', email='john@example.com')\n    user2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\n    await redis.enqueue_job('process_user', user1.model_dump())\n    print(f'Enqueued user: {repr(user1)}')\n\n    await redis.enqueue_job('process_user', user2.model_dump())\n    print(f'Enqueued user: {repr(user2)}')\n\n\nclass WorkerSettings:\n    functions = [process_user]\n    redis_settings = REDIS_SETTINGS\n\n\nasync def main():\n    redis = await create_pool(REDIS_SETTINGS)\n    await enqueue_jobs(redis)\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>\u6b64\u811a\u672c\u662f\u5b8c\u6574\u7684\u3002 \u5b83\u5e94\u8be5\u53ef\u4ee5\"\u6309\u539f\u6837\"\u8fd0\u884c\uff0c\u65e2\u53ef\u4ee5\u5165\u961f\u4f5c\u4e1a\uff0c\u4e5f\u53ef\u4ee5\u5904\u7406\u5b83\u4eec\u3002</p>"},{"location":"examples/requests/","title":"Web and API Requests","text":"<p>Pydantic \u6a21\u578b\u662f\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u8bf7\u6c42\u548c\u54cd\u5e94\u6570\u636e\u7684\u7edd\u4f73\u65b9\u5f0f\u3002 Pydantic \u5728\u8bb8\u591a Web \u6846\u67b6\u548c\u5e93\u4e2d\u53d1\u6325\u7740\u91cd\u8981\u4f5c\u7528\uff0c\u4f8b\u5982 FastAPI\u3001Django\u3001Flask \u548c HTTPX\u3002</p>"},{"location":"examples/requests/#httpx","title":"<code>httpx</code> \u8bf7\u6c42","text":"<p><code>httpx</code> \u662f\u4e00\u4e2a\u7528\u4e8e Python 3 \u7684 HTTP \u5ba2\u6237\u7aef\uff0c\u5177\u6709\u540c\u6b65\u548c\u5f02\u6b65 API\u3002 \u5728\u4e0b\u9762\u7684\u793a\u4f8b\u4e2d\uff0c\u6211\u4eec\u67e5\u8be2 JSONPlaceholder API \u6765\u83b7\u53d6\u7528\u6237\u6570\u636e\uff0c\u5e76\u4f7f\u7528 Pydantic \u6a21\u578b\u8fdb\u884c\u9a8c\u8bc1\u3002</p> <pre><code>import httpx\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/1'\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nuser = User.model_validate(response.json())\nprint(repr(user))\n#&gt; User(id=1, name='Leanne Graham', email='Sincere@april.biz')\n</code></pre> <p>Pydantic \u7684 <code>TypeAdapter</code> \u5de5\u5177\u5728\u5904\u7406 HTTP \u8bf7\u6c42\u65f6\u975e\u5e38\u65b9\u4fbf\u3002 \u8003\u8651\u4e00\u4e2a\u7c7b\u4f3c\u7684\u793a\u4f8b\uff0c\u6211\u4eec\u6b63\u5728\u9a8c\u8bc1\u7528\u6237\u5217\u8868\uff1a</p> <pre><code>from pprint import pprint\n\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr, TypeAdapter\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/'  # (1)!\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nusers_list_adapter = TypeAdapter(list[User])\n\nusers = users_list_adapter.validate_python(response.json())\npprint([u.name for u in users])\n\"\"\"\n['Leanne Graham',\n 'Ervin Howell',\n 'Clementine Bauch',\n 'Patricia Lebsack',\n 'Chelsey Dietrich',\n 'Mrs. Dennis Schulist',\n 'Kurtis Weissnat',\n 'Nicholas Runolfsdottir V',\n 'Glenna Reichert',\n 'Clementina DuBuque']\n\"\"\"\n</code></pre> <ol> <li>\u6ce8\u610f\uff0c\u6211\u4eec\u5728\u8fd9\u91cc\u67e5\u8be2 <code>/users/</code> \u7aef\u70b9\u6765\u83b7\u53d6\u7528\u6237\u5217\u8868\u3002</li> </ol>"},{"location":"integrations/aws_lambda/","title":"AWS Lambda","text":"<p><code>pydantic</code> \u4e0e AWS Lambda \u51fd\u6570\u96c6\u6210\u826f\u597d\u3002\u5728\u672c\u6307\u5357\u4e2d\uff0c\u6211\u4eec\u5c06\u8ba8\u8bba\u5982\u4f55\u4e3a AWS Lambda \u51fd\u6570\u8bbe\u7f6e <code>pydantic</code>\u3002</p>"},{"location":"integrations/aws_lambda/#aws-lambda-python","title":"\u4e3a AWS Lambda \u51fd\u6570\u5b89\u88c5 Python \u5e93","text":"<p>\u5728 AWS Lambda \u51fd\u6570\u4e2d\u4f7f\u7528 Python \u5e93\u6709\u591a\u79cd\u65b9\u5f0f\u3002\u5982 AWS Lambda \u6587\u6863 \u6240\u8ff0\uff0c\u6700\u5e38\u89c1\u7684\u65b9\u6cd5\u5305\u62ec\uff1a</p> <ul> <li>\u4f7f\u7528 <code>.zip</code> \u6587\u4ef6\u5f52\u6863 \u6253\u5305\u4ee3\u7801\u548c\u4f9d\u8d56\u9879</li> <li>\u4f7f\u7528 AWS Lambda \u5c42 \u5728\u591a\u4e2a\u51fd\u6570\u4e4b\u95f4\u5171\u4eab\u5e93</li> <li>\u4f7f\u7528 \u5bb9\u5668\u955c\u50cf \u6253\u5305\u4ee3\u7801\u548c\u4f9d\u8d56\u9879</li> </ul> <p>\u6240\u6709\u8fd9\u4e9b\u65b9\u6cd5\u90fd\u53ef\u4ee5\u4e0e <code>pydantic</code> \u4e00\u8d77\u4f7f\u7528\u3002\u6700\u9002\u5408\u60a8\u7684\u65b9\u6cd5\u5c06\u53d6\u51b3\u4e8e\u60a8\u7684\u5177\u4f53\u9700\u6c42\u548c\u7ea6\u675f\u3002\u6211\u4eec\u5c06\u5728\u8fd9\u91cc\u66f4\u6df1\u5165\u5730\u4ecb\u7ecd\u524d\u4e24\u79cd\u60c5\u51b5\uff0c\u56e0\u4e3a\u4f7f\u7528\u5bb9\u5668\u955c\u50cf\u7684\u4f9d\u8d56\u9879\u7ba1\u7406\u66f4\u4e3a\u76f4\u63a5\u3002\u5982\u679c\u60a8\u4f7f\u7528\u5bb9\u5668\u955c\u50cf\uff0c\u60a8\u53ef\u80fd\u4f1a\u53d1\u73b0 \u6b64\u8bc4\u8bba \u5bf9\u5b89\u88c5 <code>pydantic</code> \u6709\u5e2e\u52a9\u3002</p> <p>Tip</p> <p>\u5982\u679c\u60a8\u5728\u591a\u4e2a\u51fd\u6570\u4e2d\u4f7f\u7528 <code>pydantic</code>\uff0c\u60a8\u53ef\u80fd\u9700\u8981\u8003\u8651 AWS Lambda \u5c42\uff0c\u5b83\u652f\u6301\u5728\u591a\u4e2a\u51fd\u6570\u4e4b\u95f4\u65e0\u7f1d\u5171\u4eab\u5e93\u3002</p> <p>\u65e0\u8bba\u60a8\u9009\u62e9\u54ea\u79cd\u4f9d\u8d56\u9879\u7ba1\u7406\u65b9\u6cd5\uff0c\u9075\u5faa\u8fd9\u4e9b\u6307\u5357\u90fd\u6709\u52a9\u4e8e\u786e\u4fdd\u4f9d\u8d56\u9879\u7ba1\u7406\u8fc7\u7a0b\u987a\u5229\u8fdb\u884c\u3002</p>"},{"location":"integrations/aws_lambda/#aws-lambda-pydantic","title":"\u4e3a AWS Lambda \u51fd\u6570\u5b89\u88c5 <code>pydantic</code>","text":"<p>\u5f53\u60a8\u4f7f\u7528\u4ee3\u7801\u548c\u4f9d\u8d56\u9879\u6784\u5efa <code>.zip</code> \u6587\u4ef6\u5f52\u6863\u6216\u4e3a Lambda \u5c42\u7ec4\u7ec7 <code>.zip</code> \u6587\u4ef6\u65f6\uff0c\u60a8\u53ef\u80fd\u4f1a\u4f7f\u7528\u672c\u5730\u865a\u62df\u73af\u5883\u6765\u5b89\u88c5\u548c\u7ba1\u7406\u4f9d\u8d56\u9879\u3002\u5982\u679c\u60a8\u4f7f\u7528 <code>pip</code>\uff0c\u8fd9\u53ef\u80fd\u4f1a\u6709\u70b9\u68d8\u624b\uff0c\u56e0\u4e3a <code>pip</code> \u4f1a\u5b89\u88c5\u4e3a\u672c\u5730\u5e73\u53f0\u7f16\u8bd1\u7684 wheel \u5305\uff0c\u8fd9\u53ef\u80fd\u4e0e Lambda \u73af\u5883\u4e0d\u517c\u5bb9\u3002</p> <p>\u56e0\u6b64\uff0c\u6211\u4eec\u5efa\u8bae\u60a8\u4f7f\u7528\u7c7b\u4f3c\u4e8e\u4ee5\u4e0b\u547d\u4ee4\uff1a</p> <pre><code>pip install \\\n    --platform manylinux2014_x86_64 \\  # (1)!\n    --target=&lt;your_package_dir&gt; \\  # (2)!\n    --implementation cp \\  # (3)!\n    --python-version 3.10 \\  # (4)!\n    --only-binary=:all: \\  # (5)!\n    --upgrade pydantic  # (6)!\n</code></pre> <ol> <li>\u4f7f\u7528\u4e0e\u60a8\u7684 Lambda \u8fd0\u884c\u65f6\u5bf9\u5e94\u7684\u5e73\u53f0\u3002</li> <li>\u6307\u5b9a\u8981\u5b89\u88c5\u5305\u7684\u76ee\u5f55\uff08\u5bf9\u4e8e Lambda \u5c42\u901a\u5e38\u662f <code>python</code>\uff09\u3002</li> <li>\u4f7f\u7528 CPython \u5b9e\u73b0\u3002</li> <li>Python \u7248\u672c\u5fc5\u987b\u4e0e Lambda \u8fd0\u884c\u65f6\u517c\u5bb9\u3002</li> <li>\u6b64\u6807\u5fd7\u786e\u4fdd\u5b89\u88c5\u9884\u6784\u5efa\u7684\u4e8c\u8fdb\u5236 wheel \u5305\u3002</li> <li>\u5c06\u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684 <code>pydantic</code>\u3002</li> </ol>"},{"location":"integrations/aws_lambda/#_1","title":"\u6545\u969c\u6392\u9664","text":""},{"location":"integrations/aws_lambda/#pydantic_core","title":"\u7f3a\u5c11 <code>pydantic_core</code> \u6a21\u5757","text":"<pre><code>no module named `pydantic_core._pydantic_core`\n</code></pre> <p>\u9519\u8bef\u662f\u4e00\u4e2a\u5e38\u89c1\u95ee\u9898\uff0c\u8868\u660e\u60a8\u5b89\u88c5 <code>pydantic</code> \u7684\u65b9\u5f0f\u4e0d\u6b63\u786e\u3002\u8981\u8c03\u8bd5\u6b64\u95ee\u9898\uff0c\u60a8\u53ef\u4ee5\u5c1d\u8bd5\u4ee5\u4e0b\u6b65\u9aa4\uff08\u5728\u5931\u8d25\u7684\u5bfc\u5165\u4e4b\u524d\uff09\uff1a</p> <ol> <li> <p>\u68c0\u67e5\u5df2\u5b89\u88c5\u7684 <code>pydantic-core</code> \u5305\u7684\u5185\u5bb9\u3002\u7f16\u8bd1\u7684\u5e93\u53ca\u5176\u7c7b\u578b\u5b58\u6839\u662f\u5426\u90fd\u5b58\u5728\uff1f</p> <pre><code>from importlib.metadata import files\nprint([file for file in files('pydantic-core') if file.name.startswith('_pydantic_core')])\n\"\"\"\n[PackagePath('pydantic_core/_pydantic_core.pyi'), PackagePath('pydantic_core/_pydantic_core.cpython-312-x86_64-linux-gnu.so')]\n\"\"\"\n</code></pre> <p>\u60a8\u5e94\u8be5\u671f\u671b\u770b\u5230\u5982\u4e0a\u6253\u5370\u7684\u4e24\u4e2a\u6587\u4ef6\u3002\u7f16\u8bd1\u7684\u5e93\u6587\u4ef6\u5e94\u5177\u6709 <code>.so</code> \u6216 <code>.pyd</code> \u6269\u5c55\u540d\uff0c\u5176\u540d\u79f0\u6839\u636e\u64cd\u4f5c\u7cfb\u7edf\u548c Python \u7248\u672c\u800c\u53d8\u5316\u3002</p> </li> <li> <p>\u68c0\u67e5\u60a8\u7684 lambda \u7684 Python \u7248\u672c\u662f\u5426\u4e0e\u4e0a\u9762\u627e\u5230\u7684\u7f16\u8bd1\u5e93\u7248\u672c\u517c\u5bb9\u3002</p> <pre><code>import sysconfig\nprint(sysconfig.get_config_var(\"EXT_SUFFIX\"))\n#&gt; '.cpython-312-x86_64-linux-gnu.so'\n</code></pre> </li> </ol> <p>\u60a8\u5e94\u8be5\u671f\u671b\u5728\u8fd9\u91cc\u770b\u5230\u4e0e\u7f16\u8bd1\u5e93\u76f8\u540c\u7684\u540e\u7f00\uff0c\u4f8b\u5982\u8fd9\u91cc\u6211\u4eec\u770b\u5230\u540e\u7f00 <code>.cpython-312-x86_64-linux-gnu.so</code> \u786e\u5b9e\u4e0e <code>_pydantic_core.cpython-312-x86_64-linux-gnu.so</code> \u5339\u914d\u3002</p> <p>\u5982\u679c\u8fd9\u4e24\u4e2a\u68c0\u67e5\u4e0d\u5339\u914d\uff0c\u60a8\u7684\u6784\u5efa\u6b65\u9aa4\u6ca1\u6709\u4e3a\u60a8\u7684 lambda \u76ee\u6807\u5e73\u53f0\u5b89\u88c5\u6b63\u786e\u7684\u672c\u5730\u4ee3\u7801\u3002\u60a8\u5e94\u8be5\u8c03\u6574\u6784\u5efa\u6b65\u9aa4\u4ee5\u66f4\u6539\u5b89\u88c5\u7684\u5e93\u7248\u672c\u3002</p> <p>\u6700\u53ef\u80fd\u7684\u9519\u8bef\uff1a</p> <ul> <li> <p>\u60a8\u7684\u64cd\u4f5c\u7cfb\u7edf\u6216 CPU \u67b6\u6784\u4e0d\u5339\u914d\uff08\u4f8b\u5982 darwin \u4e0e x86_64-linux-gnu\uff09\u3002\u5728\u5b89\u88c5 lambda \u4f9d\u8d56\u9879\u65f6\u5c1d\u8bd5\u4f20\u9012\u6b63\u786e\u7684 <code>--platform</code> \u53c2\u6570\uff0c\u6216\u5728\u6b63\u786e\u7684\u5e73\u53f0\u5185\u7684 linux docker \u5bb9\u5668\u4e2d\u6784\u5efa\u3002\u76ee\u524d\u53ef\u80fd\u7684\u5e73\u53f0\u5305\u62ec <code>--platform manylinux2014_x86_64</code> \u6216 <code>--platform manylinux2014_aarch64</code>\uff0c\u4f46\u8fd9\u4e9b\u53ef\u80fd\u4f1a\u968f\u7740\u672a\u6765\u7684 Pydantic \u4e3b\u8981\u7248\u672c\u800c\u6539\u53d8\u3002</p> </li> <li> <p>\u60a8\u7684 Python \u7248\u672c\u4e0d\u5339\u914d\uff08\u4f8b\u5982 <code>cpython-310</code> \u4e0e <code>cpython-312</code>\uff09\u3002\u5c1d\u8bd5\u4f20\u9012\u6b63\u786e\u7684 <code>--python-version</code> \u53c2\u6570\u7ed9 <code>pip install</code>\uff0c\u6216\u8005\u66f4\u6539\u6784\u5efa\u4e2d\u4f7f\u7528\u7684 Python \u7248\u672c\u3002</p> </li> </ul>"},{"location":"integrations/aws_lambda/#email-validator","title":"\u672a\u627e\u5230 <code>email-validator</code> \u7684\u5305\u5143\u6570\u636e","text":"<p>Pydantic \u4f7f\u7528 <code>importlib.metadata</code> \u4e2d\u7684 <code>version</code> \u6765 \u68c0\u67e5\u5b89\u88c5\u4e86\u54ea\u4e2a\u7248\u672c \u7684 <code>email-validator</code>\u3002 \u8fd9\u79cd\u5305\u7248\u672c\u63a7\u5236\u673a\u5236\u4e0e AWS Lambda \u6709\u4e9b\u4e0d\u517c\u5bb9\uff0c\u5c3d\u7ba1\u5b83\u662f Python \u4e2d\u7248\u672c\u63a7\u5236\u5305\u7684\u884c\u4e1a\u6807\u51c6\u3002\u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u89e3\u51b3\u6b64\u95ee\u9898\uff1a</p> <p>\u5982\u679c\u60a8\u4f7f\u7528 serverless \u6846\u67b6\u90e8\u7f72 lambda\uff0c\u5f88\u53ef\u80fd <code>email-validator</code> \u5305\u7684\u9002\u5f53\u5143\u6570\u636e\u672a\u5305\u542b\u5728\u60a8\u7684\u90e8\u7f72\u5305\u4e2d\u3002\u50cf <code>serverless-python-requirements</code> \u8fd9\u6837\u7684\u5de5\u5177\u4f1a\u5220\u9664\u5143\u6570\u636e\u4ee5\u51cf\u5c11\u5305\u5927\u5c0f\u3002\u60a8\u53ef\u4ee5\u901a\u8fc7\u5728 <code>serverless.yml</code> \u6587\u4ef6\u4e2d\u5c06 <code>slim</code> \u8bbe\u7f6e\u8bbe\u7f6e\u4e3a false \u6765\u89e3\u51b3\u6b64\u95ee\u9898\uff1a</p> <pre><code>pythonRequirements:\n    dockerizePip: non-linux\n    slim: false\n    fileName: requirements.txt\n</code></pre> <p>\u60a8\u53ef\u4ee5\u5728\u6b64 \u535a\u5ba2\u6587\u7ae0 \u4e2d\u9605\u8bfb\u6709\u5173\u6b64\u4fee\u590d\u4ee5\u53ca\u5176\u4ed6\u53ef\u80fd\u76f8\u5173\u7684 <code>slim</code> \u8bbe\u7f6e\u7684\u66f4\u591a\u4fe1\u606f\u3002</p> <p>\u5982\u679c\u60a8\u4f7f\u7528 <code>.zip</code> \u5f52\u6863\u6587\u4ef6\u6765\u5b58\u50a8\u4ee3\u7801\u548c/\u6216\u4f9d\u8d56\u9879\uff0c\u8bf7\u786e\u4fdd\u60a8\u7684\u5305\u5305\u542b\u6240\u9700\u7684\u7248\u672c\u5143\u6570\u636e\u3002\u4e3a\u6b64\uff0c\u8bf7\u786e\u4fdd\u5728\u60a8\u7684 <code>.zip</code> \u5f52\u6863\u6587\u4ef6\u4e2d\u5305\u542b <code>email-validator</code> \u5305\u7684 <code>dist-info</code> \u76ee\u5f55\u3002</p> <p>\u6b64\u95ee\u9898\u5df2\u5728\u5176\u4ed6\u6d41\u884c\u7684 Python \u5e93\uff08\u5982 <code>jsonschema</code>\uff09\u4e2d\u62a5\u544a\uff0c\u56e0\u6b64\u60a8\u4e5f\u53ef\u4ee5\u5728\u90a3\u91cc\u9605\u8bfb\u6709\u5173\u6b64\u95ee\u9898\u548c\u6f5c\u5728\u4fee\u590d\u7684\u66f4\u591a\u4fe1\u606f\u3002</p>"},{"location":"integrations/aws_lambda/#_2","title":"\u989d\u5916\u8d44\u6e90","text":""},{"location":"integrations/aws_lambda/#_3","title":"\u66f4\u591a\u8c03\u8bd5\u6280\u5de7","text":"<p>\u5982\u679c\u60a8\u4ecd\u5728\u4e3a AWS Lambda \u5b89\u88c5 <code>pydantic</code> \u800c\u82e6\u82e6\u6323\u624e\uff0c\u60a8\u53ef\u4ee5\u67e5\u9605 \u6b64\u95ee\u9898\uff0c\u5176\u4e2d\u6db5\u76d6\u4e86\u5176\u4ed6\u5f00\u53d1\u4eba\u5458\u9047\u5230\u7684\u5404\u79cd\u95ee\u9898\u548c\u89e3\u51b3\u65b9\u6848\u3002</p>"},{"location":"integrations/aws_lambda/#event-context","title":"\u9a8c\u8bc1 <code>event</code> \u548c <code>context</code> \u6570\u636e","text":"<p>\u67e5\u770b\u6211\u4eec\u7684 \u535a\u5ba2\u6587\u7ae0\uff0c\u4e86\u89e3\u6709\u5173\u5982\u4f55\u4f7f\u7528 <code>pydantic</code> \u9a8c\u8bc1 AWS Lambda \u51fd\u6570\u4e2d\u7684 <code>event</code> \u548c <code>context</code> \u6570\u636e\u7684\u66f4\u591a\u4fe1\u606f\u3002</p>"},{"location":"integrations/datamodel_code_generator/","title":"\u4f7f\u7528 datamodel-code-generator \u8fdb\u884c\u4ee3\u7801\u751f\u6210","text":"<p>datamodel-code-generator \u9879\u76ee\u662f\u4e00\u4e2a\u5e93\u548c\u547d\u4ee4\u884c\u5de5\u5177\uff0c\u53ef\u4ee5\u4ece\u51e0\u4e4e\u4efb\u4f55\u6570\u636e\u6e90\u751f\u6210 pydantic \u6a21\u578b\uff0c\u5305\u62ec\uff1a</p> <ul> <li>OpenAPI 3 (YAML/JSON)</li> <li>JSON Schema</li> <li>JSON/YAML/CSV \u6570\u636e\uff08\u5c06\u88ab\u8f6c\u6362\u4e3a JSON Schema\uff09</li> <li>Python \u5b57\u5178\uff08\u5c06\u88ab\u8f6c\u6362\u4e3a JSON Schema\uff09</li> <li>GraphQL \u6a21\u5f0f</li> </ul> <p>\u5f53\u60a8\u9047\u5230\u4efb\u4f55\u53ef\u8f6c\u6362\u4e3a JSON \u4f46\u6ca1\u6709 pydantic \u6a21\u578b\u7684\u6570\u636e\u65f6\uff0c\u6b64\u5de5\u5177\u5c06\u5141\u8bb8\u60a8\u6309\u9700\u751f\u6210\u7c7b\u578b\u5b89\u5168\u7684\u6a21\u578b\u5c42\u6b21\u7ed3\u6784\u3002</p>"},{"location":"integrations/datamodel_code_generator/#_1","title":"\u5b89\u88c5","text":"<pre><code>pip install datamodel-code-generator\n</code></pre>"},{"location":"integrations/datamodel_code_generator/#_2","title":"\u793a\u4f8b","text":"<p>\u5728\u8fd9\u4e2a\u4f8b\u5b50\u4e2d\uff0cdatamodel-code-generator \u4ece JSON Schema \u6587\u4ef6\u521b\u5efa pydantic \u6a21\u578b\u3002</p> <pre><code>datamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n</code></pre> <p>person.json:</p> <pre><code>{\n  \"$id\": \"person.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"last_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"pets\": {\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/Pet\"\n        }\n      ]\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  },\n  \"required\": [\n      \"first_name\",\n      \"last_name\"\n  ],\n  \"definitions\": {\n    \"Pet\": {\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>model.py:</p> <pre><code># generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-05-19T15:07:31+00:00\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: str | None = None\n    age: int | None = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(description=\"The person's first name.\")\n    last_name: str = Field(description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(None, description='Age in years.')\n    pets: list[Pet] | None = None\n    comment: Any | None = None\n</code></pre> <p>\u66f4\u591a\u4fe1\u606f\u53ef\u4ee5\u5728 \u5b98\u65b9\u6587\u6863\u4e2d\u627e\u5230</p>"},{"location":"integrations/devtools/","title":"devtools","text":"<p>Note</p> <p>\u627f\u8ba4\u58f0\u660e\uff1a \u6211\uff08Pydantic \u7684\u4e3b\u8981\u5f00\u53d1\u8005\uff09\u4e5f\u5f00\u53d1\u4e86 python-devtools\u3002</p> <p>python-devtools (<code>pip install devtools</code>) \u63d0\u4f9b\u4e86\u4e00\u7cfb\u5217\u5728 Python \u5f00\u53d1\u8fc7\u7a0b\u4e2d\u6709\u7528\u7684\u5de5\u5177\uff0c\u5305\u62ec <code>debug()</code>\uff0c\u5b83\u662f <code>print()</code> \u7684\u66ff\u4ee3\u65b9\u6848\uff0c\u4ee5\u66f4\u6613\u4e8e\u9605\u8bfb\u7684\u65b9\u5f0f\u683c\u5f0f\u5316\u8f93\u51fa\uff0c\u540c\u65f6\u63d0\u4f9b\u6709\u5173\u6253\u5370\u8bed\u53e5\u6240\u5728\u6587\u4ef6/\u884c\u4ee5\u53ca\u6253\u5370\u503c\u7684\u4fe1\u606f\u3002</p> <p>Pydantic \u901a\u8fc7\u5728\u5927\u591a\u6570\u516c\u5171\u7c7b\u4e0a\u5b9e\u73b0 <code>__pretty__</code> \u65b9\u6cd5\u4e0e devtools \u96c6\u6210\u3002</p> <p>\u7279\u522b\u662f <code>debug()</code> \u5728\u68c0\u67e5\u6a21\u578b\u65f6\u975e\u5e38\u6709\u7528\uff1a</p> <pre><code>from datetime import datetime\n\nfrom devtools import debug\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: list[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\n\u5e94\u8be5\u6bd4\u4ee5\u4e0b\u5185\u5bb9\u66f4\u5bb9\u6613\u9605\u8bfb\uff1a\\n')\nprint('user:', user)\n</code></pre> <p>\u5c06\u5728\u60a8\u7684\u7ec8\u7aef\u8f93\u51fa\uff1a</p> <pre><code>\ndevtools_example.py:30 &lt;module&gt;\n    user: User(\n        id=123,\n        name='John Doe',\n        signup_ts=datetime.datetime(2019, 6, 1, 12, 22),\n        friends=[\n            1234,\n            4567,\n            7890,\n        ],\n        address=Address(\n            street='Testing',\n            country='uk',\n            lat=51.5,\n            lng=0.0,\n        ),\n    ) (User)\n\nshould be much easier read than:\n\nuser: id=123 name='John Doe' signup_ts=datetime.datetime(2019, 6, 1, 12, 22) friends=[1234, 4567, 7890] address=Address(street='Testing', country='uk', lat=51.5, lng=0.0)</code></pre> <p>Note</p> <p><code>python-devtools</code> \u76ee\u524d\u8fd8\u4e0d\u652f\u6301 Python 3.13\u3002</p>"},{"location":"integrations/documentation/","title":"Documentation","text":"<p>Pydantic \u4f7f\u7528 MkDocs \u8fdb\u884c\u6587\u6863\u7f16\u5199\uff0c\u540c\u65f6\u7ed3\u5408\u4f7f\u7528 mkdocstrings\u3002\u56e0\u6b64\uff0c\u60a8\u53ef\u4ee5\u5229\u7528 Pydantic \u7684 Sphinx \u5bf9\u8c61\u6e05\u5355\u6765\u4ea4\u53c9\u5f15\u7528 Pydantic API \u6587\u6863\u3002</p> Sphinxmkdocstrings <p>\u5728\u60a8\u7684 Sphinx \u914d\u7f6e\u4e2d\uff0c \u5c06\u4ee5\u4e0b\u5185\u5bb9\u6dfb\u52a0\u5230 <code>intersphinx</code> \u6269\u5c55\u914d\u7f6e\u4e2d\uff1a</p> <pre><code>intersphinx_mapping = {\n    'pydantic': ('https://docs.pydantic.dev/latest', None),  # (1)!\n}\n</code></pre> <ol> <li>\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>dev</code> \u4ee3\u66ff <code>latest</code> \u6765\u5b9a\u4f4d\u6700\u65b0\u7684\u6587\u6863\u6784\u5efa\uff0c\u4e0e <code>main</code> \u5206\u652f\u4fdd\u6301\u540c\u6b65\u3002</li> </ol> <p>\u5728\u60a8\u7684 MkDocs \u914d\u7f6e\u4e2d\uff0c\u5c06\u4ee5\u4e0b \u5bfc\u5165\u6dfb\u52a0\u5230\u60a8\u7684 mkdocstrings \u63d2\u4ef6\u914d\u7f6e\u4e2d\uff1a</p> <pre><code>plugins:\n- mkdocstrings:\n    handlers:\n      python:\n        import:\n        - https://docs.pydantic.dev/latest/objects.inv  # (1)!\n</code></pre> <ol> <li>\u60a8\u4e5f\u53ef\u4ee5\u4f7f\u7528 <code>dev</code> \u4ee3\u66ff <code>latest</code> \u6765\u5b9a\u4f4d\u6700\u65b0\u7684\u6587\u6863\u6784\u5efa\uff0c\u4e0e <code>main</code> \u5206\u652f\u4fdd\u6301\u540c\u6b65\u3002</li> </ol>"},{"location":"integrations/hypothesis/","title":"Hypothesis","text":"<p>Hypothesis \u662f\u7528\u4e8e\u57fa\u4e8e\u5c5e\u6027\u7684\u6d4b\u8bd5\u7684 Python \u5e93\u3002 Hypothesis \u53ef\u4ee5\u63a8\u65ad\u5982\u4f55\u6784\u9020\u7c7b\u578b\u6ce8\u89e3\u7684\u7c7b\uff0c\u5e76\u9ed8\u8ba4\u652f\u6301\u5185\u7f6e\u7c7b\u578b\u3001\u8bb8\u591a\u6807\u51c6\u5e93\u7c7b\u578b\uff0c\u4ee5\u53ca\u6765\u81ea <code>typing</code> \u548c <code>typing_extensions</code> \u6a21\u5757\u7684\u6cdb\u578b\u7c7b\u578b\u3002</p> <p>Pydantic v2.0 \u653e\u5f03\u4e86\u5bf9 Hypothesis \u7684\u5185\u7f6e\u652f\u6301\uff0c\u4e0d\u518d\u63d0\u4f9b\u96c6\u6210\u7684 Hypothesis \u63d2\u4ef6\u3002</p> <p>Warning</p> <p>\u6211\u4eec\u6682\u65f6\u79fb\u9664 Hypothesis \u63d2\u4ef6\uff0c\u4ee5\u4fbf\u7814\u7a76\u4e0d\u540c\u7684\u673a\u5236\u3002\u66f4\u591a\u4fe1\u606f\u8bf7\u53c2\u9605\u95ee\u9898 annotated-types/annotated-types#37\u3002</p> <p>Hypothesis \u63d2\u4ef6\u53ef\u80fd\u4f1a\u5728\u672a\u6765\u7684\u7248\u672c\u4e2d\u56de\u5f52\u3002\u8bf7\u8ba2\u9605 pydantic/pydantic#4682 \u4ee5\u83b7\u53d6\u66f4\u65b0\u3002</p>"},{"location":"integrations/linting/","title":"Linting","text":""},{"location":"integrations/linting/#flake8","title":"Flake8 \u63d2\u4ef6","text":"<p>\u5982\u679c\u5728\u60a8\u7684\u9879\u76ee\u4e2d\u4f7f\u7528 Flake8\uff0c\u53ef\u4ee5\u4f7f\u7528\u4e00\u4e2a\u63d2\u4ef6\uff0c \u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u65b9\u5f0f\u5b89\u88c5\uff1a</p> <pre><code>pip install flake8-pydantic\n</code></pre> <p>\u6b64\u63d2\u4ef6\u63d0\u4f9b\u7684 lint \u9519\u8bef\u4f7f\u7528 <code>PYDXXX</code> \u4ee3\u7801\u8fdb\u884c\u547d\u540d\u7a7a\u95f4\u5212\u5206\u3002\u8981\u5ffd\u7565\u4e00\u4e9b\u4e0d\u9700\u8981\u7684\u89c4\u5219\uff0c \u53ef\u4ee5\u8c03\u6574 Flake8 \u914d\u7f6e\uff1a</p> <pre><code>[flake8]\nextend-ignore = PYD001,PYD002\n</code></pre>"},{"location":"integrations/llms/","title":"LLMs","text":"<p>Pydantic \u6587\u6863\u4ee5 llms.txt \u683c\u5f0f\u63d0\u4f9b\u3002 \u8be5\u683c\u5f0f\u57fa\u4e8e Markdown \u5b9a\u4e49\uff0c\u9002\u7528\u4e8e\u5927\u578b\u8bed\u8a00\u6a21\u578b\u3002</p> <p>\u63d0\u4f9b\u4e24\u79cd\u683c\u5f0f\uff1a</p> <ul> <li>llms.txt\uff1a\u5305\u542b\u9879\u76ee\u7b80\u8981\u63cf\u8ff0\u7684\u6587\u4ef6\uff0c   \u4ee5\u53ca\u6307\u5411\u6587\u6863\u4e0d\u540c\u90e8\u5206\u7684\u94fe\u63a5\u3002\u8be5\u6587\u4ef6\u7684\u7ed3\u6784\u5728\u683c\u5f0f\u6587\u6863\u4e2d\u6709\u8be6\u7ec6\u63cf\u8ff0\u3002</li> <li>llms-full.txt\uff1a\u7c7b\u4f3c\u4e8e <code>llms.txt</code> \u6587\u4ef6\uff0c   \u4f46\u5305\u542b\u4e86\u6bcf\u4e2a\u94fe\u63a5\u7684\u5185\u5bb9\u3002\u8bf7\u6ce8\u610f\uff0c\u6b64\u6587\u4ef6\u53ef\u80fd\u5bf9\u67d0\u4e9b LLM \u6765\u8bf4\u8fc7\u5927\u3002</li> </ul> <p>\u622a\u81f3\u76ee\u524d\uff0c\u8fd9\u4e9b\u6587\u4ef6\u65e0\u6cd5\u88ab LLM \u6846\u67b6\u6216 IDE \u539f\u751f\u5229\u7528\u3002\u6216\u8005\uff0c \u53ef\u4ee5\u5b9e\u73b0\u4e00\u4e2a MCP \u670d\u52a1\u5668 \u6765\u6b63\u786e\u89e3\u6790 <code>llms.txt</code> \u6587\u4ef6\u3002</p>"},{"location":"integrations/logfire/","title":"Pydantic Logfire","text":"<p>Pydantic \u4e0e Pydantic Logfire \u65e0\u7f1d\u96c6\u6210\uff0c\u8fd9\u662f\u4e00\u4e2a\u7531\u6211\u4eec\u6784\u5efa\u7684\u53ef\u89c2\u6d4b\u6027\u5e73\u53f0\uff0c\u57fa\u4e8e\u4e0e\u6211\u4eec\u5f00\u6e90\u5e93\u76f8\u540c\u7684\u4fe1\u5ff5\u2014\u2014\u6700\u5f3a\u5927\u7684\u5de5\u5177\u53ef\u4ee5\u6613\u4e8e\u4f7f\u7528\u3002</p>"},{"location":"integrations/logfire/#_1","title":"\u5165\u95e8\u6307\u5357","text":"<p>Logfire \u63d0\u4f9b\u4e86\u5f00\u7bb1\u5373\u7528\u7684 Pydantic \u96c6\u6210\uff0c\u8ba9\u60a8\u80fd\u591f\u7406\u89e3\u901a\u8fc7 Pydantic \u6a21\u578b\u4f20\u9012\u7684\u6570\u636e\u5e76\u83b7\u53d6\u9a8c\u8bc1\u5206\u6790\u3002\u5bf9\u4e8e\u73b0\u6709\u7684 Pydantic \u7528\u6237\uff0c\u5b83\u63d0\u4f9b\u4e86\u5bf9 Pydantic \u6a21\u578b\u4f7f\u7528\u60c5\u51b5\u7684\u72ec\u7279\u6d1e\u5bdf\u3002</p> <p>\u5f00\u59cb\u4f7f\u7528 Logfire \u53ef\u4ee5\u901a\u8fc7\u4e09\u4e2a\u7b80\u5355\u6b65\u9aa4\u5b8c\u6210\uff1a</p> <ol> <li>\u8bbe\u7f6e\u60a8\u7684 Logfire \u8d26\u6237\u3002</li> <li>\u5b89\u88c5 Logfire SDK\u3002</li> <li>\u5bf9\u60a8\u7684\u9879\u76ee\u8fdb\u884c\u63d2\u6869\u3002</li> </ol>"},{"location":"integrations/logfire/#_2","title":"\u57fa\u672c\u7528\u6cd5","text":"<p>\u4e00\u65e6\u60a8\u8bbe\u7f6e\u597d Logfire\uff0c\u5c31\u53ef\u4ee5\u5f00\u59cb\u4f7f\u7528\u5b83\u6765\u76d1\u63a7\u60a8\u7684 Pydantic \u6a21\u578b\u5e76\u83b7\u53d6\u6570\u636e\u9a8c\u8bc1\u7684\u6d1e\u5bdf\uff1a</p> <pre><code>from datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nuser = User(name='Anne', country_code='USA', dob='2000-01-01')\nlogfire.info('user processed: {user!r}', user=user)  # (2)!\n</code></pre> <ol> <li><code>logfire.configure()</code> \u8c03\u7528\u662f\u60a8\u4f7f\u7528 Logfire \u5bf9\u9879\u76ee\u8fdb\u884c\u63d2\u6869\u6240\u9700\u7684\u5168\u90e8\u64cd\u4f5c\u3002</li> <li><code>logfire.info()</code> \u8c03\u7528\u5c06 <code>user</code> \u5bf9\u8c61\u8bb0\u5f55\u5230 Logfire\uff0c\u5185\u7f6e\u5bf9 Pydantic \u6a21\u578b\u7684\u652f\u6301\u3002</li> </ol> <p></p>"},{"location":"integrations/logfire/#pydantic","title":"Pydantic \u63d2\u6869","text":"<p>\u60a8\u751a\u81f3\u53ef\u4ee5\u901a\u8fc7\u4f7f\u7528\u5185\u7f6e\u7684 Pydantic \u96c6\u6210 \u81ea\u52a8\u8bb0\u5f55\u9a8c\u8bc1\u8fc7\u7a0b\u7684\u4fe1\u606f\uff1a</p> <pre><code>from datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nUser(name='Anne', country_code='USA', dob='2000-01-01')\nUser(name='David', country_code='GBR', dob='invalid-dob')\n</code></pre> <ol> <li><code>logfire.instrument_pydantic()</code> \u8c03\u7528\u4f1a\u81ea\u52a8\u8bb0\u5f55\u9879\u76ee\u4e2d\u6240\u6709 Pydantic \u6a21\u578b\u7684\u9a8c\u8bc1\u4fe1\u606f\u3002</li> </ol> <p>\u60a8\u5c06\u5728 Logfire \u4e2d\u770b\u5230\u6bcf\u4e2a\u6210\u529f\u548c\u5931\u8d25\u7684\u9a8c\u8bc1\u90fd\u88ab\u8bb0\u5f55\u4e0b\u6765\uff1a</p> <p></p> <p>\u60a8\u53ef\u4ee5\u8c03\u67e5\u6bcf\u4e2a\u76f8\u5e94\u7684 span \u6765\u83b7\u53d6\u9a8c\u8bc1\u8be6\u60c5\uff1a</p> <p></p>"},{"location":"integrations/mypy/","title":"Mypy","text":"<p>Pydantic \u4e0e mypy \u5f00\u7bb1\u5373\u7528\u914d\u5408\u826f\u597d\u3002</p> <p>\u7136\u800c\uff0cPydantic \u8fd8\u9644\u5e26\u4e86\u4e00\u4e2a mypy \u63d2\u4ef6\uff0c\u8be5\u63d2\u4ef6\u6dfb\u52a0\u4e86\u8bb8\u591a\u91cd\u8981\u7684 Pydantic \u7279\u5b9a\u529f\u80fd\uff0c\u63d0\u9ad8\u4e86\u5176\u7c7b\u578b\u68c0\u67e5\u4ee3\u7801\u7684\u80fd\u529b\u3002</p> <p>\u4f8b\u5982\uff0c\u8003\u8651\u4ee5\u4e0b\u811a\u672c\uff1a</p> Python 3.9 and abovePython 3.10 and above <pre><code>from datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: Optional[str] = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <pre><code>from datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: str | None = None\n    signup_ts: datetime | None = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n</code></pre> <p>\u6ca1\u6709\u4efb\u4f55\u7279\u6b8a\u914d\u7f6e\u7684\u60c5\u51b5\u4e0b\uff0cmypy \u4e0d\u4f1a\u6355\u83b7 \u7f3a\u5931\u7684\u6a21\u578b\u5b57\u6bb5\u6ce8\u89e3 \u4ee5\u53ca\u5173\u4e8e <code>list_of_ints</code> \u53c2\u6570\u7684\u9519\u8bef\uff0c\u800c Pydantic \u53ef\u4ee5\u6b63\u786e\u89e3\u6790\uff1a</p> <pre><code>15: error: List item 1 has incompatible type \"str\"; expected \"int\"  [list-item]\n15: error: List item 2 has incompatible type \"bytes\"; expected \"int\"  [list-item]\n16: error: \"Model\" has no attribute \"middle_name\"  [attr-defined]\n17: error: Missing named argument \"age\" for \"Model\"  [call-arg]\n17: error: Missing named argument \"list_of_ints\" for \"Model\"  [call-arg]\n</code></pre> <p>\u4f46\u662f \u542f\u7528\u63d2\u4ef6\u540e\uff0c\u5b83\u4f1a\u7ed9\u51fa\u6b63\u786e\u7684\u9519\u8bef\uff1a</p> <pre><code>9: error: Untyped fields disallowed  [pydantic-field]\n16: error: \"Model\" has no attribute \"middle_name\"  [attr-defined]\n17: error: Missing named argument \"age\" for \"Model\"  [call-arg]\n17: error: Missing named argument \"list_of_ints\" for \"Model\"  [call-arg]\n</code></pre> <p>\u4f7f\u7528 pydantic mypy \u63d2\u4ef6\uff0c\u60a8\u53ef\u4ee5\u653e\u5fc3\u5730\u91cd\u6784\u6a21\u578b\uff0c\u56e0\u4e3a\u77e5\u9053\u5982\u679c\u5b57\u6bb5\u540d\u79f0\u6216\u7c7b\u578b\u53d1\u751f\u53d8\u5316\uff0cmypy \u4f1a\u6355\u83b7\u4efb\u4f55\u9519\u8bef\u3002</p> <p>\u8bf7\u6ce8\u610f\uff0cmypy \u5df2\u7ecf\u652f\u6301\u4e00\u4e9b\u529f\u80fd\u800c\u65e0\u9700\u4f7f\u7528 Pydantic \u63d2\u4ef6\uff0c\u4f8b\u5982\u4e3a Pydantic \u6a21\u578b\u548c\u6570\u636e\u7c7b\u5408\u6210 <code>__init__</code> \u65b9\u6cd5\u3002 \u6709\u5173\u5176\u4ed6\u529f\u80fd\u7684\u5217\u8868\uff0c\u8bf7\u53c2\u9605 mypy \u63d2\u4ef6\u529f\u80fd\u3002</p> <p>Pydantic mypy \u63d2\u4ef6\u9488\u5bf9\u6700\u65b0\u7684 mypy \u7248\u672c\u8fdb\u884c\u4e86\u6d4b\u8bd5\u3002\u65e7\u7248\u672c\u53ef\u80fd\u6709\u6548\u4f46\u4e0d\u4f1a\u88ab\u6d4b\u8bd5\u3002</p>"},{"location":"integrations/mypy/#enabling-the-plugin","title":"\u542f\u7528\u63d2\u4ef6","text":"<p>\u8981\u542f\u7528\u63d2\u4ef6\uff0c\u53ea\u9700\u5c06 <code>pydantic.mypy</code> \u6dfb\u52a0\u5230\u60a8\u7684 mypy \u914d\u7f6e\u6587\u4ef6 \u4e2d\u7684\u63d2\u4ef6\u5217\u8868\u4e2d\uff1a</p> <code>mypy.ini</code><code>pyproject.toml</code> <pre><code>[mypy]\nplugins = pydantic.mypy\n</code></pre> <pre><code>[tool.mypy]\nplugins = ['pydantic.mypy']\n</code></pre> <p>Note</p> <p>\u5982\u679c\u60a8\u4f7f\u7528\u7684\u662f <code>pydantic.v1</code> \u6a21\u578b\uff0c\u60a8\u9700\u8981\u5c06 <code>pydantic.v1.mypy</code> \u6dfb\u52a0\u5230\u60a8\u7684\u63d2\u4ef6\u5217\u8868\u4e2d\u3002</p> <p>\u6709\u5173\u66f4\u591a\u8be6\u7ec6\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 \u63d2\u4ef6\u914d\u7f6e\u3002</p>"},{"location":"integrations/mypy/#mypy-plugin-capabilities","title":"Mypy \u63d2\u4ef6\u529f\u80fd","text":""},{"location":"integrations/mypy/#pydantic-__init__","title":"\u4e3a Pydantic \u6a21\u578b\u751f\u6210 <code>__init__</code> \u7b7e\u540d","text":"<ul> <li>\u4efb\u4f55\u6ca1\u6709\u52a8\u6001\u786e\u5b9a\u522b\u540d\u7684\u5fc5\u9700\u5b57\u6bb5\u90fd\u5c06\u4f5c\u4e3a\u5fc5\u9700\u7684\u5173\u952e\u5b57\u53c2\u6570\u5305\u542b\u5728\u5185\u3002</li> <li>\u5982\u679c <code>validate_by_name</code> \u6a21\u578b\u914d\u7f6e\u503c\u8bbe\u7f6e\u4e3a <code>True</code>\uff0c\u751f\u6210\u7684\u7b7e\u540d\u5c06\u4f7f\u7528\u5b57\u6bb5\u540d\u79f0\u800c\u4e0d\u662f\u522b\u540d\u3002</li> <li><code>init_forbid_extra</code> \u548c <code>init_typed</code> \u63d2\u4ef6\u914d\u7f6e\u503c\u53ef\u4ee5\u8fdb\u4e00\u6b65\u5fae\u8c03\u5408\u6210\u7684 <code>__init__</code> \u65b9\u6cd5\u3002</li> </ul>"},{"location":"integrations/mypy/#model_construct","title":"\u4e3a <code>model_construct</code> \u751f\u6210\u7c7b\u578b\u5316\u7b7e\u540d","text":"<ul> <li><code>model_construct</code> \u65b9\u6cd5\u662f\u6a21\u578b\u9a8c\u8bc1\u7684\u66ff\u4ee3\u65b9\u6848\uff0c\u5f53\u8f93\u5165\u6570\u636e\u5df2\u77e5\u6709\u6548\u4e14\u4e0d\u5e94\u89e3\u6790\u65f6\u4f7f\u7528\uff08\u8bf7\u53c2\u9605 \u6587\u6863\uff09\u3002   \u7531\u4e8e\u6b64\u65b9\u6cd5\u4e0d\u6267\u884c\u8fd0\u884c\u65f6\u9a8c\u8bc1\uff0c\u9759\u6001\u68c0\u67e5\u5bf9\u4e8e\u68c0\u6d4b\u9519\u8bef\u975e\u5e38\u91cd\u8981\u3002</li> </ul>"},{"location":"integrations/mypy/#_1","title":"\u652f\u6301\u51bb\u7ed3\u6a21\u578b","text":"<ul> <li>\u5982\u679c <code>frozen</code> \u914d\u7f6e\u8bbe\u7f6e\u4e3a <code>True</code>\uff0c\u5f53\u60a8\u5c1d\u8bd5\u4fee\u6539\u6a21\u578b\u5b57\u6bb5\u65f6\u4f1a\u51fa\u73b0\u9519\u8bef\uff08\u8bf7\u53c2\u9605 \u4f2a\u4e0d\u53ef\u53d8\u6027\uff09</li> </ul>"},{"location":"integrations/mypy/#field-default-default_factory","title":"\u5c0a\u91cd <code>Field</code> \u7684 <code>default</code> \u548c <code>default_factory</code> \u7c7b\u578b","text":"<ul> <li>\u540c\u65f6\u5177\u6709 <code>default</code> \u548c <code>default_factory</code> \u7684\u5b57\u6bb5\u5c06\u5728\u9759\u6001\u68c0\u67e5\u671f\u95f4\u5bfc\u81f4\u9519\u8bef\u3002</li> <li><code>default</code> \u548c <code>default_factory</code> \u503c\u7684\u7c7b\u578b\u5fc5\u987b\u4e0e\u5b57\u6bb5\u7684\u7c7b\u578b\u517c\u5bb9\u3002</li> </ul>"},{"location":"integrations/mypy/#_2","title":"\u8b66\u544a\u4f7f\u7528\u65e0\u7c7b\u578b\u5b57\u6bb5","text":"<ul> <li>\u867d\u7136\u5b9a\u4e49\u6ca1\u6709\u6ce8\u89e3\u7684\u5b57\u6bb5\u4f1a\u5bfc\u81f4 \u8fd0\u884c\u65f6\u9519\u8bef\uff0c\u4f46\u63d2\u4ef6\u4e5f\u4f1a\u53d1\u51fa\u7c7b\u578b\u68c0\u67e5\u9519\u8bef\u3002</li> </ul>"},{"location":"integrations/mypy/#_3","title":"\u9632\u6b62\u4f7f\u7528\u5fc5\u9700\u7684\u52a8\u6001\u522b\u540d","text":"<p>\u8bf7\u53c2\u9605 <code>warn_required_dynamic_aliases</code> \u63d2\u4ef6\u914d\u7f6e\u503c\u7684\u6587\u6863\u3002</p>"},{"location":"integrations/mypy/#configuring-the-plugin","title":"\u914d\u7f6e\u63d2\u4ef6","text":"<p>\u8981\u66f4\u6539\u63d2\u4ef6\u8bbe\u7f6e\u7684\u503c\uff0c\u8bf7\u5728\u60a8\u7684 mypy \u914d\u7f6e\u6587\u4ef6\u4e2d\u521b\u5efa\u4e00\u4e2a\u540d\u4e3a <code>[pydantic-mypy]</code> \u7684\u90e8\u5206\uff0c\u5e76\u6dfb\u52a0\u60a8\u60f3\u8981\u8986\u76d6\u7684\u8bbe\u7f6e\u952e\u503c\u5bf9\u3002</p> <p>\u542f\u7528\u6240\u6709\u63d2\u4ef6\u4e25\u683c\u6027\u6807\u5fd7\uff08\u4ee5\u53ca\u4e00\u4e9b\u5176\u4ed6 mypy \u4e25\u683c\u6027\u6807\u5fd7\uff09\u7684\u914d\u7f6e\u6587\u4ef6\u53ef\u80fd\u5982\u4e0b\u6240\u793a\uff1a</p> <code>mypy.ini</code><code>pyproject.toml</code> <pre><code>[mypy]\nplugins = pydantic.mypy\n\nfollow_imports = silent\nwarn_redundant_casts = True\nwarn_unused_ignores = True\ndisallow_any_generics = True\nno_implicit_reexport = True\ndisallow_untyped_defs = True\n\n[pydantic-mypy]\ninit_forbid_extra = True\ninit_typed = True\nwarn_required_dynamic_aliases = True\n</code></pre> <pre><code>[tool.mypy]\nplugins = [\"pydantic.mypy\"]\n\nfollow_imports = \"silent\"\nwarn_redundant_casts = true\nwarn_unused_ignores = true\ndisallow_any_generics = true\nno_implicit_reexport = true\ndisallow_untyped_defs = true\n\n[tool.pydantic-mypy]\ninit_forbid_extra = true\ninit_typed = true\nwarn_required_dynamic_aliases = true\n</code></pre>"},{"location":"integrations/mypy/#init_typed","title":"<code>init_typed</code>","text":"<p>\u7531\u4e8e Pydantic \u9ed8\u8ba4\u6267\u884c \u6570\u636e\u8f6c\u6362\uff0c\u4ee5\u4e0b\u4ee3\u7801\u5728\u8fd0\u884c\u65f6\u4ecd\u7136\u6709\u6548\uff1a</p> <pre><code>class Model(BaseModel):\n    a: int\n\n\nModel(a='1')\n</code></pre> <p>\u56e0\u6b64\uff0c\u63d2\u4ef6\u5728\u5408\u6210 <code>__init__</code> \u65b9\u6cd5\u65f6\u5c06\u4f7f\u7528 <code>Any</code> \u4f5c\u4e3a\u5b57\u6bb5\u6ce8\u89e3\uff0c\u9664\u975e\u8bbe\u7f6e\u4e86 <code>init_typed</code> \u6216\u5728\u6a21\u578b\u4e0a\u542f\u7528\u4e86 \u4e25\u683c\u6a21\u5f0f\u3002</p>"},{"location":"integrations/mypy/#init_forbid_extra","title":"<code>init_forbid_extra</code>","text":"<p>\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0cPydantic \u5141\u8bb8\uff08\u5e76\u5ffd\u7565\uff09\u4efb\u4f55\u989d\u5916\u63d0\u4f9b\u7684\u53c2\u6570\uff1a</p> <pre><code>class Model(BaseModel):\n    a: int = 1\n\n\nModel(unrelated=2)\n</code></pre> <p>\u56e0\u6b64\uff0c\u63d2\u4ef6\u5728\u5408\u6210 <code>__init__</code> \u65b9\u6cd5\u65f6\u5c06\u6dfb\u52a0\u4e00\u4e2a\u989d\u5916\u7684 <code>**kwargs: Any</code> \u53c2\u6570\uff0c\u9664\u975e\u8bbe\u7f6e\u4e86 <code>init_forbid_extra</code> \u6216\u5c06 <code>extra</code> \u8bbe\u7f6e\u4e3a <code>'forbid'</code>\u3002</p>"},{"location":"integrations/mypy/#warn_required_dynamic_aliases","title":"<code>warn_required_dynamic_aliases</code>","text":"<p>\u662f\u5426\u5728\u4f7f\u7528\u52a8\u6001\u786e\u5b9a\u7684\u522b\u540d\u6216\u522b\u540d\u751f\u6210\u5668\u65f6\u51fa\u9519\uff0c\u5f53\u6a21\u578b\u4e0a\u7684 <code>validate_by_name</code> \u8bbe\u7f6e\u4e3a <code>False</code> \u65f6\u3002\u5982\u679c\u5b58\u5728\u8fd9\u6837\u7684\u522b\u540d\uff0cmypy \u65e0\u6cd5\u6b63\u786e\u7c7b\u578b\u68c0\u67e5\u5bf9 <code>__init__</code> \u7684\u8c03\u7528\u3002\u5728\u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u5b83\u5c06\u9ed8\u8ba4\u5c06\u6240\u6709\u53c2\u6570\u89c6\u4e3a\u975e\u5fc5\u9700\u3002</p> <p>\u4e0e\u7981\u7528 <code>Any</code> \u7684\u517c\u5bb9\u6027</p> <p>\u4e00\u4e9b mypy \u914d\u7f6e\u9009\u9879\uff08\u4f8b\u5982 <code>disallow_any_explicit</code>\uff09 \u4f1a\u51fa\u9519\uff0c\u56e0\u4e3a\u5408\u6210\u7684 <code>__init__</code> \u65b9\u6cd5\u5305\u542b <code>Any</code> \u6ce8\u89e3\u3002\u8981\u89c4\u907f\u6b64\u95ee\u9898\uff0c\u60a8\u5fc5\u987b\u540c\u65f6\u542f\u7528 <code>init_forbid_extra</code> \u548c <code>init_typed</code>\u3002</p>"},{"location":"integrations/pycharm/","title":"PyCharm","text":"<p>\u867d\u7136 pydantic \u53ef\u4ee5\u4e0e\u4efb\u4f55 IDE \u5f00\u7bb1\u5373\u7528\u5730\u826f\u597d\u914d\u5408\uff0c\u4f46 JetBrains \u63d2\u4ef6\u5e93\u4e2d\u63d0\u4f9b\u4e86\u4e00\u4e2a PyCharm \u63d2\u4ef6\uff0c\u53ef\u63d0\u4f9b\u6539\u8fdb\u7684 pydantic \u96c6\u6210\u3002 \u60a8\u53ef\u4ee5\u4ece\u63d2\u4ef6\u5e02\u573a\u514d\u8d39\u5b89\u88c5\u8be5\u63d2\u4ef6 (PyCharm \u7684 Preferences -&gt; Plugin -&gt; Marketplace -&gt; \u641c\u7d22 \"pydantic\")\u3002</p> <p>\u8be5\u63d2\u4ef6\u76ee\u524d\u652f\u6301\u4ee5\u4e0b\u529f\u80fd\uff1a</p> <ul> <li> <p>\u5bf9\u4e8e <code>pydantic.BaseModel.__init__</code>\uff1a</p> <ul> <li>\u68c0\u67e5</li> <li>\u81ea\u52a8\u8865\u5168</li> <li>\u7c7b\u578b\u68c0\u67e5</li> </ul> </li> <li> <p>\u5bf9\u4e8e <code>pydantic.BaseModel</code> \u7684\u5b57\u6bb5\uff1a</p> <ul> <li>\u91cd\u6784-\u91cd\u547d\u540d\u5b57\u6bb5\u4f1a\u66f4\u65b0 <code>__init__</code> \u8c03\u7528\uff0c\u5e76\u5f71\u54cd\u5b50\u7c7b\u548c\u8d85\u7c7b</li> <li>\u91cd\u6784-\u91cd\u547d\u540d <code>__init__</code> \u5173\u952e\u5b57\u53c2\u6570\u4f1a\u66f4\u65b0\u5b57\u6bb5\u540d\u79f0\uff0c\u5e76\u5f71\u54cd\u5b50\u7c7b\u548c\u8d85\u7c7b</li> </ul> </li> </ul> <p>\u66f4\u591a\u4fe1\u606f\u53ef\u4ee5\u5728 \u5b98\u65b9\u63d2\u4ef6\u9875\u9762 \u548c Github \u4ed3\u5e93 \u4e0a\u627e\u5230\u3002</p>"},{"location":"integrations/pyrefly/","title":"Pyrefly","text":"<p>Pyrefly \u662f\u4e00\u4e2a Python \u7c7b\u578b\u68c0\u67e5\u5668\u548c\u8bed\u8a00\u670d\u52a1\u5668\uff0c\u5185\u7f6e\u4e86\u5bf9\u8bb8\u591a Pydantic \u7279\u5b9a\u529f\u80fd\u7684\u652f\u6301\u3002\u8fd9\u79cd\u652f\u6301\u5728\u5b89\u88c5\u4e86 Pydantic \u548c Pyrefly \u540e\u5373\u53ef\u5f00\u7bb1\u5373\u7528\uff0c\u65e0\u9700\u989d\u5916\u914d\u7f6e\u3002</p> <p>Pyrefly \u65e2\u53ef\u4ee5\u4f5c\u4e3a IDE \u6269\u5c55 \u4f7f\u7528\uff0c\u4e5f\u53ef\u4ee5\u4f5c\u4e3a \u547d\u4ee4\u884c\u7c7b\u578b\u68c0\u67e5\u5668 \u4f7f\u7528\u3002</p>"},{"location":"integrations/pyrefly/#ide","title":"IDE \u6269\u5c55","text":"<p>Pyrefly \u4e3a\u60a8\u63d0\u4f9b IDE \u529f\u80fd\uff0c\u4f8b\u5982\u5728 Pydantic \u6a21\u578b\u4e0a\u7684\u8df3\u8f6c\u5230\u5b9a\u4e49\u548c\u81ea\u52a8\u8865\u5168\u3002</p> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u7b7e\u540d\u5e2e\u52a9\u7684\u793a\u4f8b\uff0c\u7531 Pyrefly \u5bf9 Pydantic \u7279\u5b9a\u7684 <code>validation_alias</code> \u5173\u952e\u5b57\u7684\u7406\u89e3\u63d0\u4f9b\u652f\u6301\uff1a</p> <p></p> <p>\u5f53\u60a8\u8f93\u5165 <code>Model()</code> \u65f6\uff0cPyrefly \u63d0\u793a\u60a8\u9700\u8981\u4f7f\u7528\u540d\u79f0 <code>x_</code> \u6765\u586b\u5145 <code>x</code> \u5b57\u6bb5\u3002</p>"},{"location":"integrations/pyrefly/#_1","title":"\u7c7b\u578b\u68c0\u67e5\u5668","text":"<p>Pyrefly \u8fd8\u53ef\u4ee5\u5728\u60a8\u8fd0\u884c\u4ee3\u7801\u4e4b\u524d\u6355\u83b7\u9519\u8bef\u3002\u8003\u8651\u4ee5\u4e0b\u793a\u4f8b\uff1a</p> <pre><code>from pydantic import BaseModel, ConfigDict\n\n\nclass Model1(BaseModel, frozen=True):\n    x: int\n\n\nclass Model2(BaseModel):\n    model_config = ConfigDict(frozen=True)\n    x: int\n\n\nmodel1 = Model1(x=0)\nmodel1.x = 1  # validation error: mutating a frozen field\n\nmodel2 = Model2(x=0)\nmodel2.x = 1  # validation error: mutating a frozen field\n</code></pre> <p>\u7531\u4e8e <code>Model1</code> \u4f7f\u7528 \u6807\u51c6\u7c7b\u578b\u7cfb\u7edf\u529f\u80fd \u58f0\u660e\u5b83\u662f\u51bb\u7ed3\u7684\uff0c\u4efb\u4f55\u60a8\u9009\u62e9\u7684\u7c7b\u578b\u68c0\u67e5\u5668\u90fd\u4f1a\u6355\u83b7\u4fee\u6539 <code>model1.x</code> \u7684\u9a8c\u8bc1\u9519\u8bef\u3002\u7136\u800c\uff0c\u6ca1\u6709\u5bf9 Pydantic <code>ConfigDict</code> \u7c7b\u7279\u6b8a\u652f\u6301\u7684\u7c7b\u578b\u68c0\u67e5\u5668\u4f1a\u9519\u8fc7\u4fee\u6539 <code>model2.x</code> \u7684\u9a8c\u8bc1\u9519\u8bef\u3002</p> <p>Pyrefly \u6355\u83b7\u4e86\u8fd9\u4e24\u4e2a\u9519\u8bef\uff1a</p> <pre><code>ERROR Cannot set field `x` [read-only]\n  --&gt; foo.py:11:1\n   |\n11 | model1.x = 1  # validation error: mutating a frozen field\n   | ^^^^^^^^\n   |\n  This field belongs to a frozen Pydantic model\nERROR Cannot set field `x` [read-only]\n  --&gt; foo.py:14:1\n   |\n14 | model2.x = 1  # validation error: mutating a frozen field\n   | ^^^^^^^^\n   |\n  This field belongs to a frozen Pydantic model\n</code></pre> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Pyrefly \u6587\u6863\u3002</p>"},{"location":"integrations/rich/","title":"Rich","text":"<p>Pydantic \u6a21\u578b\u53ef\u4ee5\u4f7f\u7528 Rich \u5e93\u8fdb\u884c\u6253\u5370\uff0c\u8fd9\u5c06\u4e3a\u8f93\u51fa\u6dfb\u52a0\u989d\u5916\u7684\u683c\u5f0f\u548c\u989c\u8272\u3002\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a</p> <p></p> <p>\u6709\u5173\u66f4\u591a\u4fe1\u606f\uff0c\u8bf7\u53c2\u9605 Rich \u6587\u6863\u4e2d\u7684 \u7f8e\u5316\u6253\u5370 \u90e8\u5206\u3002</p>"},{"location":"integrations/visual_studio_code/","title":"Visual Studio Code","text":"<p>Pydantic \u4e0e\u4efb\u4f55\u7f16\u8f91\u5668\u6216 IDE \u90fd\u80fd\u5f88\u597d\u5730\u5f00\u7bb1\u5373\u7528\uff0c\u56e0\u4e3a\u5b83\u5efa\u7acb\u5728\u6807\u51c6 Python \u7c7b\u578b\u6ce8\u89e3\u4e4b\u4e0a\u3002</p> <p>\u5f53\u4f7f\u7528 Visual Studio Code (VS Code) \u65f6\uff0c\u652f\u6301\u4e00\u4e9b\u989d\u5916\u7684\u7f16\u8f91\u5668\u529f\u80fd\uff0c\u4e0e PyCharm \u63d2\u4ef6 \u63d0\u4f9b\u7684\u529f\u80fd\u76f8\u5f53\u3002</p> <p>\u8fd9\u610f\u5473\u7740\u5373\u4f7f\u5728\u521b\u5efa\u65b0\u7684 Pydantic \u6a21\u578b\u5b9e\u4f8b\u65f6\uff0c\u60a8\u4e5f\u5c06\u62e5\u6709\u81ea\u52a8\u8865\u5168\uff08\u6216 \"IntelliSense\"\uff09\u548c\u9488\u5bf9\u7c7b\u578b\u53ca\u5fc5\u9700\u53c2\u6570\u7684\u9519\u8bef\u68c0\u67e5\u3002</p> <p></p>"},{"location":"integrations/visual_studio_code/#vs-code","title":"\u914d\u7f6e VS Code","text":"<p>\u8981\u5229\u7528\u8fd9\u4e9b\u529f\u80fd\uff0c\u60a8\u9700\u8981\u786e\u4fdd\u6b63\u786e\u914d\u7f6e VS Code\uff0c\u4f7f\u7528\u63a8\u8350\u7684\u8bbe\u7f6e\u3002</p> <p>\u5982\u679c\u60a8\u6709\u4e0d\u540c\u7684\u914d\u7f6e\uff0c\u8fd9\u91cc\u7b80\u8981\u6982\u8ff0\u4e00\u4e0b\u6b65\u9aa4\u3002</p>"},{"location":"integrations/visual_studio_code/#pylance","title":"\u5b89\u88c5 Pylance","text":"<p>\u60a8\u5e94\u8be5\u4f7f\u7528 VS Code \u7684 Pylance \u6269\u5c55\u3002\u5b83\u662f\u63a8\u8350\u7684\u3001\u65b0\u4e00\u4ee3\u7684\u5b98\u65b9 VS Code Python \u63d2\u4ef6\u3002</p> <p>Pylance \u9ed8\u8ba4\u4f5c\u4e3a VS Code \u7684 Python \u6269\u5c55 \u7684\u4e00\u90e8\u5206\u5b89\u88c5\uff0c\u56e0\u6b64\u5b83\u5e94\u8be5\u53ef\u4ee5\u76f4\u63a5\u5de5\u4f5c\u3002\u5426\u5219\uff0c\u60a8\u53ef\u4ee5\u518d\u6b21\u68c0\u67e5\u5b83\u662f\u5426\u5df2\u5b89\u88c5\u5e76\u5728\u7f16\u8f91\u5668\u4e2d\u542f\u7528\u3002</p>"},{"location":"integrations/visual_studio_code/#_1","title":"\u914d\u7f6e\u60a8\u7684\u73af\u5883","text":"<p>\u7136\u540e\u60a8\u9700\u8981\u786e\u4fdd\u7f16\u8f91\u5668\u77e5\u9053\u60a8\u7684 Python \u9879\u76ee\u7684 Python \u73af\u5883\uff08\u53ef\u80fd\u662f\u4e00\u4e2a\u865a\u62df\u73af\u5883\uff09\u3002</p> <p>\u8fd9\u5e94\u8be5\u662f\u60a8\u5b89\u88c5 Pydantic \u7684\u73af\u5883\u3002</p>"},{"location":"integrations/visual_studio_code/#pylance_1","title":"\u914d\u7f6e Pylance","text":"<p>\u4f7f\u7528\u9ed8\u8ba4\u914d\u7f6e\uff0c\u60a8\u5c06\u83b7\u5f97\u81ea\u52a8\u8865\u5168\u652f\u6301\uff0c\u4f46 Pylance \u53ef\u80fd\u4e0d\u4f1a\u68c0\u67e5\u7c7b\u578b\u9519\u8bef\u3002</p> <p>\u60a8\u53ef\u4ee5\u901a\u8fc7\u4ee5\u4e0b\u6b65\u9aa4\u542f\u7528 Pylance \u7684\u7c7b\u578b\u9519\u8bef\u68c0\u67e5\uff1a</p> <ul> <li>\u6253\u5f00\"\u7528\u6237\u8bbe\u7f6e\"</li> <li>\u641c\u7d22 <code>Type Checking Mode</code></li> <li>\u60a8\u5c06\u5728 <code>Python \u203a Analysis: Type Checking Mode</code> \u4e0b\u627e\u5230\u4e00\u4e2a\u9009\u9879</li> <li>\u5c06\u5176\u8bbe\u7f6e\u4e3a <code>basic</code> \u6216 <code>strict</code>\uff08\u9ed8\u8ba4\u4e3a <code>off</code>\uff09</li> </ul> <p></p> <p>\u73b0\u5728\uff0c\u5f53\u521b\u5efa\u65b0\u7684 Pydantic \u6a21\u578b\u5b9e\u4f8b\u65f6\uff0c\u60a8\u4e0d\u4ec5\u4f1a\u83b7\u5f97\u81ea\u52a8\u8865\u5168\uff0c\u8fd8\u4f1a\u83b7\u5f97\u5bf9\u5fc5\u9700\u53c2\u6570\u7684\u9519\u8bef\u68c0\u67e5\u3002</p> <p></p> <p>\u60a8\u8fd8\u5c06\u83b7\u5f97\u5bf9\u65e0\u6548\u6570\u636e\u7c7b\u578b\u7684\u9519\u8bef\u68c0\u67e5\u3002</p> <p></p> <p>\u6280\u672f\u7ec6\u8282</p> <p>Pylance \u662f VS Code \u6269\u5c55\uff0c\u5b83\u662f\u95ed\u6e90\u7684\uff0c\u4f46\u53ef\u4ee5\u514d\u8d39\u4f7f\u7528\u3002\u5728\u5e95\u5c42\uff0cPylance \u4f7f\u7528\u4e00\u4e2a\u540d\u4e3a Pyright \u7684\u5f00\u6e90\u5de5\u5177\uff08\u4e5f\u6765\u81ea Microsoft\uff09\u6765\u5b8c\u6210\u6240\u6709\u7e41\u91cd\u7684\u5de5\u4f5c\u3002</p> <p>\u60a8\u53ef\u4ee5\u5728 Pylance \u5e38\u89c1\u95ee\u9898\u89e3\u7b54 \u4e2d\u4e86\u89e3\u66f4\u591a\u4fe1\u606f\u3002</p>"},{"location":"integrations/visual_studio_code/#mypy","title":"\u914d\u7f6e mypy","text":"<p>\u60a8\u53ef\u80fd\u8fd8\u5e0c\u671b\u5728 VS Code \u4e2d\u914d\u7f6e mypy\uff0c\u4ee5\u4fbf\u5728\u7f16\u8f91\u5668\u4e2d\u83b7\u5f97\u5185\u8054\u7684 mypy \u9519\u8bef\u68c0\u67e5\uff08\u4f5c\u4e3a Pylance \u7684\u66ff\u4ee3\u6216\u8865\u5145\uff09\u3002</p> <p>\u8fd9\u5c06\u5305\u62ec Pydantic mypy \u63d2\u4ef6 \u68c0\u6d4b\u5230\u7684\u9519\u8bef\uff08\u5982\u679c\u60a8\u5df2\u914d\u7f6e\u5b83\uff09\u3002</p> <p>\u8981\u5728 VS Code \u4e2d\u542f\u7528 mypy\uff0c\u8bf7\u6267\u884c\u4ee5\u4e0b\u64cd\u4f5c\uff1a</p> <ul> <li>\u6253\u5f00\"\u7528\u6237\u8bbe\u7f6e\"</li> <li>\u641c\u7d22 <code>Mypy Enabled</code></li> <li>\u60a8\u5c06\u5728 <code>Python \u203a Linting: Mypy Enabled</code> \u4e0b\u627e\u5230\u4e00\u4e2a\u9009\u9879</li> <li>\u52fe\u9009\u8be5\u6846\uff08\u9ed8\u8ba4\u672a\u52fe\u9009\uff09</li> </ul> <p></p>"},{"location":"integrations/visual_studio_code/#_2","title":"\u63d0\u793a\u548c\u6280\u5de7","text":"<p>\u4ee5\u4e0b\u662f\u4e00\u4e9b\u989d\u5916\u7684\u63d0\u793a\u548c\u6280\u5de7\uff0c\u53ef\u6539\u5584\u60a8\u5728\u4f7f\u7528 VS Code \u4e0e Pydantic \u65f6\u7684\u5f00\u53d1\u4f53\u9a8c\u3002</p>"},{"location":"integrations/visual_studio_code/#_3","title":"\u4e25\u683c\u9519\u8bef","text":"<p>\u8fd9\u79cd\u989d\u5916\u7f16\u8f91\u5668\u652f\u6301\u7684\u5de5\u4f5c\u65b9\u5f0f\u662f\uff0cPylance \u4f1a\u5c06\u60a8\u7684 Pydantic \u6a21\u578b\u89c6\u4e3a Python \u7684\u7eaf <code>dataclasses</code>\u3002</p> <p>\u5b83\u5c06\u5728\u521b\u5efa\u65b0\u7684 Pydantic \u6a21\u578b\u5b9e\u4f8b\u65f6\u663e\u793a\u5173\u4e8e\u53c2\u6570\u4e2d\u4f20\u9012\u7684\u6570\u636e\u7c7b\u578b\u7684\u4e25\u683c\u7c7b\u578b\u9519\u8bef\u68c0\u67e5\u3002</p> <p>\u5728\u8fd9\u4e2a\u793a\u4f8b\u4e2d\uff0c\u60a8\u53ef\u4ee5\u770b\u5230\u5b83\u663e\u793a\u4e00\u4e2a\u503c\u4e3a <code>'23'</code> \u7684 <code>str</code> \u5bf9\u4e8e\u53c2\u6570 <code>age</code> \u4e0d\u662f\u6709\u6548\u7684 <code>int</code>\u3002</p> <p></p> <p>\u5b83\u671f\u671b\u7684\u662f <code>age=23</code> \u800c\u4e0d\u662f <code>age='23'</code>\u3002</p> <p>\u7136\u800c\uff0cPydantic \u7684\u8bbe\u8ba1\u548c\u4e3b\u8981\u7279\u6027\u4e4b\u4e00\u662f\u5b83\u5bf9\u6570\u636e\u7c7b\u578b\u975e\u5e38\u5bbd\u5bb9\u3002</p> <p>\u5b83\u5b9e\u9645\u4e0a\u4f1a\u63a5\u53d7\u503c\u4e3a <code>'23'</code> \u7684 <code>str</code>\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u503c\u4e3a <code>23</code> \u7684 <code>int</code>\u3002</p> <p>\u8fd9\u4e9b\u4e25\u683c\u9519\u8bef\u68c0\u67e5\u5728\u5927\u591a\u6570\u60c5\u51b5\u4e0b\u975e\u5e38\u6709\u7528\uff0c\u53ef\u4ee5\u5e2e\u52a9\u60a8\u53ca\u65e9\u53d1\u73b0\u8bb8\u591a\u9519\u8bef\u3002\u4f46\u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6bd4\u5982 <code>age='23'</code>\uff0c\u5b83\u4eec\u53ef\u80fd\u4f1a\u56e0\u4e3a\u62a5\u544a\"\u5047\u9633\u6027\"\u9519\u8bef\u800c\u5e26\u6765\u4e0d\u4fbf\u3002</p> <p>\u4e0a\u9762\u7684 <code>age='23'</code> \u793a\u4f8b\u6545\u610f\u7b80\u5316\uff0c\u4ee5\u663e\u793a\u9519\u8bef\u548c\u7c7b\u578b\u5dee\u5f02\u3002</p> <p>\u4f46\u8fd9\u4e9b\u4e25\u683c\u9519\u8bef\u4f1a\u5e26\u6765\u4e0d\u4fbf\u7684\u66f4\u5e38\u89c1\u60c5\u51b5\u662f\u4f7f\u7528\u66f4\u590d\u6742\u7684\u6570\u636e\u7c7b\u578b\u65f6\uff0c\u6bd4\u5982\u4e3a <code>datetime</code> \u5b57\u6bb5\u4f7f\u7528 <code>int</code> \u503c\uff0c\u6216\u4e3a Pydantic \u5b50\u6a21\u578b\u4f7f\u7528 <code>dict</code> \u503c\u3002</p> <p>\u4f8b\u5982\uff0c\u8fd9\u5bf9 Pydantic \u662f\u6709\u6548\u7684\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\n    knight: Knight\n\n\nquest = Quest(\n    title='To seek the Holy Grail', knight={'title': 'Sir Lancelot', 'age': 23}\n)\n</code></pre> <p>\u5b57\u6bb5 <code>knight</code> \u7684\u7c7b\u578b\u662f\u7528\u7c7b <code>Knight</code>\uff08\u4e00\u4e2a Pydantic \u6a21\u578b\uff09\u58f0\u660e\u7684\uff0c\u800c\u4ee3\u7801\u4f20\u9012\u7684\u662f\u4e00\u4e2a\u5b57\u9762\u91cf <code>dict</code>\u3002\u8fd9\u5bf9 Pydantic \u4ecd\u7136\u662f\u6709\u6548\u7684\uff0c<code>dict</code> \u5c06\u81ea\u52a8\u8f6c\u6362\u4e3a <code>Knight</code> \u5b9e\u4f8b\u3002</p> <p>\u7136\u800c\uff0c\u5b83\u5c06\u88ab\u68c0\u6d4b\u4e3a\u7c7b\u578b\u9519\u8bef\uff1a</p> <p></p> <p>\u5728\u8fd9\u4e9b\u60c5\u51b5\u4e0b\uff0c\u6709\u51e0\u79cd\u65b9\u6cd5\u53ef\u4ee5\u5728\u975e\u5e38\u7279\u5b9a\u7684\u5730\u65b9\u7981\u7528\u6216\u5ffd\u7565\u4e25\u683c\u9519\u8bef\uff0c\u540c\u65f6\u4ecd\u7136\u5728\u4ee3\u7801\u7684\u5176\u4f59\u90e8\u5206\u4fdd\u7559\u5b83\u4eec\u3002</p> <p>\u4ee5\u4e0b\u662f\u51e0\u79cd\u5b9e\u73b0\u6b64\u76ee\u7684\u7684\u6280\u672f\u3002</p>"},{"location":"integrations/visual_studio_code/#_4","title":"\u5728\u884c\u4e2d\u7981\u7528\u7c7b\u578b\u68c0\u67e5","text":"<p>\u60a8\u53ef\u4ee5\u4f7f\u7528\u4ee5\u4e0b\u6ce8\u91ca\u4e3a\u7279\u5b9a\u884c\u7981\u7528\u9519\u8bef\uff1a</p> <pre><code># type: ignore\n</code></pre> <p>\u6216\uff08\u7279\u5b9a\u4e8e pylance/pyright\uff09\uff1a</p> <pre><code># pyright: ignore\n</code></pre> <p>\uff08pyright \u662f Pylance \u4f7f\u7528\u7684\u8bed\u8a00\u670d\u52a1\u5668\uff09\u3002</p> <p>\u56de\u5230 <code>age='23'</code> \u7684\u793a\u4f8b\uff0c\u5b83\u5c06\u662f\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age='23')  # pyright: ignore\n</code></pre> <p>\u8fd9\u6837 Pylance \u548c mypy \u5c06\u5ffd\u7565\u8be5\u884c\u4e2d\u7684\u9519\u8bef\u3002</p> <p>\u4f18\u70b9\uff1a\u53ea\u9700\u5728\u8be5\u884c\u8fdb\u884c\u7b80\u5355\u66f4\u6539\u5373\u53ef\u79fb\u9664\u9519\u8bef\u3002</p> <p>\u7f3a\u70b9\uff1a\u8be5\u884c\u4e2d\u7684\u4efb\u4f55\u5176\u4ed6\u9519\u8bef\u4e5f\u5c06\u88ab\u5ffd\u7565\uff0c\u5305\u62ec\u7c7b\u578b\u68c0\u67e5\u3001\u62fc\u5199\u9519\u8bef\u7684\u53c2\u6570\u3001\u672a\u63d0\u4f9b\u7684\u5fc5\u9700\u53c2\u6570\u7b49\u3002</p>"},{"location":"integrations/visual_studio_code/#_5","title":"\u91cd\u5199\u53d8\u91cf\u7684\u7c7b\u578b","text":"<p>\u60a8\u8fd8\u53ef\u4ee5\u521b\u5efa\u4e00\u4e2a\u5305\u542b\u8981\u4f7f\u7528\u7684\u503c\u7684\u53d8\u91cf\uff0c\u5e76\u4f7f\u7528 <code>Any</code> \u663e\u5f0f\u58f0\u660e\u5176\u7c7b\u578b\u3002</p> <pre><code>from typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nage_str: Any = '23'\nlancelot = Knight(title='Sir Lancelot', age=age_str)\n</code></pre> <p>\u8fd9\u6837 Pylance \u548c mypy \u5c06\u89e3\u91ca\u53d8\u91cf <code>age_str</code>\uff0c\u5c31\u597d\u50cf\u5b83\u4eec\u4e0d\u77e5\u9053\u5176\u7c7b\u578b\u4e00\u6837\uff0c\u800c\u4e0d\u662f\u77e5\u9053\u5b83\u6709\u4e00\u4e2a <code>str</code> \u7c7b\u578b\uff0c\u800c\u671f\u671b\u7684\u662f <code>int</code>\uff08\u7136\u540e\u663e\u793a\u76f8\u5e94\u7684\u9519\u8bef\uff09\u3002</p> <p>\u4f18\u70b9\uff1a\u9519\u8bef\u5c06\u4ec5\u9488\u5bf9\u7279\u5b9a\u503c\u88ab\u5ffd\u7565\uff0c\u60a8\u4ecd\u7136\u4f1a\u770b\u5230\u5176\u4ed6\u53c2\u6570\u7684\u4efb\u4f55\u989d\u5916\u9519\u8bef\u3002</p> <p>\u7f3a\u70b9\uff1a\u5b83\u9700\u8981\u5bfc\u5165 <code>Any</code>\uff0c\u5e76\u4e3a\u6bcf\u4e2a\u9700\u8981\u5ffd\u7565\u9519\u8bef\u7684\u53c2\u6570\u5728\u65b0\u884c\u4e2d\u521b\u5efa\u4e00\u4e2a\u65b0\u53d8\u91cf\u3002</p>"},{"location":"integrations/visual_studio_code/#cast","title":"\u4f7f\u7528 <code>cast</code> \u91cd\u5199\u503c\u7684\u7c7b\u578b","text":"<p>\u524d\u4e00\u4e2a\u793a\u4f8b\u7684\u76f8\u540c\u60f3\u6cd5\u53ef\u4ee5\u501f\u52a9 <code>cast()</code> \u653e\u5728\u540c\u4e00\u884c\u4e2d\u3002</p> <p>\u8fd9\u6837\uff0c\u503c\u7684\u7c7b\u578b\u58f0\u660e\u88ab\u5185\u8054\u91cd\u5199\uff0c\u4e0d\u9700\u8981\u989d\u5916\u7684\u53d8\u91cf\u3002</p> <pre><code>from typing import Any, cast\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age=cast(Any, '23'))\n</code></pre> <p><code>cast(Any, '23')</code> \u4e0d\u4f1a\u5f71\u54cd\u503c\uff0c\u5b83\u4ecd\u7136\u53ea\u662f <code>'23'</code>\uff0c\u4f46\u73b0\u5728 Pylance \u548c mypy \u5c06\u5047\u5b9a\u5b83\u662f <code>Any</code> \u7c7b\u578b\uff0c\u8fd9\u610f\u5473\u7740\u5b83\u4eec\u5c06\u8868\u73b0\u5f97\u597d\u50cf\u4e0d\u77e5\u9053\u503c\u7684\u7c7b\u578b\u3002</p> <p>\u6240\u4ee5\uff0c\u8fd9\u7b49\u540c\u4e8e\u524d\u4e00\u4e2a\u793a\u4f8b\uff0c\u4f46\u6ca1\u6709\u989d\u5916\u7684\u53d8\u91cf\u3002</p> <p>\u4f18\u70b9\uff1a\u9519\u8bef\u5c06\u4ec5\u9488\u5bf9\u7279\u5b9a\u503c\u88ab\u5ffd\u7565\uff0c\u60a8\u4ecd\u7136\u4f1a\u770b\u5230\u5176\u4ed6\u53c2\u6570\u7684\u4efb\u4f55\u989d\u5916\u9519\u8bef\u3002\u4e0d\u9700\u8981\u989d\u5916\u7684\u53d8\u91cf\u3002</p> <p>\u7f3a\u70b9\uff1a\u5b83\u9700\u8981\u5bfc\u5165 <code>Any</code> \u548c <code>cast</code>\uff0c\u5982\u679c\u60a8\u4e0d\u4e60\u60ef\u4f7f\u7528 <code>cast()</code>\uff0c\u4e00\u5f00\u59cb\u53ef\u80fd\u4f1a\u89c9\u5f97\u5947\u602a\u3002</p>"},{"location":"integrations/visual_studio_code/#_6","title":"\u7c7b\u53c2\u6570\u4e2d\u7684\u914d\u7f6e","text":"<p>Pydantic \u63d0\u4f9b\u4e86\u4e30\u5bcc\u7684\u6a21\u578b\u914d\u7f6e\u96c6\u3002</p> <p>\u8fd9\u4e9b\u914d\u7f6e\u53ef\u4ee5\u5728\u6bcf\u4e2a\u6a21\u578b\u7684\u5185\u90e8 <code>class Config</code> \u4e2d\u8bbe\u7f6e\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    model_config = dict(frozen=True)\n    title: str\n    age: int\n    color: str = 'blue'\n</code></pre> <p>\u6216\u5728\u5b9a\u4e49\u6a21\u578b\u7c7b\u65f6\u4f5c\u4e3a\u5173\u952e\u5b57\u53c2\u6570\u4f20\u9012\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\n    title: str\n    age: int\n    color: str = 'blue'\n</code></pre> <p>\u7279\u5b9a\u7684\u914d\u7f6e <code>frozen</code>\uff08\u6d4b\u8bd5\u7248\uff09\u5177\u6709\u7279\u6b8a\u542b\u4e49\u3002</p> <p>\u5b83\u963b\u6b62\u5176\u4ed6\u4ee3\u7801\u5728\u6a21\u578b\u5b9e\u4f8b\u521b\u5efa\u540e\u66f4\u6539\u5b83\uff0c\u4f7f\u5176\u4fdd\u6301\"\u51bb\u7ed3\"\u72b6\u6001\u3002</p> <p>\u5f53\u4f7f\u7528\u7b2c\u4e8c\u4e2a\u7248\u672c\u58f0\u660e <code>frozen=True</code>\uff08\u5728\u7c7b\u5b9a\u4e49\u4e2d\u4f7f\u7528\u5173\u952e\u5b57\u53c2\u6570\uff09\u65f6\uff0c Pylance \u53ef\u4ee5\u4f7f\u7528\u5b83\u6765\u5e2e\u52a9\u60a8\u5728\u4ee3\u7801\u4e2d\u68c0\u67e5\u5e76\u68c0\u6d4b\u9519\u8bef\uff0c\u5f53\u67d0\u4e9b\u4e1c\u897f\u8bd5\u56fe\u5728\"\u51bb\u7ed3\"\u7684\u6a21\u578b\u4e2d\u8bbe\u7f6e\u503c\u65f6\u3002</p> <p></p>"},{"location":"integrations/visual_studio_code/#field","title":"\u4f7f\u7528 <code>Field</code> \u6dfb\u52a0\u9ed8\u8ba4\u503c","text":"<p>Pylance/pyright \u8981\u6c42 <code>default</code> \u662f <code>Field</code> \u7684\u5173\u952e\u5b57\u53c2\u6570\uff0c\u4ee5\u4fbf\u63a8\u65ad\u8be5\u5b57\u6bb5\u662f\u53ef\u9009\u7684\u3002</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # \u8fd9\u662f\u53ef\u4ee5\u7684\n    age: int = Field(\n        23\n    )  # \u8fd9\u5728\u8fd0\u884c\u65f6\u5de5\u4f5c\u6b63\u5e38\uff0c\u4f46\u4f1a\u5bfc\u81f4 pyright \u9519\u8bef\n\n\nlance = Knight()  # \u9519\u8bef\uff1a\u7f3a\u5c11\u53c2\u6570 \"age\"\n</code></pre> <p>\u8fd9\u662f dataclass \u8f6c\u6362\u7684\u9650\u5236\uff0c\u65e0\u6cd5\u5728 pydantic \u4e2d\u4fee\u590d\u3002</p>"},{"location":"integrations/visual_studio_code/#_7","title":"\u6280\u672f\u7ec6\u8282","text":"<p>Warning</p> <p>\u4f5c\u4e3a Pydantic \u7528\u6237\uff0c\u60a8\u4e0d\u9700\u8981\u4e0b\u9762\u7684\u8be6\u7ec6\u4fe1\u606f\u3002\u53ef\u4ee5\u968f\u610f\u8df3\u8fc7\u672c\u8282\u7684\u5176\u4f59\u90e8\u5206\u3002</p> <p>\u8fd9\u4e9b\u7ec6\u8282\u4ec5\u5bf9\u5176\u4ed6\u5e93\u4f5c\u8005\u7b49\u6709\u7528\u3002</p> <p>\u8fd9\u79cd\u989d\u5916\u7684\u7f16\u8f91\u5668\u652f\u6301\u662f\u901a\u8fc7\u5229\u7528 <code>@dataclass_transform</code> \u88c5\u9970\u5668 \uff08\u7531 PEP 681 \u5f15\u5165\uff09\u6765\u5b9e\u73b0\u7684\u3002</p> <p>\u8be5\u6807\u51c6\u4e3a Pydantic \u7b49\u5e93\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b9\u5f0f\uff0c\u544a\u8bc9\u7f16\u8f91\u5668\u548c\u5de5\u5177\u5b83\u4eec\uff08\u7f16\u8f91\u5668\uff09\u5e94\u8be5\u5c06\u8fd9\u4e9b\u5e93\uff08\u4f8b\u5982 Pydantic\uff09\u89c6\u4e3a dataclasses\uff0c\u63d0\u4f9b\u81ea\u52a8\u8865\u5168\u3001\u7c7b\u578b\u68c0\u67e5\u7b49\u529f\u80fd\u3002</p>"},{"location":"internals/architecture/","title":"Architecture","text":"<p>Note</p> <p>\u672c\u8282\u662f\u5185\u90e8\u6587\u6863\u7684\u4e00\u90e8\u5206\uff0c\u4e3b\u8981\u9762\u5411\u8d21\u732e\u8005\u3002</p> <p>\u4ece Pydantic V2 \u5f00\u59cb\uff0c\u90e8\u5206\u4ee3\u7801\u5e93\u4f7f\u7528 Rust \u7f16\u5199\uff0c\u5e76\u653e\u5728\u4e00\u4e2a\u540d\u4e3a <code>pydantic-core</code> \u7684\u72ec\u7acb\u5305\u4e2d\u3002 \u8fd9\u6837\u505a\u4e3b\u8981\u662f\u4e3a\u4e86\u63d0\u9ad8\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u7684\u6027\u80fd\uff08\u4ee3\u4ef7\u662f\u5185\u90e8\u903b\u8f91\u7684\u81ea\u5b9a\u4e49\u6027\u548c\u53ef\u6269\u5c55\u6027\u6709\u9650\uff09\u3002</p> <p>\u672c\u67b6\u6784\u6587\u6863\u5c06\u9996\u5148\u4ecb\u7ecd <code>pydantic</code> \u548c <code>pydantic-core</code> \u8fd9\u4e24\u4e2a\u5305\u5982\u4f55\u4ea4\u4e92\uff0c \u7136\u540e\u8be6\u7ec6\u4ecb\u7ecd\u5404\u79cd\u6a21\u5f0f\u7684\u67b6\u6784\u7ec6\u8282\uff08\u6a21\u578b\u5b9a\u4e49\u3001\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u3001JSON Schema\uff09\u3002</p> <p>Pydantic \u5e93\u7684\u4f7f\u7528\u53ef\u4ee5\u5206\u4e3a\u4e24\u4e2a\u90e8\u5206\uff1a</p> <ul> <li>\u6a21\u578b\u5b9a\u4e49\uff0c\u5728 <code>pydantic</code> \u5305\u4e2d\u5b8c\u6210\u3002</li> <li>\u6a21\u578b\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\uff0c\u5728 <code>pydantic-core</code> \u5305\u4e2d\u5b8c\u6210\u3002</li> </ul>"},{"location":"internals/architecture/#_1","title":"\u6a21\u578b\u5b9a\u4e49","text":"<p>\u6bcf\u5f53\u5b9a\u4e49\u4e00\u4e2a Pydantic <code>BaseModel</code> \u65f6\uff0c\u5143\u7c7b \u4f1a\u5206\u6790\u6a21\u578b\u7684\u4e3b\u4f53\u4ee5\u6536\u96c6\u591a\u4e2a\u5143\u7d20\uff1a</p> <ul> <li>\u5b9a\u4e49\u7684\u6ce8\u89e3\u4ee5\u6784\u5efa\u6a21\u578b\u5b57\u6bb5\uff08\u6536\u96c6\u5728 <code>model_fields</code> \u5c5e\u6027\u4e2d\uff09\u3002</li> <li>\u6a21\u578b\u914d\u7f6e\uff0c\u901a\u8fc7 <code>model_config</code> \u8bbe\u7f6e\u3002</li> <li>\u989d\u5916\u7684\u9a8c\u8bc1\u5668/\u5e8f\u5217\u5316\u5668\u3002</li> <li>\u79c1\u6709\u5c5e\u6027\u3001\u7c7b\u53d8\u91cf\u3001\u6cdb\u578b\u53c2\u6570\u5316\u7684\u8bc6\u522b\u7b49\u3002</li> </ul>"},{"location":"internals/architecture/#communicating-between-pydantic-and-pydantic-core-the-core-schema","title":"<code>pydantic</code> \u548c <code>pydantic-core</code> \u4e4b\u95f4\u7684\u901a\u4fe1\uff1a\u6838\u5fc3\u6a21\u5f0f","text":"<p>\u6211\u4eec\u9700\u8981\u4e00\u79cd\u65b9\u5f0f\u5c06\u6a21\u578b\u5b9a\u4e49\u4e2d\u6536\u96c6\u7684\u4fe1\u606f\u4f20\u9012\u7ed9 <code>pydantic-core</code>\uff0c \u4ee5\u4fbf\u76f8\u5e94\u5730\u6267\u884c\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u3002\u4e3a\u6b64\uff0cPydantic \u4f7f\u7528\u4e86\u6838\u5fc3\u6a21\u5f0f\u7684\u6982\u5ff5\uff1a \u4e00\u4e2a\u7ed3\u6784\u5316\u7684\uff08\u53ef\u5e8f\u5217\u5316\u7684\uff09Python \u5b57\u5178\uff08\u4f7f\u7528 <code>TypedDict</code> \u5b9a\u4e49\u8868\u793a\uff09\uff0c \u63cf\u8ff0\u7279\u5b9a\u7684\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u903b\u8f91\u3002\u5b83\u662f <code>pydantic</code> \u548c <code>pydantic-core</code> \u5305\u4e4b\u95f4\u901a\u4fe1\u7684\u6838\u5fc3\u6570\u636e\u7ed3\u6784\u3002 \u6bcf\u4e2a\u6838\u5fc3\u6a21\u5f0f\u90fd\u6709\u4e00\u4e2a\u5fc5\u9700\u7684 <code>type</code> \u952e\uff0c\u4ee5\u53ca\u6839\u636e\u6b64 <code>type</code> \u7684\u989d\u5916\u5c5e\u6027\u3002</p> <p>\u6838\u5fc3\u6a21\u5f0f\u7684\u751f\u6210\u7531 <code>GenerateSchema</code> \u7c7b\u5728\u5355\u4e2a\u5730\u65b9\u5904\u7406 \uff08\u65e0\u8bba\u662f\u7528\u4e8e Pydantic \u6a21\u578b\u8fd8\u662f\u5176\u4ed6\u4efb\u4f55\u4e1c\u897f\uff09\u3002</p> <p>Note</p> <p>\u65e0\u6cd5\u5b9a\u4e49\u81ea\u5b9a\u4e49\u6838\u5fc3\u6a21\u5f0f\u3002\u6838\u5fc3\u6a21\u5f0f\u9700\u8981\u88ab <code>pydantic-core</code> \u5305\u7406\u89e3\uff0c \u56e0\u6b64\u6211\u4eec\u53ea\u652f\u6301\u56fa\u5b9a\u6570\u91cf\u7684\u6838\u5fc3\u6a21\u5f0f\u7c7b\u578b\u3002 \u8fd9\u4e5f\u662f <code>GenerateSchema</code> \u6ca1\u6709\u771f\u6b63\u516c\u5f00\u548c\u9002\u5f53\u6587\u6863\u5316\u7684\u90e8\u5206\u539f\u56e0\u3002</p> <p>\u6838\u5fc3\u6a21\u5f0f\u5b9a\u4e49\u53ef\u4ee5\u5728 <code>pydantic_core.core_schema</code> \u6a21\u5757\u4e2d\u627e\u5230\u3002</p> <p>\u5bf9\u4e8e Pydantic \u6a21\u578b\uff0c\u5c06\u6784\u5efa\u4e00\u4e2a\u6838\u5fc3\u6a21\u5f0f\u5e76\u8bbe\u7f6e\u4e3a <code>__pydantic_core_schema__</code> \u5c5e\u6027\u3002</p> <p>\u4e3a\u4e86\u8bf4\u660e\u6838\u5fc3\u6a21\u5f0f\u7684\u6837\u5b50\uff0c\u6211\u4eec\u5c06\u4ee5 <code>bool</code> \u6838\u5fc3\u6a21\u5f0f\u4e3a\u4f8b\uff1a</p> <pre><code>class BoolSchema(TypedDict, total=False):\n    type: Required[Literal['bool']]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n</code></pre> <p>\u5f53\u5b9a\u4e49\u4e00\u4e2a\u5e26\u6709\u5e03\u5c14\u5b57\u6bb5\u7684 Pydantic \u6a21\u578b\u65f6\uff1a</p> <pre><code>from pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    foo: bool = Field(strict=True)\n</code></pre> <p><code>foo</code> \u5b57\u6bb5\u7684\u6838\u5fc3\u6a21\u5f0f\u5c06\u5982\u4e0b\u6240\u793a\uff1a</p> <pre><code>{\n    'type': 'bool',\n    'strict': True,\n}\n</code></pre> <p>\u5982 <code>BoolSchema</code> \u5b9a\u4e49\u6240\u793a\uff0c \u5e8f\u5217\u5316\u903b\u8f91\u4e5f\u5728\u6838\u5fc3\u6a21\u5f0f\u4e2d\u5b9a\u4e49\u3002 \u5982\u679c\u6211\u4eec\u8981\u4e3a <code>foo</code> \u5b9a\u4e49\u4e00\u4e2a\u81ea\u5b9a\u4e49\u5e8f\u5217\u5316\u51fd\u6570 (1)\uff0c<code>serialization</code> \u952e\u5c06\u5982\u4e0b\u6240\u793a\uff1a</p> <ol> <li> <p>\u4f8b\u5982\u4f7f\u7528 <code>field_serializer</code> \u88c5\u9970\u5668\uff1a</p> <pre><code>class Model(BaseModel):\n    foo: bool = Field(strict=True)\n\n    @field_serializer('foo', mode='plain')\n    def serialize_foo(self, value: bool) -&gt; Any:\n        ...\n</code></pre> </li> </ol> <pre><code>{\n    'type': 'function-plain',\n    'function': &lt;function Model.serialize_foo at 0x111&gt;,\n    'is_field_serializer': True,\n    'info_arg': False,\n    'return_schema': {'type': 'int'},\n}\n</code></pre> <p>\u8bf7\u6ce8\u610f\uff0c\u8fd9\u4e5f\u662f\u4e00\u4e2a\u6838\u5fc3\u6a21\u5f0f\u5b9a\u4e49\uff0c\u53ea\u662f\u5b83\u4ec5\u5728\u5e8f\u5217\u5316\u671f\u95f4\u4e0e <code>pydantic-core</code> \u76f8\u5173\u3002</p> <p>\u6838\u5fc3\u6a21\u5f0f\u6db5\u76d6\u5e7f\u6cdb\u7684\u8303\u56f4\uff0c\u5e76\u4e14\u5728\u6211\u4eec\u60f3\u8981\u5728 Python \u548c Rust \u7aef\u4e4b\u95f4\u901a\u4fe1\u65f6\u4f7f\u7528\u3002 \u867d\u7136\u524d\u9762\u7684\u793a\u4f8b\u4e0e\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316\u76f8\u5173\uff0c\u4f46\u7406\u8bba\u4e0a\u5b83\u53ef\u4ee5\u7528\u4e8e\u4efb\u4f55\u4e8b\u60c5\uff1a \u9519\u8bef\u7ba1\u7406\u3001\u989d\u5916\u5143\u6570\u636e\u7b49\u3002</p>"},{"location":"internals/architecture/#json-schema","title":"JSON Schema \u751f\u6210","text":"<p>\u60a8\u53ef\u80fd\u5df2\u7ecf\u6ce8\u610f\u5230\uff0c\u4e4b\u524d\u7684\u5e8f\u5217\u5316\u6838\u5fc3\u6a21\u5f0f\u6709\u4e00\u4e2a <code>return_schema</code> \u952e\u3002 \u8fd9\u662f\u56e0\u4e3a\u6838\u5fc3\u6a21\u5f0f\u4e5f\u7528\u4e8e\u751f\u6210\u76f8\u5e94\u7684 JSON Schema\u3002</p> <p>\u4e0e\u6838\u5fc3\u6a21\u5f0f\u7684\u751f\u6210\u7c7b\u4f3c\uff0cJSON Schema \u7684\u751f\u6210\u7531 <code>GenerateJsonSchema</code> \u7c7b\u5904\u7406\u3002 <code>generate</code> \u65b9\u6cd5 \u662f\u4e3b\u8981\u5165\u53e3\u70b9\uff0c\u5e76\u63a5\u6536\u8be5\u6a21\u578b\u7684\u6838\u5fc3\u6a21\u5f0f\u3002</p> <p>\u56de\u5230\u6211\u4eec\u7684 <code>bool</code> \u5b57\u6bb5\u793a\u4f8b\uff0c<code>bool_schema</code> \u65b9\u6cd5\u5c06\u63a5\u6536\u5148\u524d\u751f\u6210\u7684\u5e03\u5c14\u6838\u5fc3\u6a21\u5f0f \u5e76\u8fd4\u56de\u4ee5\u4e0b JSON Schema\uff1a</p> <pre><code>{\n    {\"type\": \"boolean\"}\n}\n</code></pre>"},{"location":"internals/architecture/#json","title":"\u81ea\u5b9a\u4e49\u6838\u5fc3\u6a21\u5f0f\u548c JSON \u6a21\u5f0f","text":"<p>\u4f7f\u7528\u6587\u6863</p> <p>\u81ea\u5b9a\u4e49\u7c7b\u578b</p> <p>\u5b9e\u73b0 <code>__get_pydantic_core_schema__</code></p> <p>\u5b9e\u73b0 <code>__get_pydantic_json_schema__</code></p> <p>\u867d\u7136 <code>GenerateSchema</code> \u548c <code>GenerateJsonSchema</code> \u7c7b\u5904\u7406 \u76f8\u5e94\u6a21\u5f0f\u7684\u521b\u5efa\uff0c\u4f46 Pydantic \u5728\u67d0\u4e9b\u60c5\u51b5\u4e0b\u63d0\u4f9b\u4e86\u4e00\u79cd\u81ea\u5b9a\u4e49\u5b83\u4eec\u7684\u65b9\u5f0f\uff0c\u9075\u5faa\u5305\u88c5\u5668\u6a21\u5f0f\u3002 \u8fd9\u79cd\u81ea\u5b9a\u4e49\u901a\u8fc7 <code>__get_pydantic_core_schema__</code> \u548c <code>__get_pydantic_json_schema__</code> \u65b9\u6cd5\u5b8c\u6210\u3002</p> <p>\u4e3a\u4e86\u7406\u89e3\u8fd9\u79cd\u5305\u88c5\u5668\u6a21\u5f0f\uff0c\u6211\u4eec\u5c06\u4ee5\u4e0e <code>Annotated</code> \u4e00\u8d77\u4f7f\u7528\u7684\u5143\u6570\u636e\u7c7b\u4e3a\u4f8b\uff0c \u5176\u4e2d\u53ef\u4ee5\u4f7f\u7528 <code>__get_pydantic_core_schema__</code> \u65b9\u6cd5\uff1a</p> <pre><code>from typing import Annotated, Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass MyStrict:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        schema = handler(source)  # (1)!\n        schema['strict'] = True\n        return schema\n\n\nclass MyGt:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -&gt; CoreSchema:\n        schema = handler(source)  # (2)!\n        schema['gt'] = 1\n        return schema\n\n\nta = TypeAdapter(Annotated[int, MyStrict(), MyGt()])\n</code></pre> <ol> <li><code>MyStrict</code> \u662f\u8981\u5e94\u7528\u7684\u7b2c\u4e00\u4e2a\u6ce8\u89e3\u3002\u6b64\u65f6\uff0c<code>schema = {'type': 'int'}</code>\u3002</li> <li><code>MyGt</code> \u662f\u8981\u5e94\u7528\u7684\u6700\u540e\u4e00\u4e2a\u6ce8\u89e3\u3002\u6b64\u65f6\uff0c<code>schema = {'type': 'int', 'strict': True}</code>\u3002</li> </ol> <p>\u5f53 <code>GenerateSchema</code> \u7c7b\u4e3a <code>Annotated[int, MyStrict(), MyGt()]</code> \u6784\u5efa\u6838\u5fc3\u6a21\u5f0f\u65f6\uff0c\u5b83\u5c06 \u521b\u5efa\u4e00\u4e2a <code>GetCoreSchemaHandler</code> \u5b9e\u4f8b\u4f20\u9012\u7ed9 <code>MyGt.__get_pydantic_core_schema__</code> \u65b9\u6cd5\u3002(1)</p> <ol> <li>\u5728\u6211\u4eec\u7684 <code>Annotated</code> \u6a21\u5f0f\u7684\u60c5\u51b5\u4e0b\uff0c<code>GetCoreSchemaHandler</code> \u662f\u4ee5\u5d4c\u5957\u65b9\u5f0f\u5b9a\u4e49\u7684\u3002     \u8c03\u7528\u5b83\u5c06\u9012\u5f52\u8c03\u7528\u5176\u4ed6 <code>__get_pydantic_core_schema__</code> \u65b9\u6cd5\uff0c\u76f4\u5230\u8fbe\u5230 <code>int</code> \u6ce8\u89e3\uff0c     \u6b64\u65f6\u8fd4\u56de\u4e00\u4e2a\u7b80\u5355\u7684 <code>{'type': 'int'}</code> \u6a21\u5f0f\u3002</li> </ol> <p><code>source</code> \u53c2\u6570\u53d6\u51b3\u4e8e\u6838\u5fc3\u6a21\u5f0f\u751f\u6210\u6a21\u5f0f\u3002\u5728 <code>Annotated</code> \u7684\u60c5\u51b5\u4e0b\uff0c <code>source</code> \u5c06\u662f\u88ab\u6ce8\u89e3\u7684\u7c7b\u578b\u3002\u5f53\u5b9a\u4e49\u81ea\u5b9a\u4e49\u7c7b\u578b\u65f6\uff0c <code>source</code> \u5c06\u662f\u5b9e\u9645\u5b9a\u4e49 <code>__get_pydantic_core_schema__</code> \u7684\u7c7b\u3002</p>"},{"location":"internals/architecture/#_2","title":"\u6a21\u578b\u9a8c\u8bc1\u548c\u5e8f\u5217\u5316","text":"<p>\u867d\u7136\u6a21\u578b\u5b9a\u4e49\u662f\u5728\u7c7b\u7ea7\u522b\uff08\u5373\u5b9a\u4e49\u6a21\u578b\u65f6\uff09\u8fdb\u884c\u7684\uff0c\u4f46\u6a21\u578b\u9a8c\u8bc1 \u548c\u5e8f\u5217\u5316\u53d1\u751f\u5728\u5b9e\u4f8b\u7ea7\u522b\u3002\u8fd9\u4e24\u4e2a\u6982\u5ff5\u90fd\u5728 <code>pydantic-core</code> \u4e2d\u5904\u7406 \uff08\u4e0e Pydantic V1 \u76f8\u6bd4\uff0c\u6027\u80fd\u63d0\u9ad8\u4e86 5 \u5230 20 \u500d\uff09\uff0c\u901a\u8fc7\u4f7f\u7528\u5148\u524d\u6784\u5efa\u7684\u6838\u5fc3\u6a21\u5f0f\u3002</p> <p><code>pydantic-core</code> \u516c\u5f00\u4e86 <code>SchemaValidator</code> \u548c <code>SchemaSerializer</code> \u7c7b\u6765\u6267\u884c\u8fd9\u4e9b\u4efb\u52a1\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    foo: int\n\n\nmodel = Model.model_validate({'foo': 1})  # (1)!\ndumped = model.model_dump()  # (2)!\n</code></pre> <ol> <li>\u63d0\u4f9b\u7684\u6570\u636e\u901a\u8fc7\u4f7f\u7528 <code>SchemaValidator.validate_python</code> \u65b9\u6cd5\u53d1\u9001\u5230 <code>pydantic-core</code>\u3002    <code>pydantic-core</code> \u5c06\u9a8c\u8bc1\uff08\u9075\u5faa\u6a21\u578b\u7684\u6838\u5fc3\u6a21\u5f0f\uff09\u6570\u636e\u5e76\u586b\u5145    \u6a21\u578b\u7684 <code>__dict__</code> \u5c5e\u6027\u3002</li> <li><code>model</code> \u5b9e\u4f8b\u901a\u8fc7\u4f7f\u7528 <code>SchemaSerializer.to_python</code> \u65b9\u6cd5\u53d1\u9001\u5230 <code>pydantic-core</code>\u3002    <code>pydantic-core</code> \u5c06\u8bfb\u53d6\u5b9e\u4f8b\u7684 <code>__dict__</code> \u5c5e\u6027\u5e76\u6784\u5efa\u9002\u5f53\u7684\u7ed3\u679c    \uff08\u518d\u6b21\u9075\u5faa\u6a21\u578b\u7684\u6838\u5fc3\u6a21\u5f0f\uff09\u3002</li> </ol>"},{"location":"internals/resolving_annotations/","title":"Resolving Annotations","text":"<p>Note</p> <p>\u672c\u8282\u662f\u5185\u90e8\u6587\u6863\u7684\u4e00\u90e8\u5206\uff0c\u4e3b\u8981\u9762\u5411\u8d21\u732e\u8005\u3002</p> <p>Pydantic \u5728\u8fd0\u884c\u65f6\u4e25\u91cd\u4f9d\u8d56\u7c7b\u578b\u63d0\u793a\u6765\u6784\u5efa\u7528\u4e8e\u9a8c\u8bc1\u3001\u5e8f\u5217\u5316\u7b49\u7684\u6a21\u5f0f\u3002</p> <p>\u867d\u7136\u7c7b\u578b\u63d0\u793a\u4e3b\u8981\u662f\u4e3a\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\uff08\u5982 Mypy \u6216 Pyright\uff09\u5f15\u5165\u7684\uff0c\u4f46\u5b83\u4eec\u5728\u8fd0\u884c\u65f6\u662f\u53ef\u8bbf\u95ee\u7684\uff08\u6709\u65f6\u4f1a\u88ab\u6c42\u503c\uff09\u3002\u8fd9\u610f\u5473\u7740\u4ee5\u4e0b\u4ee3\u7801\u5728\u8fd0\u884c\u65f6\u5c06\u5931\u8d25\uff0c\u56e0\u4e3a <code>Node</code> \u5728\u5f53\u524d\u6a21\u5757\u4e2d\u5c1a\u672a\u5b9a\u4e49\uff1a</p> <pre><code>class Node:\n    \"\"\"\u4e8c\u53c9\u6811\u8282\u70b9\u3002\"\"\"\n\n    # NameError: name 'Node' is not defined:\n    def __init__(self, l: Node, r: Node) -&gt; None:\n        self.left = l\n        self.right = r\n</code></pre> <p>\u4e3a\u4e86\u89c4\u907f\u8fd9\u4e2a\u95ee\u9898\uff0c\u53ef\u4ee5\u4f7f\u7528\u524d\u5411\u5f15\u7528\uff08\u901a\u8fc7\u5c06\u6ce8\u89e3\u7528\u5f15\u53f7\u62ec\u8d77\u6765\uff09\u3002</p> <p>\u5728 Python 3.7 \u4e2d\uff0cPEP 563 \u5f15\u5165\u4e86\u5ef6\u8fdf\u6ce8\u89e3\u6c42\u503c\u7684\u6982\u5ff5\uff0c\u610f\u5473\u7740\u4f7f\u7528 <code>from __future__ import annotations</code> future statement \u65f6\uff0c\u7c7b\u578b\u63d0\u793a\u9ed8\u8ba4\u4f1a\u88ab\u5b57\u7b26\u4e32\u5316\uff1a</p> <pre><code>from __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: MyType\n    # \u7ed9\u5b9a\u4e0a\u9762\u7684 future \u5bfc\u5165\uff0c\u8fd9\u7b49\u4ef7\u4e8e\uff1a\n    # f: 'MyType'\n\n\ntype MyType = int\n\nprint(Foo.__annotations__)\n#&gt; {'f': 'MyType'}\n</code></pre>"},{"location":"internals/resolving_annotations/#_1","title":"\u8fd0\u884c\u65f6\u6c42\u503c\u7684\u6311\u6218","text":"<p>\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u5668\u5229\u7528AST\u6765\u5206\u6790\u5df2\u5b9a\u4e49\u7684\u6ce8\u89e3\u3002 \u5bf9\u4e8e\u524d\u9762\u7684\u793a\u4f8b\uff0c\u8fd9\u6837\u505a\u7684\u597d\u5904\u662f\u80fd\u591f\u5728\u5206\u6790 <code>Foo</code> \u7684\u7c7b\u5b9a\u4e49\u65f6\u7406\u89e3 <code>MyType</code> \u6307\u7684\u662f\u4ec0\u4e48\uff0c\u5373\u4f7f <code>MyType</code> \u5728\u8fd0\u884c\u65f6\u5c1a\u672a\u5b9a\u4e49\u3002</p> <p>\u7136\u800c\uff0c\u5bf9\u4e8e\u50cf Pydantic \u8fd9\u6837\u7684\u8fd0\u884c\u65f6\u5de5\u5177\uff0c\u6b63\u786e\u89e3\u6790\u8fd9\u4e9b\u524d\u5411\u6ce8\u89e3\u66f4\u5177\u6311\u6218\u6027\u3002 Python \u6807\u51c6\u5e93\u63d0\u4f9b\u4e86\u4e00\u4e9b\u5de5\u5177\u6765\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff08<code>typing.get_type_hints()</code>, <code>inspect.get_annotations()</code>\uff09\uff0c\u4f46\u5b83\u4eec\u6709\u4e00\u4e9b\u5c40\u9650\u6027\u3002\u56e0\u6b64\uff0c\u8fd9\u4e9b\u5de5\u5177\u6b63\u5728 Pydantic \u4e2d\u91cd\u65b0\u5b9e\u73b0\uff0c\u4ee5\u6539\u8fdb\u5bf9\u8fb9\u7f18\u60c5\u51b5\u7684\u652f\u6301\u3002</p> <p>\u968f\u7740 Pydantic \u7684\u53d1\u5c55\uff0c\u5b83\u5df2\u7ecf\u9002\u5e94\u4e86\u652f\u6301\u8bb8\u591a\u9700\u8981\u4e0d\u89c4\u5219\u6ce8\u89e3\u6c42\u503c\u6a21\u5f0f\u7684\u8fb9\u7f18\u60c5\u51b5\u3002 \u5176\u4e2d\u4e00\u4e9b\u7528\u4f8b\u4ece\u9759\u6001\u7c7b\u578b\u68c0\u67e5\u7684\u89d2\u5ea6\u6765\u770b\u4e0d\u4e00\u5b9a\u5408\u7406\u3002\u5728 v2.10 \u4e2d\uff0c\u5185\u90e8\u903b\u8f91\u88ab\u91cd\u6784\uff0c\u8bd5\u56fe\u7b80\u5316\u548c\u6807\u51c6\u5316\u6ce8\u89e3\u6c42\u503c\u3002 \u8bda\u7136\uff0c\u5411\u540e\u517c\u5bb9\u6027\u5e26\u6765\u4e86\u4e00\u4e9b\u6311\u6218\uff0c\u5e76\u4e14\u7531\u4e8e\u8fd9\u4e2a\u539f\u56e0\uff0c\u4ee3\u7801\u5e93\u4e2d\u4ecd\u7136\u5b58\u5728\u4e00\u4e9b\u660e\u663e\u7684\u9057\u7559\u95ee\u9898\u3002 \u5e0c\u671b PEP 649\uff08\u5728 Python 3.14 \u4e2d\u5f15\u5165\uff09\u5c06\u5927\u5927\u7b80\u5316\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u7279\u522b\u662f\u5728\u5904\u7406\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u65f6\u3002</p> <p>\u4e3a\u4e86\u6c42\u503c\u524d\u5411\u5f15\u7528\uff0cPydantic \u5927\u81f4\u9075\u5faa <code>typing.get_type_hints()</code> \u51fd\u6570\u6587\u6863\u4e2d\u63cf\u8ff0\u7684\u903b\u8f91\u3002 \u4e5f\u5c31\u662f\u8bf4\uff0c\u901a\u8fc7\u4f20\u9012\u524d\u5411\u5f15\u7528\u3001\u5168\u5c40\u547d\u540d\u7a7a\u95f4\u548c\u5c40\u90e8\u547d\u540d\u7a7a\u95f4\u6765\u4f7f\u7528\u5185\u7f6e\u7684 <code>eval()</code> \u51fd\u6570\u3002 \u547d\u540d\u7a7a\u95f4\u83b7\u53d6\u903b\u8f91\u5728\u4e0b\u9762\u7684\u7ae0\u8282\u4e2d\u5b9a\u4e49\u3002</p>"},{"location":"internals/resolving_annotations/#resolving-annotations-at-class-definition","title":"\u5728\u7c7b\u5b9a\u4e49\u65f6\u89e3\u6790\u6ce8\u89e3","text":"<p>\u4ee5\u4e0b\u793a\u4f8b\u5c06\u5728\u672c\u8282\u4e2d\u4f5c\u4e3a\u53c2\u8003\uff1a</p> <pre><code># module1.py:\ntype MyType = int\n\nclass Base:\n    f1: 'MyType'\n\n# module2.py:\nfrom pydantic import BaseModel\n\nfrom module1 import Base\n\ntype MyType = str\n\n\ndef inner() -&gt; None:\n    type InnerType = bool\n\n    class Model(BaseModel, Base):\n        type LocalType = bytes\n\n        f2: 'MyType'\n        f3: 'InnerType'\n        f4: 'LocalType'\n        f5: 'UnknownType'\n\n    type InnerType2 = complex\n</code></pre> <p>\u5f53 <code>Model</code> \u7c7b\u6b63\u5728\u6784\u5efa\u65f6\uff0c\u4e0d\u540c\u7684\u547d\u540d\u7a7a\u95f4\u5728\u8d77\u4f5c\u7528\u3002\u5bf9\u4e8e <code>Model</code> \u7684MRO\u4e2d\u7684\u6bcf\u4e2a\u57fa\u7c7b\uff08\u6309\u76f8\u53cd\u987a\u5e8f\u2014\u2014\u5373\u4ece <code>Base</code> \u5f00\u59cb\uff09\uff0c\u5e94\u7528\u4ee5\u4e0b\u903b\u8f91\uff1a</p> <ol> <li>\u4ece\u5f53\u524d\u57fa\u7c7b\u7684 <code>__dict__</code> \u4e2d\u83b7\u53d6 <code>__annotations__</code> \u952e\uff08\u5982\u679c\u5b58\u5728\uff09\u3002\u5bf9\u4e8e <code>Base</code>\uff0c\u8fd9\u5c06\u662f <code>{'f1': 'MyType'}</code>\u3002</li> <li>\u904d\u5386 <code>__annotations__</code> \u9879\uff0c\u5e76\u5c1d\u8bd5\u4f7f\u7528\u56f4\u7ed5\u5185\u7f6e <code>eval()</code> \u51fd\u6570\u7684\u81ea\u5b9a\u4e49\u5305\u88c5\u5668\u6765\u6c42\u503c\u6ce8\u89e3<sup>1</sup>\u3002\u6b64\u51fd\u6570\u63a5\u53d7\u4e24\u4e2a <code>globals</code> \u548c <code>locals</code> \u53c2\u6570\uff1a<ul> <li>\u5f53\u524d\u6a21\u5757\u7684 <code>__dict__</code> \u81ea\u7136\u7528\u4f5c <code>globals</code>\u3002\u5bf9\u4e8e <code>Base</code>\uff0c\u8fd9\u5c06\u662f <code>sys.modules['module1'].__dict__</code>\u3002</li> <li>\u5bf9\u4e8e <code>locals</code> \u53c2\u6570\uff0cPydantic \u5c06\u5c1d\u8bd5\u6309\u4ee5\u4e0b\u4f18\u5148\u7ea7\u987a\u5e8f\u5728\u4ee5\u4e0b\u547d\u540d\u7a7a\u95f4\u4e2d\u89e3\u6790\u7b26\u53f7\uff1a<ul> <li>\u4e00\u4e2a\u5373\u65f6\u521b\u5efa\u7684\u547d\u540d\u7a7a\u95f4\uff0c\u5305\u542b\u5f53\u524d\u7c7b\u540d\uff08<code>{cls.__name__: cls}</code>\uff09\u3002\u8fd9\u6837\u505a\u662f\u4e3a\u4e86\u652f\u6301\u9012\u5f52\u5f15\u7528\u3002</li> <li>\u5f53\u524d\u7c7b\u7684\u5c40\u90e8\u53d8\u91cf\uff08\u5373 <code>cls.__dict__</code>\uff09\u3002\u5bf9\u4e8e <code>Model</code>\uff0c\u8fd9\u5c06\u5305\u62ec <code>LocalType</code>\u3002</li> <li>\u7c7b\u7684\u7236\u547d\u540d\u7a7a\u95f4\uff0c\u5982\u679c\u4e0e\u4e0a\u8ff0 globals \u4e0d\u540c\u3002\u8fd9\u662f\u7c7b\u6b63\u5728\u5b9a\u4e49\u7684\u5e27\u7684locals\u3002\u5bf9\u4e8e <code>Base</code>\uff0c\u56e0\u4e3a\u7c7b\u76f4\u63a5\u5728\u6a21\u5757\u4e2d\u5b9a\u4e49\uff0c\u6240\u4ee5\u4e0d\u4f1a\u4f7f\u7528\u6b64\u547d\u540d\u7a7a\u95f4\uff0c\u56e0\u4e3a\u5b83\u5c06\u5bfc\u81f4\u518d\u6b21\u4f7f\u7528 globals\u3002\u5bf9\u4e8e <code>Model</code>\uff0c\u7236\u547d\u540d\u7a7a\u95f4\u662f <code>inner()</code> \u5e27\u7684\u5c40\u90e8\u53d8\u91cf\u3002</li> </ul> </li> </ul> </li> <li>\u5982\u679c\u6ce8\u89e3\u6c42\u503c\u5931\u8d25\uff0c\u5219\u4fdd\u6301\u539f\u6837\uff0c\u4ee5\u4fbf\u53ef\u4ee5\u5728\u7a0d\u540e\u9636\u6bb5\u91cd\u65b0\u6784\u5efa\u6a21\u578b\u3002<code>f5</code> \u5c31\u662f\u8fd9\u79cd\u60c5\u51b5\u3002</li> </ol> <p>\u4e0b\u8868\u5217\u51fa\u4e86 <code>Model</code> \u7c7b\u521b\u5efa\u540e\u6bcf\u4e2a\u5b57\u6bb5\u7684\u5df2\u89e3\u6790\u7c7b\u578b\u6ce8\u89e3\uff1a</p> \u5b57\u6bb5\u540d \u5df2\u89e3\u6790\u7684\u6ce8\u89e3 <code>f1</code> <code>int</code> <code>f2</code> <code>str</code> <code>f3</code> <code>bool</code> <code>f4</code> <code>bytes</code> <code>f5</code> <code>'UnknownType'</code>"},{"location":"internals/resolving_annotations/#_2","title":"\u5c40\u9650\u6027\u548c\u5411\u540e\u517c\u5bb9\u6027\u95ee\u9898","text":"<p>\u867d\u7136\u547d\u540d\u7a7a\u95f4\u83b7\u53d6\u903b\u8f91\u8bd5\u56fe\u5c3d\u53ef\u80fd\u51c6\u786e\uff0c\u4f46\u6211\u4eec\u4ecd\u7136\u9762\u4e34\u4e00\u4e9b\u5c40\u9650\u6027\uff1a</p> <ul> <li>\u5f53\u524d\u7c7b\u7684\u5c40\u90e8\u53d8\u91cf\uff08<code>cls.__dict__</code>\uff09\u53ef\u80fd\u5305\u542b\u4e0d\u76f8\u5173\u7684\u6761\u76ee\uff0c\u5176\u4e2d\u5927\u90e8\u5206\u662f\u53cc\u4e0b\u5212\u7ebf\u5c5e\u6027\u3002   \u8fd9\u610f\u5473\u7740\u4ee5\u4e0b\u6ce8\u89e3\uff1a<code>f: '__doc__'</code> \u5c06\u6210\u529f\uff08\u4e14\u610f\u5916\u5730\uff09\u88ab\u89e3\u6790\u3002</li> <li>\u5f53 <code>Model</code> \u7c7b\u5728\u51fd\u6570\u5185\u90e8\u521b\u5efa\u65f6\uff0c\u6211\u4eec\u4f1a\u4fdd\u7559\u5e27\u7684locals\u7684\u526f\u672c\u3002   \u6b64\u526f\u672c\u4ec5\u5305\u542b <code>Model</code> \u6b63\u5728\u5b9a\u4e49\u65f6\u5c40\u90e8\u53d8\u91cf\u4e2d\u5b9a\u4e49\u7684\u7b26\u53f7\uff0c\u8fd9\u610f\u5473\u7740 <code>InnerType2</code> \u4e0d\u4f1a\u88ab\u5305\u542b\u5728\u5185   \uff08\u5e76\u4e14\u5982\u679c\u5728\u7a0d\u540e\u70b9\u8fdb\u884c\u6a21\u578b\u91cd\u5efa\uff0c\u4e5f\u4e0d\u4f1a\u88ab\u5305\u542b\uff01\uff09\u3002<ul> <li>\u4e3a\u4e86\u907f\u514d\u5185\u5b58\u6cc4\u6f0f\uff0c\u6211\u4eec\u5bf9\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u4f7f\u7528\u5f31\u5f15\u7528\uff0c\u8fd9\u610f\u5473\u7740\u4e00\u4e9b\u524d\u5411\u5f15\u7528\u53ef\u80fd\u5728\u51fd\u6570\u5916\u90e8\u65e0\u6cd5\u89e3\u6790\uff081\uff09\u3002</li> <li>\u51fd\u6570\u7684\u5c40\u90e8\u53d8\u91cf\u4ec5\u5bf9 Pydantic \u6a21\u578b\u8003\u8651\uff0c\u4f46\u6b64\u6a21\u5f0f\u4e0d\u9002\u7528\u4e8e\u6570\u636e\u7c7b\u3001\u7c7b\u578b\u5316\u5b57\u5178\u6216\u547d\u540d\u5143\u7ec4\u3002</li> </ul> </li> </ul> <ol> <li> <p>\u4ee5\u4e0b\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a</p> <pre><code>def func():\n    A = int\n\n    class Model(BaseModel):\n        f: 'A | Forward'\n\n    return Model\n\n\nModel = func()\n\nModel.model_rebuild(_types_namespace={'Forward': str})\n# pydantic.errors.PydanticUndefinedAnnotation: name 'A' is not defined\n</code></pre> </li> </ol> <p>\u51fa\u4e8e\u5411\u540e\u517c\u5bb9\u6027\u7684\u539f\u56e0\uff0c\u5e76\u4e14\u4e3a\u4e86\u80fd\u591f\u652f\u6301\u6709\u6548\u7684\u7528\u4f8b\u800c\u65e0\u9700\u91cd\u5efa\u6a21\u578b\uff0c \u4e0a\u8ff0\u547d\u540d\u7a7a\u95f4\u903b\u8f91\u5728\u6838\u5fc3\u6a21\u5f0f\u751f\u6210\u65f6\u7565\u6709\u4e0d\u540c\u3002 \u4ee5\u4ee5\u4e0b\u793a\u4f8b\u4e3a\u4f8b\uff1a</p> <pre><code>from dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    a: 'Bar | None' = None\n\n\nclass Bar(BaseModel):\n    b: Foo\n</code></pre> <p>\u4e00\u65e6 <code>Bar</code> \u7684\u5b57\u6bb5\u88ab\u6536\u96c6\uff08\u610f\u5473\u7740\u6ce8\u89e3\u5df2\u89e3\u6790\uff09\uff0c<code>GenerateSchema</code> \u7c7b\u5c06\u6bcf\u4e2a\u5b57\u6bb5\u8f6c\u6362\u4e3a\u6838\u5fc3\u6a21\u5f0f\u3002 \u5f53\u5b83\u9047\u5230\u53e6\u4e00\u4e2a\u7c7b\u5b57\u6bb5\u7c7b\u578b\uff08\u5982\u6570\u636e\u7c7b\uff09\u65f6\uff0c\u5b83\u5c06\u5c1d\u8bd5\u6c42\u503c\u6ce8\u89e3\uff0c\u5927\u81f4\u9075\u5faa\u4e0a\u8ff0\u63cf\u8ff0\u7684\u903b\u8f91\u3002 \u7136\u800c\uff0c\u4e3a\u4e86\u6c42\u503c <code>'Bar | None'</code> \u6ce8\u89e3\uff0c<code>Bar</code> \u9700\u8981\u51fa\u73b0\u5728 globals \u6216 locals \u4e2d\uff0c\u8fd9\u901a\u5e38\u4e0d\u662f\u60c5\u51b5\uff1a<code>Bar</code> \u6b63\u5728\u521b\u5efa\u4e2d\uff0c\u56e0\u6b64\u6b64\u65f6\u5b83\u6ca1\u6709\u88ab\"\u5206\u914d\"\u5230\u5f53\u524d\u6a21\u5757\u7684 <code>__dict__</code> \u4e2d\u3002</p> <p>\u4e3a\u4e86\u907f\u514d\u5fc5\u987b\u5728 <code>Bar</code> \u4e0a\u8c03\u7528 <code>model_rebuild()</code>\uff0c\u7236\u547d\u540d\u7a7a\u95f4 \uff08\u5982\u679c <code>Bar</code> \u8981\u5728\u51fd\u6570\u5185\u90e8\u5b9a\u4e49\uff0c\u4ee5\u53ca\u6a21\u578b\u91cd\u5efa\u671f\u95f4\u63d0\u4f9b\u7684\u547d\u540d\u7a7a\u95f4\uff09 \u548c <code>{Bar.__name__: Bar}</code> \u547d\u540d\u7a7a\u95f4\u5728 <code>Foo</code> \u7684\u6ce8\u89e3\u6c42\u503c\u671f\u95f4\u90fd\u5305\u542b\u5728 locals \u4e2d \uff08\u4f18\u5148\u7ea7\u6700\u4f4e\uff09\uff081\uff09\u3002</p> <ol> <li> <p>\u8fd9\u79cd\u5411\u540e\u517c\u5bb9\u6027\u903b\u8f91\u53ef\u80fd\u4f1a\u5f15\u5165\u4e00\u4e9b\u4e0d\u4e00\u81f4\u6027\uff0c\u4f8b\u5982\u4ee5\u4e0b\u60c5\u51b5\uff1a</p> <pre><code>from dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    # `a` \u548c `b` \u4e0d\u5e94\u8be5\u89e3\u6790\uff1a\n    a: 'Model'\n    b: 'Inner'\n\n\ndef func():\n    Inner = int\n\n    class Model(BaseModel):\n        foo: Foo\n\n    Model.__pydantic_complete__\n    #&gt; True, \u5e94\u8be5\u662f False\u3002\n</code></pre> </li> </ol>"},{"location":"internals/resolving_annotations/#_3","title":"\u91cd\u5efa\u6a21\u578b\u65f6\u89e3\u6790\u6ce8\u89e3","text":"<p>\u5f53\u524d\u5411\u5f15\u7528\u6c42\u503c\u5931\u8d25\u65f6\uff0cPydantic \u5c06\u9759\u9ed8\u5931\u8d25\u5e76\u505c\u6b62\u6838\u5fc3\u6a21\u5f0f\u751f\u6210\u8fc7\u7a0b\u3002 \u8fd9\u53ef\u4ee5\u901a\u8fc7\u68c0\u67e5\u6a21\u578b\u7c7b\u7684 <code>__pydantic_core_schema__</code> \u6765\u770b\u5230\uff1a</p> <pre><code>from pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: 'MyType'\n\n\nFoo.__pydantic_core_schema__\n#&gt; &lt;pydantic._internal._mock_val_ser.MockCoreSchema object at 0x73cd0d9e6d00&gt;\n</code></pre> <p>\u5982\u679c\u60a8\u968f\u540e\u6b63\u786e\u5b9a\u4e49 <code>MyType</code>\uff0c\u60a8\u53ef\u4ee5\u91cd\u5efa\u6a21\u578b\uff1a</p> <pre><code>type MyType = int\n\nFoo.model_rebuild()\nFoo.__pydantic_core_schema__\n#&gt; {'type': 'model', 'schema': {...}, ...}\n</code></pre> <p><code>model_rebuild()</code> \u65b9\u6cd5\u4f7f\u7528\u91cd\u5efa\u547d\u540d\u7a7a\u95f4\uff0c\u5177\u6709\u4ee5\u4e0b\u8bed\u4e49\uff1a</p> <ul> <li>\u5982\u679c\u63d0\u4f9b\u4e86\u663e\u5f0f\u7684 <code>_types_namespace</code> \u53c2\u6570\uff0c\u5219\u5c06\u5176\u7528\u4f5c\u91cd\u5efa\u547d\u540d\u7a7a\u95f4\u3002</li> <li>\u5982\u679c\u6ca1\u6709\u63d0\u4f9b\u547d\u540d\u7a7a\u95f4\uff0c\u5219\u8c03\u7528\u8be5\u65b9\u6cd5\u7684\u547d\u540d\u7a7a\u95f4\u5c06\u7528\u4f5c\u91cd\u5efa\u547d\u540d\u7a7a\u95f4\u3002</li> </ul> <p>\u6b64\u91cd\u5efa\u547d\u540d\u7a7a\u95f4\u5c06\u4e0e\u6a21\u578b\u7684\u7236\u547d\u540d\u7a7a\u95f4\uff08\u5982\u679c\u5b83\u5728\u51fd\u6570\u4e2d\u5b9a\u4e49\uff09\u5408\u5e76\u5e76\u6309\u539f\u6837\u4f7f\u7528 \uff08\u53c2\u89c1\u4e0a\u8ff0\u5411\u540e\u517c\u5bb9\u6027\u903b\u8f91\uff09\u3002</p> <ol> <li> <p>\u8fd9\u662f\u65e0\u6761\u4ef6\u5b8c\u6210\u7684\uff0c\u56e0\u4e3a\u524d\u5411\u6ce8\u89e3\u53ef\u80fd\u4ec5\u4f5c\u4e3a\u7c7b\u578b\u63d0\u793a\u7684\u4e00\u90e8\u5206\u51fa\u73b0\uff08\u4f8b\u5982 <code>Optional['int']</code>\uff09\uff0c   \u5982\u7c7b\u578b\u89c4\u8303\u6240\u89c4\u5b9a\u3002\u00a0\u21a9</p> </li> </ol>"}]}